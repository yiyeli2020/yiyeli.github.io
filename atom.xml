<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-19T02:51:25.617Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2104. 子数组范围和</title>
    <link href="http://yoursite.com/2021/12/19/2104.%20%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/"/>
    <id>http://yoursite.com/2021/12/19/2104. 子数组范围和/</id>
    <published>2021-12-19T02:30:12.000Z</published>
    <updated>2021-12-19T02:51:25.617Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。</p><p>返回 nums 中 所有 子数组范围的 和 。</p><a id="more"></a><p>[TOC]</p><p><strong>子数组是数组中一个连续 非空 的元素序列。</strong></p><p>示例 1：</p><pre><code>输入：nums = [1,2,3]输出：4解释：nums 的 6 个子数组如下所示：[1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0[3]，范围 = 3 - 3 = 0[1,2]，范围 = 2 - 1 = 1[2,3]，范围 = 3 - 2 = 1[1,2,3]，范围 = 3 - 1 = 2所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,3,3]输出：4解释：nums 的 6 个子数组如下所示：[1]，范围 = 最大 - 最小 = 1 - 1 = 0[3]，范围 = 3 - 3 = 0[3]，范围 = 3 - 3 = 0[1,3]，范围 = 3 - 1 = 2[3,3]，范围 = 3 - 3 = 0[1,3,3]，范围 = 3 - 1 = 2所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4</code></pre><p>示例 3：</p><pre><code>输入：nums = [4,-2,-3,4,1]输出：59解释：nums 中所有子数组范围的和是 59</code></pre><p>提示：</p><p>1 &lt;= nums.length &lt;= 1000<br>-109 &lt;= nums[i] &lt;= 109</p><p>进阶：你可以设计一种时间复杂度为 O(n) 的解决方案吗？</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1、一个很自然的思路就是枚举每一个子数组，找到子数组的最小值、最大值，然后求范围之和。这样做复杂度至少是O(n^2)。  </p><p>2、要找到一个O(n)复杂度的方法，只能依次考虑每一个数字。当出现数字nums[j]时，它对范围之和有什么影响呢？这样问题就变为了nums[j]可能是哪些子数组的最大值、最小值呢？沿着这个思路，我们发现，假设nums[i]…nums[j]…nums[k]，nums[i]是nums[j]左边第一个大于nums[j]的数，nums[k]是nums[j]右边第一个大于nums[j]的数，那么显然区间nums(i,k)之间的最大值是nums[j]，这就意味着该区间内所有包含nums[j]的子数组的最大值都是nums[j]；而任何一个包含nums[i]或者nums[k]的子数组的最大值都不可能是nums[j]。这样nums[j]作为最大值，贡献的范围之和就是区间nums(i,k)包含nums[j]的子数组个数 * nums[j]，而这个子数组个数 = (j - i) * (k - j)。  </p><p>3、同样的思路，我们可以找到nums[j]作为最小值，对范围之和的贡献。我们遍历所有的nums[j]，加上它作为最大值的贡献，减去它作为最小值的贡献，这样就可以求出范围之和了。  </p><p>4、那么如何求得nums[j]左右两边第一个大于它的数呢？这是一个典型的单调栈问题，我们正向遍历数组，维护一个单调递增栈和一个单调递减栈，单调递增栈的栈顶元素就是左边第一个小于nums[j]的元素，单调递减栈的栈顶元素就是左边第一个大于nums[j]的元素。同样的方法，反向遍历数组，即可求得nums[j]右边第一个大于、小于它的元素。  </p><p>5、注意一个细节问题，当有相同num出现时，如果是正向遍历，那么不应该继续弹出栈顶元素，因为在一个子数组中相同的两个数只有第一个会被认为是最大值、最小值，所以后来的第二个没有办法取代第一个。而反向遍历时恰恰相反，后来的第二个数在原数组的前面位置，它应该取代第一个数，所以需要继续弹出栈顶元素。  </p><h2 id="复杂度问题"><a href="#复杂度问题" class="headerlink" title="复杂度问题"></a>复杂度问题</h2><p>时间复杂度：O(n)，单调栈和后续的求范围之和，都只需要遍历一次数组。  </p><p>空间复杂度：O(n)，需要保存每个数左右两边第一个大于、小于自己的数的位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">subArrayRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, size = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftLess(size), leftGreater(size), rightLess(size), rightGreater(size);</span><br><span class="line"></span><br><span class="line">        getLeft(nums, leftLess, leftGreater);</span><br><span class="line">        getRight(nums, rightLess, rightGreater);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            sum += (nums[i] * ((<span class="keyword">long</span> <span class="keyword">long</span>)i - leftGreater[i]) * ((<span class="keyword">long</span> <span class="keyword">long</span>)rightGreater[i] - i));</span><br><span class="line">            sum -= (nums[i] * ((<span class="keyword">long</span> <span class="keyword">long</span>)i - leftLess[i]) * ((<span class="keyword">long</span> <span class="keyword">long</span>)rightLess[i] - i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getLeft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; leftLess, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; leftGreater)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, size = nums.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; increasing, decreasing;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!increasing.empty() &amp;&amp; nums[increasing.top()] &gt; nums[i]) &#123;</span><br><span class="line">                increasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftLess[i] = increasing.empty() ? <span class="number">-1</span> : increasing.top();</span><br><span class="line">            increasing.push(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!decreasing.empty() &amp;&amp; nums[decreasing.top()] &lt; nums[i]) &#123;</span><br><span class="line">                decreasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftGreater[i] = decreasing.empty() ? <span class="number">-1</span> : decreasing.top();</span><br><span class="line">            decreasing.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rightLess, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rightGreater)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, size = nums.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; increasing, decreasing;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!increasing.empty() &amp;&amp; nums[increasing.top()] &gt;= nums[i]) &#123;</span><br><span class="line">                increasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rightLess[i] = increasing.empty() ? size : increasing.top();</span><br><span class="line">            increasing.push(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!decreasing.empty() &amp;&amp; nums[decreasing.top()] &lt;= nums[i]) &#123;</span><br><span class="line">                decreasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rightGreater[i] = decreasing.empty() ? size : decreasing.top();</span><br><span class="line">            decreasing.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。&lt;/p&gt;
&lt;p&gt;返回 nums 中 所有 子数组范围的 和 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>2103. 环和杆</title>
    <link href="http://yoursite.com/2021/12/19/2103.%20%E7%8E%AF%E5%92%8C%E6%9D%86/"/>
    <id>http://yoursite.com/2021/12/19/2103. 环和杆/</id>
    <published>2021-12-19T02:30:12.000Z</published>
    <updated>2021-12-19T02:31:37.502Z</updated>
    
    <content type="html"><![CDATA[<p>找出所有集齐全部三种颜色环的杆，并返回这种杆的数量。</p><a id="more"></a><p>[TOC]</p><p>总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 0 到 9 的杆上。</p><p>给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：</p><p>第 i 对中的 第一个 字符表示第 i 个环的 颜色（’R’、’G’、’B’）。<br>第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（’0’ 到 ‘9’）。<br>例如，”R3G2B1” 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p><p>找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。</p><p>示例 1：</p><pre><code>输入：rings = &quot;B0B6G0R6R0R6G9&quot;输出：1解释：- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。- 编号 9 的杆上只有 1 个绿色环。因此，集齐全部三种颜色环的杆的数目为 1 。</code></pre><p>示例 2：</p><pre><code>输入：rings = &quot;B0R0G0R9R0B0G0&quot;输出：1解释：- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。- 编号 9 的杆上只有 1 个红色环。因此，集齐全部三种颜色环的杆的数目为 1 。</code></pre><p>示例 3：</p><pre><code>输入：rings = &quot;G4&quot;输出：0解释：只给了一个环，因此，不存在集齐全部三种颜色环的杆。</code></pre><p>提示：</p><pre><code>rings.length == 2 * n1 &lt;= n &lt;= 100如 i 是 偶数 ，则 rings[i] 的值可以取 &apos;R&apos;、&apos;G&apos; 或 &apos;B&apos;（下标从 0 开始计数）如 i 是 奇数 ，则 rings[i] 的值可以取 &apos;0&apos; 到 &apos;9&apos; 中的一个数字（下标从 0 开始计数）</code></pre><h1 id="方法一：维护每根杆的状态"><a href="#方法一：维护每根杆的状态" class="headerlink" title="方法一：维护每根杆的状态"></a>方法一：维护每根杆的状态</h1><p><strong>思路与算法</strong></p><p>我们可以遍历字符串的每个颜色位置对，来模拟套环的过程。</p><p>对于每一个环，由于我们只关心它上面有哪些颜色的环，而不在意具体的数量；同时是否有某一种颜色的环的状态相互独立，因此我们可以用一个 <em>3</em> 二进制位的整数来表示每个环的状态。具体地，<strong>从低到高</strong>第一位表示是否有红色的环，第二位表示是否有蓝色的环，第三位表示是否有绿色的环；每一位为 <em>1</em> 则代表当前杆上有对应颜色的环，为 <em>0</em> 则代表没有。当套上某种颜色的环后，无论该二进制位之前取值如何，新的取值一定为 <em>1</em>，这等价于对应二进制位<strong>对 <em>1</em> 取或</strong>的操作。</p><p>我们可以用一个长度为 <em>10</em> 的状态数组来表示每个环的状态，数组下标即为杆的编号。在模拟开始前，所有环的状态对应的整数均为 <em>0</em>。在遍历到每个颜色位置对时，我们首先看第二个字符寻找出对应的下标，同时根据环的颜色对状态值的对应二进制位<strong>对 <em>1</em> 取或</strong>。当遍历完成后，我们遍历状态数组，统计状态值为 <em>(111)_2 = 7</em> （代表对应杆上有三种颜色的环）的个数，并返回该个数作为答案。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPoints</span><span class="params">(<span class="built_in">string</span> rings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; status(<span class="number">10</span>);   <span class="comment">// 状态数组</span></span><br><span class="line">        <span class="comment">// 遍历颜色位置对维护状态数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = rings[i+<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (rings[i] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                status[idx] |= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rings[i] == <span class="string">'G'</span>) &#123;</span><br><span class="line">                status[idx] |= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                status[idx] |= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计集齐三色环的杆的数量</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status[i] == <span class="number">7</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPoints</span><span class="params">(self, rings: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(rings)</span><br><span class="line">        status = [<span class="number">0</span>] * <span class="number">10</span>   <span class="comment"># 状态数组</span></span><br><span class="line">        <span class="comment"># 遍历颜色位置对维护状态数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n, <span class="number">2</span>):</span><br><span class="line">            idx = int(rings[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> rings[i] == <span class="string">'R'</span>:</span><br><span class="line">                status[idx] |= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> rings[i] == <span class="string">'G'</span>:</span><br><span class="line">                status[idx] |= <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                status[idx] |= <span class="number">4</span></span><br><span class="line">        <span class="comment"># 统计集齐三色环的杆的数量</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> status[i] == <span class="number">7</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + k)*，其中 *n</em> 为rings 的长度，<em>k</em> 为杆的数量。初始化杆状态数组与统计数量的时间复杂度为 <em>O(k)</em>，遍历字符串的时间复杂度为 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(k)</em>，即为状态数组的空间开销。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找出所有集齐全部三种颜色环的杆，并返回这种杆的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>875. 爱吃香蕉的珂珂</title>
    <link href="http://yoursite.com/2021/12/17/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <id>http://yoursite.com/2021/12/17/875. 爱吃香蕉的珂珂/</id>
    <published>2021-12-17T11:30:12.000Z</published>
    <updated>2021-12-17T11:16:14.922Z</updated>
    
    <content type="html"><![CDATA[<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><a id="more"></a><p>[TOC]</p><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p>示例 1：</p><pre><code>输入: piles = [3,6,7,11], H = 8输出: 4</code></pre><p>示例 2：</p><pre><code>输入: piles = [30,11,23,4,20], H = 5输出: 30</code></pre><p>示例 3：</p><pre><code>输入: piles = [30,11,23,4,20], H = 6输出: 23</code></pre><p>提示：</p><pre><code>1 &lt;= piles.length &lt;= 10^4piles.length &lt;= H &lt;= 10^91 &lt;= piles[i] &lt;= 10^9</code></pre><h1 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找^1"></a>二分查找<a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/ai-chi-xiang-jiao-de-ke-ke-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路</strong></p><p>如果珂珂能以 <code>K</code> 的进食速度最终吃完所有的香蕉（在 <code>H</code> 小时内），那么她也可以用更快的速度吃完。</p><p>当珂珂能以 <code>K</code> 的进食速度吃完香蕉时，我们令 <code>possible(K)</code> 为 <code>true</code>，那么就存在 <code>X</code> 使得当 <code>K &gt;= X</code> 时， <code>possible(K) = True</code>。</p><p>举个例子，当初始条件为 <code>piles = [3, 6, 7, 11]</code> 和 <code>H = 8</code> 时，存在 <code>X = 4</code> 使得 <code>possible(1) = possible(2) = possible(3) = False</code>，且 <code>possible(4) = possible(5) = ... = True</code>。</p><p><strong>算法</strong></p><p>我们可以二分查找 <code>possible(K)</code> 的值来找到第一个使得 <code>possible(X)</code> 为 <code>True</code> 的 <code>X</code>：这将是我们的答案。我们的循环中，不变量 <code>possible(hi)</code> 总为 <code>True</code>， <code>lo</code> 总小于等于答案。有关二分查找的更多信息，请参阅<a href="https://leetcode-cn.com/explore/learn/card/binary-search/" target="_blank" rel="noopener">《力扣探索：二分查找》</a>。</p><p>为了找到 <code>possible(K)</code> 的值， (即<code>珂珂</code>是否能以 <code>K</code> 的进食速度在 <code>H</code> 小时内吃完所有的香蕉），我们模拟这一情景。对于每一堆（大小 <code>p &gt; 0</code>），我们可以推断出珂珂将在 <code>Math.ceil(p / K) = ((p-1) // K) + 1</code> 小时内吃完这一堆，我们将每一堆的完成时间加在一起并与 <code>H</code> 进行比较。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[2q2E5AzB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p - <span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[2q2E5AzB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">1_000_000_000</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p-<span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[2q2E5AzB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="comment"># Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">possible</span><span class="params">(K)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum((p<span class="number">-1</span>) / K + <span class="number">1</span> <span class="keyword">for</span> p <span class="keyword">in</span> piles) &lt;= H</span><br><span class="line"></span><br><span class="line">        lo, hi = <span class="number">1</span>, max(piles)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (lo + hi) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> possible(mi):</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 073. 狒狒吃香蕉</title>
    <link href="http://yoursite.com/2021/12/17/%E5%89%91%E6%8C%87%20Offer%20II%20073.%20%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89/"/>
    <id>http://yoursite.com/2021/12/17/剑指 Offer II 073. 狒狒吃香蕉/</id>
    <published>2021-12-17T11:30:12.000Z</published>
    <updated>2021-12-17T11:16:09.347Z</updated>
    
    <content type="html"><![CDATA[<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><a id="more"></a><p>[TOC]</p><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p>注意：本题与<a href="https://leetcode-cn.com/problems/nZZqjQ/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a>相同</p><p>示例 1：</p><pre><code>输入: piles = [3,6,7,11], H = 8输出: 4</code></pre><p>示例 2：</p><pre><code>输入: piles = [30,11,23,4,20], H = 5输出: 30</code></pre><p>示例 3：</p><pre><code>输入: piles = [30,11,23,4,20], H = 6输出: 23</code></pre><p>提示：</p><pre><code>1 &lt;= piles.length &lt;= 10^4piles.length &lt;= H &lt;= 10^91 &lt;= piles[i] &lt;= 10^9</code></pre><h1 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找^1"></a>二分查找<a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/ai-chi-xiang-jiao-de-ke-ke-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路</strong></p><p>如果珂珂能以 <code>K</code> 的进食速度最终吃完所有的香蕉（在 <code>H</code> 小时内），那么她也可以用更快的速度吃完。</p><p>当珂珂能以 <code>K</code> 的进食速度吃完香蕉时，我们令 <code>possible(K)</code> 为 <code>true</code>，那么就存在 <code>X</code> 使得当 <code>K &gt;= X</code> 时， <code>possible(K) = True</code>。</p><p>举个例子，当初始条件为 <code>piles = [3, 6, 7, 11]</code> 和 <code>H = 8</code> 时，存在 <code>X = 4</code> 使得 <code>possible(1) = possible(2) = possible(3) = False</code>，且 <code>possible(4) = possible(5) = ... = True</code>。</p><p><strong>算法</strong></p><p>我们可以二分查找 <code>possible(K)</code> 的值来找到第一个使得 <code>possible(X)</code> 为 <code>True</code> 的 <code>X</code>：这将是我们的答案。我们的循环中，不变量 <code>possible(hi)</code> 总为 <code>True</code>， <code>lo</code> 总小于等于答案。有关二分查找的更多信息，请参阅<a href="https://leetcode-cn.com/explore/learn/card/binary-search/" target="_blank" rel="noopener">《力扣探索：二分查找》</a>。</p><p>为了找到 <code>possible(K)</code> 的值， (即<code>珂珂</code>是否能以 <code>K</code> 的进食速度在 <code>H</code> 小时内吃完所有的香蕉），我们模拟这一情景。对于每一堆（大小 <code>p &gt; 0</code>），我们可以推断出珂珂将在 <code>Math.ceil(p / K) = ((p-1) // K) + 1</code> 小时内吃完这一堆，我们将每一堆的完成时间加在一起并与 <code>H</code> 进行比较。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[2q2E5AzB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p - <span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[2q2E5AzB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">1_000_000_000</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p-<span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[2q2E5AzB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="comment"># Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">possible</span><span class="params">(K)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum((p<span class="number">-1</span>) / K + <span class="number">1</span> <span class="keyword">for</span> p <span class="keyword">in</span> piles) &lt;= H</span><br><span class="line"></span><br><span class="line">        lo, hi = <span class="number">1</span>, max(piles)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (lo + hi) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> possible(mi):</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>403. 青蛙过河</title>
    <link href="http://yoursite.com/2021/12/17/403.%20%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
    <id>http://yoursite.com/2021/12/17/403. 青蛙过河/</id>
    <published>2021-12-17T07:30:12.000Z</published>
    <updated>2021-12-17T10:33:56.730Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p><p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p><a id="more"></a><p>[TOC]</p><p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p><p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p>示例 1：</p><pre><code>输入：stones = [0,1,3,5,6,8,12,17]输出：true解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</code></pre><p>示例 2：</p><pre><code>输入：stones = [0,1,2,3,4,8,9,11]输出：false解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</code></pre><p>提示：</p><pre><code>2 &lt;= stones.length &lt;= 20000 &lt;= stones[i] &lt;= 231 - 1stones[0] == 0</code></pre><h1 id="方法一：记忆化搜索-二分查找-1"><a href="#方法一：记忆化搜索-二分查找-1" class="headerlink" title="方法一：记忆化搜索 + 二分查找^1"></a>方法一：记忆化搜索 + 二分查找<a href="https://leetcode-cn.com/problems/frog-jump/solution/qing-wa-guo-he-by-leetcode-solution-mbuo/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路及算法</strong></p><p>最直接的想法是使用深度优先搜索的方式尝试所有跳跃方案，直到我们找到一组可行解为止。但是不加优化的该算法的时间复杂度在最坏情况下是指数级的，因此考虑优化。</p><p>注意到当青蛙每次能够跳跃的距离仅取决于青蛙的「上一次跳跃距离」。而青蛙此后能否到达终点，只和它「现在所处的石子编号」以及「上一次跳跃距离」有关。因此我们可以将这两个维度综合记录为一个状态。使用记忆化搜索的方式优化时间复杂度。</p><p>具体地，当青蛙位于第 <em>i</em> 个石子，上次跳跃距离为 lastDis 时，它当前能够跳跃的距离范围为[lastDis-1,lastDis+1]。我们需要分别判断这三个距离对应的三个位置是否存在石子。注意到给定的石子列表为升序，所以我们可以利用二分查找来优化查找石子的时间复杂度。每次我们找到了符合要求的位置，我们就尝试进行一次递归搜索即可。</p><p>为了优化编码，我们可以认为青蛙的初始状态为：「现在所处的石子编号」为 <em>0</em>（石子从 <em>0</em> 开始编号），「上一次跳跃距离」为 <em>0</em>（这样可以保证青蛙的第一次跳跃距离为 <em>1</em>）。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; rec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> i, <span class="keyword">int</span> lastDis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == stones.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[i].count(lastDis)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[i][lastDis];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = lower_bound(stones.begin(), stones.end(), curDis + stones[i]) - stones.begin();</span><br><span class="line">                <span class="keyword">if</span> (j != stones.size() &amp;&amp; stones[j] == curDis + stones[i] &amp;&amp; dfs(stones, j, curDis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> rec[i][lastDis] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[i][lastDis] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        rec.resize(n);</span><br><span class="line">        <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean[][] rec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        rec = <span class="keyword">new</span> Boolean[n][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> i, <span class="keyword">int</span> lastDis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == stones.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[i][lastDis] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[i][lastDis];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = Arrays.binarySearch(stones, i + <span class="number">1</span>, stones.length, curDis + stones[i]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; dfs(stones, j, curDis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> rec[i][lastDis] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[i][lastDis] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canCross = <span class="function"><span class="keyword">function</span>(<span class="params">stones</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stones.length;</span><br><span class="line">    rec = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">stones, i, lastDis</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === stones.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[i].has(lastDis)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[i].get(lastDis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> j = lower_bound(stones, curDis + stones[i]);</span><br><span class="line">                <span class="keyword">if</span> (j !== stones.length &amp;&amp; stones[j] === curDis + stones[i] &amp;&amp; dfs(stones, j, curDis)) &#123;</span><br><span class="line">                    rec[i].set(lastDis, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> rec[i].get(lastDis);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rec[i].set(lastDis, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> rec[i].get(lastDis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lower_bound</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>, hi = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="built_in">Math</span>.floor((hi - lo) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCross</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(stones)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">dfs</span> = <span class="title">func</span><span class="params">(i, lastDis <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> res, has := dp[i][lastDis]; has &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; dp[i][lastDis] = res &#125;()</span><br><span class="line">        <span class="keyword">for</span> curDis := lastDis - <span class="number">1</span>; curDis &lt;= lastDis+<span class="number">1</span>; curDis++ &#123;</span><br><span class="line">            <span class="keyword">if</span> curDis &gt; <span class="number">0</span> &#123;</span><br><span class="line">                j := sort.SearchInts(stones, curDis+stones[i])</span><br><span class="line">                <span class="keyword">if</span> j != n &amp;&amp; stones[j] == curDis+stones[i] &amp;&amp; dfs(j, curDis) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>** <span class="title">rec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count</span><span class="params">(struct HashTable** hashTable, <span class="keyword">int</span> ikey)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(*hashTable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(struct HashTable** hashTable, <span class="keyword">int</span> ikey, <span class="keyword">int</span> ival)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(*hashTable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(*hashTable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ival;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(struct HashTable** hashTable, <span class="keyword">int</span> ikey)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(*hashTable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = stonesSize;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (stones[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize, <span class="keyword">int</span> i, <span class="keyword">int</span> lastDis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == stonesSize - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count(&amp;rec[i], lastDis)) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(&amp;rec[i], lastDis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = lower_bound(stones, stonesSize, curDis + stones[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != stonesSize &amp;&amp; stones[j] == curDis + stones[i] &amp;&amp; dfs(stones, stonesSize, j, curDis)) &#123;</span><br><span class="line">                <span class="keyword">return</span> modify(&amp;rec[i], lastDis, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modify(&amp;rec[i], lastDis, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize)</span> </span>&#123;</span><br><span class="line">    rec = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable*) * stonesSize);</span><br><span class="line">    <span class="built_in">memset</span>(rec, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct HashTable*) * stonesSize);</span><br><span class="line">    <span class="keyword">return</span> dfs(stones, stonesSize, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路及算法</strong></p><p>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canCross = <span class="function"><span class="keyword">function</span>(<span class="params">stones</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stones.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">const</span> k = stones[i] - stones[j];</span><br><span class="line">            <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i === n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCross</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(stones)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> stones[i]-stones[i<span class="number">-1</span>] &gt; i &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            k := stones[i] - stones[j]</span><br><span class="line">            <span class="keyword">if</span> k &gt; j+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k] = dp[j][k<span class="number">-1</span>] || dp[j][k] || dp[j][k+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i == n<span class="number">-1</span> &amp;&amp; dp[i][k] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[stonesSize][stonesSize];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stonesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stonesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">            <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i == stonesSize - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是石子的数量。因为青蛙仅能在石子间跳跃，且不能向后方（起点的方向）跳跃，而第 <em>i</em> 个石子后方只有 <em>i-1</em> 个石子，因此在任意位置，青蛙的「上一次跳跃距离」至多只有 <em>n</em> 种，状态总数为 <em>n^2*。最坏情况下我们要遍历每一个状态，每次我们只需要 *O(1)</em> 的时间计算当前状态是否可达，相乘即可得到最终时间复杂度。</p></li><li><p>空间复杂度：<em>O(n^2)*，其中 *n</em> 是石子的数量。我们需要记录全部 <em>n^2</em> 个状态。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。&lt;/p&gt;
&lt;p&gt;给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>1884. 鸡蛋掉落-两枚鸡蛋</title>
    <link href="http://yoursite.com/2021/12/16/1884.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-%E4%B8%A4%E6%9E%9A%E9%B8%A1%E8%9B%8B/"/>
    <id>http://yoursite.com/2021/12/16/1884. 鸡蛋掉落-两枚鸡蛋/</id>
    <published>2021-12-16T14:30:12.000Z</published>
    <updated>2021-12-17T07:31:29.457Z</updated>
    
    <content type="html"><![CDATA[<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p><a id="more"></a><p>[TOC]</p><p>给你 2 枚相同 的鸡蛋，和一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p><p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都 会碎 ，从 f 楼层或比它低 的楼层落下的鸡蛋都 不会碎 。</p><p>每次操作，你可以取一枚 没有碎 的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p><p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p><p>示例 1：</p><pre><code>输入：n = 2输出：2解释：我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。如果第一枚鸡蛋碎了，可知 f = 0；如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；否则，当两个鸡蛋都没碎时，可知 f = 2。</code></pre><p>示例 2：</p><pre><code>输入：n = 100输出：14解释：一种最优的策略是：- 将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。- 如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。- 如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。不管结果如何，最多需要扔 14 次来确定 f 。</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 1000</code></pre><p>此题可参见<a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/" target="_blank" rel="noopener">887. 鸡蛋掉落</a></p><h1 id="查表-动态规划"><a href="#查表-动态规划" class="headerlink" title="查表+动态规划"></a>查表+动态规划</h1><p><strong>函数定义：</strong><br><code>dp(n, k)</code>表示现在有<code>n</code>层楼需要验证，此时你手里有<code>k</code>个鸡蛋，返回此时的最小操作次数。</p><p><strong>base case：</strong></p><ul><li>如果没有楼层需要验证了(<code>n == 0</code>)，那你不管有几个鸡蛋都不用操作了。</li><li>如果你手里只有一个鸡蛋了(<code>k == 1</code>)，那你只能从1楼开始试：1楼、2楼、…、n楼，共需要<code>n</code>次操作。</li></ul><p><strong>状态转移：</strong><br>现在你手里有<code>k</code>个鸡蛋，接下来你要选一层楼扔鸡蛋，假设你选择了第<code>i</code>层楼，有两种情况：</p><ol><li><strong>鸡蛋碎了</strong>。你知道你要确定的<code>f</code>一定在[0, i-1]范围内了，也就是需要验证的楼层数变成了<code>i-1</code>，除此之外你还损失了一个鸡蛋，只剩下<code>k-1</code>个鸡蛋了。</li><li><strong>鸡蛋没碎</strong>。你知道你要确定的<code>f</code>一定在[i, n]范围内了，接下来需要验证的楼层数变成了<code>n-i</code>，并且你没有损失鸡蛋，你还有<code>k</code>个鸡蛋。</li></ol><p>题目的要求可以解释为：<strong>最坏情况下最少需要操作几次</strong>。<strong>最坏情况</strong>就是在这两种情况之间，选择那个需要<strong>操作次数最大</strong>的，再加上自己这一次扔鸡蛋的操作，也就是<code>Math.max(dp(i-1, k-1), dp(n-i, k)) + 1</code>，这个值就是你选择从第<code>i</code>层楼扔鸡蛋，最坏情况下需要的操作次数。</p><p><code>dp(n, k)</code>需要的操作次数，是你<strong>在所有楼层中选择一个最坏情况下需要的操作次数最小</strong>的楼层扔鸡蛋。所以需要遍历所有楼层，找到<code>Math.min(res, Math.max(dp(i-1, k-1), dp(n-i, k)) + 1)</code>。</p><p>为了避免重复计算，加上<strong>备忘录</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoEggDrop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(n, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查表</span></span><br><span class="line">        <span class="keyword">if</span>(memo[n][k] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[n][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 选一层楼扔鸡蛋</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res = Math.min(res, Math.max(dp(i-<span class="number">1</span>, k-<span class="number">1</span>), dp(n-i, k)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[n][k] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>1377. T 秒后青蛙的位置</title>
    <link href="http://yoursite.com/2021/12/16/1377.%20T%20%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/12/16/1377. T 秒后青蛙的位置/</id>
    <published>2021-12-16T12:30:12.000Z</published>
    <updated>2021-12-16T14:29:09.224Z</updated>
    
    <content type="html"><![CDATA[<p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。</p><a id="more"></a><p>[TOC]</p><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：</p><p>在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。<br>青蛙无法跳回已经访问过的顶点。<br>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。<br>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。<br>无向树的边用数组 edges 描述，其中 edges[i] = [fromi, toi] 意味着存在一条直接连通 fromi 和 toi 两个顶点的边。</p><p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。</p><p>示例 1：</p><pre><code>输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4输出：0.16666666666666666 解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 1 秒 有 1/3 的概率跳到顶点 2 ，然后第 2 秒 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 </code></pre><p>示例 2：</p><pre><code>输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7输出：0.3333333333333333解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 1 秒 后跳到顶点 7 。 </code></pre><p>示例 3：</p><pre><code>输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6输出：0.16666666666666666</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 100edges.length == n-1edges[i].length == 21 &lt;= edges[i][0], edges[i][1] &lt;= n1 &lt;= t &lt;= 501 &lt;= target &lt;= n与准确值误差在 10^-5 之内的结果将被判定为正确。</code></pre><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>朴素BFS搜素，中间需要注意已经访问过的点不能计算到概率当中，<br>这个青蛙就算是当前它已经到达target，只要还有其他没有访问过的点，他还是会继续跳，直到时间用完。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    class node &#123;</span><br><span class="line">        int id;</span><br><span class="line">        double p; //概率</span><br><span class="line">        int t; //时间</span><br><span class="line"></span><br><span class="line">        node(int i, double pp, int tt) &#123;</span><br><span class="line">            id = i;</span><br><span class="line">            p = pp;</span><br><span class="line">            t = tt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double frogPosition(int n, int[][] edges, int t, int target) &#123;</span><br><span class="line">        Set&lt;Integer&gt;[] sets = new Set[n + 1];</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            sets[i] = new HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] e : edges) &#123;</span><br><span class="line">            sets[e[0]].add(e[1]);</span><br><span class="line">            //因为是无向图，有的edges顺序可能从子节点指向父节点</span><br><span class="line">            sets[e[1]].add(e[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;node&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(new node(1, 1.0, 0));</span><br><span class="line">        boolean[] vis = new boolean[n + 1];</span><br><span class="line">        vis[1] = true;</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            node u = q.poll();</span><br><span class="line">            if (u.t == t &amp;&amp; u.id == target) &#123;</span><br><span class="line">                return u.p;</span><br><span class="line">            &#125;</span><br><span class="line">            //统计下一步可能的所有选择数</span><br><span class="line">            int sz = 0;</span><br><span class="line">            for (int nb : sets[u.id]) &#123;</span><br><span class="line">                if (!vis[nb]) &#123;</span><br><span class="line">                    sz++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (u.t &lt; t) &#123;</span><br><span class="line">                boolean find = false;</span><br><span class="line">                for (int nb : sets[u.id]) &#123;</span><br><span class="line">                    if (vis[nb]) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //下一层有未访问的节点即加入队列</span><br><span class="line">                    find = true;</span><br><span class="line">                    vis[nb] = true;</span><br><span class="line">                    q.add(new node(nb, u.p / sz, u.t + 1));</span><br><span class="line">                &#125;</span><br><span class="line">                //下一层无未访问的节点</span><br><span class="line">                if (find == false) &#123;</span><br><span class="line">                    q.add(new node(u.id, u.p, u.t + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0.0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回青蛙在 t 秒后位于目标顶点 target 上的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
      <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>1419. 数青蛙</title>
    <link href="http://yoursite.com/2021/12/16/1419.%20%E6%95%B0%E9%9D%92%E8%9B%99/"/>
    <id>http://yoursite.com/2021/12/16/1419. 数青蛙/</id>
    <published>2021-12-16T09:43:12.000Z</published>
    <updated>2021-12-16T10:34:52.080Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以croakOfFrogs 中会混合多个 “croak” 。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p><a id="more"></a><p>[TOC]</p><p>注意：要想发出蛙鸣 “croak”，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p><p>如果字符串 croakOfFrogs 不是由若干有效的 “croak” 字符混合而成，请返回 -1 。</p><p>示例 1：</p><pre><code>输入：croakOfFrogs = &quot;croakcroak&quot;输出：1 解释：一只青蛙 “呱呱” 两次</code></pre><p>示例 2：</p><pre><code>输入：croakOfFrogs = &quot;crcoakroak&quot;输出：2 解释：最少需要两只青蛙，“呱呱” 声用黑体标注第一只青蛙 &quot;crcoakroak&quot;第二只青蛙 &quot;crcoakroak&quot;</code></pre><p>示例 3：</p><pre><code>输入：croakOfFrogs = &quot;croakcrook&quot;输出：-1解释：给出的字符串不是 &quot;croak&quot; 的有效组合。</code></pre><p>示例 4：</p><pre><code>输入：croakOfFrogs = &quot;croakcroa&quot;输出：-1</code></pre><p>提示：</p><pre><code>1 &lt;= croakOfFrogs.length &lt;= 10^5字符串中的字符只有 &apos;c&apos;, &apos;r&apos;, &apos;o&apos;, &apos;a&apos; 或者 &apos;k&apos;</code></pre><p>思想就是维护croak的个数，如果遇到当前字母，则肯定是由前面字母过来，前面字母数-1。<br>如遇到r，则必是c-&gt;r，所以c–<br>k代表结尾，其实也是青蛙的起始（一次喊叫结束），所以遇到c的时候，先去消耗k，没有k了，需要新青蛙，答案+1</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int minNumberOfFrogs(String croakOfFrogs) &#123;</span><br><span class="line">        int c,r,o,a,k;</span><br><span class="line">        c = 0; r = 0; o = 0; a = 0;k = 0;</span><br><span class="line">        char []chars = croakOfFrogs.toCharArray();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0;i &lt; chars.length;i++)&#123;</span><br><span class="line">            if(chars[i] == &apos;c&apos;)&#123;</span><br><span class="line">                if(k &gt; 0)&#123;k--;&#125;else&#123;res++;&#125;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;r&apos;)&#123;</span><br><span class="line">                c--;r++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;o&apos;)&#123;</span><br><span class="line">                r--;o++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;a&apos;)&#123;</span><br><span class="line">                o--;a++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;k&apos;)&#123;</span><br><span class="line">                a--;k++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(c &lt; 0 || r &lt; 0 || o &lt; 0 || a &lt; 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(c != 0 || r != 0 || o != 0 || a != 0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java switch case写法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minNumberOfFrogs(String croakOfFrogs) &#123;</span><br><span class="line">        int c = 0;</span><br><span class="line">        int r = 0;</span><br><span class="line">        int o = 0;</span><br><span class="line">        int a = 0;</span><br><span class="line">        int k = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        char[] chars = croakOfFrogs.toCharArray();</span><br><span class="line">        for (char character : chars) &#123;</span><br><span class="line">            switch (character) &#123;</span><br><span class="line">                case &apos;c&apos;:</span><br><span class="line">                    if (k &gt; 0) &#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;r&apos;:</span><br><span class="line">                    c--;</span><br><span class="line">                    r++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;o&apos;:</span><br><span class="line">                    r--;</span><br><span class="line">                    o++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;:</span><br><span class="line">                    o--;</span><br><span class="line">                    a++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;k&apos;:</span><br><span class="line">                    a--;</span><br><span class="line">                    k++;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (c &lt; 0 || r &lt; 0 || o &lt; 0 || a &lt; 0 || k&lt;0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (c != 0 || r != 0 || o != 0 || a != 0) &#123;</span><br><span class="line">            res = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以croakOfFrogs 中会混合多个 “croak” 。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Counting" scheme="http://yoursite.com/tags/Counting/"/>
    
  </entry>
  
  <entry>
    <title>1936. 新增的最少台阶数</title>
    <link href="http://yoursite.com/2021/12/16/1936.%20%E6%96%B0%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%B0%E9%98%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/16/1936. 新增的最少台阶数/</id>
    <published>2021-12-16T08:28:12.000Z</published>
    <updated>2021-12-16T09:39:28.211Z</updated>
    
    <content type="html"><![CDATA[<p>返回爬到最后一阶时必须添加到梯子上的 最少台阶数。</p><a id="more"></a><p>[TOC]</p><p>给你一个 严格递增 的整数数组 rungs ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。</p><p>另给你一个整数 dist 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过dist高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。</p><p>返回爬到最后一阶时必须添加到梯子上的 最少台阶数。</p><p>示例 1：</p><pre><code>输入：rungs = [1,3,5,10], dist = 2输出：2解释：现在无法到达最后一阶。在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,5,7,8,10] 的位置上有台阶。</code></pre><p>示例 2：</p><pre><code>输入：rungs = [3,6,8,10], dist = 3输出：0解释：这个梯子无需增设新台阶也可以爬上去。</code></pre><p>示例 3：</p><pre><code>输入：rungs = [3,4,6,7], dist = 2输出：1解释：现在无法从地板到达梯子的第一阶。 在高度为 1 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,4,6,7] 的位置上有台阶。</code></pre><p>示例 4：</p><pre><code>输入：rungs = [5], dist = 10输出：0解释：这个梯子无需增设新台阶也可以爬上去。</code></pre><p>提示：</p><pre><code>1 &lt;= rungs.length &lt;= 1051 &lt;= rungs[i] &lt;= 1091 &lt;= dist &lt;= 109rungs 严格递增</code></pre><h1 id="方法一：模拟-贪心"><a href="#方法一：模拟-贪心" class="headerlink" title="方法一：模拟 + 贪心"></a>方法一：模拟 + 贪心</h1><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/add-minimum-number-of-rungs/solution/xin-zeng-de-zui-shao-tai-jie-shu-by-leet-y0de/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addRungs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rungs, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// 需要增设的梯子数目</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;   <span class="comment">// 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h: rungs)&#123;</span><br><span class="line">            <span class="comment">// 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            <span class="keyword">int</span> d = h - curr;</span><br><span class="line">            res += (d - <span class="number">1</span>) / dist;</span><br><span class="line">            curr = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addRungs</span><span class="params">(self, rungs: List[int], dist: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span>   <span class="comment"># 需要增设的梯子数目</span></span><br><span class="line">        curr = <span class="number">0</span>   <span class="comment"># 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> rungs:</span><br><span class="line">            <span class="comment"># 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            d = h - curr</span><br><span class="line">            res += (h - curr - <span class="number">1</span>) // dist</span><br><span class="line">            curr = h</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addRungs</span><span class="params">(<span class="keyword">int</span>[] rungs, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;    <span class="comment">// 需要增设的梯子数目</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;   <span class="comment">// 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h : rungs) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            <span class="keyword">int</span> d = h - curr;</span><br><span class="line">            res += (d - <span class="number">1</span>) / dist;</span><br><span class="line">            curr = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回爬到最后一阶时必须添加到梯子上的 最少台阶数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <link href="http://yoursite.com/2021/12/16/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2021/12/16/746. 使用最小花费爬楼梯/</id>
    <published>2021-12-16T08:12:12.000Z</published>
    <updated>2021-12-16T08:23:50.543Z</updated>
    
    <content type="html"><![CDATA[<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</code></pre><p> 示例 2：</p><pre><code>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</code></pre><p>提示：</p><pre><code>cost 的长度范围是 [2, 1000]。cost[i] 将会是一个整型数据，范围为 [0, 999] 。</code></pre><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.Min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[costSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        dp[i] = fmin(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述代码的时间复杂度和空间复杂度都是 <em>O(n)</em> 。可以使用滚动数组的思想，将空间复杂度优化到 <em>O(1)</em>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = Math.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="built_in">Math</span>.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int prev = 0, curr = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int next = Math.Min(curr + cost[i - 1], prev + cost[i - 2]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        pre, cur = cur, min(cur+cost[i<span class="number">-1</span>], pre+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        prev = curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>])</span><br><span class="line">            prev, curr = curr, nxt</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = fmin(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组cost 的长度。需要依次计算每个dp 值，每个值的计算需要常数时间，因此总时间复杂度是 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用滚动数组的思想，只需要使用有限的额外空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 088. 爬楼梯的最少成本</title>
    <link href="http://yoursite.com/2021/12/16/%E5%89%91%E6%8C%87%20Offer%20II%20088.%20%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%91%E6%88%90%E6%9C%AC/"/>
    <id>http://yoursite.com/2021/12/16/剑指 Offer II 088. 爬楼梯的最少成本/</id>
    <published>2021-12-16T08:12:12.000Z</published>
    <updated>2021-12-16T08:25:41.154Z</updated>
    
    <content type="html"><![CDATA[<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</code></pre><p> 示例 2：</p><pre><code>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</code></pre><p>提示：</p><pre><code>cost 的长度范围是 [2, 1000]。cost[i] 将会是一个整型数据，范围为 [0, 999] 。</code></pre><p>注意：本题与<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a>相同： </p><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.Min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[costSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        dp[i] = fmin(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述代码的时间复杂度和空间复杂度都是 <em>O(n)</em> 。可以使用滚动数组的思想，将空间复杂度优化到 <em>O(1)</em>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = Math.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="built_in">Math</span>.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int prev = 0, curr = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int next = Math.Min(curr + cost[i - 1], prev + cost[i - 2]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        pre, cur = cur, min(cur+cost[i<span class="number">-1</span>], pre+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        prev = curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>])</span><br><span class="line">            prev, curr = curr, nxt</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = fmin(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组cost 的长度。需要依次计算每个dp 值，每个值的计算需要常数时间，因此总时间复杂度是 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用滚动数组的思想，只需要使用有限的额外空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="http://yoursite.com/2021/12/16/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2021/12/16/70. 爬楼梯/</id>
    <published>2021-12-16T07:12:12.000Z</published>
    <updated>2021-12-16T07:30:09.737Z</updated>
    
    <content type="html"><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><a id="more"></a><p>[TOC]</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><p>示例 2：</p><pre><code>输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><p>具体解法和斐波那契数列一样，动态规划，矩阵快速幂和齐次线性递推方程取通解。本来已经这样就玩到极致了<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，没想到还有卷中卷，评论里有人提到字节面试还会修改条件，这样就又为之一变。</p><h1 id="加入新的限制条件：不能连续跳两个台阶。"><a href="#加入新的限制条件：不能连续跳两个台阶。" class="headerlink" title="加入新的限制条件：不能连续跳两个台阶。"></a>加入新的限制条件：不能连续跳两个台阶。</h1><p> 1、每次你可以爬 1 或 2 个台阶。</p><p> 2、不能连续跳两个台阶。（个人理解为这次跳了两个台阶，下次不能再跳两个台阶）</p><p> 假设：</p><pre><code>f(x) 表示爬到第 x 级台阶的方案数， g(x, 1) 表示爬到第 x 级台阶并且最后一步只跨越一个台阶的方案数， g(x, 2) 表示爬到第 x 级台阶并且最后一步跨越了两个台阶的方案数。由 ：f(x) = g(x, 1)+g(x,2)， g(x, 1) = f(x-1)， g(x, 2) = g(x-2, 1) // 最后一步跨越了两步，那么上一步只能跨越一步得：f(x) = g(x, 1) + g(x, 2)       = f(x-1) + g(x-2, 1)       = f(x-1) + f((x-2)-1)      = f(x-1) + f(x-3)</code></pre><p>题目里“不能连续跳两个台阶”，即一旦跳了两个台阶，则下一步只能跳一步（2-&gt;1），把它们连在一起就一共跳了三个台阶，所以问题可以转化为要么跳一个台阶，要么跳三个台阶（当然还是有点区别的，只不过因为结果是一样的，所以可以这么转化），于是就有了 f(x) = f(x-1) + f(x-3)</p><pre><code>public int climbStarts2(int n) {        if(n == 1) return 1; // 防止数组溢出（f[2]）        int[] f = new int[n+1];        f[0] = 1;        f[1] = 1;        f[2] = 2;        for(int i = 3; i &lt;= n; i++) {            f[i] = f[i-1] + f[i-3];        }        return f[n];    }</code></pre><p>结合执行树会更快理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                         6</span><br><span class="line">                   /            \</span><br><span class="line">                  5              4</span><br><span class="line">             /        \         /</span><br><span class="line">            4          3       3</span><br><span class="line">        /       \     /      /   \</span><br><span class="line">       3         2   2      2     1</span><br><span class="line">     /  \       /   / \    / \   /</span><br><span class="line">    2    1     1   1   0  1   0 0</span><br><span class="line">   / \   /    /   /      /</span><br><span class="line">  1   0 0    0   0      0</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这是一个 n = 6 时绘制的一个带权二叉树，其中左节点为权 1，右节点为权 2，很明显，问题的解为树的非空叶节点个数。</p><p>根节点为 f(x)<br>根节点的左节点为 g(x, 1)，又为 f(x - 1)，因为它是一个同类型的子问题<br>根节点的右节点为 g(x, 2)<br>而看节点 g(x, 2)，其不包含非空右节点，即它的解等同于它的左节点的解，再将其相对于根节点，可以明显看出其为 f(x - 3)</p><p>最终结果便为：f(x) = f(x - 1) + f(x - 3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="http://yoursite.com/2021/12/16/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/12/16/剑指 Offer 10- II. 青蛙跳台阶问题/</id>
    <published>2021-12-16T07:12:12.000Z</published>
    <updated>2021-12-16T07:30:03.599Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><a id="more"></a><p>[TOC]</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><pre><code>输入：n = 2输出：2</code></pre><p>示例 2：</p><pre><code>输入：n = 7输出：21</code></pre><p>示例 3：</p><pre><code>输入：n = 0输出：1</code></pre><p>提示：</p><p>0 &lt;= n &lt;= 100</p><p>注意：本题与<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a>相同</p><p>具体解法和斐波那契数列一样，动态规划，矩阵快速幂和齐次线性递推方程取通解。本来已经这样就玩到极致了<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，没想到还有卷中卷，评论里有人提到字节面试还会修改条件，这样就又为之一变。</p><h1 id="加入新的限制条件：不能连续跳两个台阶。"><a href="#加入新的限制条件：不能连续跳两个台阶。" class="headerlink" title="加入新的限制条件：不能连续跳两个台阶。"></a>加入新的限制条件：不能连续跳两个台阶。</h1><p> 1、每次你可以爬 1 或 2 个台阶。</p><p> 2、不能连续跳两个台阶。（个人理解为这次跳了两个台阶，下次不能再跳两个台阶）</p><p> 假设：</p><pre><code>f(x) 表示爬到第 x 级台阶的方案数， g(x, 1) 表示爬到第 x 级台阶并且最后一步只跨越一个台阶的方案数， g(x, 2) 表示爬到第 x 级台阶并且最后一步跨越了两个台阶的方案数。由 ：f(x) = g(x, 1)+g(x,2)， g(x, 1) = f(x-1)， g(x, 2) = g(x-2, 1) // 最后一步跨越了两步，那么上一步只能跨越一步得：f(x) = g(x, 1) + g(x, 2)       = f(x-1) + g(x-2, 1)       = f(x-1) + f((x-2)-1)      = f(x-1) + f(x-3)</code></pre><p>题目里“不能连续跳两个台阶”，即一旦跳了两个台阶，则下一步只能跳一步（2-&gt;1），把它们连在一起就一共跳了三个台阶，所以问题可以转化为要么跳一个台阶，要么跳三个台阶（当然还是有点区别的，只不过因为结果是一样的，所以可以这么转化），于是就有了 f(x) = f(x-1) + f(x-3)</p><pre><code>public int climbStarts2(int n) {        if(n == 1) return 1; // 防止数组溢出（f[2]）        int[] f = new int[n+1];        f[0] = 1;        f[1] = 1;        f[2] = 2;        for(int i = 3; i &lt;= n; i++) {            f[i] = f[i-1] + f[i-3];        }        return f[n];    }</code></pre><p>结合执行树会更快理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                         6</span><br><span class="line">                   /            \</span><br><span class="line">                  5              4</span><br><span class="line">             /        \         /</span><br><span class="line">            4          3       3</span><br><span class="line">        /       \     /      /   \</span><br><span class="line">       3         2   2      2     1</span><br><span class="line">     /  \       /   / \    / \   /</span><br><span class="line">    2    1     1   1   0  1   0 0</span><br><span class="line">   / \   /    /   /      /</span><br><span class="line">  1   0 0    0   0      0</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这是一个 n = 6 时绘制的一个带权二叉树，其中左节点为权 1，右节点为权 2，很明显，问题的解为树的非空叶节点个数。</p><p>根节点为 f(x)<br>根节点的左节点为 g(x, 1)，又为 f(x - 1)，因为它是一个同类型的子问题<br>根节点的右节点为 g(x, 2)<br>而看节点 g(x, 2)，其不包含非空右节点，即它的解等同于它的左节点的解，再将其相对于根节点，可以明显看出其为 f(x - 3)</p><p>最终结果便为：f(x) = f(x - 1) + f(x - 3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="http://yoursite.com/2021/12/15/842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2021/12/15/842. 将数组拆分成斐波那契序列/</id>
    <published>2021-12-15T13:30:12.000Z</published>
    <updated>2021-12-15T14:42:44.038Z</updated>
    
    <content type="html"><![CDATA[<p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><a id="more"></a><p>[TOC]</p><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p><p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p><p>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length &gt;= 3；<br>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p><p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><p>示例 1：</p><pre><code>输入：&quot;123456579&quot;输出：[123,456,579]</code></pre><p>示例 2：</p><pre><code>输入: &quot;11235813&quot;输出: [1,1,2,3,5,8,13]</code></pre><p>示例 3：</p><pre><code>输入: &quot;112358130&quot;输出: []解释: 这项任务无法完成。</code></pre><p>示例 4：</p><pre><code>输入：&quot;0123&quot;输出：[]解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。</code></pre><p>示例 5：</p><pre><code>输入: &quot;1101111&quot;输出: [110, 1, 111]解释: 输出 [11,0,11,11] 也同样被接受。</code></pre><p>提示：</p><pre><code>1 &lt;= S.length &lt;= 200字符串 S 中只含有数字。</code></pre><h1 id="回溯法模板-1"><a href="#回溯法模板-1" class="headerlink" title="回溯法模板^1"></a>回溯法模板<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>回溯法模板</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void backtrack(&quot;原始参数&quot;) &#123;</span><br><span class="line">    //终止条件(递归必须要有终止条件)</span><br><span class="line">    if (&quot;终止条件&quot;) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = &quot;for循环开始的参数&quot;; i &lt; &quot;for循环结束的参数&quot;; i++) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //做出选择</span><br><span class="line"></span><br><span class="line">        //递归</span><br><span class="line">        backtrack(&quot;新的参数&quot;);</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法一：回溯-剪枝-2"><a href="#方法一：回溯-剪枝-2" class="headerlink" title="方法一：回溯 + 剪枝^2"></a>方法一：回溯 + 剪枝<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/jiang-shu-zu-chai-fen-cheng-fei-bo-na-qi-ts6c/" target="_blank" rel="noopener">^2</a></h1><p>将给定的字符串拆分成斐波那契式序列，可以通过回溯的方法实现。</p><p>使用列表存储拆分出的数，回溯过程中维护该列表的元素，列表初始为空。遍历字符串的所有可能的前缀，作为当前被拆分出的数，然后对剩余部分继续拆分，直到整个字符串拆分完毕。</p><p>根据斐波那契式序列的要求，从第 <em>3</em> 个数开始，每个数都等于前 <em>2</em> 个数的和，因此从第 <em>3</em> 个数开始，需要判断拆分出的数是否等于前 <em>2</em> 个数的和，只有满足要求时才进行拆分，否则不进行拆分。</p><p>回溯过程中，还有三处可以进行剪枝操作。</p><ul><li><p>拆分出的数如果不是 <em>0</em>，则不能以 <em>0</em> 开头，因此如果字符串剩下的部分以 <em>0</em> 开头，就不需要考虑拆分出长度大于 <em>1</em> 的数，因为长度大于 <em>1</em> 的数以 <em>0</em> 开头是不符合要求的，不可能继续拆分得到斐波那契式序列；</p></li><li><p>拆分出的数必须符合 <em>32</em> 位有符号整数类型，即每个数必须在 <em>[0,2^{31}-1]</em> 的范围内，如果拆分出的数大于 <em>2^{31}-1</em>，则不符合要求，长度更大的数的数值也一定更大，一定也大于 <em>2^{31}-1</em>，因此不可能继续拆分得到斐波那契式序列；</p></li><li><p>如果列表中至少有 <em>2</em> 个数，并且拆分出的数已经大于最后 <em>2</em> 个数的和，就不需要继续尝试拆分了。</p></li></ul><p>当整个字符串拆分完毕时，如果列表中至少有 <em>3</em> 个数，则得到一个符合要求的斐波那契式序列，返回列表。如果没有找到符合要求的斐波那契式序列，则返回空列表。</p><p>实现方面，回溯需要带返回值，表示是否存在符合要求的斐波那契式序列。</p><p>但是代码部分实现的过于繁琐，简洁版可以参见<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">^1</a></p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(S.toCharArray(), res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[] digit, List&lt;Integer&gt; res, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件判断，如果截取完了，并且res长度大于等于3，表示找到了一个组合。</span></span><br><span class="line">    <span class="keyword">if</span> (index == digit.length &amp;&amp; res.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; digit.length; i++) &#123;</span><br><span class="line">        <span class="comment">//两位以上的数字不能以0开头</span></span><br><span class="line">        <span class="keyword">if</span> (digit[index] == <span class="string">'0'</span> &amp;&amp; i &gt; index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//截取字符串转化为数字</span></span><br><span class="line">        <span class="keyword">long</span> num = subDigit(digit, index, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果截取的数字大于int的最大值，则终止截取</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = res.size();</span><br><span class="line">        <span class="comment">//如果截取的数字大于res中前两个数字的和，说明这次截取的太大，直接终止，因为后面越截取越大</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= <span class="number">2</span> &amp;&amp; num &gt; res.get(size - <span class="number">1</span>) + res.get(size - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span> || num == res.get(size - <span class="number">1</span>) + res.get(size - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="comment">//把数字num添加到集合res中</span></span><br><span class="line">            res.add((<span class="keyword">int</span>) num);</span><br><span class="line">            <span class="comment">//如果找到了就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (backtrack(digit, res, i + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果没找到，就会走回溯这一步，然后把上一步添加到集合res中的数字给移除掉</span></span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于截取字符串S中的子串然后转换为十进制数字</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">subDigit</span><span class="params">(<span class="keyword">char</span>[] digit, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + digit[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; splitIntoFibonacci(<span class="built_in">string</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">        backtrack(<span class="built_in">list</span>, num, num.length(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">list</span>, <span class="built_in">string</span> num, <span class="keyword">int</span> length, <span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>.size() &gt;= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr * <span class="number">10</span> + num[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr &gt; INT_MAX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>.push_back(curr);</span><br><span class="line">            <span class="keyword">if</span> (backtrack(<span class="built_in">list</span>, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> splitIntoFibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">new</span> <span class="built_in">Array</span>().fill(<span class="number">0</span>);</span><br><span class="line">    backtrack(list, num, num.length, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> backtrack = <span class="function">(<span class="params">list, num, length, index, sum, prev</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === length) &#123;</span><br><span class="line">        <span class="keyword">return</span> list.length &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currLong = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] === <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currLong = currLong * <span class="number">10</span> + num[i].charCodeAt() - <span class="string">'0'</span>.charCodeAt();</span><br><span class="line">        <span class="keyword">if</span> (currLong &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> curr = currLong;</span><br><span class="line">        <span class="keyword">if</span> (list.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.push(curr);</span><br><span class="line">        <span class="keyword">if</span> (backtrack(list, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.splice(list.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, num: str)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = list()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index: int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == len(num):</span><br><span class="line">                <span class="keyword">return</span> len(ans) &gt;= <span class="number">3</span></span><br><span class="line">            </span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(num)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> num[index] == <span class="string">"0"</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                curr = curr * <span class="number">10</span> + ord(num[i]) - ord(<span class="string">"0"</span>)</span><br><span class="line">                <span class="keyword">if</span> curr &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> len(ans) &lt; <span class="number">2</span> <span class="keyword">or</span> curr == ans[<span class="number">-2</span>] + ans[<span class="number">-1</span>]:</span><br><span class="line">                    ans.append(curr)</span><br><span class="line">                    <span class="keyword">if</span> backtrack(i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    ans.pop()</span><br><span class="line">                <span class="keyword">elif</span> len(ans) &gt; <span class="number">2</span> <span class="keyword">and</span> curr &gt; ans[<span class="number">-2</span>] + ans[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">splitIntoFibonacci</span><span class="params">(num <span class="keyword">string</span>)</span> <span class="params">(F []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(num)</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(index, sum, prev <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">backtrack</span> = <span class="title">func</span><span class="params">(index, sum, prev <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == n &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(F) &gt;= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">// 每个块的数字一定不要以零开头，除非这个块是数字 0 本身</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur*<span class="number">10</span> + <span class="keyword">int</span>(num[i]-<span class="string">'0'</span>)</span><br><span class="line">            <span class="comment">// 拆出的整数要符合 32 位有符号整数类型</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; math.MaxInt32 &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// F[i] + F[i+1] = F[i+2]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(F) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> cur &lt; sum &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> cur &gt; sum &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 符合要求，加入序列 F</span></span><br><span class="line">            F = <span class="built_in">append</span>(F, cur)</span><br><span class="line">            <span class="keyword">if</span> backtrack(i+<span class="number">1</span>, prev+cur, cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            F = F[:<span class="built_in">len</span>(F)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">list</span>, <span class="keyword">int</span>* listSize, <span class="keyword">char</span>* num, <span class="keyword">int</span> length, <span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">        <span class="keyword">return</span> (*listSize) &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr * <span class="number">10</span> + num[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr &gt; INT_MAX) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((*listSize) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>[(*listSize)++] = curr;</span><br><span class="line">        <span class="keyword">if</span> (backtrack(<span class="built_in">list</span>, listSize, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (*listSize)--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">splitIntoFibonacci</span><span class="params">(<span class="keyword">char</span>* num, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(num);</span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">list</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    backtrack(<span class="built_in">list</span>, returnSize, num, <span class="built_in">strlen</span>(num), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="http://yoursite.com/2021/12/15/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <id>http://yoursite.com/2021/12/15/1414. 和为 K 的最少斐波那契数字数目/</id>
    <published>2021-12-15T12:02:12.000Z</published>
    <updated>2021-12-15T13:11:39.981Z</updated>
    
    <content type="html"><![CDATA[<p>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><a id="more"></a><p>[TOC]</p><p>斐波那契数字定义为：</p><pre><code>F1 = 1F2 = 1Fn = Fn-1 + Fn-2 ， 其中 n &gt; 2 。</code></pre><p>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：</p><pre><code>输入：k = 7输出：2 解释：斐波那契数字为：1，1，2，3，5，8，13，……对于 k = 7 ，我们可以得到 2 + 5 = 7 。</code></pre><p>示例 2：</p><pre><code>输入：k = 10输出：2 解释：对于 k = 10 ，我们可以得到 2 + 8 = 10 。</code></pre><p>示例 3：</p><pre><code>输入：k = 19输出：3 解释：对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。</code></pre><p>提示：</p><pre><code>1 &lt;= k &lt;= 10^9</code></pre><h1 id="贪心-栈"><a href="#贪心-栈" class="headerlink" title="贪心+栈"></a>贪心+栈</h1><p>证明参见<a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/he-wei-k-de-zui-shao-fei-bo-na-qi-shu-zi-shu-mu-by/" target="_blank" rel="noopener">^1</a>，自己觉得用栈的写法比官方题解更易于理解</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinFibonacciNumbers(int k) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int a = 1, b = 1;</span><br><span class="line">        stack.push(a);</span><br><span class="line">        stack.push(b);</span><br><span class="line">        while (stack.peek() &lt;= k) &#123;</span><br><span class="line">            int c = a + b;</span><br><span class="line">            stack.push(c);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = 0;</span><br><span class="line">        while (!stack.isEmpty() &amp;&amp; k &gt; 0) &#123;</span><br><span class="line">            int temp = stack.pop();</span><br><span class="line">            if (temp &lt;= k) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                k = k - temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>873. 最长的斐波那契子序列的长度</title>
    <link href="http://yoursite.com/2021/12/14/873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>http://yoursite.com/2021/12/14/873. 最长的斐波那契子序列的长度/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:34:37.497Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 093. 最长斐波那契数列</title>
    <link href="http://yoursite.com/2021/12/14/%E5%89%91%E6%8C%87%20Offer%20II%20093.%20%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2021/12/14/剑指 Offer II 093. 最长斐波那契数列/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:36:10.891Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><p>本题与<a href="https://leetcode-cn.com/problems/length-of-longest-fibonacc//i-subsequence/" target="_blank" rel="noopener">873. 最长的斐波那契子序列的长度</a>相同： </p><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>372. 超级次方</title>
    <link href="http://yoursite.com/2021/12/13/372.%20%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
    <id>http://yoursite.com/2021/12/13/372. 超级次方/</id>
    <published>2021-12-13T07:28:12.000Z</published>
    <updated>2021-12-13T10:23:30.426Z</updated>
    
    <content type="html"><![CDATA[<p>你的任务是计算ab对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：a = 2, b = [3]输出：8</code></pre><p>示例 2：</p><pre><code>输入：a = 2, b = [1,0]输出：1024</code></pre><p>示例 3：</p><pre><code>输入：a = 1, b = [4,3,3,8,5,2]输出：1</code></pre><p>示例 4：</p><pre><code>输入：a = 2147483647, b = [2,0,0]输出：1198</code></pre><p>提示：</p><pre><code>1 &lt;= a &lt;= 231 - 11 &lt;= b.length &lt;= 20000 &lt;= b[i] &lt;= 9b 不含前导 0</code></pre><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>在阅读本文前，读者需要掌握快速幂这一算法，具体可以见「<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">50. Pow(x, n) 的官方题解</a>」。</p><h1 id="方法一：倒序遍历-1"><a href="#方法一：倒序遍历-1" class="headerlink" title="方法一：倒序遍历^1"></a>方法一：倒序遍历<a href="https://leetcode-cn.com/problems/super-pow/solution/chao-ji-ci-fang-by-leetcode-solution-ow8j/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superPow</span><span class="params">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class="line">        MOD = <span class="number">1337</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> reversed(b):</span><br><span class="line">            ans = ans * pow(a, e, MOD) % MOD</span><br><span class="line">            a = pow(a, <span class="number">10</span>, MOD)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">long</span>) res * x % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">long</span>) x * x % MOD;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">long</span>) ans * <span class="built_in">pow</span>(a, b[i]) % MOD;</span><br><span class="line">            a = <span class="built_in">pow</span>(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    const int MOD = 1337;</span><br><span class="line"></span><br><span class="line">    public int SuperPow(int a, int[] b) &#123;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = b.Length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            ans = (int) ((long) ans * Pow(a, b[i]) % MOD);</span><br><span class="line">            a = Pow(a, 10);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pow(int x, int n) &#123;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            if (n % 2 != 0) &#123;</span><br><span class="line">                res = (int) ((long) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (int) ((long) x * x % MOD);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            res = res * x % mod</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superPow</span><span class="params">(a <span class="keyword">int</span>, b []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(b)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        ans = ans * pow(a, b[i]) % mod</span><br><span class="line">        a = pow(a, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD = BigInt(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superPow = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ans = ans * pow(BigInt(a), b[i]) % MOD;</span><br><span class="line">        a = pow(BigInt(a), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            res = res * BigInt(x) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：秦九韶算法（正序遍历）"><a href="#方法二：秦九韶算法（正序遍历）" class="headerlink" title="方法二：秦九韶算法（正序遍历）"></a>方法二：秦九韶算法（正序遍历）</h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superPow</span><span class="params">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class="line">        MOD = <span class="number">1337</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> b:</span><br><span class="line">            ans = pow(ans, <span class="number">10</span>, MOD) * pow(a, e, MOD) % MOD</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">long</span>) res * x % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">long</span>) x * x % MOD;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e: b) &#123;</span><br><span class="line">            ans = (<span class="keyword">long</span>) <span class="built_in">pow</span>(ans, <span class="number">10</span>) * <span class="built_in">pow</span>(a, e) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : b) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) pow(ans, <span class="number">10</span>) * pow(a, e) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    const int MOD = 1337;</span><br><span class="line"></span><br><span class="line">    public int SuperPow(int a, int[] b) &#123;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        foreach (int e in b) &#123;</span><br><span class="line">            ans = (int) ((long) Pow(ans, 10) * Pow(a, e) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pow(int x, int n) &#123;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            if (n % 2 != 0) &#123;</span><br><span class="line">                res = (int) ((long) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (int) ((long) x * x % MOD);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            res = res * x % mod</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superPow</span><span class="params">(a <span class="keyword">int</span>, b []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> b &#123;</span><br><span class="line">        ans = pow(ans, <span class="number">10</span>) * pow(a, e) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD = BigInt(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superPow = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> e <span class="keyword">of</span> b) &#123;</span><br><span class="line">        ans = pow(BigInt(ans), <span class="number">10</span>) * pow(BigInt(a), e) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            res = res * BigInt(x) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的任务是计算ab对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Division" scheme="http://yoursite.com/tags/Division/"/>
    
  </entry>
  
  <entry>
    <title>69. x 的平方根(二分法模板题及经典解释）</title>
    <link href="http://yoursite.com/2021/12/13/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/13/69. x 的平方根(二分法模板题及经典解释）/</id>
    <published>2021-12-13T07:23:12.000Z</published>
    <updated>2021-12-13T07:23:04.822Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道常见的面试题，面试官一般会要求面试者在不使用sqrt 函数的情况下，得到 <em>x</em> 的平方根的整数部分。一般的思路会有以下几种：</p><ul><li><p>通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；</p></li><li><p>通过数学方法得到近似结果，直接作为答案。</p></li></ul><h1 id="二分法典型解法-二分法模板题及经典解释）-1"><a href="#二分法典型解法-二分法模板题及经典解释）-1" class="headerlink" title="二分法典型解法(二分法模板题及经典解释）^1"></a>二分法典型解法(二分法模板题及经典解释）<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">^1</a></h1><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><ul><li>这道题要求我们实现平方根函数，输入是一个非负整数，输出也是一个整数；</li><li>但是题目当中说：结果只保留整数的部分，小数部分将被舍去。这是什么意思呢？我们分析一下示例。</li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这是显然的，<em>4</em> 本身是一个完全平方数，<em>2^2 = 4</em>。虽然在数学上一个数的平方根有正有负，但是这个题目只要求我们返回算术平方根。</p><p>示例 2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>因为 <em>8</em> 的平方根实际上是 <em>2.82842<em>，题目要求我们将小数部分舍去。因此输出 *2</em>。于是我们知道：由于输出结果的时候，需要将小数部分舍去，因此问题的答案，平方以后一定不会严格大于输入的整数。这里返回 *3</em> 就不对了，这是因为 <em>3^2 = 9 &gt; 8</em>。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>从题目的要求和示例我们可以看出，这其实是一个查找整数的问题，并且这个整数是有范围的。</p><ul><li>如果这个整数的平方 <strong>恰好等于</strong> 输入整数，那么我们就找到了这个整数；</li><li>如果这个整数的平方 <strong>严格大于</strong> 输入整数，那么这个整数肯定不是我们要找的那个数；</li><li>如果这个整数的平方 <strong>严格小于</strong> 输入整数，那么这个整数 <strong>可能</strong> 是我们要找的那个数（重点理解这句话）。</li></ul><p>因此我们可以使用「二分查找」来查找这个整数，不断缩小范围去猜。</p><ul><li>猜的数平方以后大了就往小了猜；</li><li>猜的数平方以后恰恰好等于输入的数就找到了；</li><li>猜的数平方以后小了，可能猜的数就是，也可能不是。</li></ul><p>很容易知道，题目要我们返回的整数是有范围的，直觉上一个整数的平方根肯定不会超过它自己的一半，但是 <em>0</em> 和 <em>1</em> 除外，因此我们可以在 <em>1</em> 到输入整数除以 <em>2</em> 这个范围里查找我们要找的平方根整数。<em>0</em> 单独判断一下就好。</p><p><strong>参考代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(logx) ，每一次搜索的区间大小约为原来的1/2 ，时间复杂度为 O(log_2x)=O(logx) ；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><p><strong>对代码编写逻辑的解释</strong>：</p><p>一、写 <code>if</code> 和 <code>else</code> 的原因：</p><ul><li>猜的数是 <code>mid</code> ，根据上面的分析，如果 <code>mid</code> 的平方 <strong>严格大于</strong> <code>x</code>，<code>mid</code> 肯定不是解，比 <code>mid</code> 大的整数也肯定不是解，因此问题的答案只可能存在区间 <code>[left..mid - 1]</code>，此时设置 <code>right = mid - 1</code>；</li><li><code>else</code> 的情况就是 <code>if</code> 的反面，只要 <code>if</code> 的分支和对应的区间分析对了，<code>else</code> 的区间是  <code>[left..mid - 1]</code> 的反面区间，即 <code>[mid..right]</code> ，此时设置 <code>left = mid</code>。</li></ul><p>二、为什么最后返回 <code>left</code>。</p><ul><li>退出 <code>while (left &lt; right)</code> 循环的时候，由于边界搜索是 <code>left = mid</code> 与 <code>right = mid - 1</code>，因此退出循环的时候一定有 <code>left</code> 与 <code>right</code> 重合，返回 <code>right</code> 也可以。</li></ul><hr><h2 id="问题：mid-为什么要加-1？"><a href="#问题：mid-为什么要加-1？" class="headerlink" title="问题：mid 为什么要加 1？"></a>问题：<code>mid</code> 为什么要加 <code>1</code>？</h2><p>对着错误的测试用例打印出变量 <code>left</code> 、<code>right</code> 和 <code>mid</code> 的值看一下就很清楚了。</p><p><strong><code>mid</code> 不加 <code>1</code> 会造成死循环的代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 取中间数 mid 下取整时</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调试语句开始</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"left = "</span> + left + <span class="string">", right = "</span> + right + <span class="string">", mid = "</span> + mid);</span><br><span class="line">            <span class="comment">// 调试语句结束</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> res = solution.mySqrt(x);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left = 1, right = 4, mid = 2</span><br><span class="line">left = 2, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br></pre></td></tr></table></figure><p><strong>在区间只有 <em>2</em> 个数的时候</strong>，本题 <code>if</code>、<code>else</code> 的逻辑区间的划分方式是：<code>[left..mid - 1]</code> 与 <code>[mid..right]</code>。如果 <code>mid</code> 下取整，在区间只有 <em>2</em> 个数的时候有 <code>mid</code> 的值等于 <code>left</code>，一旦进入分支 <code>[mid..right]</code> 区间不会再缩小，出现死循环。</p><p><a href="https://pic.leetcode-cn.com/1639366986-BFgeWx-image.png" target="_blank" rel="noopener">image.png</a></p><p><strong>解决办法</strong>：把取中间数的方式改成上取整。</p><h1 id="方法一：袖珍计算器算法"><a href="#方法一：袖珍计算器算法" class="headerlink" title="方法一：袖珍计算器算法"></a>方法一：袖珍计算器算法</h1><p>「袖珍计算器算法」是一种用指数函数 exp  和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p><p>我们将sqrt(x) 写成幂的形式 <em>x^{1/2}*，再使用自然对数 *e</em> 进行换底，即可得到</p><pre><code>sqrt(x)=x^{1/2} = (e^lnx)^{1/2}=e^{lnx/2}</code></pre><p>这样我们就可以得到sqrt(x)的值了。</p><p><strong>注意：</strong> 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 <a href="https://baike.baidu.com/item/IEEE%20754" target="_blank" rel="noopener">IEEE 754</a>，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。例如当 <em>x = 2147395600</em> 时，(e^lnx/2) 的计算结果与正确值 <em>46340</em> 相差 <em>10^{-11}*，这样在对结果取整数部分时，会得到 *46339</em> 这个错误的结果。</p><p>因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1  中哪一个是真正的答案。</p><details>    <summary>袖珍计算器算法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = int(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="keyword">int</span>(math.Exp(<span class="number">0.5</span> * math.Log(<span class="keyword">float64</span>(x))))</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x &#123;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em>，由于内置的 <code>exp</code> 函数与 <code>log</code> 函数一般都很快，我们在这里将其复杂度视为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>由于 <em>x</em> 平方根的整数部分 ans 是<strong>满足 k^2&lt;=x  的最大 <em>k</em> 值</strong>，因此我们可以对 <em>k</em> 进行二分查找，从而得到答案。</p><p>二分查找的下界为 <em>0</em>，上界可以粗略地设定为 <em>x</em>。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 <em>x</em> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, x</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt;= x &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logx)，即为二分查找需要的次数。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：牛顿迭代"><a href="#方法三：牛顿迭代" class="headerlink" title="方法三：牛顿迭代"></a>方法三：牛顿迭代</h1><p><strong>思路</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。参见<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">^2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II072</title>
    <link href="http://yoursite.com/2021/12/13/%E5%89%91%E6%8C%87%20Offer%20II%20072.%20%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/13/剑指 Offer II 072. 求平方根(二分法模板题及经典解释）/</id>
    <published>2021-12-13T07:23:12.000Z</published>
    <updated>2021-12-13T10:26:04.755Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><p> 注意：本题与<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69.x的平方根</a>相同</p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道常见的面试题，面试官一般会要求面试者在不使用sqrt 函数的情况下，得到 <em>x</em> 的平方根的整数部分。一般的思路会有以下几种：</p><ul><li><p>通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；</p></li><li><p>通过数学方法得到近似结果，直接作为答案。</p></li></ul><h1 id="二分法典型解法-二分法模板题及经典解释）-1"><a href="#二分法典型解法-二分法模板题及经典解释）-1" class="headerlink" title="二分法典型解法(二分法模板题及经典解释）^1"></a>二分法典型解法(二分法模板题及经典解释）<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">^1</a></h1><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><ul><li>这道题要求我们实现平方根函数，输入是一个非负整数，输出也是一个整数；</li><li>但是题目当中说：结果只保留整数的部分，小数部分将被舍去。这是什么意思呢？我们分析一下示例。</li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这是显然的，<em>4</em> 本身是一个完全平方数，<em>2^2 = 4</em>。虽然在数学上一个数的平方根有正有负，但是这个题目只要求我们返回算术平方根。</p><p>示例 2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>因为 <em>8</em> 的平方根实际上是 <em>2.82842<em>，题目要求我们将小数部分舍去。因此输出 *2</em>。于是我们知道：由于输出结果的时候，需要将小数部分舍去，因此问题的答案，平方以后一定不会严格大于输入的整数。这里返回 *3</em> 就不对了，这是因为 <em>3^2 = 9 &gt; 8</em>。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>从题目的要求和示例我们可以看出，这其实是一个查找整数的问题，并且这个整数是有范围的。</p><ul><li>如果这个整数的平方 <strong>恰好等于</strong> 输入整数，那么我们就找到了这个整数；</li><li>如果这个整数的平方 <strong>严格大于</strong> 输入整数，那么这个整数肯定不是我们要找的那个数；</li><li>如果这个整数的平方 <strong>严格小于</strong> 输入整数，那么这个整数 <strong>可能</strong> 是我们要找的那个数（重点理解这句话）。</li></ul><p>因此我们可以使用「二分查找」来查找这个整数，不断缩小范围去猜。</p><ul><li>猜的数平方以后大了就往小了猜；</li><li>猜的数平方以后恰恰好等于输入的数就找到了；</li><li>猜的数平方以后小了，可能猜的数就是，也可能不是。</li></ul><p>很容易知道，题目要我们返回的整数是有范围的，直觉上一个整数的平方根肯定不会超过它自己的一半，但是 <em>0</em> 和 <em>1</em> 除外，因此我们可以在 <em>1</em> 到输入整数除以 <em>2</em> 这个范围里查找我们要找的平方根整数。<em>0</em> 单独判断一下就好。</p><p><strong>参考代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(logx) ，每一次搜索的区间大小约为原来的1/2 ，时间复杂度为 O(log_2x)=O(logx) ；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><p><strong>对代码编写逻辑的解释</strong>：</p><p>一、写 <code>if</code> 和 <code>else</code> 的原因：</p><ul><li>猜的数是 <code>mid</code> ，根据上面的分析，如果 <code>mid</code> 的平方 <strong>严格大于</strong> <code>x</code>，<code>mid</code> 肯定不是解，比 <code>mid</code> 大的整数也肯定不是解，因此问题的答案只可能存在区间 <code>[left..mid - 1]</code>，此时设置 <code>right = mid - 1</code>；</li><li><code>else</code> 的情况就是 <code>if</code> 的反面，只要 <code>if</code> 的分支和对应的区间分析对了，<code>else</code> 的区间是  <code>[left..mid - 1]</code> 的反面区间，即 <code>[mid..right]</code> ，此时设置 <code>left = mid</code>。</li></ul><p>二、为什么最后返回 <code>left</code>。</p><ul><li>退出 <code>while (left &lt; right)</code> 循环的时候，由于边界搜索是 <code>left = mid</code> 与 <code>right = mid - 1</code>，因此退出循环的时候一定有 <code>left</code> 与 <code>right</code> 重合，返回 <code>right</code> 也可以。</li></ul><hr><h2 id="问题：mid-为什么要加-1？"><a href="#问题：mid-为什么要加-1？" class="headerlink" title="问题：mid 为什么要加 1？"></a>问题：<code>mid</code> 为什么要加 <code>1</code>？</h2><p>对着错误的测试用例打印出变量 <code>left</code> 、<code>right</code> 和 <code>mid</code> 的值看一下就很清楚了。</p><p><strong><code>mid</code> 不加 <code>1</code> 会造成死循环的代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 取中间数 mid 下取整时</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调试语句开始</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"left = "</span> + left + <span class="string">", right = "</span> + right + <span class="string">", mid = "</span> + mid);</span><br><span class="line">            <span class="comment">// 调试语句结束</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> res = solution.mySqrt(x);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left = 1, right = 4, mid = 2</span><br><span class="line">left = 2, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br></pre></td></tr></table></figure><p><strong>在区间只有 <em>2</em> 个数的时候</strong>，本题 <code>if</code>、<code>else</code> 的逻辑区间的划分方式是：<code>[left..mid - 1]</code> 与 <code>[mid..right]</code>。如果 <code>mid</code> 下取整，在区间只有 <em>2</em> 个数的时候有 <code>mid</code> 的值等于 <code>left</code>，一旦进入分支 <code>[mid..right]</code> 区间不会再缩小，出现死循环。</p><p><a href="https://pic.leetcode-cn.com/1639366986-BFgeWx-image.png" target="_blank" rel="noopener">image.png</a></p><p><strong>解决办法</strong>：把取中间数的方式改成上取整。</p><h1 id="方法一：袖珍计算器算法"><a href="#方法一：袖珍计算器算法" class="headerlink" title="方法一：袖珍计算器算法"></a>方法一：袖珍计算器算法</h1><p>「袖珍计算器算法」是一种用指数函数 exp  和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p><p>我们将sqrt(x) 写成幂的形式 <em>x^{1/2}*，再使用自然对数 *e</em> 进行换底，即可得到</p><pre><code>sqrt(x)=x^{1/2} = (e^lnx)^{1/2}=e^{lnx/2}</code></pre><p>这样我们就可以得到sqrt(x)的值了。</p><p><strong>注意：</strong> 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 <a href="https://baike.baidu.com/item/IEEE%20754" target="_blank" rel="noopener">IEEE 754</a>，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。例如当 <em>x = 2147395600</em> 时，(e^lnx/2) 的计算结果与正确值 <em>46340</em> 相差 <em>10^{-11}*，这样在对结果取整数部分时，会得到 *46339</em> 这个错误的结果。</p><p>因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1  中哪一个是真正的答案。</p><details>    <summary>袖珍计算器算法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = int(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="keyword">int</span>(math.Exp(<span class="number">0.5</span> * math.Log(<span class="keyword">float64</span>(x))))</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x &#123;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em>，由于内置的 <code>exp</code> 函数与 <code>log</code> 函数一般都很快，我们在这里将其复杂度视为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>由于 <em>x</em> 平方根的整数部分 ans 是<strong>满足 k^2&lt;=x  的最大 <em>k</em> 值</strong>，因此我们可以对 <em>k</em> 进行二分查找，从而得到答案。</p><p>二分查找的下界为 <em>0</em>，上界可以粗略地设定为 <em>x</em>。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 <em>x</em> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, x</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt;= x &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logx)，即为二分查找需要的次数。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：牛顿迭代"><a href="#方法三：牛顿迭代" class="headerlink" title="方法三：牛顿迭代"></a>方法三：牛顿迭代</h1><p><strong>思路</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。参见<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">^2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
</feed>
