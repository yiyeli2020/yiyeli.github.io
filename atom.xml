<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-14T15:34:37.497Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>873. 最长的斐波那契子序列的长度</title>
    <link href="http://yoursite.com/2021/12/14/873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>http://yoursite.com/2021/12/14/873. 最长的斐波那契子序列的长度/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:34:37.497Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 093. 最长斐波那契数列</title>
    <link href="http://yoursite.com/2021/12/14/%E5%89%91%E6%8C%87%20Offer%20II%20093.%20%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2021/12/14/剑指 Offer II 093. 最长斐波那契数列/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:36:10.891Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><p>本题与<a href="https://leetcode-cn.com/problems/length-of-longest-fibonacc//i-subsequence/" target="_blank" rel="noopener">873. 最长的斐波那契子序列的长度</a>相同： </p><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>372. 超级次方</title>
    <link href="http://yoursite.com/2021/12/13/372.%20%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
    <id>http://yoursite.com/2021/12/13/372. 超级次方/</id>
    <published>2021-12-13T07:28:12.000Z</published>
    <updated>2021-12-13T10:23:30.426Z</updated>
    
    <content type="html"><![CDATA[<p>你的任务是计算ab对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：a = 2, b = [3]输出：8</code></pre><p>示例 2：</p><pre><code>输入：a = 2, b = [1,0]输出：1024</code></pre><p>示例 3：</p><pre><code>输入：a = 1, b = [4,3,3,8,5,2]输出：1</code></pre><p>示例 4：</p><pre><code>输入：a = 2147483647, b = [2,0,0]输出：1198</code></pre><p>提示：</p><pre><code>1 &lt;= a &lt;= 231 - 11 &lt;= b.length &lt;= 20000 &lt;= b[i] &lt;= 9b 不含前导 0</code></pre><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>在阅读本文前，读者需要掌握快速幂这一算法，具体可以见「<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">50. Pow(x, n) 的官方题解</a>」。</p><h1 id="方法一：倒序遍历-1"><a href="#方法一：倒序遍历-1" class="headerlink" title="方法一：倒序遍历^1"></a>方法一：倒序遍历<a href="https://leetcode-cn.com/problems/super-pow/solution/chao-ji-ci-fang-by-leetcode-solution-ow8j/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superPow</span><span class="params">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class="line">        MOD = <span class="number">1337</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> reversed(b):</span><br><span class="line">            ans = ans * pow(a, e, MOD) % MOD</span><br><span class="line">            a = pow(a, <span class="number">10</span>, MOD)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">long</span>) res * x % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">long</span>) x * x % MOD;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">long</span>) ans * <span class="built_in">pow</span>(a, b[i]) % MOD;</span><br><span class="line">            a = <span class="built_in">pow</span>(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    const int MOD = 1337;</span><br><span class="line"></span><br><span class="line">    public int SuperPow(int a, int[] b) &#123;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = b.Length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            ans = (int) ((long) ans * Pow(a, b[i]) % MOD);</span><br><span class="line">            a = Pow(a, 10);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pow(int x, int n) &#123;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            if (n % 2 != 0) &#123;</span><br><span class="line">                res = (int) ((long) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (int) ((long) x * x % MOD);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            res = res * x % mod</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superPow</span><span class="params">(a <span class="keyword">int</span>, b []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(b)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        ans = ans * pow(a, b[i]) % mod</span><br><span class="line">        a = pow(a, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD = BigInt(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superPow = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ans = ans * pow(BigInt(a), b[i]) % MOD;</span><br><span class="line">        a = pow(BigInt(a), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            res = res * BigInt(x) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：秦九韶算法（正序遍历）"><a href="#方法二：秦九韶算法（正序遍历）" class="headerlink" title="方法二：秦九韶算法（正序遍历）"></a>方法二：秦九韶算法（正序遍历）</h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superPow</span><span class="params">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class="line">        MOD = <span class="number">1337</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> b:</span><br><span class="line">            ans = pow(ans, <span class="number">10</span>, MOD) * pow(a, e, MOD) % MOD</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">long</span>) res * x % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">long</span>) x * x % MOD;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e: b) &#123;</span><br><span class="line">            ans = (<span class="keyword">long</span>) <span class="built_in">pow</span>(ans, <span class="number">10</span>) * <span class="built_in">pow</span>(a, e) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : b) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) pow(ans, <span class="number">10</span>) * pow(a, e) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    const int MOD = 1337;</span><br><span class="line"></span><br><span class="line">    public int SuperPow(int a, int[] b) &#123;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        foreach (int e in b) &#123;</span><br><span class="line">            ans = (int) ((long) Pow(ans, 10) * Pow(a, e) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pow(int x, int n) &#123;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            if (n % 2 != 0) &#123;</span><br><span class="line">                res = (int) ((long) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (int) ((long) x * x % MOD);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            res = res * x % mod</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superPow</span><span class="params">(a <span class="keyword">int</span>, b []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> b &#123;</span><br><span class="line">        ans = pow(ans, <span class="number">10</span>) * pow(a, e) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD = BigInt(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superPow = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> e <span class="keyword">of</span> b) &#123;</span><br><span class="line">        ans = pow(BigInt(ans), <span class="number">10</span>) * pow(BigInt(a), e) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            res = res * BigInt(x) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的任务是计算ab对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Division" scheme="http://yoursite.com/tags/Division/"/>
    
  </entry>
  
  <entry>
    <title>69. x 的平方根(二分法模板题及经典解释）</title>
    <link href="http://yoursite.com/2021/12/13/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/13/69. x 的平方根(二分法模板题及经典解释）/</id>
    <published>2021-12-13T07:23:12.000Z</published>
    <updated>2021-12-13T07:23:04.822Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道常见的面试题，面试官一般会要求面试者在不使用sqrt 函数的情况下，得到 <em>x</em> 的平方根的整数部分。一般的思路会有以下几种：</p><ul><li><p>通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；</p></li><li><p>通过数学方法得到近似结果，直接作为答案。</p></li></ul><h1 id="二分法典型解法-二分法模板题及经典解释）-1"><a href="#二分法典型解法-二分法模板题及经典解释）-1" class="headerlink" title="二分法典型解法(二分法模板题及经典解释）^1"></a>二分法典型解法(二分法模板题及经典解释）<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">^1</a></h1><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><ul><li>这道题要求我们实现平方根函数，输入是一个非负整数，输出也是一个整数；</li><li>但是题目当中说：结果只保留整数的部分，小数部分将被舍去。这是什么意思呢？我们分析一下示例。</li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这是显然的，<em>4</em> 本身是一个完全平方数，<em>2^2 = 4</em>。虽然在数学上一个数的平方根有正有负，但是这个题目只要求我们返回算术平方根。</p><p>示例 2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>因为 <em>8</em> 的平方根实际上是 <em>2.82842<em>，题目要求我们将小数部分舍去。因此输出 *2</em>。于是我们知道：由于输出结果的时候，需要将小数部分舍去，因此问题的答案，平方以后一定不会严格大于输入的整数。这里返回 *3</em> 就不对了，这是因为 <em>3^2 = 9 &gt; 8</em>。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>从题目的要求和示例我们可以看出，这其实是一个查找整数的问题，并且这个整数是有范围的。</p><ul><li>如果这个整数的平方 <strong>恰好等于</strong> 输入整数，那么我们就找到了这个整数；</li><li>如果这个整数的平方 <strong>严格大于</strong> 输入整数，那么这个整数肯定不是我们要找的那个数；</li><li>如果这个整数的平方 <strong>严格小于</strong> 输入整数，那么这个整数 <strong>可能</strong> 是我们要找的那个数（重点理解这句话）。</li></ul><p>因此我们可以使用「二分查找」来查找这个整数，不断缩小范围去猜。</p><ul><li>猜的数平方以后大了就往小了猜；</li><li>猜的数平方以后恰恰好等于输入的数就找到了；</li><li>猜的数平方以后小了，可能猜的数就是，也可能不是。</li></ul><p>很容易知道，题目要我们返回的整数是有范围的，直觉上一个整数的平方根肯定不会超过它自己的一半，但是 <em>0</em> 和 <em>1</em> 除外，因此我们可以在 <em>1</em> 到输入整数除以 <em>2</em> 这个范围里查找我们要找的平方根整数。<em>0</em> 单独判断一下就好。</p><p><strong>参考代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(logx) ，每一次搜索的区间大小约为原来的1/2 ，时间复杂度为 O(log_2x)=O(logx) ；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><p><strong>对代码编写逻辑的解释</strong>：</p><p>一、写 <code>if</code> 和 <code>else</code> 的原因：</p><ul><li>猜的数是 <code>mid</code> ，根据上面的分析，如果 <code>mid</code> 的平方 <strong>严格大于</strong> <code>x</code>，<code>mid</code> 肯定不是解，比 <code>mid</code> 大的整数也肯定不是解，因此问题的答案只可能存在区间 <code>[left..mid - 1]</code>，此时设置 <code>right = mid - 1</code>；</li><li><code>else</code> 的情况就是 <code>if</code> 的反面，只要 <code>if</code> 的分支和对应的区间分析对了，<code>else</code> 的区间是  <code>[left..mid - 1]</code> 的反面区间，即 <code>[mid..right]</code> ，此时设置 <code>left = mid</code>。</li></ul><p>二、为什么最后返回 <code>left</code>。</p><ul><li>退出 <code>while (left &lt; right)</code> 循环的时候，由于边界搜索是 <code>left = mid</code> 与 <code>right = mid - 1</code>，因此退出循环的时候一定有 <code>left</code> 与 <code>right</code> 重合，返回 <code>right</code> 也可以。</li></ul><hr><h2 id="问题：mid-为什么要加-1？"><a href="#问题：mid-为什么要加-1？" class="headerlink" title="问题：mid 为什么要加 1？"></a>问题：<code>mid</code> 为什么要加 <code>1</code>？</h2><p>对着错误的测试用例打印出变量 <code>left</code> 、<code>right</code> 和 <code>mid</code> 的值看一下就很清楚了。</p><p><strong><code>mid</code> 不加 <code>1</code> 会造成死循环的代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 取中间数 mid 下取整时</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调试语句开始</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"left = "</span> + left + <span class="string">", right = "</span> + right + <span class="string">", mid = "</span> + mid);</span><br><span class="line">            <span class="comment">// 调试语句结束</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> res = solution.mySqrt(x);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left = 1, right = 4, mid = 2</span><br><span class="line">left = 2, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br></pre></td></tr></table></figure><p><strong>在区间只有 <em>2</em> 个数的时候</strong>，本题 <code>if</code>、<code>else</code> 的逻辑区间的划分方式是：<code>[left..mid - 1]</code> 与 <code>[mid..right]</code>。如果 <code>mid</code> 下取整，在区间只有 <em>2</em> 个数的时候有 <code>mid</code> 的值等于 <code>left</code>，一旦进入分支 <code>[mid..right]</code> 区间不会再缩小，出现死循环。</p><p><a href="https://pic.leetcode-cn.com/1639366986-BFgeWx-image.png" target="_blank" rel="noopener">image.png</a></p><p><strong>解决办法</strong>：把取中间数的方式改成上取整。</p><h1 id="方法一：袖珍计算器算法"><a href="#方法一：袖珍计算器算法" class="headerlink" title="方法一：袖珍计算器算法"></a>方法一：袖珍计算器算法</h1><p>「袖珍计算器算法」是一种用指数函数 exp  和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p><p>我们将sqrt(x) 写成幂的形式 <em>x^{1/2}*，再使用自然对数 *e</em> 进行换底，即可得到</p><pre><code>sqrt(x)=x^{1/2} = (e^lnx)^{1/2}=e^{lnx/2}</code></pre><p>这样我们就可以得到sqrt(x)的值了。</p><p><strong>注意：</strong> 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 <a href="https://baike.baidu.com/item/IEEE%20754" target="_blank" rel="noopener">IEEE 754</a>，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。例如当 <em>x = 2147395600</em> 时，(e^lnx/2) 的计算结果与正确值 <em>46340</em> 相差 <em>10^{-11}*，这样在对结果取整数部分时，会得到 *46339</em> 这个错误的结果。</p><p>因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1  中哪一个是真正的答案。</p><details>    <summary>袖珍计算器算法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = int(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="keyword">int</span>(math.Exp(<span class="number">0.5</span> * math.Log(<span class="keyword">float64</span>(x))))</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x &#123;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em>，由于内置的 <code>exp</code> 函数与 <code>log</code> 函数一般都很快，我们在这里将其复杂度视为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>由于 <em>x</em> 平方根的整数部分 ans 是<strong>满足 k^2&lt;=x  的最大 <em>k</em> 值</strong>，因此我们可以对 <em>k</em> 进行二分查找，从而得到答案。</p><p>二分查找的下界为 <em>0</em>，上界可以粗略地设定为 <em>x</em>。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 <em>x</em> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, x</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt;= x &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logx)，即为二分查找需要的次数。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：牛顿迭代"><a href="#方法三：牛顿迭代" class="headerlink" title="方法三：牛顿迭代"></a>方法三：牛顿迭代</h1><p><strong>思路</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。参见<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">^2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II072</title>
    <link href="http://yoursite.com/2021/12/13/%E5%89%91%E6%8C%87%20Offer%20II%20072.%20%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/13/剑指 Offer II 072. 求平方根(二分法模板题及经典解释）/</id>
    <published>2021-12-13T07:23:12.000Z</published>
    <updated>2021-12-13T10:26:04.755Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><p> 注意：本题与<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69.x的平方根</a>相同</p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道常见的面试题，面试官一般会要求面试者在不使用sqrt 函数的情况下，得到 <em>x</em> 的平方根的整数部分。一般的思路会有以下几种：</p><ul><li><p>通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；</p></li><li><p>通过数学方法得到近似结果，直接作为答案。</p></li></ul><h1 id="二分法典型解法-二分法模板题及经典解释）-1"><a href="#二分法典型解法-二分法模板题及经典解释）-1" class="headerlink" title="二分法典型解法(二分法模板题及经典解释）^1"></a>二分法典型解法(二分法模板题及经典解释）<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">^1</a></h1><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><ul><li>这道题要求我们实现平方根函数，输入是一个非负整数，输出也是一个整数；</li><li>但是题目当中说：结果只保留整数的部分，小数部分将被舍去。这是什么意思呢？我们分析一下示例。</li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这是显然的，<em>4</em> 本身是一个完全平方数，<em>2^2 = 4</em>。虽然在数学上一个数的平方根有正有负，但是这个题目只要求我们返回算术平方根。</p><p>示例 2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>因为 <em>8</em> 的平方根实际上是 <em>2.82842<em>，题目要求我们将小数部分舍去。因此输出 *2</em>。于是我们知道：由于输出结果的时候，需要将小数部分舍去，因此问题的答案，平方以后一定不会严格大于输入的整数。这里返回 *3</em> 就不对了，这是因为 <em>3^2 = 9 &gt; 8</em>。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>从题目的要求和示例我们可以看出，这其实是一个查找整数的问题，并且这个整数是有范围的。</p><ul><li>如果这个整数的平方 <strong>恰好等于</strong> 输入整数，那么我们就找到了这个整数；</li><li>如果这个整数的平方 <strong>严格大于</strong> 输入整数，那么这个整数肯定不是我们要找的那个数；</li><li>如果这个整数的平方 <strong>严格小于</strong> 输入整数，那么这个整数 <strong>可能</strong> 是我们要找的那个数（重点理解这句话）。</li></ul><p>因此我们可以使用「二分查找」来查找这个整数，不断缩小范围去猜。</p><ul><li>猜的数平方以后大了就往小了猜；</li><li>猜的数平方以后恰恰好等于输入的数就找到了；</li><li>猜的数平方以后小了，可能猜的数就是，也可能不是。</li></ul><p>很容易知道，题目要我们返回的整数是有范围的，直觉上一个整数的平方根肯定不会超过它自己的一半，但是 <em>0</em> 和 <em>1</em> 除外，因此我们可以在 <em>1</em> 到输入整数除以 <em>2</em> 这个范围里查找我们要找的平方根整数。<em>0</em> 单独判断一下就好。</p><p><strong>参考代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(logx) ，每一次搜索的区间大小约为原来的1/2 ，时间复杂度为 O(log_2x)=O(logx) ；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><p><strong>对代码编写逻辑的解释</strong>：</p><p>一、写 <code>if</code> 和 <code>else</code> 的原因：</p><ul><li>猜的数是 <code>mid</code> ，根据上面的分析，如果 <code>mid</code> 的平方 <strong>严格大于</strong> <code>x</code>，<code>mid</code> 肯定不是解，比 <code>mid</code> 大的整数也肯定不是解，因此问题的答案只可能存在区间 <code>[left..mid - 1]</code>，此时设置 <code>right = mid - 1</code>；</li><li><code>else</code> 的情况就是 <code>if</code> 的反面，只要 <code>if</code> 的分支和对应的区间分析对了，<code>else</code> 的区间是  <code>[left..mid - 1]</code> 的反面区间，即 <code>[mid..right]</code> ，此时设置 <code>left = mid</code>。</li></ul><p>二、为什么最后返回 <code>left</code>。</p><ul><li>退出 <code>while (left &lt; right)</code> 循环的时候，由于边界搜索是 <code>left = mid</code> 与 <code>right = mid - 1</code>，因此退出循环的时候一定有 <code>left</code> 与 <code>right</code> 重合，返回 <code>right</code> 也可以。</li></ul><hr><h2 id="问题：mid-为什么要加-1？"><a href="#问题：mid-为什么要加-1？" class="headerlink" title="问题：mid 为什么要加 1？"></a>问题：<code>mid</code> 为什么要加 <code>1</code>？</h2><p>对着错误的测试用例打印出变量 <code>left</code> 、<code>right</code> 和 <code>mid</code> 的值看一下就很清楚了。</p><p><strong><code>mid</code> 不加 <code>1</code> 会造成死循环的代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 取中间数 mid 下取整时</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调试语句开始</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"left = "</span> + left + <span class="string">", right = "</span> + right + <span class="string">", mid = "</span> + mid);</span><br><span class="line">            <span class="comment">// 调试语句结束</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> res = solution.mySqrt(x);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left = 1, right = 4, mid = 2</span><br><span class="line">left = 2, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br></pre></td></tr></table></figure><p><strong>在区间只有 <em>2</em> 个数的时候</strong>，本题 <code>if</code>、<code>else</code> 的逻辑区间的划分方式是：<code>[left..mid - 1]</code> 与 <code>[mid..right]</code>。如果 <code>mid</code> 下取整，在区间只有 <em>2</em> 个数的时候有 <code>mid</code> 的值等于 <code>left</code>，一旦进入分支 <code>[mid..right]</code> 区间不会再缩小，出现死循环。</p><p><a href="https://pic.leetcode-cn.com/1639366986-BFgeWx-image.png" target="_blank" rel="noopener">image.png</a></p><p><strong>解决办法</strong>：把取中间数的方式改成上取整。</p><h1 id="方法一：袖珍计算器算法"><a href="#方法一：袖珍计算器算法" class="headerlink" title="方法一：袖珍计算器算法"></a>方法一：袖珍计算器算法</h1><p>「袖珍计算器算法」是一种用指数函数 exp  和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p><p>我们将sqrt(x) 写成幂的形式 <em>x^{1/2}*，再使用自然对数 *e</em> 进行换底，即可得到</p><pre><code>sqrt(x)=x^{1/2} = (e^lnx)^{1/2}=e^{lnx/2}</code></pre><p>这样我们就可以得到sqrt(x)的值了。</p><p><strong>注意：</strong> 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 <a href="https://baike.baidu.com/item/IEEE%20754" target="_blank" rel="noopener">IEEE 754</a>，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。例如当 <em>x = 2147395600</em> 时，(e^lnx/2) 的计算结果与正确值 <em>46340</em> 相差 <em>10^{-11}*，这样在对结果取整数部分时，会得到 *46339</em> 这个错误的结果。</p><p>因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1  中哪一个是真正的答案。</p><details>    <summary>袖珍计算器算法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = int(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="keyword">int</span>(math.Exp(<span class="number">0.5</span> * math.Log(<span class="keyword">float64</span>(x))))</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x &#123;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em>，由于内置的 <code>exp</code> 函数与 <code>log</code> 函数一般都很快，我们在这里将其复杂度视为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>由于 <em>x</em> 平方根的整数部分 ans 是<strong>满足 k^2&lt;=x  的最大 <em>k</em> 值</strong>，因此我们可以对 <em>k</em> 进行二分查找，从而得到答案。</p><p>二分查找的下界为 <em>0</em>，上界可以粗略地设定为 <em>x</em>。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 <em>x</em> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, x</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt;= x &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logx)，即为二分查找需要的次数。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：牛顿迭代"><a href="#方法三：牛顿迭代" class="headerlink" title="方法三：牛顿迭代"></a>方法三：牛顿迭代</h1><p><strong>思路</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。参见<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">^2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>50. Pow(x, n)快速幂算法</title>
    <link href="http://yoursite.com/2021/12/13/50.%20Pow(x,%20n)%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/12/13/50. Pow(x, n)快速幂算法/</id>
    <published>2021-12-13T03:12:12.000Z</published>
    <updated>2021-12-13T06:33:46.311Z</updated>
    
    <content type="html"><![CDATA[<p>在计算斐波那契数时遇到要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，需要用到快速幂算法。</p><p>实现 pow(x, n) ，即计算x的n次幂函数（即x^n）。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：x = 2.00000, n = 10输出：1024.00000</code></pre><p>示例 2：</p><pre><code>输入：x = 2.10000, n = 3输出：9.26100</code></pre><p>示例 3：</p><pre><code>输入：x = 2.00000, n = -2输出：0.25000解释：2^-2 = 1/2^2 = 1/4 = 0.25</code></pre><p>提示：</p><pre><code>-100.0 &lt; x &lt; 100.0-2^31 &lt;= n &lt;= 2^31-1-10^4 &lt;= x^n &lt;= 10^4</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题的方法被称为「快速幂算法」，有递归和迭代两个版本。这篇题解会从递归版本的开始讲起，再逐步引出迭代的版本。</p><p>当指数 <em>n</em> 为负数时，我们可以计算 <em>x^{-n}</em> 再取倒数得到结果，因此我们只需要考虑 <em>n</em> 为自然数的情况。</p><h1 id="方法一：快速幂-递归-1"><a href="#方法一：快速幂-递归-1" class="headerlink" title="方法一：快速幂 + 递归^1"></a>方法一：快速幂 + 递归<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></h1><p>「快速幂算法」的本质是分治算法。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">            y = quickMul(N // <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> y * y <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> y * y * x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickMul(x, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / quickMul(x, -n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickMul</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := quickMul(x, n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y * y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y * y * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：快速幂-迭代"><a href="#方法二：快速幂-迭代" class="headerlink" title="方法二：快速幂 + 迭代"></a>方法二：快速幂 + 迭代</h1><p>由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 <em>x</em>。但我们不妨找一找规律，看看哪些地方额外乘了 <em>x</em>，并且它们对答案产生了什么影响。</p><p>下面的代码给出了详细的注释。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(N)</span>:</span></span><br><span class="line">            ans = <span class="number">1.0</span></span><br><span class="line">            <span class="comment"># 贡献的初始值为 x</span></span><br><span class="line">            x_contribute = x</span><br><span class="line">            <span class="comment"># 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">            <span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                    ans *= x_contribute</span><br><span class="line">                <span class="comment"># 将贡献不断地平方</span></span><br><span class="line">                x_contribute *= x_contribute</span><br><span class="line">                <span class="comment"># 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">                N //= <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickMul(x, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / quickMul(x, -n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickMul</span><span class="params">(x <span class="keyword">float64</span>, N <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1.0</span></span><br><span class="line">    <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">    x_contribute := x</span><br><span class="line">    <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">    <span class="keyword">for</span> N &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">            ans *= x_contribute</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">        x_contribute *= x_contribute</span><br><span class="line">        <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">        N /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算斐波那契数时遇到要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，需要用到快速幂算法。&lt;/p&gt;
&lt;p&gt;实现 pow(x, n) ，即计算x的n次幂函数（即x^n）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>509. 斐波那契数</title>
    <link href="http://yoursite.com/2021/12/13/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/13/509. 斐波那契数/</id>
    <published>2021-12-13T02:12:12.000Z</published>
    <updated>2021-12-13T03:16:50.108Z</updated>
    
    <content type="html"><![CDATA[<p> 计算斐波那契数，虽然此题看起来简单，但面试中常要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，难度属实不低。</p><a id="more"></a><p>[TOC]</p><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p>示例 1：</p><pre><code>输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1</code></pre><p>示例 2：</p><pre><code>输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2</code></pre><p>示例 3：</p><pre><code>输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3</code></pre><p>提示：</p><pre><code>0 &lt;= n &lt;= 30</code></pre><p>与<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a>相同</p><p>参见<a href="https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/" target="_blank" rel="noopener">^1</a></p><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p>斐波那契数的边界条件是 <em>F(0)=0</em> 和 <em>F(1)=1*。当 *n&gt;1</em> 时，每一项的和都等于前两项的和，因此有如下递推关系：</p><p><em>F(n)=F(n-1)+F(n-2)</em></p><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 <em>F(0)</em> 和 <em>F(1)</em>。</p><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 <em>O(n)</em> 的实现。由于 <em>F(n)</em> 只和 <em>F(n-1)</em> 与 <em>F(n-2)</em> 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <em>O(1)</em>。<strong>如下的代码中给出的就是这种实现。</strong></p><p> <a href="https://assets.leetcode-cn.com/solution-static/509/509_fig1.gif" target="_blank" rel="noopener">fig1</a></p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        p, q, r = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            p, q = q, r</span><br><span class="line">            r = p + q</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：矩阵快速幂"><a href="#方法二：矩阵快速幂" class="headerlink" title="方法二：矩阵快速幂"></a>方法二：矩阵快速幂</h1><p>方法一的时间复杂度是 <em>O(n)</em>。使用矩阵快速幂的方法可以降低时间复杂度。</p><p>首先我们可以构建一个递推关系：</p><p>因此只要我们能快速计算矩阵 <em>M</em> 的 <em>n</em> 次幂，就可以得到 <em>F(n)</em> 的值。如果直接求取 <em>M^n<em>，时间复杂度是 *O(n)</em>，可以定义矩阵乘法，然后用快速幂算法来加速这里 *M^n</em> 的求取。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = matrix_pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix_pow(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret = matrix_multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = matrix_multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix_multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">const</span> res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">a, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">            ret = multiply(ret, a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = multiply(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> matrix [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(a, b matrix)</span> <span class="params">(c matrix)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>]*b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>]*b[<span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a matrix, n <span class="keyword">int</span>)</span> <span class="title">matrix</span></span> &#123;</span><br><span class="line">    ret := matrix&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ret = multiply(ret, a)</span><br><span class="line">        &#125;</span><br><span class="line">        a = multiply(a, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    res := pow(matrix&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Matrix <span class="title">matrixMultiply</span><span class="params">(struct Matrix* a, struct Matrix* b)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c.mat[i][j] = (*a).mat[i][<span class="number">0</span>] * (*b).mat[<span class="number">0</span>][j] + (*a).mat[i][<span class="number">1</span>] * (*b).mat[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Matrix <span class="title">matrixPow</span><span class="params">(struct Matrix a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">ret</span>;</span></span><br><span class="line">    ret.mat[<span class="number">0</span>][<span class="number">0</span>] = ret.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ret.mat[<span class="number">0</span>][<span class="number">1</span>] = ret.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = matrixMultiply(&amp;ret, &amp;a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = matrixMultiply(&amp;a, &amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">q</span>;</span></span><br><span class="line">    q.mat[<span class="number">0</span>][<span class="number">0</span>] = q.mat[<span class="number">0</span>][<span class="number">1</span>] = q.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">res</span> = <span class="title">matrixPow</span>(<span class="title">q</span>, <span class="title">n</span> - 1);</span></span><br><span class="line">    <span class="keyword">return</span> res.mat[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        res = self.matrix_pow(q, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrix_pow</span><span class="params">(self, a: List[List[int]], n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ret = self.matrix_multiply(ret, a)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            a = self.matrix_multiply(a, a)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrix_multiply</span><span class="params">(self, a: List[List[int]], b: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        c = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logn)  。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：通项公式"><a href="#方法三：通项公式" class="headerlink" title="方法三：通项公式"></a>方法三：通项公式</h1><p>斐波那契数 <em>F(n)</em> 是齐次线性递推，根据递推方程 <em>F(n)=F(n-1)+F(n-2)</em>，可以写出这样的特征方程：</p><p><em>x^2=x+1</em></p><p>得到通项公式之后，就可以通过公式直接求解第 <em>n</em> 项。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sqrt5 = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> fibN = <span class="built_in">Math</span>.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(fibN / sqrt5);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sqrt5 := math.Sqrt(<span class="number">5</span>)</span><br><span class="line">    p1 := math.Pow((<span class="number">1</span>+sqrt5)/<span class="number">2</span>, <span class="keyword">float64</span>(n))</span><br><span class="line">    p2 := math.Pow((<span class="number">1</span>-sqrt5)/<span class="number">2</span>, <span class="keyword">float64</span>(n))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(math.Round((p1 - p2) / sqrt5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        sqrt5 = <span class="number">5</span>**<span class="number">0.5</span></span><br><span class="line">        fibN = ((<span class="number">1</span> + sqrt5) / <span class="number">2</span>) ** n - ((<span class="number">1</span> - sqrt5) / <span class="number">2</span>) ** n</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>代码中使用的 pow 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 计算斐波那契数，虽然此题看起来简单，但面试中常要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，难度属实不低。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>面试题 08.06. 汉诺塔问题</title>
    <link href="http://yoursite.com/2021/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.06.%20%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/12/13/面试题 08.06. 汉诺塔问题/</id>
    <published>2021-12-13T02:12:12.000Z</published>
    <updated>2021-12-13T02:23:43.428Z</updated>
    
    <content type="html"><![CDATA[<p> 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><a id="more"></a><p>[TOC]</p><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p>示例1:</p><pre><code>输入：A = [2, 1, 0], B = [], C = []输出：C = [2, 1, 0]</code></pre><p>示例2:</p><pre><code>输入：A = [1, 0], B = [], C = []输出：C = [1, 0]</code></pre><p>提示:</p><pre><code>A中盘子的数目不大于14个。</code></pre><h2 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h2><blockquote><p>相传在很久以前，有个寺庙里的几个和尚整天不停地移动着 64 个盘子，日复一日，年复一年。据说，当 64 个盘子全部移完的那一天就是世界末日…</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有 A,B,C 三根柱子，A 上面有 n 个盘子，我们想把 A 上面的盘子移动到 C 上，但是要满足以下三个条件：</p><ol><li>每次只能移动一个盘子;</li><li>盘子只能从柱子顶端滑出移到下一根柱子;</li><li>盘子只能叠在比它大的盘子上。</li></ol><p><a href="https://pic.leetcode-cn.com/7043dec266338d396d186805072660d5f9517e2c1008af80d461b553c5b32470-p1.png" target="_blank" rel="noopener">p1.png</a></p><h3 id="解题思路：递归与分治"><a href="#解题思路：递归与分治" class="headerlink" title="解题思路：递归与分治"></a>解题思路：递归与分治</h3><p>这是一道递归方法的经典题目，乍一想还挺难理清头绪的，我们不妨先从简单的入手。</p><p>假设 <code>n = 1</code>,只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；</p><p>如果 <code>n = 2</code> 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 4 步。</p><p> <a href="https://pic.leetcode-cn.com/f6f3b97651247c9ff846f115e1866ab364b1c0e265fd51689ddd6a8ca1758482-0806.gif" target="_blank" rel="noopener">0806.gif</a></p><p>如果  <code>n &gt; 2</code> 呢？思路和上面是一样的，我们把 n 个盘子也看成两个部分，一部分有 1 个盘子，另一部分有 n - 1 个盘子。</p><p> <a href="https://pic.leetcode-cn.com/3bffd1a1faf4323a92b659e37d7e2cd6c79fe074602b2977f4a7931fe82bbb13-08061.gif" target="_blank" rel="noopener">08061.gif</a></p><p>观察上图，你可能会问：“那 n - 1 个盘子是怎么从 A 移到 C 的呢？”</p><p>注意，<strong>当你在思考这个问题的时候，就将最初的 n 个盘子从 A 移到 C 的问题，转化成了将 n - 1 个盘子从 A 移到 C 的问题，</strong> 依次类推，直至转化成 1 个盘子的问题时，问题也就解决了。这就是分治的思想。 </p><p>而实现分治思想的常用方法就是递归。不难发现，如果原问题可以分解成若干个与原问题结构相同但规模较小的子问题时，往往可以用递归的方法解决。具体解决办法如下：</p><ul><li><code>n = 1</code> 时，直接把盘子从 A 移到 C；</li><li><code>n &gt; 1</code> 时，<ul><li>先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；</li><li>再将最大的盘子从 A 移到 C；</li><li>再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hanota</span><span class="params">(self, A: List[int], B: List[int], C: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        self.move(n, A, B, C)</span><br><span class="line">    <span class="comment"># 定义move 函数移动汉诺塔</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,n, A, B, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            C.append(A[<span class="number">-1</span>])</span><br><span class="line">            A.pop()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.move(n<span class="number">-1</span>, A, C, B)  <span class="comment"># 将A上面n-1个通过C移到B</span></span><br><span class="line">            C.append(A[<span class="number">-1</span>])          <span class="comment"># 将A最后一个移到C</span></span><br><span class="line">            A.pop()                  <span class="comment"># 这时，A空了</span></span><br><span class="line">            self.move(n<span class="number">-1</span>,B, A, C)   <span class="comment"># 将B上面n-1个通过空的A移到C</span></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        move(n, A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.push_back(A.back());</span><br><span class="line">            A.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        move(n<span class="number">-1</span>, A, C, B);    <span class="comment">// 将A上面n-1个通过C移到B</span></span><br><span class="line">        C.push_back(A.back());  <span class="comment">// 将A最后一个移到C</span></span><br><span class="line">        A.pop_back();          <span class="comment">// 这时，A空了</span></span><br><span class="line">        move(n<span class="number">-1</span>, B, A, C);     <span class="comment">// 将B上面n-1个通过空的A移到C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            C.add(A.get(A.size() - <span class="number">1</span>));</span><br><span class="line">            A.remove(A.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move(n - <span class="number">1</span>, A, C, B);</span><br><span class="line">        C.add(A.get(A.size() - <span class="number">1</span>));</span><br><span class="line">        A.remove(A.size() - <span class="number">1</span>);</span><br><span class="line">        move(n - <span class="number">1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析：世界会毁灭吗"><a href="#复杂度分析：世界会毁灭吗" class="headerlink" title="复杂度分析：世界会毁灭吗"></a>复杂度分析：世界会毁灭吗</h2><ul><li>时间复杂度：<em>O(2^n-1)</em>。一共需要移动的次数。</li><li>空间复杂度：<em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ学习笔记（概念，架构和消息交换机类型）</title>
    <link href="http://yoursite.com/2021/12/12/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B6%88%E6%81%AF%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/12/RabbitMQ学习笔记（概念，架构和消息交换机类型）/</id>
    <published>2021-12-12T12:12:12.000Z</published>
    <updated>2021-12-13T01:56:48.612Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ是AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的技术实现，也是高性能消息服务组件的代表之作。由于其隶属于Pivotal公司，所以与Spring的整合效果是最完善的。在SpringCloud开发技术中大量使用了RabbitMQ消息组件。</p><a id="more"></a><p>[TOC]</p><h1 id="概念-1"><a href="#概念-1" class="headerlink" title="概念^1"></a>概念<a href="[名师讲坛：Java微服务架构实战（SpringBoot+SpringCloud+Docker+RabbitMQ](https://weread.qq.com/web/reader/0e03209071c96a420e02710ka0a32dd027aa0a080f42962)">^1</a></h1><p>RabbitMQ是一种消息队列服务，同样也是在进行系统整合时的一种通信手段，其运行模式遵循“生产者—消费者”模型，即会存在若干个消息生产者以及若干个消息消费者。与JavaEE提出的JMS标准不同之处在于：RabbitMQ是由ERLang开发的基于AMQP应用层协议标准的一种消息组件，所以其处理性能要比JMS组件更高。RabbitMQ官方网站的网址为<a href="http://www.rabbitmq.com" target="_blank" rel="noopener">http://www.rabbitmq.com</a></p><p>深入了解还可以参见<a href="[深入RabbitMQ](https://weread.qq.com/web/reader/80c32e0071dbdd9580c74f2k8f132430178f14e45fce0f7)">^2</a></p><h3 id="提示：常见消息组件。"><a href="#提示：常见消息组件。" class="headerlink" title="提示：常见消息组件。"></a>提示：常见消息组件。</h3><p>消息组件主要划分为JMS组件和AMQP组件两类。[插图] JMS（Java Message Service）组件：ActiveMQ性能较差。[插图] AMQP组件（协议）：性能是最高的，而AMQP有两个主要的开源。|- RabbitMQ：使用最为广泛，响应速度快。|- Kafka：是大数据时代作为数据采集的重要组件，处理速度更高。RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购，在2013年5月被并入Pivotal。</p><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p>AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放标准，为<br>面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言<br>等条件的限制。</p><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可<br>用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布<br>确认。</li><li>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对<br>于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路<br>由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节<br>点出问题的情况下队列仍然可用。</li><li>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT<br>等等。</li><li>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、<br>Ruby 等等。</li><li>管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控<br>和管理消息 Broker 的许多方面。</li><li>跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生<br>了什么。</li><li>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编<br>写自己的插件。</li></ol><h1 id="RabbitMQ-架构"><a href="#RabbitMQ-架构" class="headerlink" title="RabbitMQ 架构"></a>RabbitMQ 架构</h1><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h2 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h2><ol><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li></ol><h2 id="Exchange-消息交换机（将消息路由给队列-）"><a href="#Exchange-消息交换机（将消息路由给队列-）" class="headerlink" title="Exchange 消息交换机（将消息路由给队列 ）"></a>Exchange 消息交换机（将消息路由给队列 ）</h2><ol start="2"><li>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li></ol><h2 id="Binding（消息队列和交换器之间的关联）"><a href="#Binding（消息队列和交换器之间的关联）" class="headerlink" title="Binding（消息队列和交换器之间的关联）"></a>Binding（消息队列和交换器之间的关联）</h2><ol start="3"><li>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连<br>接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ol start="4"><li>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息<br>可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li></ol><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol start="5"><li>网络连接，比如一个 TCP 连接。</li></ol><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ol start="6"><li>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li></ol><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><ol start="7"><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li></ol><h2 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h2><ol start="8"><li>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</li></ol><h2 id="Broker-消息队列服务主机"><a href="#Broker-消息队列服务主机" class="headerlink" title="Broker 消息队列服务主机"></a>Broker 消息队列服务主机</h2><ol start="9"><li>表示消息队列服务器实体。</li></ol><h1 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h1><p>Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外headers交换器和direct交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：topic（主题订阅）、direct（直连）、fanout（广播）</p><h2 id="Direct-键（routing-key）分布："><a href="#Direct-键（routing-key）分布：" class="headerlink" title="Direct 键（routing key）分布："></a>Direct 键（routing key）分布：</h2><ol><li>Direct：消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。</li></ol><h2 id="Fanout（广播分发）"><a href="#Fanout（广播分发）" class="headerlink" title="Fanout（广播分发）"></a>Fanout（广播分发）</h2><ol start="2"><li>Fanout：每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout类型转发消息是最快的。</li></ol><h2 id="topic-交换器（模式匹配）"><a href="#topic-交换器（模式匹配）" class="headerlink" title="topic 交换器（模式匹配）"></a>topic 交换器（模式匹配）</h2><ol start="3"><li>topic 交换器：topic交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配 0 个或多个单词，匹配不多不少一个单词。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RabbitMQ是AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的技术实现，也是高性能消息服务组件的代表之作。由于其隶属于Pivotal公司，所以与Spring的整合效果是最完善的。在SpringCloud开发技术中大量使用了RabbitMQ消息组件。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.07. 最大数值</title>
    <link href="http://yoursite.com/2021/12/12/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.07.%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/"/>
    <id>http://yoursite.com/2021/12/12/面试题 16.07. 最大数值/</id>
    <published>2021-12-12T04:12:12.000Z</published>
    <updated>2021-12-12T04:20:48.078Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。</p><a id="more"></a><p>[TOC]</p><p>示例：</p><pre><code>输入： a = 1, b = 2输出： 2</code></pre><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><ol><li><p>首先 a - b 得到差值x</p></li><li><p>由于是long型，右移63位得到符号位，注意负号不变，那么正数右移63位就是0，负数右移63位就是-1</p></li><li><p>那么得出我们的计算公式  (1 + k) * a - b * k</p><p> 当 x &gt;= 0 的时候，k = 0, 即 a &gt; b<br> 那么我们的计算公式为  1 * a - b * 0 = a</p><p> 当 x &lt; 0的时候，k = -1, 即 b &gt; a<br> 那么我们的计算公式为  0 * a - b * ( -1 ) = b</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximum(int a, int b) &#123;</span><br><span class="line">        long x = (long) a - (long) b;</span><br><span class="line">        int k = (int) (x &gt;&gt; 63);</span><br><span class="line"></span><br><span class="line">        return (1 + k) * a - b * k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>关于这道题已有很多解法，大概有以下几种：</p><ol><li>使用 <code>max</code>，<code>abs</code> 之类的库函数。这种真的不要骗自己，就是作弊方法；</li><li>使用位运算，但申请了更大的类型避免溢出。这种没有作弊，但是我觉得还可以改进，因为如果入参就已经是系统支持的最大类型，那么这类解法就无效了；</li><li>使用位运算，同时没有申请更大的类型。这种已经很完美了，但是我没有看到 C/C++ 的 Solution，可能 C/C++ 面对溢出问题会报错（Java 不会），处理起来更困难一些。</li></ol><p>回到问题中，我们现在来一步一步思考。首先，如果没有限制条件，那么非常简单：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者使用三目运算符</span></span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>但是，我们不能使用 if-else 或者比较运算符，所以我们需要构思如何去返回结果，这里不妨构造一个计算公式：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>这里 k 的值应该为 1 或 0，且我们应使其：</p><ul><li>当 a &lt; b 时，k = 0，则 k ^ 1 = 1。此时计算结果等于 b；</li><li>当 a &gt; b 是，k = 1，则 k ^ 1 = 0。此时计算结果等于 a。</li></ul><p>那么如何让 k 满足我们的要求的呢？这里可以用算术运算+位运算操作：判断 a - b 的最高位（符号位），即：</p><ul><li>当 a - b &lt; 0 时，a - b 的最高位为 1，此时，k 应该为 0；</li><li>当 a - b &gt; 0 时，a - b 的最高位为 0，此时，k 应该为 1；</li></ul><p>发现了吗？k 的值和 a - b 的最高位恰好相反，这里很自然的再引入异或运算，可以得到代码：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// C/C++ 中负数右移最高位会补 1，因此需要转成无符号类型后再右移</span></span><br><span class="line">        <span class="comment">// 将 a-b 的符号位移动到最左边，再与 1 异或取反，得到 k 的值</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a - b) &gt;&gt; (bitlen - <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>这样我们就返回了正确结果。但是需要注意 a - b 可能会导致溢出问题，一种简单的解决方式是用更大的类型（例如 long long）保存中间结果，但如果入参已经是系统支持的最大类型，那这种解法就失效了，所以并不完美。因此，我们来思考一下如何在给定的类型范围内解决这个问题。这里，我们需要分情况考虑：</p><ul><li>当 a 和 b 同号时，a - b 不会溢出，使用上面的代码即可；</li><li>当 a 和 b 异号时，a - b 可能溢出，需要额外处理；</li></ul><p>第一种情况我们已经解决了，现在来考虑第二种情况。我们可以使用 a 的符号位异或 b 的符号位，当结果为 1 时，说明异号；结果为 0 时，说明同号。当异号时，我们应该直接返回正数，避免 a - b 的运算。那么当两数异号时，我们如何确定 k 的值呢？当 a 为负数时，a 的符号位为 1，此时 k 应该为 0；当 a 为正数时，a 的符号位为 0，k 应该为 1。总结规律可以发现，k 的值应该等于 a 的符号位异或 1。现在来实现第二种情况的代码：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> asign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> k = asign ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>现在我们已经实现了两种不同情况下的代码，针对两数同号或异号的场景分别处理，以避免溢出问题，最后我们只需要将其组合起来。由于不能使用 if-else 语句，需要我们用一点 trick，见下：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算 int 类型的位数，避免不同系统下长度不同</span></span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 a 的符号位，b 的符号位</span></span><br><span class="line">        <span class="comment">// C/C++ 中负数右移最高位会补 1，因此需要转成无符号类型后再右移</span></span><br><span class="line">        <span class="keyword">int</span> asign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bsign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(b) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 假设 a 与 b 异号，计算 k 的值</span></span><br><span class="line">        <span class="keyword">int</span> k = asign ^ <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 a 和 b 异号时，asign ^ bsign ^ 1 为 0，由于 逻辑与运算 的短路性，将不再计算后半行代码，避免溢出</span></span><br><span class="line">        <span class="comment">// 当 a 和 b 同号时，asign ^ bsign ^ 1 为 1，此时会执行后半行代码，重新对 k 赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp_cond = (asign ^ bsign ^ <span class="number">1</span>) &amp;&amp; (k = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a - b) &gt;&gt; (bitlen - <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>至此，我们就完成了这道题。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Brainteaser" scheme="http://yoursite.com/tags/Brainteaser/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 079. 所有子集</title>
    <link href="http://yoursite.com/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20079.%20%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2021/12/12/剑指 Offer II 079. 所有子集/</id>
    <published>2021-12-12T03:36:12.000Z</published>
    <updated>2021-12-12T03:45:52.725Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 10-10 &lt;= nums[i] &lt;= 10nums 中的所有元素 互不相同</code></pre><p>注意：本题与主站 <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78.子集</a>题相同。</p><h1 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int state = 0; state &lt; (1 &lt;&lt; n); state ++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (((state &gt;&gt; i) &amp; 1) == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int state = 0; state &lt; (1 &lt;&lt; n); state ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; cur;</span><br><span class="line">            for (int i = 0; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if ((state &gt;&gt; i) &amp; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur.push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        for state in range(0, 1 &lt;&lt; n):</span><br><span class="line">            cur = []</span><br><span class="line">            for i in range(n):</span><br><span class="line">                if (state &gt;&gt; i) &amp; 1:</span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">            res.append(cur)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details><h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">    int [] nums;</span><br><span class="line">    int n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, tmp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int idx, List&lt;Integer&gt; path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path1 = new ArrayList&lt;&gt;();     path1.addAll(path);</span><br><span class="line">        dfs(idx + 1, path1);</span><br><span class="line">        path.add(nums[idx]);</span><br><span class="line">        List&lt;Integer&gt; path2 = new ArrayList&lt;&gt;();     path2.addAll(path);</span><br><span class="line">        dfs(idx + 1, path2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        dfs(0, vector&lt;int&gt;&#123;&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int idx, vector&lt;int&gt; path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(idx + 1, path);</span><br><span class="line">        path.push_back(nums[idx]);</span><br><span class="line">        dfs(idx + 1, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        def dfs(idx: int, path: List[int]) -&gt; None:</span><br><span class="line">            nonlocal res</span><br><span class="line">            if idx == n:</span><br><span class="line">                res.append(path)</span><br><span class="line">                return </span><br><span class="line">            dfs(idx + 1, path + [nums[idx]])</span><br><span class="line">            dfs(idx + 1, path)</span><br><span class="line"></span><br><span class="line">        dfs(0, [])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">    int [] nums;</span><br><span class="line">    int n;</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        this.n = nums.length;</span><br><span class="line">        backtrace(0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtrace(int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line"></span><br><span class="line">        path.add(nums[idx]);</span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line">        path.remove(path.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        this-&gt;n = nums.size();</span><br><span class="line">        backtrace(0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backtrace(int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line"></span><br><span class="line">        path.push_back(nums[idx]);</span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        path = []</span><br><span class="line">        def backtrace(idx: int) -&gt; None:</span><br><span class="line">            nonlocal res</span><br><span class="line">            nonlocal path</span><br><span class="line">            if idx == n:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                return </span><br><span class="line">                </span><br><span class="line">            backtrace(idx + 1)</span><br><span class="line"></span><br><span class="line">            path.append(nums[idx])</span><br><span class="line">            backtrace(idx + 1)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        backtrace(0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 067. 最大的异或</title>
    <link href="http://yoursite.com/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20067.%20%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96/"/>
    <id>http://yoursite.com/2021/12/12/剑指 Offer II 067. 最大的异或/</id>
    <published>2021-12-12T02:12:12.000Z</published>
    <updated>2021-12-12T01:53:16.297Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p><p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p><p>注意：本题与主站 <a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. 数组中两个数的最大异或值</a>相同</p><p>示例 1：</p><pre><code>输入：nums = [3,10,5,25,2,8]输出：28解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [2,4]输出：6</code></pre><p>示例 4：</p><pre><code>输入：nums = [8,10,2]输出：10</code></pre><p>示例 5：</p><pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]输出：127</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2 * 1040 &lt;= nums[i] &lt;= 231 - 1</code></pre><h1 id="方法一：哈希表-1"><a href="#方法一：哈希表-1" class="headerlink" title="方法一：哈希表^1"></a>方法一：哈希表<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>假设我们已经确定了 <em>x</em> 最高的若干个二进制位，当前正在确定第 <em>k</em> 个二进制位。根据「前言」部分的分析，我们希望第 <em>k</em> 个二进制位能够取到 <em>1</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.insert(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.count(x_next ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = x_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = xNext - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            ISet&lt;int&gt; seen = new HashSet&lt;int&gt;();</span><br><span class="line">            // 将所有的 pre^k(a_j) 放入哈希表中</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                // 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br><span class="line">                // 只需将其右移 k 位</span><br><span class="line">                seen.Add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br><span class="line">            // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br><span class="line">            int xNext = x * 2 + 1;</span><br><span class="line">            bool found = false;</span><br><span class="line">            </span><br><span class="line">            // 枚举 i</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                if (seen.Contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br><span class="line">                // 即为 x = x*2</span><br><span class="line">                x = xNext - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            seen = set()</span><br><span class="line">            <span class="comment"># 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment"># 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment"># 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            x_next = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x_next ^ (num &gt;&gt; k) <span class="keyword">in</span> seen:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                x = x_next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment"># 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaximumXOR = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen.add(num &gt;&gt; k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">const</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.has(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = xNext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> highBit = <span class="number">30</span> <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">for</span> k := highBit; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        seen := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen[num&gt;&gt;k] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        xNext := x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found &#123;</span><br><span class="line">            x = xNext</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">hashTable</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            <span class="keyword">int</span> x = nums[i] &gt;&gt; k;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">                tmp-&gt;key = x;</span><br><span class="line">                HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x_next ^ (nums[i] &gt;&gt; k);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = x_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = x_next - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h1><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie* left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            Add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = Math.Max(x, Check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Add(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (cur.left == null) &#123;</span><br><span class="line">                    cur.left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (cur.right == null) &#123;</span><br><span class="line">                    cur.right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Check(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur.right != null) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur.left != null) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    public Trie left = null;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    public Trie right = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 左子树指向表示 0 的子节点</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 右子树指向表示 1 的子节点</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 字典树的根节点</span></span><br><span class="line">        root = Trie()</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num: int)</span>:</span></span><br><span class="line">            cur = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                        cur.left = Trie()</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                        cur.right = Trie()</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(num: int)</span> -&gt; int:</span></span><br><span class="line">            cur = root</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highBit = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.left == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.left = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.right == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.right = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">check</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    root := &amp;trie&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        root.add(nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = max(x, root.check(nums[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Trie* <span class="title">createTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">ret</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trie</span>));</span></span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                cur-&gt;left = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                cur-&gt;right = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">root</span> = <span class="title">createTrie</span>();</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        add(root, nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = fmax(x, check(root, nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>421. 数组中两个数的最大异或值</title>
    <link href="http://yoursite.com/2021/12/10/421.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/"/>
    <id>http://yoursite.com/2021/12/10/421. 数组中两个数的最大异或值/</id>
    <published>2021-12-10T10:12:12.000Z</published>
    <updated>2021-12-12T01:53:09.707Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p><p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p><p>示例 1：</p><pre><code>输入：nums = [3,10,5,25,2,8]输出：28解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [2,4]输出：6</code></pre><p>示例 4：</p><pre><code>输入：nums = [8,10,2]输出：10</code></pre><p>示例 5：</p><pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]输出：127</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2 * 1040 &lt;= nums[i] &lt;= 231 - 1</code></pre><h1 id="方法一：哈希表-1"><a href="#方法一：哈希表-1" class="headerlink" title="方法一：哈希表^1"></a>方法一：哈希表<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>假设我们已经确定了 <em>x</em> 最高的若干个二进制位，当前正在确定第 <em>k</em> 个二进制位。根据「前言」部分的分析，我们希望第 <em>k</em> 个二进制位能够取到 <em>1</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.insert(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.count(x_next ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = x_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = xNext - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            ISet&lt;int&gt; seen = new HashSet&lt;int&gt;();</span><br><span class="line">            // 将所有的 pre^k(a_j) 放入哈希表中</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                // 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br><span class="line">                // 只需将其右移 k 位</span><br><span class="line">                seen.Add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br><span class="line">            // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br><span class="line">            int xNext = x * 2 + 1;</span><br><span class="line">            bool found = false;</span><br><span class="line">            </span><br><span class="line">            // 枚举 i</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                if (seen.Contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br><span class="line">                // 即为 x = x*2</span><br><span class="line">                x = xNext - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            seen = set()</span><br><span class="line">            <span class="comment"># 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment"># 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment"># 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            x_next = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x_next ^ (num &gt;&gt; k) <span class="keyword">in</span> seen:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                x = x_next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment"># 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaximumXOR = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen.add(num &gt;&gt; k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">const</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.has(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = xNext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> highBit = <span class="number">30</span> <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">for</span> k := highBit; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        seen := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen[num&gt;&gt;k] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        xNext := x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found &#123;</span><br><span class="line">            x = xNext</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">hashTable</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            <span class="keyword">int</span> x = nums[i] &gt;&gt; k;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">                tmp-&gt;key = x;</span><br><span class="line">                HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x_next ^ (nums[i] &gt;&gt; k);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = x_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = x_next - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h1><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie* left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            Add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = Math.Max(x, Check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Add(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (cur.left == null) &#123;</span><br><span class="line">                    cur.left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (cur.right == null) &#123;</span><br><span class="line">                    cur.right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Check(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur.right != null) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur.left != null) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    public Trie left = null;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    public Trie right = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 左子树指向表示 0 的子节点</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 右子树指向表示 1 的子节点</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 字典树的根节点</span></span><br><span class="line">        root = Trie()</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num: int)</span>:</span></span><br><span class="line">            cur = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                        cur.left = Trie()</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                        cur.right = Trie()</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(num: int)</span> -&gt; int:</span></span><br><span class="line">            cur = root</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highBit = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.left == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.left = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.right == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.right = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">check</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    root := &amp;trie&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        root.add(nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = max(x, root.check(nums[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Trie* <span class="title">createTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">ret</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trie</span>));</span></span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                cur-&gt;left = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                cur-&gt;right = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">root</span> = <span class="title">createTrie</span>();</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        add(root, nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = fmax(x, check(root, nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>面试题 05.03. 翻转数位</title>
    <link href="http://yoursite.com/2021/12/10/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.03.%20%E7%BF%BB%E8%BD%AC%E6%95%B0%E4%BD%8D/"/>
    <id>http://yoursite.com/2021/12/10/面试题 05.03. 翻转数位/</id>
    <published>2021-12-10T07:12:12.000Z</published>
    <updated>2021-12-10T09:50:02.413Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入: num = 1775(110111011112)输出: 8</code></pre><p>示例 2：</p><pre><code>输入: num = 7(01112)输出: 4</code></pre><h1 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h1><p>每次维护三个变量<br>cur：当前位置为止连续1的个数，遇到0归零，遇到1加1<br>insert：在当前位置变成1，往前数连续1的最大个数，遇到0变为cur+1，遇到1加1<br>res:保存insert的最大值即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        insert = <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> num &amp; (<span class="number">1</span>&lt;&lt;i):</span><br><span class="line">               cur += <span class="number">1</span></span><br><span class="line">               insert +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                insert = cur + <span class="number">1</span></span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            res = max(res,insert)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insert = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                cur += <span class="number">1</span>;</span><br><span class="line">                insert += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                insert = cur + <span class="number">1</span>;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, insert);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="模拟法解题思路"><a href="#模拟法解题思路" class="headerlink" title="模拟法解题思路"></a>模拟法解题思路</h1><p>这是一道模拟题。</p><p><strong>关键点</strong></p><ol><li>用 bitset&lt;32&gt; 记录好num的32位二进制01串。</li><li>遍历 bitset&lt;32&gt; , 找相邻的连续0串 和 连续1串。</li><li>记录好前后被0串分隔的1串的长度，通过中间的0串的长度是否为1 判断两个1串是否可以连接</li><li>不要忽略特殊情况，当32位全为1时,例如-1，不需要变位就已经达到最长的1串长度，为32</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;32&gt; bits(num);<span class="comment">//记录 num 的二进制 01 串</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span> , zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= <span class="number">32</span>)&#123;</span><br><span class="line">            n1 = n2 ,n2 = <span class="number">0</span>, zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=<span class="number">32</span> &amp;&amp; bits[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                ++zero;<span class="comment">//统计连续的 0 的个数</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=<span class="number">32</span> &amp;&amp; bits[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                ++n2;<span class="comment">//统计连续的 1 的个数</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,n2+<span class="number">1</span>);           </span><br><span class="line">            <span class="keyword">if</span>(zero==<span class="number">1</span>)&#123; <span class="comment">//如果前后的连续为 1 的串中间之隔了一个0</span></span><br><span class="line">                ans = max(ans,n1+n2+<span class="number">1</span>); <span class="comment">//看连接之后是否达到最长</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(<span class="number">32</span>,ans); <span class="comment">//有可能全为 1 ，此时不用变位已达到最长</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet(<span class="number">32</span>);<span class="comment">//记录 num 的二进制 01 串</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                bitSet.set(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = <span class="number">0</span>;</span><br><span class="line">            zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">32</span> &amp;&amp; !bitSet.get(i)) &#123;</span><br><span class="line">                zero++; <span class="comment">//统计连续的 0 的个数</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">32</span> &amp;&amp; bitSet.get(i)) &#123;</span><br><span class="line">                n2++;<span class="comment">//统计连续的 1 的个数</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, n2 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (zero == <span class="number">1</span>) &#123;<span class="comment">//如果前后的连续为 1 的串中间之隔了一个0</span></span><br><span class="line">                ans = Math.max(ans, n1 + n2 + <span class="number">1</span>);<span class="comment">//看连接之后是否达到最长</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(<span class="number">32</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 65. 不用加减乘除做加法</title>
    <link href="http://yoursite.com/2021/12/10/%E5%89%91%E6%8C%87%20Offer%2065.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <id>http://yoursite.com/2021/12/10/剑指 Offer 65. 不用加减乘除做加法/</id>
    <published>2021-12-10T04:12:12.000Z</published>
    <updated>2021-12-10T03:52:57.268Z</updated>
    
    <content type="html"><![CDATA[<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><a id="more"></a><p>[TOC]</p><p>示例:</p><pre><code>输入: a = 1, b = 1输出: 2</code></pre><p>提示：</p><pre><code>a, b 均可能是负数或 0结果不会溢出 32 位整数</code></pre><h1 id="解题思路-1："><a href="#解题思路-1：" class="headerlink" title="解题思路^1："></a>解题思路<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/" target="_blank" rel="noopener">^1</a>：</h1><p>本题考察对位运算的灵活使用，即使用位运算实现加法。<br>设两数字的二进制形式 <em>a, b</em> ，其求和 <em>s = a + b</em> ，<em>a(i)</em> 代表 <em>a</em> 的二进制第 <em>i</em> 位，则分为以下四种情况：</p><table><thead><tr><th align="center"><em>a(i)</em></th><th align="center"><em>b(i)</em></th><th align="center">无进位和 <em>n(i)</em></th><th align="center">进位 <em>c(i+1)</em></th></tr></thead><tbody><tr><td align="center"><em>0</em></td><td align="center"><em>0</em></td><td align="center"><em>0</em></td><td align="center"><em>0</em></td></tr><tr><td align="center"><em>0</em></td><td align="center"><em>1</em></td><td align="center"><em>1</em></td><td align="center"><em>0</em></td></tr><tr><td align="center"><em>1</em></td><td align="center"><em>0</em></td><td align="center"><em>1</em></td><td align="center"><em>0</em></td></tr><tr><td align="center"><em>1</em></td><td align="center"><em>1</em></td><td align="center"><em>0</em></td><td align="center"><em>1</em></td></tr></tbody></table><p>观察发现，<strong>无进位和</strong> 与 <strong>异或运算</strong> 规律相同，<strong>进位</strong> 和 <strong>与运算</strong> 规律相同（并需左移一位）。因此，无进位和 <em>n</em> 与进位 <em>c</em> 的计算公式如下；</p><p>（和 <em>s</em> ）<em>=</em>（非进位和 <em>n</em> ）<em>+</em>（进位 <em>c</em> ）。即可将 <em>s = a + b</em> 转化为：</p><p>循环求 <em>n</em> 和 <em>c</em> ，直至进位 <em>c = 0</em> ；此时 <em>s = n</em> ，返回 <em>n</em> 即可。</p><blockquote><p><strong>Q ：</strong> 若数字 <em>a</em> 和 <em>b</em> 中有负数，则变成了减法，如何处理？<br><strong>A ：</strong> 在计算机系统中，数值一律用 <strong>补码</strong> 来表示和存储。<strong>补码的优势：</strong> 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 <strong>同时适用于正数和负数的加法</strong> 。</p></blockquote><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(1)</em> ：</strong> 最差情况下（例如 <em>a =</em> 0x7fffffff , <em>b = 1</em> 时），需循环 32 次，使用 <em>O(1)</em> 时间；每轮中的常数次位操作使用 <em>O(1)</em> 时间。</li><li><strong>空间复杂度 <em>O(1)</em> ：</strong> 使用常数大小的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和</span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x</span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            a, b = (a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x)</span><br></pre></td></tr></table></figure></details><h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h2><details>    <summary>递归写法java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和</span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><blockquote><p>由于 Python 的数字存储特点，需要做特殊考虑，以下详细介绍。</p></blockquote><h2 id="Python-负数的存储："><a href="#Python-负数的存储：" class="headerlink" title="Python 负数的存储："></a>Python 负数的存储：</h2><p>Python，Java 等语言中的数字都是以 <strong>补码</strong> 形式存储的。但 Python 没有 <code>int</code> , <code>long</code> 等不同长度变量，即在编程时无变量位数的概念。<br><strong>获取负数的补码：</strong> 需要将数字与十六进制数 <code>0xffffffff</code> 相与。可理解为舍去此数字 32 位以上的数字（将 32 位以上都变为 <em>0</em> ），从无限长度变为一个 32 位整数。<br><strong>返回前数字还原：</strong> 若补码 <em>a</em> 为负数（ <code>0x7fffffff</code> 是最大的正数的补码 ），需执行 <code>~(a ^ x)</code> 操作，将补码还原至 Python 的存储格式。 <code>a ^ x</code> 运算将 1 至 32 位按位取反； <code>~</code> 运算是将整个数字取反；因此， <code>~(a ^ x)</code> 是将 32 位以上的位取反，1 至 32 位不变。</p><details>    <summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(hex(<span class="number">1</span>)) <span class="comment"># = 0x1 补码</span></span><br><span class="line">print(hex(<span class="number">-1</span>)) <span class="comment"># = -0x1 负号 + 原码 （ Python 特色，Java 会直接输出补码）</span></span><br><span class="line"></span><br><span class="line">print(hex(<span class="number">1</span> &amp; <span class="number">0xffffffff</span>)) <span class="comment"># = 0x1 正数补码</span></span><br><span class="line">print(hex(<span class="number">-1</span> &amp; <span class="number">0xffffffff</span>)) <span class="comment"># = 0xffffffff 负数补码</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">-1</span> &amp; <span class="number">0xffffffff</span>) <span class="comment"># = 4294967295 （ Python 将其认为正数）</span></span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 64. 求1+2+…+n</title>
    <link href="http://yoursite.com/2021/12/09/%E5%89%91%E6%8C%87%20Offer%2064.%20%E6%B1%821+2+%E2%80%A6+n/"/>
    <id>http://yoursite.com/2021/12/09/剑指 Offer 64. 求1+2+…+n/</id>
    <published>2021-12-09T02:12:12.000Z</published>
    <updated>2021-12-09T07:22:10.018Z</updated>
    
    <content type="html"><![CDATA[<p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入: n = 3输出: 6</code></pre><p>示例 2：</p><pre><code>输入: n = 9输出: 45</code></pre><p>限制：</p><pre><code>1 &lt;= n &lt;= 10000</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先我们梳理题目要求。题目要求我们不能使用乘除法、<code>for</code>、<code>while</code>、<code>if</code>、<code>else</code>、<code>switch</code>、<code>case</code> 等关键字及条件判断语句，因此我们手里能用的工具很少，列举出来发现只有加减法、赋值、位运算符以及逻辑运算符。</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><p><strong>思路和算法</strong></p><p>试想一下如果不加限制地使用递归的方法来实现这道题，相信大家都能很容易地给出下面的实现（以 C++ 为例）：</p><figure class="highlight c++"><figcaption><span>[sol0-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。</p><p>以逻辑运算符 <code>&amp;&amp;</code> 为例，对于 <code>A &amp;&amp; B</code> 这个表达式，如果 <code>A</code> 表达式返回False  ，那么 <code>A &amp;&amp; B</code> 已经确定为 False ，此时不会去执行表达式 <code>B</code>。同理，对于逻辑运算符 <code>||</code>， 对于 <code>A || B</code> 这个表达式，如果 <code>A</code> 表达式返回 True ，那么 <code>A || B</code> 已经确定为 True ，此时不会去执行表达式 <code>B</code>。</p><p>利用这一特性，我们可以将判断是否为递归的出口看作 <code>A &amp;&amp; B</code> 表达式中的 <code>A</code> 部分，递归的主体函数看作 <code>B</code> 部分。如果不是递归出口，则返回 True，并继续执行表达式 <code>B</code> 的部分，否则递归结束。当然，你也可以用逻辑运算符 <code>||</code> 给出类似的实现，这里我们只提供结合逻辑运算符 <code>&amp;&amp;</code> 的递归实现。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += sumNums(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>TypeScript</summary><figure class="highlight typescript"><figcaption><span>[sol1-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumNums = <span class="function"><span class="keyword">function</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    n &amp;&amp; (n += sumNums(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNums</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">sum</span> = <span class="title">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        ans += n</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; sum(n<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sum(n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)*。递归函数递归 *n</em> 次，每次递归中计算时间复杂度为 <em>O(1)</em>，因此总时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(n)</em>。递归函数的空间复杂度取决于递归调用栈的深度，这里递归函数调用栈深度为 <em>O(n)</em>，因此空间复杂度为 <em>O(n)</em>。</li></ul><h1 id="方法二：快速乘"><a href="#方法二：快速乘" class="headerlink" title="方法二：快速乘"></a>方法二：快速乘</h1><p><strong>思路和算法</strong></p><p>考虑 <code>A</code> 和 <code>B</code> 两数相乘的时候我们如何利用加法和位运算来模拟，其实就是将 <code>B</code> 二进制展开，如果 <code>B</code> 的二进制表示下第 <em>i</em> 位为 1，那么这一位对最后结果的贡献就是 <em>A</em>(1&lt;&lt;i)* ，即 <em>A&lt;&lt;i</em>。我们遍历 <code>B</code> 二进制展开下的每一位，将所有贡献累加起来就是最后的答案，这个方法也被称作「俄罗斯农民乘法」，感兴趣的读者可以自行网上搜索相关资料。这个方法经常被用于两数相乘取模的场景，如果两数相乘已经超过数据范围，但取模后不会超过，我们就可以利用这个方法来拆位取模计算贡献，保证每次运算都在数据范围内。</p><p>下面给出这个算法的 C++ 实现：</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol20-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickMulti</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; B; B &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans += A;</span><br><span class="line">        &#125;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>回到本题，由等差数列求和公式我们可以知道 1+2+…+n 等价于 n(n+1)/2 ，对于除以 <em>2</em> 我们可以用右移操作符来模拟，那么等式变成了 <em>n(n+1)&gt;&gt;1<em>，剩下不符合题目要求的部分即为 *n(n+1)</em>，根据上文提及的快速乘，我们可以将两个数相乘用加法和位运算来模拟，但是可以看到上面的 C++ 实现里我们还是需要循环语句，有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 *n</em> 为 <em>[1,10000]*，所以 *n</em> 二进制展开最多不会超过 <em>14</em> 位，我们手动展开 <em>14</em> 层代替循环即可，至此满足了题目的要求，具体实现可以参考下面给出的代码。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>TypeScript</summary><figure class="highlight typescript"><figcaption><span>[sol2-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumNums = <span class="function"><span class="keyword">function</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans: <span class="built_in">number</span> = <span class="number">0</span>, A: <span class="built_in">number</span> = n, B: <span class="built_in">number</span> = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNums</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans, A, B := <span class="number">0</span>, n, n + <span class="number">1</span></span><br><span class="line">    addGreatZero := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        ans += A</span><br><span class="line">        <span class="keyword">return</span> ans &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Brainteaser" scheme="http://yoursite.com/tags/Brainteaser/"/>
    
  </entry>
  
  <entry>
    <title>1863. 找出所有子集的异或总和再求和</title>
    <link href="http://yoursite.com/2021/12/08/1863.%20%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2021/12/08/1863. 找出所有子集的异或总和再求和/</id>
    <published>2021-12-08T14:12:12.000Z</published>
    <updated>2021-12-09T06:35:01.980Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><a id="more"></a><p>[TOC]</p><p>一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。</p><p>例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。<br>给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p><p>数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。</p><p>示例 1：</p><pre><code>输入：nums = [1,3]输出：6解释：[1,3] 共有 4 个子集：- 空子集的异或总和是 0 。- [1] 的异或总和为 1 。- [3] 的异或总和为 3 。- [1,3] 的异或总和为 1 XOR 3 = 2 。0 + 1 + 3 + 2 = 6</code></pre><p>示例 2：</p><pre><code>输入：nums = [5,1,6]输出：28解释：[5,1,6] 共有 8 个子集：- 空子集的异或总和是 0 。- [5] 的异或总和为 5 。- [1] 的异或总和为 1 。- [6] 的异或总和为 6 。- [5,1] 的异或总和为 5 XOR 1 = 4 。- [5,6] 的异或总和为 5 XOR 6 = 3 。- [1,6] 的异或总和为 1 XOR 6 = 7 。- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28</code></pre><p>示例 3：</p><pre><code>输入：nums = [3,4,5,6,7,8]输出：480解释：每个子集的全部异或总和值之和为 480 。</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 121 &lt;= nums[i] &lt;= 20</code></pre><h1 id="方法一：递归法枚举子集-1"><a href="#方法一：递归法枚举子集-1" class="headerlink" title="方法一：递归法枚举子集^1"></a>方法一：递归法枚举子集<a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/solution/sum-of-all-subset-xor-totals-by-leetcode-o5aa/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == n)&#123;</span><br><span class="line">            <span class="comment">// 终止递归</span></span><br><span class="line">            res += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前数字</span></span><br><span class="line">        dfs(val ^ nums[idx], idx + <span class="number">1</span>, nums);</span><br><span class="line">        <span class="comment">// 考虑不选择当前数字</span></span><br><span class="line">        dfs(val, idx + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(val, idx)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> idx == n:</span><br><span class="line">                <span class="comment"># 终止递归</span></span><br><span class="line">                res += val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 考虑选择当前数字</span></span><br><span class="line">            dfs(val ^ nums[idx], idx + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 考虑不选择当前数字</span></span><br><span class="line">            dfs(val, idx + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> idx, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            res += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(val ^ nums[idx], idx + <span class="number">1</span>, nums);</span><br><span class="line">        dfs(val, idx + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：迭代法枚举子集"><a href="#方法二：迭代法枚举子集" class="headerlink" title="方法二：迭代法枚举子集"></a>方法二：迭代法枚举子集</h1><p><strong>提示 <em>1</em></strong></p><p>一个长度为 <em>n</em> 的数组 nums  有 <em>2^n</em> 个子集（包括空集与自身）。我们可以将这些子集一一映射到 <em>[0, 2^n-1]</em> 中的整数。</p><p><strong>提示 <em>2</em></strong></p><p>数组中的每个元素都有「选取」与「未选取」两个状态，可以对应一个二进制位的 <em>1</em> 与 <em>0</em>。那么对于一个长度为 <em>n</em> 的数组nums ，我们也可以用 <em>n</em> 个二进制位的整数来唯一表示每个元素的选取情况。此时该整数第 <em>j</em> 位的取值表示数组第 <em>j</em> 个元素是否包含在对应的子集中。</p><p><strong>思路与算法</strong></p><p>我们也可以用迭代来实现子集枚举。</p><p>根据 <strong>提示 <em>1</em></strong> 与 <strong>提示 <em>2</em></strong>，我们枚举 <em>[0, 2^n-1]</em> 中的整数 <em>i</em>，其第 <em>j</em> 位的取值表示nums 的第 <em>j</em> 个元素是否包含在对应的子集中。</p><p>对于每个整数 <em>i</em>，我们遍历它的每一位计算对应子集的异或总和，并维护这些值之和。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)&#123;   <span class="comment">// 遍历所有子集</span></span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;   <span class="comment">// 遍历每个元素</span></span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j))&#123;</span><br><span class="line">                    tmp ^= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; n):   <span class="comment"># 遍历所有子集</span></span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):   <span class="comment"># 遍历每个元素</span></span><br><span class="line">                <span class="keyword">if</span> i &amp; (<span class="number">1</span> &lt;&lt; j):</span><br><span class="line">                    tmp ^= nums[j]</span><br><span class="line">            res += tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; nums.length); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span> )!= <span class="number">0</span>) &#123;</span><br><span class="line">                    val ^= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n2^n)*，其中 *n</em> 为nums 的长度。我们遍历了 nums 的 <em>2^n</em> 个子集，每个子集需要 <em>O(n)</em> 的时间计算异或总和。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：按位考虑-二项式展开-1"><a href="#方法三：按位考虑-二项式展开-1" class="headerlink" title="方法三：按位考虑 + 二项式展开^1"></a>方法三：按位考虑 + 二项式展开<a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/solution/sum-of-all-subset-xor-totals-by-leetcode-o5aa/" target="_blank" rel="noopener">^1</a></h1><p><strong>提示 <em>1</em></strong></p><p>由于异或运算本质上是按位操作，因此我们可以按位考虑取值情况。</p><p><strong>提示 <em>2</em></strong></p><p>对于数组中所有元素的某一位，存在两种可能：</p><ul><li><p>第一种，所有元素该位都为 <em>0</em>；</p></li><li><p>第二种，至少有一个元素该位为 <em>1</em>。</p></li></ul><p>假设数组元素个数为 <em>n</em>，那么第一种情况下，所有子集异或总和中该位均为 <em>0</em>；第二种情况下，所有子集异或总和中该位为 <em>0</em> 的个数与为 <em>1</em> 的个数相等，均为 <em>2^{n-1}</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res |= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res |= num</span><br><span class="line">        <span class="keyword">return</span> res &lt;&lt; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为 nums 的长度，即为一遍遍历数组的时间复杂度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Combinatorics" scheme="http://yoursite.com/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 56 - II. 数组中数字出现的次数 II</title>
    <link href="http://yoursite.com/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2056%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/"/>
    <id>http://yoursite.com/2021/12/08/剑指 Offer 56 - II. 数组中数字出现的次数 II/</id>
    <published>2021-12-08T07:12:12.000Z</published>
    <updated>2021-12-08T07:05:05.128Z</updated>
    
    <content type="html"><![CDATA[<p>在一个数组 nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [3,4,3,3]输出：4</code></pre><p>示例 2：</p><pre><code>输入：nums = [9,1,7,9,7,9,7]输出：1</code></pre><p>限制：</p><pre><code>1 &lt;= nums.length &lt;= 100001 &lt;= nums[i] &lt; 2^31</code></pre><p>参见137. 只出现一次的数字II<a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个数组 nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
    <link href="http://yoursite.com/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2053%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2021/12/08/剑指 Offer 53 - II. 0～n-1中缺失的数字/</id>
    <published>2021-12-08T07:12:12.000Z</published>
    <updated>2021-12-08T07:34:12.449Z</updated>
    
    <content type="html"><![CDATA[<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: [0,1,3]输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [0,1,2,3,4,5,6,7,9]输出: 8</code></pre><p>限制：</p><pre><code>1 &lt;= 数组长度 &lt;= 10000</code></pre><p>此题由<a href="https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/" target="_blank" rel="noopener">268. 丢失的数字</a>改编而来，但题干部分描述的不太清楚，多出来的数字应该是n</p><p>解法可参见<a href="https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/" target="_blank" rel="noopener">268. 丢失的数字</a></p><p>由于该题不同之处在于是有序的，所以还可以使用二分法</p><h1 id="二分法解题思路-1："><a href="#二分法解题思路-1：" class="headerlink" title="二分法解题思路^1："></a>二分法解题思路<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/" target="_blank" rel="noopener">^1</a>：</h1><ul><li>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</li><li>根据题意，数组可以按照以下规则划分为两部分。<ul><li><strong>左子数组：</strong> <em>nums[i] = i</em> ；</li><li><strong>右子数组：</strong> <em>nums[i] != i</em>  ；</li></ul></li><li>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</li></ul><h1 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h1><ul><li><strong>时间复杂度 <em>O(log N)</em>：</strong> 二分法为对数级别复杂度。</li><li><strong>空间复杂度 <em>O(1)</em>：</strong> 几个变量使用常数大小的额外空间。</li></ul><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == m: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == m) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
    <link href="http://yoursite.com/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/08/剑指 Offer 56 - I. 数组中数字出现的次数/</id>
    <published>2021-12-08T06:12:12.000Z</published>
    <updated>2021-12-08T06:40:04.185Z</updated>
    
    <content type="html"><![CDATA[<p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]</code></pre><p>限制：</p><pre><code>2 &lt;= nums.length &lt;= 10000</code></pre><h1 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h1><h2 id="方法一：分组异或"><a href="#方法一：分组异或" class="headerlink" title="方法一：分组异或"></a>方法一：分组异或</h2><p><strong>思路</strong></p><p>让我们先来考虑一个比较简单的问题：</p><blockquote><p>如果除了<strong>一个</strong>数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p></blockquote><p>答案很简单：全员进行异或操作即可。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 <em>0</em>，不同结果为 <em>1</em>。那么在计算过程中，成对出现的数字的所有位会两两抵消为 <em>0</em>，最终得到的结果就是那个出现了一次的数字。</p><p>那么这一方法如何扩展到找出<strong>两个</strong>出现一次的数字呢？</p><p>如果我们可以把所有数字分成两组，使得：</p><ol><li><p>两个只出现一次的数字在不同的组中；</p></li><li><p>相同的数字会被分到相同的组中。</p></li></ol><p>那么对两个组分别进行异或操作，即可得到答案的两个数字。<strong>这是解决这个问题的关键。</strong></p><p>那么如何实现这样的分组呢？</p><p>记这两个只出现了一次的数字为 <em>a</em> 和 <em>b</em>，那么所有数字异或的结果就等于 <em>a</em> 和 <em>b</em> 异或的结果，我们记为 <em>x</em>。如果我们把 <em>x</em> 写成二进制的形式 X_kX_k-1…X0 ，其中x_i in {0,1} ，我们考虑一下 <em>x_i = 0</em> 和 <em>x_i = 1</em> 的含义是什么？它意味着如果我们把 <em>a</em> 和 <em>b</em> 写成二进制的形式，<em>a_i</em> 和 <em>b_i</em> 的关系——<em>x_i = 1</em> 表示 <em>a_i</em> 和 <em>b_i</em> 不等，<em>x_i = 0</em> 表示 <em>a_i</em> 和 <em>b_i</em> 相等。假如我们任选一个不为 <em>0</em> 的 <em>x_i*，按照第 *i</em> 位给原来的序列分组，如果该位为 <em>0</em> 就分到第一组，否则就分到第二组，这样就能满足以上两个条件，为什么呢？ </p><ul><li><p>首先，两个相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2。</p></li><li><p>这个方法在 <em>x_i = 1</em> 的时候 <em>a</em> 和 <em>b</em> 不被分在同一组，因为 <em>x_i = 1</em> 表示 <em>a_i</em> 和 <em>b_i</em> 不等，根据这个方法的定义「如果该位为 <em>0</em> 就分到第一组，否则就分到第二组」可以知道它们被分进了两组，所以满足了条件 1。</p></li></ul><p>在实际操作的过程中，我们拿到序列的异或和 <em>x</em> 之后，对于这个「位」是可以任取的，只要它满足 <em>x_i = 1*。但是为了方便，这里的代码选取的是「不为 *0</em> 的最低位」，当然你也可以选择其他不为 <em>0</em> 的位置。</p><p>至此，答案已经呼之欲出了。</p><p><strong>算法</strong></p><p>先对所有数字进行一次异或，得到两个出现一次的数字的异或值。</p><p>在异或结果中找到任意为 <em>1</em> 的位。</p><p>根据这一位对所有的数字进行分组。</p><p>在每个组内进行异或操作，得到两个数字。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            ret ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ret = functools.reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br><span class="line">        div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> div &amp; ret == <span class="number">0</span>:</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &amp; div:</span><br><span class="line">                a ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= n</span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">SingleNumbers</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xorSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> x <span class="keyword">in</span> nums) xorSum ^= x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lowbit = xorSum &amp; (-xorSum);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> x <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            ret[(x &amp; lowbit) &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>] ^= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em>，我们只需要遍历数组两次。</p></li><li><p>空间复杂度：<em>O(1)</em>，只需要常数的空间存放若干变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
</feed>
