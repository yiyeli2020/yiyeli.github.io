<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-16T09:01:09.183Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>136. 只出现一次的数字</title>
    <link href="http://yoursite.com/2020/09/16/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/09/16/136. 只出现一次的数字/</id>
    <published>2020-09-16T09:12:12.000Z</published>
    <updated>2020-09-16T09:01:09.183Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><a id="more"></a><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><pre><code>输入: [2,2,1]输出: 1</code></pre><p>示例 2:</p><pre><code>输入: [4,1,2,1,2]输出: 4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="47a527e0-e01f-4ece-a158-140764b7c319">136. 只出现一次的数字.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h2><p>如果没有时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p><ul><li><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p></li><li><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p></li><li><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p></li></ul><p>上述三种解法都需要额外使用 <em>O(n)</em> 的空间，其中 <em>n</em> 是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？</p><p>答案是使用位运算。对于这道题，可使用异或运算 ^ 。异或运算有以下三个性质。</p><ol><li>任何数和 <em>0</em> 做异或运算，结果仍然是原来的数。</li><li>任何数和其自身做异或运算，结果是 <em>0</em>。</li><li>异或运算满足交换律和结合律.</li></ol><p>假设数组中有 <em>2m+1</em> 个数，其中有 <em>m</em> 个数各出现两次，一个数出现一次。令 <em>a_{1}<em>、</em>a_{2}<em>、…、</em>a_{m}</em> 为出现两次的 <em>m</em> 个数，<em>a_{m+1}</em> 为出现一次的数。</p><p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p><details>    <summary>位运算Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SingleNumber</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> e <span class="keyword">in</span> nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位运算Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    single := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        single ^= num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组长度。只需要对数组遍历一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>137. 只出现一次的数字II</title>
    <link href="http://yoursite.com/2020/09/16/137.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
    <id>http://yoursite.com/2020/09/16/137. 只出现一次的数字II/</id>
    <published>2020-09-16T09:12:12.000Z</published>
    <updated>2020-09-17T09:53:05.162Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 </p><a id="more"></a><p> 说明： </p><pre><code>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ </code></pre><p> 示例 1: </p><pre><code>输入: [2,2,3,2]输出: 3</code></pre><p> 示例 2: </p><pre><code>输入: [0,1,0,1,0,1,99]输出: 99 </code></pre><h1 id="解题思路-1："><a href="#解题思路-1：" class="headerlink" title="解题思路^1："></a>解题思路<a href="https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/" target="_blank" rel="noopener">^1</a>：</h1><p>如下图所示，考虑数字的二进制形式，对于出现三次的数字，各 <strong>二进制位</strong> 出现的次数都是 <em>3</em> 的倍数。<br>因此，统计所有数字的各二进制位中 <em>1</em> 的出现次数，并对 <em>3</em> 求余，结果则为只出现一次的数字。</p><p><a href="https://pic.leetcode-cn.com/28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><h1 id="方法一：有限状态自动机"><a href="#方法一：有限状态自动机" class="headerlink" title="方法一：有限状态自动机"></a>方法一：有限状态自动机</h1><p>各二进制位的 <strong>位运算规则相同</strong> ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 <em>1</em> 的个数，存在 3 种状态，即对 3 余数为 <em>0, 1, 2</em> 。</p><ul><li>若输入二进制位 <em>1</em> ，则状态按照以下顺序转换；</li><li>若输入二进制位 <em>0</em> ，则状态不变。</li></ul><p>0-&gt;1-&gt;2-&gt;0-&gt;…</p><p><a href="https://pic.leetcode-cn.com/ab00d4d1ad961a3cd4fc1840e34866992571162096000325e7ce10ff75fda770-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><p>如下图所示，由于二进制只能表示 <em>0, 1</em> ，因此需要使用两个二进制位来表示 <em>3</em> 个状态。设此两位分别为 <em>two</em> , <em>one</em> ，则状态转换变为：</p><p>00-&gt;01-&gt;10-&gt;00</p><p><a href="https://pic.leetcode-cn.com/0a7ea5bca055b095673620d8bb4c98ef6c610a22f999294ed11ae35d43621e93-Picture3.png" target="_blank" rel="noopener">Picture3.png</a></p><p>接下来，需要通过 <strong>状态转换表</strong> 导出 <strong>状态转换的计算公式</strong> 。首先回忆一下位运算特点，对于任意二进制位 <em>x</em> ，有：</p><ul><li>异或运算：<code>x ^ 0 = x</code>​ ， <code>x ^ 1 = ~x</code></li><li>与运算：<code>x &amp; 0 = 0</code> ， <code>x &amp; 1 = x</code></li></ul><p><strong>计算 <em>one</em> 方法：</strong></p><p>设当前状态为 <em>two</em> <em>one</em> ，此时输入二进制位 <em>n</em> 。如下图所示，通过对状态表的情况拆分，可推出 <em>one</em> 的计算方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    one = one</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = ~one</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span>:</span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>引入 <strong>异或运算</strong> ，可将以上拆分简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span>:</span><br><span class="line">    one = one ^ n</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span>:</span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>引入 <strong>与运算</strong> ，可继续简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one = one ^ n &amp; ~two</span><br></pre></td></tr></table></figure><p><a href="https://pic.leetcode-cn.com/f75d89219ad93c69757b187c64784b4c7a57dce7911884fe82f14073d654d32f-Picture4.png" target="_blank" rel="noopener">Picture4.png</a></p><p><strong>计算 <em>two</em> 方法：</strong></p><p>由于是先计算 <em>one</em> ，因此应在新 <em>one</em> 的基础上计算 <em>two</em> 。<br>如下图所示，修改为新 <em>one</em> 后，得到了新的状态图。观察发现，可以使用同样的方法计算 <em>two</em> ，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two = two ^ n &amp; ~one</span><br></pre></td></tr></table></figure><p><strong>这部分我一开始看时有些疑惑，但仔细看下面这张图会发现其中one都是新的变化后的，可以再把one和two调换位置就发现整个状态变化图是等效的了。</strong></p><p><a href="https://pic.leetcode-cn.com/6ba76dba1ac98ee2bb982e011fdffd1df9a6963f157b2780461dbce453f0ded3-Picture5.png" target="_blank" rel="noopener">Picture5.png</a></p><p><strong>返回值：</strong></p><p>以上是对数字的二进制中 “一位” 的分析，而 <code>int</code> 类型的其他 31 位具有相同的运算规则，因此可将以上公式直接套用在 32 位数上。</p><p>遍历完所有数字后，各二进制位都处于状态 <em>00</em> 和状态 <em>01</em> （取决于 “只出现一次的数字” 的各二进制位是 <em>1</em> 还是 <em>0</em> ），而此两状态是由 <em>one</em> 来记录的（此两状态下 <em>twos</em> 恒为 <em>0</em> ），因此返回 <em>ones</em> 即可。</p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><p><strong>时间复杂度 <em>O(N)</em> ：</strong> 其中 <em>N</em> 位数组 <em>nums</em> 的长度；遍历数组占用 <em>O(N)</em> ，每轮中的常数个位运算操作占用 O(32<em>3</em>2)=O(1)。</p></li><li><p><strong>空间复杂度 <em>O(1)</em> ：</strong> 变量 <em>ones</em> , <em>twos</em> 使用常数大小的额外空间。</p><p><a href="https://pic.leetcode-cn.com/045023f05080e0844f05b8ee5b68885e1b9e41926d3e4ab054c68e6dceacfc0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/fd0ab6b3cd20c18729321957f6b4bedbf6480fd6862c01de1c5d598c82a26d2b-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/46b0974b13206beda512dd037df10772fae1c7375a97a7a05abb4a736dc0ebb3-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/4cfe4cf13367851efdb9dee5fceed969326cc3478be0769c8f60294ef5d2866d-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/fa2e7ecb991d5183e2f53ca7741150ae18badb087b01bff4a32caaec245fec79-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/6a6b8561c913c45d7be3428ff8553a2188890fee0687a1a113a7c2bea12b95a9-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> </p></li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>有限状态自动机python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        ones, twos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            ones = ones ^ num &amp; ~twos</span><br><span class="line">            twos = twos ^ num &amp; ~ones</span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure></details><details>    <summary>有限状态自动机java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：遍历统计"><a href="#方法二：遍历统计" class="headerlink" title="方法二：遍历统计"></a>方法二：遍历统计</h1><blockquote><p>此方法相对容易理解，但效率较低，总体推荐方法一。</p></blockquote><p>使用 <strong>与运算</strong> ，可获取二进制数字 <em>num</em> 的最右一位 <em>n_1</em> ：</p><p>n_1=num &amp; i</p><p>配合 <strong>无符号右移操作</strong> ，可获取 <em>num</em> 所有位的值（即 <em>n_1</em> ~ <em>n_{32}</em> ）：</p><p>num = num &gt;&gt;&gt; 1</p><p>建立一个长度为 32 的数组 <em>counts</em> ，通过以上方法可记录所有数字的各二进制位的 <em>1</em> 的出现次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">        counts[j] += nums[i] &amp; <span class="number">1</span>; <span class="comment">// 更新第 j 位</span></span><br><span class="line">        nums[i] &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// 第 j 位 --&gt; 第 j + 1 位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <em>counts</em> 各元素对 <em>3</em> 求余，则结果为 “只出现一次的数字” 的各二进制位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    counts[i] %= <span class="number">3</span>; <span class="comment">// 得到 只出现一次的数字 的第 (31 - i) 位 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <strong>左移操作</strong> 和 <strong>或运算</strong> ，可将 <em>counts</em> 数组中各二进位的值恢复到数字 <em>res</em> 上（循环区间是 <img src="./p__i_in__0,_31__.png" alt="i\in\[0,31\] ">  ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">    res &lt;&lt;= <span class="number">1</span>; <span class="comment">// 左移 1 位</span></span><br><span class="line">    res |= counts[<span class="number">31</span> - i]; <span class="comment">// 恢复第 i 位的值到 res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回 <em>res</em> 即可。</p><blockquote><p>由于 Python 的存储负数的特殊性，需要先将 <em>0</em> - <em>32</em> 位取反（即 <code>res ^ 0xffffffff</code> ），再将所有位取反（即 <code>~</code> ）。<br>两个组合操作实质上是将数字 <em>32</em> 以上位取反， <em>0</em> - <em>32</em> 位不变。</p></blockquote><h2 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N)</em> ：</strong> 其中 <em>N</em> 位数组 <em>nums</em> 的长度；遍历数组占用 <em>O(N)</em> ，每轮中的常数个位运算操作占用 <em>O(1)</em> 。</li><li><strong>空间复杂度 <em>O(1)</em> ：</strong> 数组 <em>counts</em> 长度恒为 <em>32</em> ，占用常数大小的额外空间。</li></ul><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><p>实际上，只需要修改求余数值 <em>m</em> ，即可实现解决 <strong>除了一个数字以外，其余数字都出现 <em>m</em> 次</strong> 的通用问题。</p><details>    <summary>遍历统计python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        counts = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span></span><br><span class="line">        res, m = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span></span><br><span class="line">            res |= counts[<span class="number">31</span> - i] % m</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> counts[<span class="number">31</span>] % m == <span class="number">0</span> <span class="keyword">else</span> ~(res ^ <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>遍历统计java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span>;</span><br><span class="line">                num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            res |= counts[<span class="number">31</span> - i] % m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 &lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>210. 课程表II</title>
    <link href="http://yoursite.com/2020/09/15/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8II/"/>
    <id>http://yoursite.com/2020/09/15/210. 课程表II/</id>
    <published>2020-09-15T03:12:12.000Z</published>
    <updated>2020-09-16T08:37:41.944Z</updated>
    
    <content type="html"><![CDATA[<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><a id="more"></a><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p>示例 1:</p><pre><code>输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</code></pre><p>示例 2:</p><pre><code>输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</code></pre><p>说明:</p><ul><li>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ul><p>提示:</p><ul><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过 BFS 完成。</li></ul><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="def715df-7ba6-462e-b957-ebaf4120b1ce">210. 课程表 II的.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道经典的「拓扑排序」问题。</p><p>给定一个包含 <em>n</em> 个节点的有向图 <em>G</em>，我们给出它的节点编号的一种排列，如果满足：</p><blockquote><p>对于图 <em>G</em> 中的任意一条有向边 <em>(u, v)<em>，</em>u</em> 在排列中都出现在 <em>v</em> 的前面。</p></blockquote><p>那么称该排列是图 <em>G</em> 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><ul><li>如果图 <em>G</em> 中存在环（即图 <em>G</em> 不是「有向无环图」），那么图 <em>G</em> 不存在拓扑排序。这是因为假设图中存在环 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_1,x_2,...,x_n,x_1</span><br></pre></td></tr></table></figure><p>，那么 <em>x_1</em> 在排列中必须出现在 <em>x_n</em> 的前面，但 <em>x_n</em> 同时也必须出现在 <em>x_1</em> 的前面，因此不存在一个满足要求的排列，也就不存在拓扑排序；</p><ul><li>如果图 <em>G</em> 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 <em>G</em> 值包含 <em>n</em> 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</li></ul><p>有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：</p><ul><li><p>我们将每一门课看成一个节点；</p></li><li><p>如果想要学习课程 <em>A</em> 之前必须完成课程 <em>B</em>，那么我们从 <em>B</em> 到 <em>A</em> 连接一条有向边。这样以来，在拓扑排序中，<em>B</em> 一定出现在 <em>A</em> 的前面。</p></li></ul><p>求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。下面介绍两种求解拓扑排序的方法。</p><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p><strong>思路</strong></p><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有<strong>已经搜索完成的节点</strong>。</p><blockquote><p>对于一个节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 <em>u</em> 的时候，<em>u</em> 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 <em>u</em> 出发通过一条有向边可以到达的所有节点。</p></blockquote><p>假设我们当前搜索到了节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 <em>u</em> 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 <em>u</em> 处于栈顶的位置，那么 <em>u</em> 出现在所有 <em>u</em> 的相邻节点的前面。因此对于 <em>u</em> 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p><strong>算法</strong></p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 <em>u</em> 标记为「搜索中」，遍历该节点的每一个相邻节点 <em>v</em>：</p><ul><li><p>如果 <em>v</em> 为「未搜索」，那么我们开始搜索 <em>v</em>，待搜索完成回溯到 <em>u</em>；</p></li><li><p>如果 <em>v</em> 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 <em>v</em> 为「已完成」，那么说明 <em>v</em> 已经在栈中了，而 <em>u</em> 还不在栈中，因此 <em>u</em> 无论何时入栈都不会影响到 <em>(u, v)</em> 之前的拓扑关系，以及不用进行任何操作。</p></li></ul></li><li><p>当 <em>u</em> 的所有相邻节点都为「已完成」时，我们将 <em>u</em> 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 <em>n</em> 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><p>下面的幻灯片给出了深度优先搜索的可视化流程。图中的「白色」「黄色」「绿色」节点分别表示「未搜索」「搜索中」「已完成」的状态。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/1.png" target="_blank" rel="noopener">DFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/2.png" target="_blank" rel="noopener">DFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/3.png" target="_blank" rel="noopener">DFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/4.png" target="_blank" rel="noopener">DFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/5.png" target="_blank" rel="noopener">DFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/6.png" target="_blank" rel="noopener">DFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/7.png" target="_blank" rel="noopener">DFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/8.png" target="_blank" rel="noopener">DFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/9.png" target="_blank" rel="noopener">DFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/10.png" target="_blank" rel="noopener">DFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/11.png" target="_blank" rel="noopener">DFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/12.png" target="_blank" rel="noopener">DFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/13.png" target="_blank" rel="noopener">DFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/14.png" target="_blank" rel="noopener">DFS14</a> <a href="https://assets.leetcode-cn.com/solution-static/207/15.png" target="_blank" rel="noopener">DFS15</a> <a href="https://assets.leetcode-cn.com/solution-static/207/16.png" target="_blank" rel="noopener">DFS16</a> <a href="https://assets.leetcode-cn.com/solution-static/207/17.png" target="_blank" rel="noopener">DFS17</a> <a href="https://assets.leetcode-cn.com/solution-static/207/18.png" target="_blank" rel="noopener">DFS18</a> <a href="https://assets.leetcode-cn.com/solution-static/207/19.png" target="_blank" rel="noopener">DFS19</a> <a href="https://assets.leetcode-cn.com/solution-static/207/20.png" target="_blank" rel="noopener">DFS20</a> </p><details>    <summary>深度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="comment">// 注意下标 0 为栈底，因此需要将数组反序输出</span></span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="keyword">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 存储有向图</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="comment"># 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶</span></span><br><span class="line">        result = list()</span><br><span class="line">        <span class="comment"># 判断有向图中是否有环</span></span><br><span class="line">        valid = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u: int)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> valid</span><br><span class="line">            <span class="comment"># 将节点标记为「搜索中」</span></span><br><span class="line">            visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 搜索其相邻节点</span></span><br><span class="line">            <span class="comment"># 只要发现有环，立刻停止搜索</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                <span class="comment"># 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">                <span class="keyword">if</span> visited[v] == <span class="number">0</span>:</span><br><span class="line">                    dfs(v)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># 如果「搜索中」说明找到了环</span></span><br><span class="line">                <span class="keyword">elif</span> visited[v] == <span class="number">1</span>:</span><br><span class="line">                    valid = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 将节点标记为「已完成」</span></span><br><span class="line">            visited[u] = <span class="number">2</span></span><br><span class="line">            <span class="comment"># 将节点入栈</span></span><br><span class="line">            result.append(u)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> valid <span class="keyword">and</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                dfs(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="comment"># 注意下标 0 为栈底，因此需要将数组反序输出</span></span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        visited = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">        valid <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">        dfs <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">dfs</span> = <span class="title">func</span><span class="params">(u <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        visited[u] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[v] == <span class="number">0</span> &#123;</span><br><span class="line">                dfs(v)</span><br><span class="line">                <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> visited[v] == <span class="number">1</span> &#123;</span><br><span class="line">                valid = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span></span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span> &#123;</span><br><span class="line">            dfs(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !valid &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(result)/<span class="number">2</span>; i ++ &#123;</span><br><span class="line">        result[i], result[numCourses-i<span class="number">-1</span>] = result[numCourses-i<span class="number">-1</span>], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** edges;</span><br><span class="line"><span class="keyword">int</span>* edgeColSize;</span><br><span class="line"><span class="keyword">int</span>* visited;</span><br><span class="line"><span class="keyword">int</span>* result;</span><br><span class="line"><span class="keyword">int</span> resultSize;</span><br><span class="line"><span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(edges[u][i]);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">    result[resultSize++] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    valid = <span class="literal">true</span>;</span><br><span class="line">    edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    edgeColSize = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    visited = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(edgeColSize);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *returnSize = numCourses;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = result[i];</span><br><span class="line">        result[i] = result[numCourses - i - <span class="number">1</span>], result[numCourses - i - <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在深度优先搜索的过程中，我们需要最多 *O(n)</em> 的栈空间（递归）进行深度优先搜索，并且还需要若干个 <em>O(n)</em> 的空间存储节点状态、最终答案等。</p></li></ul><h2 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h2><p><strong>思路</strong></p><p>方法一的深度优先搜索是一种「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点。我们也可以使用正向思维，顺序地生成拓扑排序，这种方法也更加直观。</p><p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点<strong>少了一门先修课程的要求</strong>。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p><p>上面的想法类似于广度优先搜索，因此我们可以将广度优先搜索的流程与拓扑排序的求解联系起来。</p><p><strong>算法</strong></p><p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 <em>0</em> 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 <em>u</em>：</p><ul><li><p>我们将 <em>u</em> 放入答案中；</p></li><li><p>我们移除 <em>u</em> 的所有出边，也就是将 <em>u</em> 的所有相邻节点的入度减少 <em>1</em>。如果某个相邻节点 <em>v</em> 的入度变为 <em>0</em>，那么我们就将 <em>v</em> 放入队列中。</p></li></ul><p>在广度优先搜索的过程结束后。如果答案中包含了这 <em>n</em> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><p>下面的幻灯片给出了广度优先搜索的可视化流程。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/fig1.png" target="_blank" rel="noopener">BFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig2.png" target="_blank" rel="noopener">BFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig3.png" target="_blank" rel="noopener">BFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig4.png" target="_blank" rel="noopener">BFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig5.png" target="_blank" rel="noopener">BFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig6.png" target="_blank" rel="noopener">BFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig7.png" target="_blank" rel="noopener">BFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig8.png" target="_blank" rel="noopener">BFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig9.png" target="_blank" rel="noopener">BFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig10.png" target="_blank" rel="noopener">BFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig11.png" target="_blank" rel="noopener">BFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig12.png" target="_blank" rel="noopener">BFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig13.png" target="_blank" rel="noopener">BFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig14.png" target="_blank" rel="noopener">BFS14</a> </p><details>    <summary>广度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result.push_back(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="keyword">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="keyword">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 存储有向图</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 存储每个节点的入度</span></span><br><span class="line">        indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="comment"># 存储答案</span></span><br><span class="line">        result = list()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">            indeg[info[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        q = collections.deque([u <span class="keyword">for</span> u <span class="keyword">in</span> range(numCourses) <span class="keyword">if</span> indeg[u] == <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="comment"># 从队首取出一个节点</span></span><br><span class="line">            u = q.popleft()</span><br><span class="line">            <span class="comment"># 放入答案中</span></span><br><span class="line">            result.append(u)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                indeg[v] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> indeg[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(result) != numCourses:</span><br><span class="line">            result = list()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        indeg = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">        indeg[info[<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> indeg[i] == <span class="number">0</span> &#123;</span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        u := q[<span class="number">0</span>]</span><br><span class="line">        q = q[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            indeg[v]--</span><br><span class="line">            <span class="keyword">if</span> indeg[v] == <span class="number">0</span> &#123;</span><br><span class="line">                q = <span class="built_in">append</span>(q, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) != numCourses &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> edgeColSize[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(edgeColSize));</span><br><span class="line">    <span class="keyword">int</span> indeg[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(indeg, <span class="number">0</span>, <span class="keyword">sizeof</span>(indeg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">        ++indeg[b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q[numCourses];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q[++r] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ++visited;</span><br><span class="line">        <span class="keyword">int</span> u = q[l++];</span><br><span class="line">        result[resultSize++] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">            --indeg[edges[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (indeg[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                q[++r] = edges[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="keyword">if</span> (visited == numCourses) &#123;</span><br><span class="line">        *returnSize = numCourses;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在广度优先搜索的过程中，我们需要最多 *O(n)</em> 的队列空间（迭代）进行广度优先搜索，并且还需要若干个 <em>O(n)</em> 的空间存储节点入度、最终答案等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Topological sort" scheme="http://yoursite.com/tags/Topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>207. 课程表</title>
    <link href="http://yoursite.com/2020/09/14/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/09/14/207. 课程表/</id>
    <published>2020-09-14T08:45:12.000Z</published>
    <updated>2020-09-15T03:11:08.819Z</updated>
    
    <content type="html"><![CDATA[<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><a id="more"></a><p>你这个学期必须选修 numCourse 门课程，记为0到numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><p>示例 1:</p><pre><code>输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</code></pre><p>示例 2:</p><pre><code>输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</code></pre><p>提示：</p><pre><code>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="29da2f01-af1a-45a6-bb69-aea71f42900f">207.课程表 2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本题和 <a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a> 是几乎一样的题目。如果在过去完成过该题，那么只要将代码中的返回值从「非空数组 / 空数组」修改成[True/False]就可以通过本题。</p></blockquote><p>本题是一道经典的「拓扑排序」问题。</p><p>给定一个包含 <em>n</em> 个节点的有向图 <em>G</em>，我们给出它的节点编号的一种排列，如果满足：</p><blockquote><p>对于图 <em>G</em> 中的任意一条有向边 <em>(u, v)<em>，</em>u</em> 在排列中都出现在 <em>v</em> 的前面。</p></blockquote><p>那么称该排列是图 <em>G</em> 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><ul><li>如果图 <em>G</em> 中存在环（即图 <em>G</em> 不是「有向无环图」），那么图 <em>G</em> 不存在拓扑排序。这是因为假设图中存在环 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_1,x_2,...,x_n,x_1</span><br></pre></td></tr></table></figure><p>，那么 <em>x_1</em> 在排列中必须出现在 <em>x_n</em> 的前面，但 <em>x_n</em> 同时也必须出现在 <em>x_1</em> 的前面，因此不存在一个满足要求的排列，也就不存在拓扑排序；</p><ul><li>如果图 <em>G</em> 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 <em>G</em> 值包含 <em>n</em> 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</li></ul><p>有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：</p><ul><li><p>我们将每一门课看成一个节点；</p></li><li><p>如果想要学习课程 <em>A</em> 之前必须完成课程 <em>B</em>，那么我们从 <em>B</em> 到 <em>A</em> 连接一条有向边。这样以来，在拓扑排序中，<em>B</em> 一定出现在 <em>A</em> 的前面。</p></li></ul><p>求出该图是否存在拓扑排序，就可以判断是否有一种符合要求的课程学习顺序。事实上，<strong>由于求出一种拓扑排序方法的最优时间复杂度为 <em>O(n+m)*，其中 *n</em> 和 <em>m</em> 分别是有向图 <em>G</em> 的节点数和边数，方法见 <a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/" target="_blank" rel="noopener">210. 课程表 II 的官方题解</a>。而判断图 <em>G</em> 是否存在拓扑排序，至少也要对其进行一次完整的遍历，时间复杂度也为 <em>O(n+m)*。因此不可能存在一种仅判断图是否存在拓扑排序的方法，它的时间复杂度在渐进意义上严格优于 *O(n+m)</em></strong>。这样一来，我们使用和 <a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a> 完全相同的方法，但无需使用数据结构记录实际的拓扑排序。为了叙述的完整性，下面的两种方法与 <a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/" target="_blank" rel="noopener">210. 课程表 II 的官方题解</a> 完全相同，但在「算法」部分后的「优化」部分说明了如何省去对应的数据结构。</p><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p><strong>思路</strong></p><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有<strong>已经搜索完成的节点</strong>。</p><blockquote><p>对于一个节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 <em>u</em> 的时候，<em>u</em> 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 <em>u</em> 出发通过一条有向边可以到达的所有节点。</p></blockquote><p>假设我们当前搜索到了节点 <em>u</em>，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 <em>u</em> 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 <em>u</em> 处于栈顶的位置，那么 <em>u</em> 出现在所有 <em>u</em> 的相邻节点的前面。因此对于 <em>u</em> 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p><strong>算法</strong></p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 <em>u</em> 标记为「搜索中」，遍历该节点的每一个相邻节点 <em>v</em>：</p><ul><li><p>如果 <em>v</em> 为「未搜索」，那么我们开始搜索 <em>v</em>，待搜索完成回溯到 <em>u</em>；</p></li><li><p>如果 <em>v</em> 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 <em>v</em> 为「已完成」，那么说明 <em>v</em> 已经在栈中了，而 <em>u</em> 还不在栈中，因此 <em>u</em> 无论何时入栈都不会影响到 <em>(u, v)</em> 之前的拓扑关系，以及不用进行任何操作。</p></li></ul></li><li><p>当 <em>u</em> 的所有相邻节点都为「已完成」时，我们将 <em>u</em> 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 <em>n</em> 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><p>下面的幻灯片给出了深度优先搜索的可视化流程。图中的「白色」「黄色」「绿色」节点分别表示「未搜索」「搜索中」「已完成」的状态。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/1.png" target="_blank" rel="noopener">DFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/2.png" target="_blank" rel="noopener">DFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/3.png" target="_blank" rel="noopener">DFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/4.png" target="_blank" rel="noopener">DFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/5.png" target="_blank" rel="noopener">DFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/6.png" target="_blank" rel="noopener">DFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/7.png" target="_blank" rel="noopener">DFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/8.png" target="_blank" rel="noopener">DFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/9.png" target="_blank" rel="noopener">DFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/10.png" target="_blank" rel="noopener">DFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/11.png" target="_blank" rel="noopener">DFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/12.png" target="_blank" rel="noopener">DFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/13.png" target="_blank" rel="noopener">DFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/14.png" target="_blank" rel="noopener">DFS14</a> <a href="https://assets.leetcode-cn.com/solution-static/207/15.png" target="_blank" rel="noopener">DFS15</a> <a href="https://assets.leetcode-cn.com/solution-static/207/16.png" target="_blank" rel="noopener">DFS16</a> <a href="https://assets.leetcode-cn.com/solution-static/207/17.png" target="_blank" rel="noopener">DFS17</a> <a href="https://assets.leetcode-cn.com/solution-static/207/18.png" target="_blank" rel="noopener">DFS18</a> <a href="https://assets.leetcode-cn.com/solution-static/207/19.png" target="_blank" rel="noopener">DFS19</a> <a href="https://assets.leetcode-cn.com/solution-static/207/20.png" target="_blank" rel="noopener">DFS20</a> </p><p><strong>优化</strong></p><p>由于我们只需要判断是否存在一种拓扑排序，而栈的作用仅仅是存放最终的拓扑排序结果，因此我们可以只记录每个节点的状态，而省去对应的栈。</p><p><strong>代码</strong></p><details>    <summary>深度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">//如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        result = list()</span><br><span class="line">        valid = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u: int)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> valid</span><br><span class="line">            visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                <span class="keyword">if</span> visited[v] == <span class="number">0</span>:</span><br><span class="line">                    dfs(v)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> visited[v] == <span class="number">1</span>:</span><br><span class="line">                    valid = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            visited[u] = <span class="number">2</span></span><br><span class="line">            result.append(u)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> valid <span class="keyword">and</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                dfs(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> valid</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** edges;</span><br><span class="line"><span class="keyword">int</span>* edgeColSize;</span><br><span class="line"><span class="keyword">int</span>* visited;</span><br><span class="line"><span class="keyword">bool</span> valid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(edges[u][i]);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[edges[u][i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize)</span> </span>&#123;</span><br><span class="line">    valid = <span class="literal">true</span>;</span><br><span class="line">    edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    edgeColSize = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    visited = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="built_in">free</span>(edgeColSize);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        visited = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">        valid = <span class="literal">true</span></span><br><span class="line">        dfs <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">dfs</span> = <span class="title">func</span><span class="params">(u <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        visited[u] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[v] == <span class="number">0</span> &#123;</span><br><span class="line">                dfs(v)</span><br><span class="line">                <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> visited[v] == <span class="number">1</span> &#123;</span><br><span class="line">                valid = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span></span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span> &#123;</span><br><span class="line">            dfs(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在深度优先搜索的过程中，我们需要最多 *O(n)</em> 的栈空间（递归）进行深度优先搜索，因此总空间复杂度为 <em>O(n+m)</em>。</p></li></ul><h2 id="方法二-广度优先搜索"><a href="#方法二-广度优先搜索" class="headerlink" title="方法二: 广度优先搜索"></a>方法二: 广度优先搜索</h2><p><strong>思路</strong></p><p>方法一的深度优先搜索是一种「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点。我们也可以使用正向思维，顺序地生成拓扑排序，这种方法也更加直观。</p><p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点<strong>少了一门先修课程的要求</strong>。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p><p>上面的想法类似于广度优先搜索，因此我们可以将广度优先搜索的流程与拓扑排序的求解联系起来。</p><p><strong>算法</strong></p><p>我们使用一个队列来进行广度优先搜索。初始时，所有入度为 <em>0</em> 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 <em>u</em>：</p><ul><li><p>我们将 <em>u</em> 放入答案中；</p></li><li><p>我们移除 <em>u</em> 的所有出边，也就是将 <em>u</em> 的所有相邻节点的入度减少 <em>1</em>。如果某个相邻节点 <em>v</em> 的入度变为 <em>0</em>，那么我们就将 <em>v</em> 放入队列中。</p></li></ul><p>在广度优先搜索的过程结束后。如果答案中包含了这 <em>n</em> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><p>下面的幻灯片给出了广度优先搜索的可视化流程。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/207/fig1.png" target="_blank" rel="noopener">BFS1</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig2.png" target="_blank" rel="noopener">BFS2</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig3.png" target="_blank" rel="noopener">BFS3</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig4.png" target="_blank" rel="noopener">BFS4</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig5.png" target="_blank" rel="noopener">BFS5</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig6.png" target="_blank" rel="noopener">BFS6</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig7.png" target="_blank" rel="noopener">BFS7</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig8.png" target="_blank" rel="noopener">BFS8</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig9.png" target="_blank" rel="noopener">BFS9</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig10.png" target="_blank" rel="noopener">BFS10</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig11.png" target="_blank" rel="noopener">BFS11</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig12.png" target="_blank" rel="noopener">BFS12</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig13.png" target="_blank" rel="noopener">BFS13</a> <a href="https://assets.leetcode-cn.com/solution-static/207/fig14.png" target="_blank" rel="noopener">BFS14</a> </p><p><strong>优化</strong></p><p>由于我们只需要判断是否存在一种拓扑排序，因此我们省去存放答案数组，而是只用一个变量记录被放入答案数组的节点个数。在广度优先搜索结束之后，我们判断该变量的值是否等于课程数，就能知道是否存在一种拓扑排序。</p><p><strong>代码</strong></p><details>    <summary>广度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].push_back(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] indeg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//在广度优先搜索的每一步中，我们取出队首的节点 u：</span></span><br><span class="line">        <span class="comment">//我们将 u 放入答案中；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            visited++;</span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="comment">//我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v : edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</span></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">            indeg[info[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        q = collections.deque([u <span class="keyword">for</span> u <span class="keyword">in</span> range(numCourses) <span class="keyword">if</span> indeg[u] == <span class="number">0</span>])</span><br><span class="line">        visited = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            visited += <span class="number">1</span></span><br><span class="line">            u = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                indeg[v] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indeg[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>** prerequisites, <span class="keyword">int</span> prerequisitesSize, <span class="keyword">int</span>* prerequisitesColSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** edges = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> edgeColSize[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(edgeColSize, <span class="number">0</span>, <span class="keyword">sizeof</span>(edgeColSize));</span><br><span class="line">    <span class="keyword">int</span> indeg[numCourses];</span><br><span class="line">    <span class="built_in">memset</span>(indeg, <span class="number">0</span>, <span class="keyword">sizeof</span>(indeg));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisitesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = prerequisites[i][<span class="number">1</span>], b = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        edgeColSize[a]++;</span><br><span class="line">        edges[a] = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(edges[a], <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * edgeColSize[a]);</span><br><span class="line">        edges[a][edgeColSize[a] - <span class="number">1</span>] = b;</span><br><span class="line">        ++indeg[b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q[numCourses];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q[++r] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ++visited;</span><br><span class="line">        <span class="keyword">int</span> u = q[l++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeColSize[u]; ++i) &#123;</span><br><span class="line">            --indeg[edges[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (indeg[edges[u][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                q[++r] = edges[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(edges);</span><br><span class="line">    <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        edges = <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        indeg = <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">        result []<span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, info := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]] = <span class="built_in">append</span>(edges[info[<span class="number">1</span>]], info[<span class="number">0</span>])</span><br><span class="line">        indeg[info[<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> indeg[i] == <span class="number">0</span> &#123;</span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        u := q[<span class="number">0</span>]</span><br><span class="line">        q = q[<span class="number">1</span>:]</span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            indeg[v]--</span><br><span class="line">            <span class="keyword">if</span> indeg[v] == <span class="number">0</span> &#123;</span><br><span class="line">                q = <span class="built_in">append</span>(q, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(result) == numCourses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度: <em>O(n+m)*，其中 *n</em> 为课程数，<em>m</em> 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: <em>O(n+m)<em>。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 *O(n+m)</em>。在广度优先搜索的过程中，我们需要最多 *O(n)</em> 的队列空间（迭代）进行广度优先搜索。因此总空间复杂度为 <em>O(n+m)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="Topological sort" scheme="http://yoursite.com/tags/Topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>200. 岛屿数量</title>
    <link href="http://yoursite.com/2020/09/14/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://yoursite.com/2020/09/14/200. 岛屿数量/</id>
    <published>2020-09-14T07:45:12.000Z</published>
    <updated>2020-09-14T08:51:15.789Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><a id="more"></a><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:</p><pre><code>输入:[[&apos;1&apos;,&apos;1&apos;,&apos;1&apos;,&apos;1&apos;,&apos;0&apos;],[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;1&apos;,&apos;0&apos;],[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;]]输出: 1</code></pre><p>示例 2:</p><pre><code>输入:[[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;1&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;0&apos;,&apos;0&apos;,&apos;1&apos;,&apos;0&apos;,&apos;0&apos;],[&apos;0&apos;,&apos;0&apos;,&apos;0&apos;,&apos;1&apos;,&apos;1&apos;]]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="0a3f7b6f-abd0-4af8-87ef-89c565b967d4">LeetCode 200 ZYH.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 <em>1</em> 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 <em>1</em>，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 <em>1</em> 都会被重新标记为 <em>0</em>。</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数。</p><p>下面的动画展示了整个算法。</p><p> <a href="https://pic.leetcode-cn.com/5dae0de2a06f4eae5113f9cadfa5c51bbcf0b9347c5861aa73c93d7bc1d50b34-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/61a98091fe75de107bf886a608e87d5bb29d810b9e7eb1e00c541f49194ea543-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6d060f275561dc390841f78d85124fd193efb0801ea2dc865b2767f1093e4f3a-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/233368eab82832268c3c7266fd7fe65c78626de9fd89cb90b3f36a7b4e52860d-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/bf055c3d5f6b310f6a110ada65d503de6d7793276f5638731c81c53b4276b835-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/195ba530a5350e0a8f8e372319d061c85316c1064017d5c00d7cfc2b0c055de6-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/c21a88bde9450ad83d6164c2df4677b16154fa5990408459a2a45982b9cd70fd-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/0cfddec2d15ed9a56c434f470ff07eb3dfc83dccbda0160583d1bce469077274-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>深度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span>) dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span>) dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, r, c)</span>:</span></span><br><span class="line">        grid[r][c] = <span class="number">0</span></span><br><span class="line">        nr, nc = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(r - <span class="number">1</span>, c), (r + <span class="number">1</span>, c), (r, c - <span class="number">1</span>), (r, c + <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">"1"</span>:</span><br><span class="line">                self.dfs(grid, x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        nr = len(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    num_islands += <span class="number">1</span></span><br><span class="line">                    self.dfs(grid, r, c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(MN)*，其中 *M</em> 和 <em>N</em> 分别为行数和列数。</p></li><li><p>空间复杂度：<em>O(MN)</em>，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 <em>M N</em>。</p></li></ul><h2 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h2><p>同样地，我们也可以使用广度优先搜索代替深度优先搜索。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 <em>1</em>，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 <em>1</em> 都会被重新标记为 <em>0</em>。直到队列为空，搜索结束。</p><p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p><details>    <summary>广度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.push(&#123;r, c&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> rc = neighbors.front();</span><br><span class="line">                        neighbors.pop();</span><br><span class="line">                        <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                            grid[row<span class="number">-1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[row][col<span class="number">-1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.push(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(r * nc + c);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> id = neighbors.remove();</span><br><span class="line">                        <span class="keyword">int</span> row = id / nc;</span><br><span class="line">                        <span class="keyword">int</span> col = id % nc;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row-<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add((row-<span class="number">1</span>) * nc + col);</span><br><span class="line">                            grid[row-<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add((row+<span class="number">1</span>) * nc + col);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col-<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col-<span class="number">1</span>);</span><br><span class="line">                            grid[row][col-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col+<span class="number">1</span>);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        nr = len(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    num_islands += <span class="number">1</span></span><br><span class="line">                    grid[r][c] = <span class="string">"0"</span></span><br><span class="line">                    neighbors = collections.deque([(r, c)])</span><br><span class="line">                    <span class="keyword">while</span> neighbors:</span><br><span class="line">                        row, col = neighbors.popleft()</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(row - <span class="number">1</span>, col), (row + <span class="number">1</span>, col), (row, col - <span class="number">1</span>), (row, col + <span class="number">1</span>)]:</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">"1"</span>:</span><br><span class="line">                                neighbors.append((x, y))</span><br><span class="line">                                grid[x][y] = <span class="string">"0"</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(MN)*，其中 *M</em> 和 <em>N</em> 分别为行数和列数。</p></li><li><p>空间复杂度：O(min(M,N)) ，在最坏情况下，整个网格均为陆地，队列的大小可以达到 min(M,N)。</p></li></ul><h2 id="方法三：并查集"><a href="#方法三：并查集" class="headerlink" title="方法三：并查集"></a>方法三：并查集</h2><p>同样地，我们也可以使用并查集代替搜索。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 <em>1</em>，则将其与相邻四个方向上的 <em>1</em> 在并查集中进行合并。</p><p>最终岛屿的数量就是并查集中连通分量的数目。</p><p>下面的动画展示了整个算法。</p><p> <a href="https://pic.leetcode-cn.com/41b6ce1794ba80a7a82b31dc4c0642b26ccd280457d254d2fdad37a1f5a73ca6-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/82fa6f7b52294fdd8a2f4a0a28d4ca2dd3d71e86e7ddf5fa5ef4b18a13d3c438-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/773a3ac931ca2b397b0ba6cac17a15a0dd21fe2d0f2887d6b90405d9025c3f85-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6c1a18d84a24f74c18654e0f20b17c263646a9fad911e6bb227e665688abb037-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/1a35068b177ce3ed70de37d3e7a1fb3e91ba0e5588ab3e3633ddb963f3d64f68-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6f35cbfc7410e54ec80f96af3123c5eed5e5b8f73e6a1cc2fa4aea0f911e919c-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>并查集C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    parent.push_back(i * n + j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.push_back(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rank.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">            parent[i] = find(parent[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx = find(x);</span><br><span class="line">        <span class="keyword">int</span> rooty = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                swap(rootx, rooty);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] == rank[rooty]) rank[rootx] += <span class="number">1</span>;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(grid)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">'1'</span>) uf.unite(r * nc + c, (r<span class="number">-1</span>) * nc + c);</span><br><span class="line">                    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) uf.unite(r * nc + c, (r+<span class="number">1</span>) * nc + c);</span><br><span class="line">                    <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">'1'</span>) uf.unite(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) uf.unite(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>并查集Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m = grid.length;</span><br><span class="line">            <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        parent[i * n + j] = i * n + j;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != i) parent[i] = find(parent[i]);</span><br><span class="line">            <span class="keyword">return</span> parent[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootx = find(x);</span><br><span class="line">            <span class="keyword">int</span> rooty = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rootx] = rooty;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                    rank[rootx] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, (r-<span class="number">1</span>) * nc + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, (r+<span class="number">1</span>) * nc + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>并查集Python</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.parent = [<span class="number">-1</span>] * (m * n)</span><br><span class="line">        self.rank = [<span class="number">0</span>] * (m * n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">"1"</span>:</span><br><span class="line">                    self.parent[i * n + j] = i * n + j</span><br><span class="line">                    self.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        <span class="keyword">return</span> self.parent[i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            <span class="keyword">if</span> self.rank[rootx] &lt; self.rank[rooty]:</span><br><span class="line">                rootx, rooty = rooty, rootx</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line">            <span class="keyword">if</span> self.rank[rootx] == self.rank[rooty]:</span><br><span class="line">                self.rank[rootx] += <span class="number">1</span></span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCount</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        nr = len(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    grid[r][c] = <span class="string">"0"</span></span><br><span class="line">                    <span class="keyword">for</span> x, y <span class="keyword">in</span> [(r - <span class="number">1</span>, c), (r + <span class="number">1</span>, c), (r, c - <span class="number">1</span>), (r, c + <span class="number">1</span>)]:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">"1"</span>:</span><br><span class="line">                            uf.union(r * nc + c, x * nc + y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uf.getCount()</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(MN*\alpha(MN))</span><br></pre></td></tr></table></figure></li></ul><p>，其中 <em>M</em> 和 <em>N</em> 分别为行数和列数。注意当使用路径压缩（见 <code>find</code> 函数）和按秩合并（见数组 <code>rank</code>）实现并查集时，单次操作的时间复杂度为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha(MN)</span><br></pre></td></tr></table></figure><p>，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha(x)</span><br></pre></td></tr></table></figure><p>为反阿克曼函数，当自变量 <em>x</em> 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\alpha(x)</span><br></pre></td></tr></table></figure><p>的值不会超过 <em>5</em>，因此也可以看成是常数时间复杂度。</p><ul><li>空间复杂度：<em>O(MN)</em>，这是并查集需要使用的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>127. 单词接龙</title>
    <link href="http://yoursite.com/2020/09/09/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <id>http://yoursite.com/2020/09/09/127. 单词接龙/</id>
    <published>2020-09-09T09:45:12.000Z</published>
    <updated>2020-09-14T07:42:39.750Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。</p><a id="more"></a><p>转换需遵循如下规则：</p><ul><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ul><p>说明:</p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><p>示例 1:</p><pre><code>输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</code></pre><p>示例 2:</p><pre><code>输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>拥有一个 <code>beginWord</code> 和一个 <code>endWord</code>，分别表示图上的 <code>start node</code> 和  <code>end node</code>。我们希望利用一些中间节点（单词）从  <code>start node</code> 到  <code>end node</code>，中间节点是 <code>wordList</code> 给定的单词。我们对这个单词接龙每个步骤的唯一条件是相邻单词只可以改变<code>一个字母</code>。</p><p><a href="https://pic.leetcode-cn.com/fc3a60e60cb7a80723feea0689c25a6f1637df8c64cfec0d70a264eee7e88254-Word_Ladder_1.png" target="_blank" rel="noopener">Word_Ladder_1.png</a></p><p>我们将问题抽象在一个无向无权图中，每个单词作为节点，差距只有一个字母的两个单词之间连一条边。问题变成找到从起点到终点的最短路径，如果存在的话。因此可以使用<code>广度优先搜索</code>方法。</p><p>算法中最重要的步骤是找出相邻的节点，也就是只差一个字母的两个单词。为了快速的找到这些相邻节点，我们对给定的 <code>wordList</code> 做一个预处理，将单词中的某个字母用 <code>*</code> 代替。</p><p><a href="https://pic.leetcode-cn.com/7212249f3e224d9d5ccbc292e902e48b572f965236378e034d8e03924404cba2-Word_Ladder_2.png" target="_blank" rel="noopener">Word_Ladder_2.png</a></p><p>这个预处理帮我们构造了一个单词变换的通用状态。例如：<code>Dog ----&gt; D*g &lt;---- Dig</code>，<code>Dog</code> 和 <code>Dig</code> 都指向了一个通用状态 <code>D*g</code>。</p><p>这步预处理找出了单词表中所有单词改变某个字母后的通用状态，并帮助我们更方便也更快的找到相邻节点。否则，对于每个单词我们需要遍历整个字母表查看是否存在一个单词与它相差一个字母，这将花费很多时间。预处理操作在广度优先搜索之前高效的建立了邻接表。</p><p>例如，在广搜时我们需要访问 <code>Dug</code> 的所有邻接点，我们可以先生成 <code>Dug</code> 的所有通用状态：</p><ol><li><code>Dug =&gt; *ug</code></li><li><code>Dug =&gt; D*g</code></li><li><code>Dug =&gt; Du*</code></li></ol><p>第二个变换 <code>D*g</code> 可以同时映射到 <code>Dog</code> 或者 <code>Dig</code>，因为他们都有相同的通用状态。拥有相同的通用状态意味着两个单词只相差一个字母，他们的节点是相连的。</p><h1 id="方法-1：广度优先搜索"><a href="#方法-1：广度优先搜索" class="headerlink" title="方法 1：广度优先搜索"></a>方法 1：广度优先搜索</h1><p><strong>想法</strong></p><p>利用广度优先搜索搜索从 <code>beginWord</code> 到 <code>endWord</code> 的路径。</p><p><strong>算法</strong></p><ol><li><p>对给定的 <code>wordList</code> 做预处理，找出所有的通用状态。将通用状态记录在字典中，键是通用状态，值是所有具有通用状态的单词。</p></li><li><p>将包含 <code>beginWord</code> 和 <code>1</code> 的元组放入队列中，<code>1</code> 代表节点的层次。我们需要返回 <code>endWord</code> 的层次也就是从 <code>beginWord</code> 出发的最短距离。</p></li><li><p>为了防止出现环，使用访问数组记录。</p></li><li><p>当队列中有元素的时候，取出第一个元素，记为 <code>current_word</code>。</p></li><li><p>找到 <code>current_word</code> 的所有通用状态，并检查这些通用状态是否存在其它单词的映射，这一步通过检查 <code>all_combo_dict</code> 来实现。</p></li><li><p>从 <code>all_combo_dict</code> 获得的所有单词，都和 <code>current_word</code> 共有一个通用状态，所以都和 <code>current_word</code> 相连，因此将他们加入到队列中。</p></li><li><p>对于新获得的所有单词，向队列中加入元素 <code>(word, level + 1)</code> 其中 <code>level</code> 是 <code>current_word</code> 的层次。</p></li><li><p>最终当你到达期望的单词，对应的层次就是最短变换序列的长度。</p><blockquote><p>标准广度优先搜索的终止条件就是找到结束单词。</p></blockquote></li></ol><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since all words are of same length.</span></span><br><span class="line">    <span class="keyword">int</span> L = beginWord.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">    <span class="comment">// from any given word. By changing one letter at a time.</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; allComboDict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    wordList.forEach(</span><br><span class="line">        word -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">            <span class="comment">// Key is the generic word</span></span><br><span class="line">            <span class="comment">// Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">            String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line">            List&lt;String&gt; transformations = allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            transformations.add(word);</span><br><span class="line">            allComboDict.put(newWord, transformations);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue for BFS</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Q.add(<span class="keyword">new</span> Pair(beginWord, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">    Map&lt;String, Boolean&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    visited.put(beginWord, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;String, Integer&gt; node = Q.remove();</span><br><span class="line">      String word = node.getKey();</span><br><span class="line">      <span class="keyword">int</span> level = node.getValue();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intermediate words for current word</span></span><br><span class="line">        String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next states are all the words which share the same intermediate state.</span></span><br><span class="line">        <span class="keyword">for</span> (String adjacentWord : allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">          <span class="comment">// If at any point if we find what we are looking for</span></span><br><span class="line">          <span class="comment">// i.e. the end word - we can return with the answer.</span></span><br><span class="line">          <span class="keyword">if</span> (adjacentWord.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">          <span class="keyword">if</span> (!visited.containsKey(adjacentWord)) &#123;</span><br><span class="line">            visited.put(adjacentWord, <span class="keyword">true</span>);</span><br><span class="line">            Q.add(<span class="keyword">new</span> Pair(adjacentWord, level + <span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        L = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        all_combo_dict = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queue for BFS</span></span><br><span class="line">        queue = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">        visited = &#123;beginWord: <span class="keyword">True</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                <span class="comment"># Intermediate words for current word</span></span><br><span class="line">                intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate_word]:</span><br><span class="line">                    <span class="comment"># If at any point if we find what we are looking for</span></span><br><span class="line">                    <span class="comment"># i.e. the end word - we can return with the answer.</span></span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = <span class="keyword">True</span></span><br><span class="line">                        queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">                all_combo_dict[intermediate_word] = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure></li></ul><p>，其中 <em>M</em> 是单词的长度 <em>N</em> 是单词表中单词的总数。找到所有的变换需要对每个单词做 <em>M</em> 次操作。同时，最坏情况下广度优先搜索也要访问所有的 <em>N</em> 个单词。</p><ul><li>空间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure></li></ul><p>，要在 <code>all_combo_dict</code> 字典中记录每个单词的 <em>M</em> 个通用状态。访问数组的大小是 <em>N</em>。广搜队列最坏情况下需要存储 <em>N</em> 个单词。</p><h1 id="方法-2：双向广度优先搜索"><a href="#方法-2：双向广度优先搜索" class="headerlink" title="方法 2：双向广度优先搜索"></a>方法 2：双向广度优先搜索</h1><p><strong>想法</strong></p><p>根据给定字典构造的图可能会很大，而广度优先搜索的搜索空间大小依赖于每层节点的分支数量。假如每个节点的分支数量相同，搜索空间会随着层数的增长指数级的增加。考虑一个简单的二叉树，每一层都是满二叉树的扩展，节点的数量会以 <code>2</code> 为底数呈指数增长。</p><p>如果使用两个同时进行的广搜可以有效地减少搜索空间。一边从 <code>beginWord</code> 开始，另一边从 <code>endWord</code> 开始。我们每次从两边各扩展一个节点，当发现某一时刻两边都访问了某一顶点时就停止搜索。这就是<code>双向广度优先搜索</code>，它可以可观地减少搜索空间大小，从而降低时间和空间复杂度。</p><p><a href="https://pic.leetcode-cn.com/be92086801e264f49bb1c01593dbfee5b08e52c600b62576c5fa0c1ef2d54eb8-Word_Ladder_3.png" target="_blank" rel="noopener">Word_Ladder_3.png</a></p><p><strong>算法</strong></p><ol><li><p>算法与之前描述的标准广搜方法相类似。</p></li><li><p>唯一的不同是我们从两个节点同时开始搜索，同时搜索的结束条件也有所变化。</p></li><li><p>我们现在有两个访问数组，分别记录从对应的起点是否已经访问了该节点。</p></li><li><p>如果我们发现一个节点被两个搜索同时访问，就结束搜索过程。因为我们找到了双向搜索的交点。过程如同从中间相遇而不是沿着搜索路径一直走。</p><blockquote><p>双向搜索的结束条件是找到一个单词被两边搜索都访问过了。</p></blockquote></li><li><p>最短变换序列的长度就是中间节点在两边的层次之和。因此，我们可以在访问数组中记录节点的层次。</p></li></ol><p><a href="https://pic.leetcode-cn.com/77ff942730428bad804a3f3e8bcddb618ce7b26a2df85cae104c5c2563803dde-Word_Ladder_4.png" target="_blank" rel="noopener">Word_Ladder_4.png</a></p><details>    <summary>双向广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> L;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; allComboDict;</span><br><span class="line"></span><br><span class="line">  Solution() &#123;</span><br><span class="line">    <span class="keyword">this</span>.L = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">    <span class="comment">// from any given word. By changing one letter at a time.</span></span><br><span class="line">    <span class="keyword">this</span>.allComboDict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">visitWordNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Queue&lt;Pair&lt;String, Integer&gt;&gt; Q,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Integer&gt; visited,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Integer&gt; othersVisited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Pair&lt;String, Integer&gt; node = Q.remove();</span><br><span class="line">    String word = node.getKey();</span><br><span class="line">    <span class="keyword">int</span> level = node.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.L; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Intermediate words for current word</span></span><br><span class="line">      String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next states are all the words which share the same intermediate state.</span></span><br><span class="line">      <span class="keyword">for</span> (String adjacentWord : <span class="keyword">this</span>.allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">        <span class="comment">// If at any point if we find what we are looking for</span></span><br><span class="line">        <span class="comment">// i.e. the end word - we can return with the answer.</span></span><br><span class="line">        <span class="keyword">if</span> (othersVisited.containsKey(adjacentWord)) &#123;</span><br><span class="line">          <span class="keyword">return</span> level + othersVisited.get(adjacentWord);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(adjacentWord)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Save the level as the value of the dictionary, to save number of hops.</span></span><br><span class="line">          visited.put(adjacentWord, level + <span class="number">1</span>);</span><br><span class="line">          Q.add(<span class="keyword">new</span> Pair(adjacentWord, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since all words are of same length.</span></span><br><span class="line">    <span class="keyword">this</span>.L = beginWord.length();</span><br><span class="line"></span><br><span class="line">    wordList.forEach(</span><br><span class="line">        word -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">            <span class="comment">// Key is the generic word</span></span><br><span class="line">            <span class="comment">// Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">            String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">'*'</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line">            List&lt;String&gt; transformations =</span><br><span class="line">                <span class="keyword">this</span>.allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            transformations.add(word);</span><br><span class="line">            <span class="keyword">this</span>.allComboDict.put(newWord, transformations);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queues for birdirectional BFS</span></span><br><span class="line">    <span class="comment">// BFS starting from beginWord</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q_begin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// BFS starting from endWord</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q_end = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Q_begin.add(<span class="keyword">new</span> Pair(beginWord, <span class="number">1</span>));</span><br><span class="line">    Q_end.add(<span class="keyword">new</span> Pair(endWord, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visited to make sure we don't repeat processing same word.</span></span><br><span class="line">    Map&lt;String, Integer&gt; visitedBegin = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; visitedEnd = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    visitedBegin.put(beginWord, <span class="number">1</span>);</span><br><span class="line">    visitedEnd.put(endWord, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q_begin.isEmpty() &amp;&amp; !Q_end.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// One hop from begin word</span></span><br><span class="line">      <span class="keyword">int</span> ans = visitWordNode(Q_begin, visitedBegin, visitedEnd);</span><br><span class="line">      <span class="keyword">if</span> (ans &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// One hop from end word</span></span><br><span class="line">      ans = visitWordNode(Q_end, visitedEnd, visitedBegin);</span><br><span class="line">      <span class="keyword">if</span> (ans &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>双向广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">        <span class="comment"># from any given word. By changing one letter at a time.</span></span><br><span class="line">        self.all_combo_dict = defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitWordNode</span><span class="params">(self, queue, visited, others_visited)</span>:</span></span><br><span class="line">        current_word, level = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">            <span class="comment"># Intermediate words for current word</span></span><br><span class="line">            intermediate_word = current_word[:i] + <span class="string">"*"</span> + current_word[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Next states are all the words which share the same intermediate state.</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> self.all_combo_dict[intermediate_word]:</span><br><span class="line">                <span class="comment"># If the intermediate state/word has already been visited from the</span></span><br><span class="line">                <span class="comment"># other parallel traversal this means we have found the answer.</span></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> others_visited:</span><br><span class="line">                    <span class="keyword">return</span> level + others_visited[word]</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="comment"># Save the level as the value of the dictionary, to save number of hops.</span></span><br><span class="line">                    visited[word] = level + <span class="number">1</span></span><br><span class="line">                    queue.append((word, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> endWord <span class="keyword">or</span> <span class="keyword">not</span> beginWord <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Since all words are of same length.</span></span><br><span class="line">        self.length = len(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.length):</span><br><span class="line">                <span class="comment"># Key is the generic word</span></span><br><span class="line">                <span class="comment"># Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">                self.all_combo_dict[word[:i] + <span class="string">"*"</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Queues for birdirectional BFS</span></span><br><span class="line">        queue_begin = [(beginWord, <span class="number">1</span>)] <span class="comment"># BFS starting from beginWord</span></span><br><span class="line">        queue_end = [(endWord, <span class="number">1</span>)] <span class="comment"># BFS starting from endWord</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Visited to make sure we don't repeat processing same word</span></span><br><span class="line">        visited_begin = &#123;beginWord: <span class="number">1</span>&#125;</span><br><span class="line">        visited_end = &#123;endWord: <span class="number">1</span>&#125;</span><br><span class="line">        ans = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We do a birdirectional search starting one pointer from begin</span></span><br><span class="line">        <span class="comment"># word and one pointer from end word. Hopping one by one.</span></span><br><span class="line">        <span class="keyword">while</span> queue_begin <span class="keyword">and</span> queue_end:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># One hop from begin word</span></span><br><span class="line">            ans = self.visitWordNode(queue_begin, visited_begin, visited_end)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="comment"># One hop from end word</span></span><br><span class="line">            ans = self.visitWordNode(queue_end, visited_end, visited_begin)</span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure></li></ul><p>，其中 <em>M</em> 是单词的长度 <em>N</em> 是单词表中单词的总数。与单向搜索相同的是，找到所有的变换需要 <em>M * N</em> 次操作。但是搜索时间会被缩小一半，因为两个搜索会在中间某处相遇。</p><ul><li>空间复杂度：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(M\times N)</span><br></pre></td></tr></table></figure><p>，要在 <code>all_combo_dict</code> 字典中记录每个单词的 <em>M</em> 个通用状态，这与单向搜索相同。但是因为会在中间相遇，所以双向搜索的搜索空间变小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>322. 零钱兑换</title>
    <link href="http://yoursite.com/2020/09/08/322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/09/08/322. 零钱兑换/</id>
    <published>2020-09-08T11:51:12.000Z</published>
    <updated>2020-09-09T07:34:37.632Z</updated>
    
    <content type="html"><![CDATA[<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1</code></pre><p>示例 2:</p><pre><code>输入: coins = [2], amount = 3输出: -1</code></pre><p>说明:<br>    你可以认为每种硬币的数量是无限的。</p><h1 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h1><ul><li>搜索回溯</li><li>动态规划</li></ul><h1 id="方法一、搜索回溯-超出时间限制"><a href="#方法一、搜索回溯-超出时间限制" class="headerlink" title="方法一、搜索回溯 [超出时间限制]"></a>方法一、搜索回溯 [超出时间限制]</h1><p>参考<a href="https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><details>    <summary>搜索回溯Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> coinChange(<span class="number">0</span>, coins, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span> idxCoin, <span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (idxCoin &lt; coins.length &amp;&amp; amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> maxVal = amount / coins[idxCoin];</span><br><span class="line">      <span class="keyword">int</span> minCost = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= maxVal; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt;= x * coins[idxCoin]) &#123;</span><br><span class="line">          <span class="keyword">int</span> res = coinChange(idxCoin + <span class="number">1</span>, coins, amount - x * coins[idxCoin]);</span><br><span class="line">          <span class="keyword">if</span> (res != -<span class="number">1</span>)</span><br><span class="line">            minCost = Math.min(minCost, res + x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (minCost == Integer.MAX_VALUE)? -<span class="number">1</span>: minCost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br></pre></td></tr></table></figure></details><details>    <summary>搜索回溯C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span> idxCoin, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (idxCoin &lt; coins.size() &amp;&amp; amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxVal = amount / coins[idxCoin];</span><br><span class="line">            <span class="keyword">int</span> minCost = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= maxVal; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (amount &gt;= x * coins[idxCoin]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> res = coinChange(idxCoin + <span class="number">1</span>, coins, amount - x * coins[idxCoin]);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="number">-1</span>) minCost = min(minCost, res + x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> minCost == INT_MAX ? <span class="number">-1</span>: minCost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coinChange(<span class="number">0</span>, coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>参考<a href="https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><h1 id="方法二、动态规划-自上而下-通过"><a href="#方法二、动态规划-自上而下-通过" class="headerlink" title="方法二、动态规划-自上而下 [通过]"></a>方法二、动态规划-自上而下 [通过]</h1><p>我们能改进上面的指数时间复杂度的解吗？当然可以，利用动态规划，我们可以在多项式的时间范围内求解。首先，我们定义：</p><ul><li><p><em>F(S)*：组成金额 *S</em> 所需的最少硬币数量 </p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[c_0,...,c_&#123;n-1&#125;]：可选的 n 枚硬币面额值</span><br></pre></td></tr></table></figure></li></ul><p>我们注意到这个问题有一个最优的子结构性质，这是解决动态规划问题的关键。最优解可以从其子问题的最优解构造出来。如何将问题分解成子问题？假设我们知道 <em>F(S)</em> ，即组成金额 <em>S</em> 最少的硬币数，最后一枚硬币的面值是 <em>C</em>。那么由于问题的最优子结构，转移方程应为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(S) = F(S - C) + 1</span><br></pre></td></tr></table></figure><p>但我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_0,...,c_&#123;n-1&#125;</span><br></pre></td></tr></table></figure><p>并选择其中的最小值。下列递推关系成立： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F(S)=\mathop &#123;min&#125;_&#123;i=0...n-1&#125;F(S-c_i)+1 \ subject\ to \ S-c_i \ge 0 </span><br><span class="line"></span><br><span class="line">F(S)=0,when \ S=0</span><br><span class="line"></span><br><span class="line">F(S)=-1,when \  n=0</span><br></pre></td></tr></table></figure><p><a href="https://pic.leetcode-cn.com/e0fd2252775b89649ceb6e867ff0e546ec77621edb566693482c8588a98066b8-file_1583404923188" target="_blank" rel="noopener">递归树</a></p><p>在上面的递归树中，我们可以看到许多子问题被多次计算。例如， <em>F(1)</em> 被计算了 <em>13</em> 次。为了避免重复的计算，我们将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中取出返回即可，这样能保证每个子问题最多只被计算一次。 </p><details>    <summary>动态规划-自上而下Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> coinChange(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> rem, <span class="keyword">int</span>[] count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">      <span class="keyword">int</span> res = coinChange(coins, rem - coin, count);</span><br><span class="line">      <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min)</span><br><span class="line">        min = <span class="number">1</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">    count[rem - <span class="number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min;</span><br><span class="line">    <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划-自上而下C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> rem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> Min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin:coins) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = dp(coins, rem - coin);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; Min) &#123;</span><br><span class="line">                Min = res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[rem - <span class="number">1</span>] = Min == INT_MAX ? <span class="number">-1</span> : Min;</span><br><span class="line">        <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        count.resize(amount);</span><br><span class="line">        <span class="keyword">return</span> dp(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划-自上而下Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line"><span class="meta">        @functools.lru_cache(amount)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(rem)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> rem &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> rem == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mini = int(<span class="number">1e9</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> self.coins:</span><br><span class="line">                res = dp(rem - coin)</span><br><span class="line">                <span class="keyword">if</span> res &gt;= <span class="number">0</span> <span class="keyword">and</span> res &lt; mini:</span><br><span class="line">                    mini = res + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mini <span class="keyword">if</span> mini &lt; int(<span class="number">1e9</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        self.coins = coins</span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(Sn)*，其中 *S</em> 是金额，<em>n</em> 是面额数。我们一共需要计算 <em>S</em> 个状态的答案，且每个状态 <em>F(S)</em> 由于上面的记忆化的措施只计算了一次，而计算一个状态的答案需要枚举 <em>n</em> 个面额值，所以一共需要 <em>O(Sn)</em> 的时间复杂度。</li><li>空间复杂度：<em>O(S)*，我们需要额外开一个长为 *S</em> 的数组来存储计算出来的答案 <em>F(S)</em> 。</li></ul><p>这种自上而下的动态规划没有太理解，我感觉下次遇到时也很难想到这种方法，直接还是看第三种解法吧。</p><h1 id="方法三、动态规划：自下而上-推荐"><a href="#方法三、动态规划：自下而上-推荐" class="headerlink" title="方法三、动态规划：自下而上 [推荐]"></a>方法三、动态规划：自下而上 [推荐]</h1><p>这种方法比较容易理解。</p><p><strong>算法：</strong></p><p>我们采用自下而上的方式进行思考。仍定义 <em>F(i)</em> 为组成金额 <em>i</em> 所需最少的硬币数量，假设在计算 <em>F(i)</em> 之前，我们已经计算出 <em>F(0)-F(i-1)</em> 的答案。 则 <em>F(i)</em> 对应的转移方程应为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(i)=\mathop &#123;min&#125;_&#123;j=0...n-1&#125;F(i-c_i)+1</span><br></pre></td></tr></table></figure><p>其中 <em>c_j</em> 代表的是第 <em>j</em> 枚硬币的面值，即我们枚举最后一枚硬币面额是 <em>c_j*，那么需要从 *i-c_j</em> 这个金额的状态 <em>F(i-c_j)</em> 转移过来，再算上枚举的这枚硬币数量 <em>1</em> 的贡献，由于要硬币数量最少，所以 <em>F(i)</em> 为前面能转移过来的状态的最小值加上枚举的硬币数量 <em>1</em> 。</p><p>例子1：假设</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coins = [1, 2, 5], amount = 11</span><br></pre></td></tr></table></figure><p>则，当 <em>i==0</em> 时无法用硬币组成，为 0 。当 <em>i&lt;0</em> 时，忽略 <em>F(i)</em><br>| F(i)  | 最小硬币数量                                 |<br>| —– | ——————————————– |<br>| F(0)  | 0 //金额为0不能由硬币组成                    |<br>| F(1)  | 1 //<em>F(1)=min(F(1-1),F(1-2),F(1-5))+1=1</em>     |<br>| F(2)  | 1 //<em>F(2)=min(F(2-1),F(2-2),F(2-5))+1=1</em>     |<br>| F(3)  | 2 //<em>F(3)=min(F(3-1),F(3-2),F(3-5))+1=2</em>     |<br>| F(4)  | 2 //<em>F(4)=min(F(4-1),F(4-2),F(4-5))+1=2</em>     |<br>| …   | …                                          |<br>| F(11) | 3 //<em>F(11)=min(F(11-1),F(11-2),F(11-5))+1=3</em> |<br>我们可以看到问题的答案是通过子问题的最优解得到的。</p><p>例子2：假设</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coins = [1, 2, 3], amount = 6</span><br></pre></td></tr></table></figure><p><a href="https://pic.leetcode-cn.com/f4fd96a19871ff55282b0fa90e86ee4768a267ee7e5c446fb6b1837bc215fe2e-file_1583404923197" target="_blank" rel="noopener">例子2</a></p><p>在上图中，可以看到： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F(3)=min(F(3−c_1),F(3−c_2),F(3−c_3))+1</span><br><span class="line"></span><br><span class="line">=min(F(3−1),F(3−2),F(3−3))+1</span><br><span class="line"></span><br><span class="line">=min(F(2),F(1),F(0))+1</span><br><span class="line"></span><br><span class="line">=min(1,1,0)+1</span><br><span class="line"></span><br><span class="line">=1</span><br></pre></td></tr></table></figure><details>    <summary>动态规划：自下而上Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = min(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划：自下而上Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">          dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划：自下而上C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, Max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)coins.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(Sn)*，其中 *S</em> 是金额，<em>n</em> 是面额数。我们一共需要计算 <em>O(S)</em> 个状态，<em>S</em> 为题目所给的总金额。对于每个状态，每次需要枚举 <em>n</em> 个面额来转移状态，所以一共需要 <em>O(Sn)</em> 的时间复杂度。</li><li>空间复杂度：<em>O(S)*。DP 数组需要开长度为总金额 *S</em> 的空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>329. 矩阵中的最长递增路径</title>
    <link href="http://yoursite.com/2020/09/08/329.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/09/08/329. 矩阵中的最长递增路径/</id>
    <published>2020-09-08T11:51:12.000Z</published>
    <updated>2020-09-09T09:42:02.474Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数矩阵，找出最长递增路径的长度。</p><a id="more"></a><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p>示例 1:</p><pre><code>输入: nums = [  [9,9,4],  [6,6,8],  [2,1,1]] 输出: 4 </code></pre><p>解释: 最长递增路径为 [1, 2, 6, 9]。<br>示例 2:</p><pre><code>输入: nums = [  [3,4,5],  [3,2,6],  [2,2,1]] 输出: 4 </code></pre><p>解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</p><h1 id="方法一：记忆化深度优先搜索"><a href="#方法一：记忆化深度优先搜索" class="headerlink" title="方法一：记忆化深度优先搜索"></a>方法一：记忆化深度优先搜索</h1><p>将矩阵看成一个有向图，每个单元格对应图中的一个节点，如果相邻的两个单元格的值不相等，则在相邻的两个单元格之间存在一条从较小值指向较大值的有向边。问题转化成在有向图中寻找最长路径。</p><p>深度优先搜索是非常直观的方法。从一个单元格开始进行深度优先搜索，即可找到从该单元格开始的最长递增路径。对每个单元格分别进行深度优先搜索之后，即可得到矩阵中的最长递增路径的长度。</p><p>但是如果使用朴素深度优先搜索，时间复杂度是指数级，会超出时间限制，因此必须加以优化。</p><p>朴素深度优先搜索的时间复杂度过高的原因是进行了大量的重复计算，同一个单元格会被访问多次，每次访问都要重新计算。由于同一个单元格对应的最长递增路径的长度是固定不变的，因此可以使用记忆化的方法进行优化。用矩阵memo 作为缓存矩阵，已经计算过的单元格的结果存储到缓存矩阵中。</p><p>使用记忆化深度优先搜索，当访问到一个单元格 <em>(i,j)</em> 时，如果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">memo[i][j]\neq0</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果</span><br><span class="line">```math</span><br><span class="line">memo[i][j]=0</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</span><br><span class="line"></span><br><span class="line">遍历完矩阵中的所有单元格之后，即可得到矩阵中的最长递增路径的长度。</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;记忆化深度优先搜索Java&lt;/summary&gt;</span><br><span class="line">```Java [sol1-Java]</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    public int rows, columns;</span><br><span class="line"></span><br><span class="line">    public int longestIncreasingPath(int[][] matrix) &#123;</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.length;</span><br><span class="line">        columns = matrix[0].length;</span><br><span class="line">        int[][] memo = new int[rows][columns];</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; rows; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; columns; ++j) &#123;</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dfs(int[][] matrix, int row, int column, int[][] memo) &#123;</span><br><span class="line">        if (memo[row][column] != 0) &#123;</span><br><span class="line">            return memo[row][column];</span><br><span class="line">        &#125;</span><br><span class="line">        ++memo[row][column];</span><br><span class="line">        for (int[] dir : dirs) &#123;</span><br><span class="line">            int newRow = row + dir[0], newColumn = column + dir[1];</span><br><span class="line">            if (newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">                memo[row][column] = Math.max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return memo[row][column];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>记忆化深度优先搜索C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.size();</span><br><span class="line">        columns = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">auto</span> memo = <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; (rows, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (columns));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                ans = max(ans, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[row][column] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[row][column];</span><br><span class="line">        &#125;</span><br><span class="line">        ++memo[row][column];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + dirs[i][<span class="number">0</span>], newColumn = column + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">                memo[row][column] = max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[row][column];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>记忆化深度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    DIRS = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(row: int, column: int)</span> -&gt; int:</span></span><br><span class="line">            best = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> Solution.DIRS:</span><br><span class="line">                newRow, newColumn = row + dx, column + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= newRow &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= newColumn &lt; columns <span class="keyword">and</span> matrix[newRow][newColumn] &gt; matrix[row][column]:</span><br><span class="line">                    best = max(best, dfs(newRow, newColumn) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> best</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        rows, columns = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(columns):</span><br><span class="line">                ans = max(ans, dfs(i, j))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>记忆化深度优先搜索C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrixSize == <span class="number">0</span> || matrixColSize[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rows = matrixSize;</span><br><span class="line">    columns = matrixColSize[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** memo = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        memo[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * columns);</span><br><span class="line">        <span class="built_in">memset</span>(memo[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * columns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">            ans = fmax(ans, dfs(matrix, i, j, memo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(memo);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span>** memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[row][column] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[row][column];</span><br><span class="line">    &#125;</span><br><span class="line">    ++memo[row][column];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> newRow = row + dirs[i][<span class="number">0</span>], newColumn = column + dirs[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column]) &#123;</span><br><span class="line">            memo[row][column] = fmax(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[row][column];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>记忆化深度优先搜索Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    dirs = [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    rows, columns <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestIncreasingPath</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    memo := <span class="built_in">make</span>([][]<span class="keyword">int</span>, rows)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        memo[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, columns)</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; columns; j++ &#123;</span><br><span class="line">            ans = max(ans, dfs(matrix, i, j, memo))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(matrix [][]<span class="keyword">int</span>, row, column <span class="keyword">int</span>, memo [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> memo[row][column] != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[row][column]</span><br><span class="line">    &#125;</span><br><span class="line">    memo[row][column]++</span><br><span class="line">    <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">        newRow, newColumn := row + dir[<span class="number">0</span>], column + dir[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[row][column] &#123;</span><br><span class="line">            memo[row][column] = max(memo[row][column], dfs(matrix, newRow, newColumn, memo) + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[row][column]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(mn)*，其中 *m</em> 和 <em>n</em> 分别是矩阵的行数和列数。深度优先搜索的时间复杂度是 <em>O(V+E)*，其中 *V</em> 是节点数，<em>E</em> 是边数。在矩阵中，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O(V)=O(mn)</span><br><span class="line"></span><br><span class="line">O(E) \approx O(4mn)=O(mn)</span><br></pre></td></tr></table></figure><ul><li>空间复杂度：<em>O(mn)*，其中 *m</em> 和 <em>n</em> 分别是矩阵的行数和列数。空间复杂度主要取决于缓存和递归调用深度，缓存的空间复杂度是 <em>O(mn)</em>，递归调用深度不会超过 <em>mn</em>。</li></ul><h1 id="方法二：拓扑排序"><a href="#方法二：拓扑排序" class="headerlink" title="方法二：拓扑排序"></a>方法二：拓扑排序</h1><p>从方法一可以看到，每个单元格对应的最长递增路径的结果只和相邻单元格的结果有关，那么是否可以使用动态规划求解？</p><p>根据方法一的分析，动态规划的状态定义和状态转移方程都很容易得到。方法一中使用的缓存矩阵 memo  即为状态值，状态转移方程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memo[i][j]=max&#123;memo[x][y]&#125;+1</span><br><span class="line"></span><br><span class="line">其中(x,y)与(i,j)在矩阵中相邻，并且memo[x][y]&gt;memo[i][j]</span><br></pre></td></tr></table></figure><p>动态规划除了状态定义和状态转移方程，还需要考虑边界情况。这里的边界情况是什么呢？</p><p>如果一个单元格的值比它的所有相邻单元格的值都要大，那么这个单元格对应的最长递增路径是 <em>1</em>，这就是边界条件。这个边界条件并不直观，而是需要根据矩阵中的每个单元格的值找到作为边界条件的单元格。</p><p>仍然使用方法一的思想，将矩阵看成一个有向图，计算每个单元格对应的出度，即有多少条边从该单元格出发。对于作为边界条件的单元格，该单元格的值比所有的相邻单元格的值都要大，因此作为边界条件的单元格的出度都是 <em>0</em>。</p><p>基于出度的概念，可以使用拓扑排序求解。从所有出度为 <em>0</em> 的单元格开始广度优先搜索，每一轮搜索都会遍历当前层的所有单元格，更新其余单元格的出度，并将出度变为 <em>0</em> 的单元格加入下一层搜索。当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。</p><details>    <summary>拓扑排序Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.length;</span><br><span class="line">        columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] outdegrees = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = i + dir[<span class="number">0</span>], newColumn = j + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        ++outdegrees[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] cell = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> row = cell[<span class="number">0</span>], column = cell[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = row + dir[<span class="number">0</span>], newColumn = column + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) &#123;</span><br><span class="line">                        --outdegrees[newRow][newColumn];</span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[newRow][newColumn] == <span class="number">0</span>) &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newRow, newColumn&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>拓扑排序cpp</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.size();</span><br><span class="line">        columns = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">auto</span> outdegrees = <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; (rows, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = i + dirs[k][<span class="number">0</span>], newColumn = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        ++outdegrees[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span> &lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cell = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">int</span> row = cell.first, column = cell.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = row + dirs[k][<span class="number">0</span>], newColumn = column + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) &#123;</span><br><span class="line">                        --outdegrees[newRow][newColumn];</span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[newRow][newColumn] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.push(&#123;newRow, newColumn&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>拓扑排序Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    DIRS = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        rows, columns = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        outdegrees = [[<span class="number">0</span>] * columns <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(columns):</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> Solution.DIRS:</span><br><span class="line">                    newRow, newColumn = i + dx, j + dy</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= newRow &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= newColumn &lt; columns <span class="keyword">and</span> matrix[newRow][newColumn] &gt; matrix[i][j]:</span><br><span class="line">                        outdegrees[i][j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> outdegrees[i][j] == <span class="number">0</span>:</span><br><span class="line">                    queue.append((i, j))</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            size = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                row, column = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> Solution.DIRS:</span><br><span class="line">                    newRow, newColumn = row + dx, column + dy</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= newRow &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= newColumn &lt; columns <span class="keyword">and</span> matrix[newRow][newColumn] &lt; matrix[row][column]:</span><br><span class="line">                        outdegrees[newRow][newColumn] -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> outdegrees[newRow][newColumn] == <span class="number">0</span>:</span><br><span class="line">                            queue.append((newRow, newColumn))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>拓扑排序C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrixSize == <span class="number">0</span> || matrixColSize[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rows = matrixSize;</span><br><span class="line">    columns = matrixColSize[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** outdegrees = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        outdegrees[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * columns);</span><br><span class="line">        <span class="built_in">memset</span>(outdegrees[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * columns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> newRow = i + dirs[k][<span class="number">0</span>], newColumn = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) &#123;</span><br><span class="line">                    ++outdegrees[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    point* q = (point*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(point) * rows * columns);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                q[r++] = (point)&#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ++ans;</span><br><span class="line">        <span class="keyword">int</span> size = r - l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            point cell = q[l++];</span><br><span class="line">            <span class="keyword">int</span> row = cell.x, column = cell.y;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> newRow = row + dirs[k][<span class="number">0</span>], newColumn = column + dirs[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) &#123;</span><br><span class="line">                    --outdegrees[newRow][newColumn];</span><br><span class="line">                    <span class="keyword">if</span> (outdegrees[newRow][newColumn] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q[r++] = (point)&#123;newRow, newColumn&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>拓扑排序Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    dirs = [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    rows, columns <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestIncreasingPath</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    outdegrees := <span class="built_in">make</span>([][]<span class="keyword">int</span>, rows)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        outdegrees[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, columns)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; columns; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">                newRow, newColumn := i + dir[<span class="number">0</span>], j + dir[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j] &#123;</span><br><span class="line">                    outdegrees[i][j]++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; columns; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> outdegrees[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, []<span class="keyword">int</span>&#123;i, j&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        ans++</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            cell := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            row, column := cell[<span class="number">0</span>], cell[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">                newRow, newColumn := row + dir[<span class="number">0</span>], column + dir[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column] &#123;</span><br><span class="line">                    outdegrees[newRow][newColumn]--</span><br><span class="line">                    <span class="keyword">if</span> outdegrees[newRow][newColumn] == <span class="number">0</span> &#123;</span><br><span class="line">                        queue = <span class="built_in">append</span>(queue, []<span class="keyword">int</span>&#123;newRow, newColumn&#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 和 <em>n</em> 分别是矩阵的行数和列数。拓扑排序的时间复杂度是 <em>O(V+E)*，其中 *V</em> 是节点数，<em>E</em> 是边数。在矩阵中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O(V)=O(mn)</span><br><span class="line"></span><br><span class="line">O(E) \approx O(4mn)=O(mn)</span><br></pre></td></tr></table></figure></li><li><p>空间复杂度：<em>O(mn)*，其中 *m</em> 和 <em>n</em> 分别是矩阵的行数和列数。空间复杂度主要取决于队列，队列中的元素个数不会超过 <em>mn</em>。</p></li></ul><p>这种方法我看的还是有点儿懵，特别是这段</p><p>基于出度的概念，可以使用拓扑排序求解。从所有出度为 <em>0</em> 的单元格开始广度优先搜索，每一轮搜索都会遍历当前层的所有单元格，更新其余单元格的出度，并将出度变为 <em>0</em> 的单元格加入下一层搜索。当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>为了让大家更好地理解这道题，出了四道思考题</p><ul><li><p>「方法一」中使用了记忆化存储和深度优先搜索，这里的深度优先搜索可以替换成广度优先搜索吗？</p></li><li><p>「方法二」中基于拓扑排序对排序后的有向无环图做了层次遍历，如果没有拓扑排序直接进行广度优先搜索会发生什么？</p></li><li><p>「方法二」中如果不使用拓扑排序，而是直接按照矩阵中元素的值<strong>从大到小</strong>进行排序，并依此顺序进行状态转移，那么可以得到正确的答案吗？如果是<strong>从小到大</strong>进行排序呢？</p></li><li><p>「变式」给定一个整数矩阵，找出符合以下条件的路径的数量：这个路径是严格递增的，且它的长度至少是 <em>3</em>。矩阵的边长最大为 <em>10^3*，答案对 *10^9 + 7</em> 取模。其他条件和题目相同。<strong>思考：是否可以借鉴这道题的方法？</strong></p></li></ul><p>解答参见<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数矩阵，找出最长递增路径的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Topological Sort" scheme="http://yoursite.com/tags/Topological-Sort/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>300. 最长上升子序列</title>
    <link href="http://yoursite.com/2020/09/08/300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/09/08/300. 最长上升子序列/</id>
    <published>2020-09-08T02:51:12.000Z</published>
    <updated>2020-09-08T11:43:19.567Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><a id="more"></a><p>示例:</p><pre><code>输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是[2,3,7,101]，它的长度是 4。</code></pre><p>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为O(n^2) 。</p><p>进阶: 你能将算法的时间复杂度降低到O(n log n) 吗?</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最开始的想法想先用暴力方法做出来，但是遇到一个问题，[2, 5, 3, 4]这个测试用例长度应该是3，但是我的暴力方法结果是2，因为外层遍历到2，内层遍历到5时就已经认为找到了上升序列，不会再更新后面的3和4.</p><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p><strong>思路与算法</strong></p><p>定义 <em>dp[i]</em> 为考虑前 <em>i</em> 个元素，以第 <em>i</em> 个数字结尾的最长上升子序列的长度，<strong>注意nums[i] 必须被选取</strong>。</p><p>我们从小到大计算 <em>dp[]</em> 数组的值，在计算 <em>dp[i]</em> 之前，我们已经计算出 dp[0..i-1] 的值，则状态转移方程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]=max(dp[j])+1,其中0&lt;=j&lt;i且num[j]&lt;num[i]</span><br></pre></td></tr></table></figure><p>即考虑往 dp[0..i-1] 中最长的上升子序列后面再加一个 nums[i] 。由于 <em>dp[j]</em> 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 <em>dp[j]</em> 这个状态转移过来，那么 nums[i] 必然要大于nums[j]，才能将  nums[i]  放在nums[j]后面以形成更长的上升子序列。</p><p>最后，整个数组的最长上升子序列即所有 <em>dp[i]</em> 中的最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIS_&#123;length&#125;=max(dp[j]),其中0&lt;=i&lt;n</span><br></pre></td></tr></table></figure><p>以下动画演示了该方法： </p><p> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide1.PNG" target="_blank" rel="noopener">1</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide2.PNG" target="_blank" rel="noopener">2</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide3.PNG" target="_blank" rel="noopener">3</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide4.PNG" target="_blank" rel="noopener">4</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide5.PNG" target="_blank" rel="noopener">5</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide6.PNG" target="_blank" rel="noopener">6</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide7.PNG" target="_blank" rel="noopener">7</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide8.PNG" target="_blank" rel="noopener">8</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide9.PNG" target="_blank" rel="noopener">9</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide10.PNG" target="_blank" rel="noopener">10</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide11.PNG" target="_blank" rel="noopener">11</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide12.PNG" target="_blank" rel="noopener">12</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide13.PNG" target="_blank" rel="noopener">13</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide14.PNG" target="_blank" rel="noopener">14</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide15.PNG" target="_blank" rel="noopener">15</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide16.PNG" target="_blank" rel="noopener">16</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide17.PNG" target="_blank" rel="noopener">17</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide18.PNG" target="_blank" rel="noopener">18</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide19.PNG" target="_blank" rel="noopener">19</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide20.PNG" target="_blank" rel="noopener">20</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide21.PNG" target="_blank" rel="noopener">21</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide22.PNG" target="_blank" rel="noopener">22</a> <a href="https://pic.leetcode-cn.com/Figures/300_LISSlide23.PNG" target="_blank" rel="noopener">23</a> </p><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    maxval = Math.max(maxval, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=(<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Python3</summary><figure class="highlight plain"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        dp = []</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            dp.append(1)</span><br><span class="line">            for j in range(i):</span><br><span class="line">                if nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1)</span><br><span class="line">        return max(dp)</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 为数组nums 的长度。动态规划的状态数为 <em>n</em>，计算状态 <em>dp[i]</em> 时，需要 <em>O(n)</em> 的时间遍历 dp[0…i-1]的所有状态，所以总时间复杂度为 <em>O(n^2)</em>。</p></li><li><p>空间复杂度：<em>O(n)*，需要额外使用长度为 *n</em> 的 <em>dp</em> 数组。</p></li></ul><h1 id="方法二：贪心-二分查找"><a href="#方法二：贪心-二分查找" class="headerlink" title="方法二：贪心 + 二分查找"></a>方法二：贪心 + 二分查找</h1><p><strong>思路与算法</strong></p><p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p><p>基于上面的贪心思路，我们维护一个数组 <em>d[i]</em> ，表示长度为 <em>i</em> 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 <em>len</em> 为 <em>1</em>，d[1]=nums[0]。</p><p>同时我们可以注意到 <em>d[i]</em> 是关于 <em>i</em> 单调递增的。因为如果 d[j]&gt;=d[i] 且 <em>j &lt; i*，我们考虑从长度为 *i</em> 的最长上升子序列的末尾删除 <em>i-j</em> 个元素，那么这个序列长度变为 <em>j</em> ，且第 <em>j</em> 个元素 <em>x</em>（末尾元素）必然小于 <em>d[i]<em>，也就小于 *d[j]</em>。那么我们就找到了一个长度为 *j</em> 的最长上升子序列，并且末尾元素比 <em>d[j]</em> 小，从而产生了矛盾。因此数组 <em>d[]</em> 的单调性得证。</p><p>我们依次遍历数组 nums[] 中的每个元素，并更新数组 <em>d[]</em> 和 <em>len</em> 的值。如果 nums[i]&gt;d[len]  则更新 <em>len = len + 1</em>，否则在 d[1…len]中找满足d[i-1]&lt;nums[j]&lt;d[i] 的下标 <em>i</em>，并更新 d[i]=nums[j] 。</p><p>根据 <em>d</em> 数组的单调性，我们可以使用二分查找寻找下标 <em>i</em>，优化时间复杂度。</p><p>最后整个算法流程为：</p><ul><li><p>设当前已求出的最长上升子序列的长度为len （初始时为 <em>1</em>），从前往后遍历数组 nums，在遍历到 nums[i] 时：</p><ul><li><p>如果 nums[i]&gt;d[len]  ，则直接加入到 <em>d</em> 数组末尾，并更新len=len+1；</p></li><li><p>否则，在 <em>d</em> 数组中二分查找，找到第一个比nums[i] 小的数 <em>d[k]</em> ，并更新d[k+1]=nums[i]。</p></li></ul></li></ul><p>以输入序列 <em>[0, 8, 4, 12, 2]</em> 为例：</p><ul><li><p>第一步插入 <em>0</em>，<em>d = [0]</em>；</p></li><li><p>第二步插入 <em>8</em>，<em>d = [0, 8]</em>；</p></li><li><p>第三步插入 <em>4</em>，<em>d = [0, 4]</em>；</p></li><li><p>第四步插入 <em>12</em>，<em>d = [0, 4, 12]</em>；</p></li><li><p>第五步插入 <em>2</em>，<em>d = [0, 2, 12]</em>。</p></li></ul><p>最终得到最大递增子序列长度为 <em>3</em>。</p><details>    <summary>贪心 + 二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心 + 二分查找Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        d = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d <span class="keyword">or</span> n &gt; d[<span class="number">-1</span>]:</span><br><span class="line">                d.append(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l, r = <span class="number">0</span>, len(d) - <span class="number">1</span></span><br><span class="line">                loc = r</span><br><span class="line">                <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                    mid = (l + r) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> d[mid] &gt;= n:</span><br><span class="line">                        loc = mid</span><br><span class="line">                        r = mid - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">                d[loc] = n</span><br><span class="line">        <span class="keyword">return</span> len(d)</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心 + 二分查找Java</summary> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">    public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">        // len 记录目前最长上升子序列的长度</span><br><span class="line">        int len = 1, n = nums.length;</span><br><span class="line">        if (n == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //d[]表示长度为 i 的最长上升子序列的末尾元素的最小值</span><br><span class="line">        int[] d=new int[n+1];</span><br><span class="line">        d[len] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &gt; d[len])&#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span><br><span class="line">                while (l &lt;= r) &#123;</span><br><span class="line">                    int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">                    if (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        r = mid - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + 1] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogn)。数组 nums 的长度为 <em>n</em>，我们依次用数组中的元素去更新 <em>d</em> 数组，而更新 <em>d</em> 数组时需要进行 O(logn) 的二分搜索，所以总时间复杂度为 O(nlogn) 。</p></li><li><p>空间复杂度：<em>O(n)*，需要额外使用长度为 *n</em> 的 <em>d</em> 数组。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>279. 完全平方数</title>
    <link href="http://yoursite.com/2020/09/03/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2020/09/03/279. 完全平方数/</id>
    <published>2020-09-03T11:41:12.000Z</published>
    <updated>2020-09-08T02:48:13.638Z</updated>
    
    <content type="html"><![CDATA[<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4.</code></pre><p>示例 2:</p><pre><code>输入: n = 13输出: 2解释: 13 = 4 + 9.</code></pre><h1 id="方法一：暴力枚举法-超出时间限制"><a href="#方法一：暴力枚举法-超出时间限制" class="headerlink" title="方法一：暴力枚举法 [超出时间限制]"></a>方法一：暴力枚举法 [超出时间限制]</h1><p>这个问题要求我们找出由完全平方数组合成给定数字的最小个数。我们将问题重新表述成：</p><p>给定一个完全平方数列表和正整数 <code>n</code>，求出完全平方数组合成 <code>n</code> 的组合，要求组合中的解拥有完全平方数的最小个数。</p><p>注：可以重复使用列表中的完全平方数。</p><p>从上面对这个问题的叙述来看，它似乎是一个组合问题，对于这个问题，一个直观的解决方案是使用暴力枚举法，我们枚举所有可能的组合，并找到完全平方数的个数最小的一个。</p><p>我们可以用下面的公式来表述这个问题：</p><p><code>numSquares(n)=min(numSquares(n-k)+1) ∀k∈ square numbers</code></p><p>从上面的公式中，我们可以将其转换为递归解决方案。这里有一个例子。</p><p><strong>算法：</strong></p><details>    <summary>暴力枚举法</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        square_nums = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(math.sqrt(n))+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">minNumSquares</span><span class="params">(k)</span>:</span></span><br><span class="line">            <span class="string">""" recursive solution """</span></span><br><span class="line">            <span class="comment"># bottom cases: find a square number</span></span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> square_nums:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            min_num = float(<span class="string">'inf'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Find the minimal value among all possible solutions</span></span><br><span class="line">            <span class="keyword">for</span> square <span class="keyword">in</span> square_nums:</span><br><span class="line">                <span class="keyword">if</span> k &lt; square:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                new_num = minNumSquares(k-square) + <span class="number">1</span></span><br><span class="line">                min_num = min(min_num, new_num)</span><br><span class="line">            <span class="keyword">return</span> min_num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minNumSquares(n)</span><br></pre></td></tr></table></figure></details><p>上面的解决方案可以适用于较小的正整数 <code>n</code>。然而，会发现对于中等大小的数字（例如 55），我们也会很快遇到超出时间限制的问题。</p><p>简单的说，可能会由于过度递归，产生堆栈溢出。</p><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p>使用暴力枚举法会超出时间限制的原因很简单，因为我们重复的计算了中间解。我们以前的公式仍然是有效的。我们只需要一个更好的方法实现这个公式。</p><p><code>numSquares(n)=min(numSquares(n-k)+1) ∀k∈ square numbers</code></p><p>你可能注意到从公式看来，这个问题和<a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数问题</a>类似。和斐波那契数一样，我们由几种更有效的方法来计算解，而不是简单的递归。</p><p>解决递归中堆栈溢出的问题的一个思路就是使用动态规划（DP）技术，该技术建立在重用中间解的结果来计算终解的思想之上。</p><p>要计算numSquares(n) 的值，首先要计算 <em>n</em> 之前的所有值，即 numSquares(n-k) 。如果我们已经在某个地方保留了数字 <em>n-k</em> 的解，那么就不需要使用递归计算。</p><p><strong>算法：</strong></p><p>基于上述所说，我么可以在以下步骤实现 DP 解决方案。</p><ul><li>几乎所有的动态规划解决方案，首先会创建一个一维或多维数组 DP 来保存中间子解的值，以及通常数组最后一个值代表最终解。注意，我们创建了一个虚构的元素 <code>dp[0]=0</code> 来简化逻辑，这有助于在在余数 (<code>n-k</code>）恰好是一个完全平方数的情况下。</li><li>我们还需要预计算小于给定数字 <code>n</code> 的完全平方数列表（即 <code>square_nums</code>）。</li><li>在主要步骤中，我们从数字 <code>1</code> 循环到 <code>n</code>，计算每个数字 <code>i</code> 的解（即 <code>numSquares(i)</code>）。每次迭代中，我们将 <code>numSquares(i)</code> 的结果保存在 <code>dp[i]</code> 中。</li><li>在循环结束时，我们返回数组中的最后一个元素作为解决方案的结果。</li><li>在下图中，我们演示了如何计算与 <code>dp[4]</code> 和 <code>dp[5]</code> 相对应的 <code>numSquares(4)</code> 和 <code>numSquares(5)</code> 的结果。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9kcC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>下面是示例实现，其中 Python 解决方案花费了约 3500 ms，这比当时 50% 的提交要快。</p><p>注意：以下 Python 解决方案仅适用于 Python2。出于某种未知的原因，Python3 运行相同的代码需要更长的时间。</p><details>    <summary>动态规划Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        square_nums = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, int(math.sqrt(n))+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># bottom case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> square <span class="keyword">in</span> square_nums:</span><br><span class="line">                <span class="keyword">if</span> i &lt; square:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                dp[i] = min(dp[i], dp[i-square] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// bottom case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pre-calculate the square numbers.</span></span><br><span class="line">    <span class="keyword">int</span> max_square_index = (<span class="keyword">int</span>) Math.sqrt(n) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> square_nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[max_square_index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max_square_index; ++i) &#123;</span><br><span class="line">      square_nums[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; max_square_index; ++s) &#123;</span><br><span class="line">        <span class="comment">//为了使dp[i - square_nums[s]] 数组不越界</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; square_nums[s])</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n<em>n^1/2) ，在主步骤中，我们有一个嵌套循环，其中外部循环是 *n</em> 次迭代，而内部循环最多需要 n^1/2  迭代。</li><li>空间复杂度：O(n) ，使用了一个一维数组 dp。</li></ul><h1 id="方法三：贪心枚举"><a href="#方法三：贪心枚举" class="headerlink" title="方法三：贪心枚举"></a>方法三：贪心枚举</h1><p>递归解决方法为我们理解问题提供了简洁直观的方法。我们仍然可以用递归解决这个问题。为了改进上述暴力枚举解决方案，我们可以在递归中加入贪心。我们可以将枚举重新格式化如下：</p><p>从一个数字到多个数字的组合开始，一旦我们找到一个可以组合成给定数字 <code>n</code> 的组合，那么我们可以说我们找到了最小的组合，因为我们贪心的从小到大的枚举组合。</p><p>为了更好的解释，我们首先定义一个名为 <code>is_divided_by(n, count)</code> 的函数，该函数返回一个布尔值，表示数字 <code>n</code> 是否可以被一个数字 <code>count</code> 组合，而不是像前面函数 <code>numSquares(n)</code> 返回组合的确切大小。</p><p> <code>numSquares(n)=argmin(is_divided_by(n,count)  count∈[1,2,...,n]</code></p><p>与递归函数 <code>numSquare(n)</code> 不同，<code>is_divided_by(n, count)</code> 的递归过程可以归结为底部情况（即 <code>count==1</code>）更快。</p><p>下面是一个关于函数 <code>is_divided_by(n, count)</code> 的例子，它对 输入 <code>n=5</code> 和 <code>count=2</code> 进行了分解。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9ncmVlZHkucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>通过这种重新构造的技巧，我们可以显著降低堆栈溢出的风险。</p><p><strong>算法：</strong></p><ul><li>首先，我们准备一个小于给定数字 <code>n</code> 的完全平方数列表（称为 <code>square_nums</code>）。</li><li>在主循环中，将组合的大小（称为 <code>count</code>）从 <code>1</code> 迭代到 <code>n</code>，我们检查数字 <code>n</code> 是否可以除以组合的和，即 <code>is_divided_by(n, count)</code>。</li><li>函数 <code>is_divided_by(n, count)</code> 可以用递归的形式实现，汝上面所说。</li><li>在最下面的例子中，我们有 <code>count==1</code>，我们只需检查数字 <code>n</code> 是否本身是一个完全平方数。可以在 <code>square_nums</code> 中检查，即 <code>n ∈ square_nums</code> 。如果 <code>square_nums</code> 使用的是集合数据结构，我们可以获得比 <code>n == int(sqrt(n)) ^ 2</code> 更快的运行时间。</li></ul><p>关于算法的正确性，通常情况下，我们可以用反证法来证明贪心算法。这也不例外。假设我们发现 <code>count=m</code> 可以除以 <code>n</code>，并且假设在以后的迭代中存在另一个 <code>count=p</code> 也可以除以 <code>n</code>，并且这个数的组合小于找到的数，即 <code>p&lt;m</code>。如果给定迭代的顺序，<code>count = p</code> 会在 <code>count=m</code> 之前被发现，因此，该算法总是能够找到组合的最小大小。</p><p>下面是一些示例实现。Python 解决方案需要大约 70ms，这比当时大约 90% 的提交要快。</p><details>    <summary>贪心枚举Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_divided_by</span><span class="params">(n, count)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">                return: true if "n" can be decomposed into "count" number of perfect square numbers.</span></span><br><span class="line"><span class="string">                e.g. n=12, count=3:  true.</span></span><br><span class="line"><span class="string">                     n=12, count=2:  false</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> n <span class="keyword">in</span> square_nums</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> square_nums:</span><br><span class="line">                <span class="keyword">if</span> is_divided_by(n - k, count - <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        square_nums = set([i * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>)])</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> count <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> is_divided_by(n, count):</span><br><span class="line">                <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心枚举Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  Set&lt;Integer&gt; square_nums = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">is_divided_by</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> square_nums.contains(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer square : square_nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (is_divided_by(n - square, count - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.square_nums.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">this</span>.square_nums.add(i * i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; count &lt;= n; ++count) &#123;</span><br><span class="line">      <span class="keyword">if</span> (is_divided_by(n, count))</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>参见<a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="方法四：贪心-BFS（广度优先搜索）"><a href="#方法四：贪心-BFS（广度优先搜索）" class="headerlink" title="方法四：贪心 + BFS（广度优先搜索）"></a>方法四：贪心 + BFS（广度优先搜索）</h1><p>正如上述贪心算法的复杂性分析种提到的，调用堆栈的轨迹形成一颗 N 元树，其中每个结点代表 <code>is_divided_by(n, count)</code> 函数的调用。基于上述想法，我们可以把原来的问题重新表述如下：</p><p>给定一个 N 元树，其中每个节点表示数字 n 的余数减去一个完全平方数的组合，我们的任务是在树中找到一个节点，该节点满足两个条件：</p><p>(1) 节点的值（即余数）也是一个完全平方数。<br>(2) 在满足条件（1）的所有节点中，节点和根之间的距离应该最小。</p><p>下面是这棵树的样子。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9ncmVlZHlfdHJlZS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>在前面的方法3中，由于我们执行调用的贪心策略，我们实际上是从上到下逐层构造 N 元树。我们以 BFS（广度优先搜索）的方式遍历它。在 N 元树的每一级，我们都在枚举相同大小的组合。</p><p>遍历的顺序是 BFS，而不是 DFS（深度优先搜索），这是因为在用尽固定数量的完全平方数分解数字 n 的所有可能性之前，我们不会探索任何需要更多元素的潜在组合。</p><p><strong>算法：</strong></p><ul><li>首先，我们准备小于给定数字 <code>n</code> 的完全平方数列表（即 <code>square_nums</code>）。</li><li>然后创建 <code>queue</code> 遍历，该变量将保存所有剩余项在每个级别的枚举。</li><li>在主循环中，我们迭代 <code>queue</code> 变量。在每次迭代中，我们检查余数是否是一个完全平方数。如果余数不是一个完全平方数，就用其中一个完全平方数减去它，得到一个新余数，然后将新余数添加到 <code>next_queue</code> 中，以进行下一级的迭代。一旦遇到一个完全平方数的余数，我们就会跳出循环，这也意味着我们找到了解。</li></ul><p>注意：在典型的 BFS 算法中，<code>queue</code> 变量通常是数组或列表类型。但是，这里我们使用 <code>set</code> 类型，以消除同一级别中的剩余项的冗余。事实证明，这个小技巧甚至可以增加 5 倍的运行加速。</p><p>在下图中，我们以 <code>numSquares(7)</code> 为例说明队列的布局。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9ncmVlZHlfYmZzLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><details>    <summary>贪心 + BFS（广度优先搜索）Python</summary><figure class="highlight python"><figcaption><span>[solution4-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># list of square numbers that are less than `n`</span></span><br><span class="line">        square_nums = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        queue = &#123;n&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            <span class="comment">#! Important: use set() instead of list() to eliminate the redundancy,</span></span><br><span class="line">            <span class="comment"># which would even provide a 5-times speedup, 200ms vs. 1000ms.</span></span><br><span class="line">            next_queue = set()</span><br><span class="line">            <span class="comment"># construct the queue for the next level</span></span><br><span class="line">            <span class="keyword">for</span> remainder <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">for</span> square_num <span class="keyword">in</span> square_nums:    </span><br><span class="line">                    <span class="keyword">if</span> remainder == square_num:</span><br><span class="line">                        <span class="keyword">return</span> level  <span class="comment"># find the node!</span></span><br><span class="line">                    <span class="keyword">elif</span> remainder &lt; square_num:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        next_queue.add(remainder - square_num)</span><br><span class="line">            queue = next_queue</span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心 + BFS（广度优先搜索）Java</summary><figure class="highlight java"><figcaption><span>[solution4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; square_nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">      square_nums.add(i * i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; queue = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    queue.add(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      level += <span class="number">1</span>;</span><br><span class="line">      Set&lt;Integer&gt; next_queue = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Integer remainder : queue) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer square : square_nums) &#123;</span><br><span class="line">          <span class="keyword">if</span> (remainder.equals(square)) &#123;</span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remainder &lt; square) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next_queue.add(remainder - square);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      queue = next_queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>参见<a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><h1 id="方法五：数学运算"><a href="#方法五：数学运算" class="headerlink" title="方法五：数学运算"></a>方法五：数学运算</h1><p>参见<a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p>随着时间的推移，已经提出并证明的数学定理可以解决这个问题。在这一节中，我们将把这个问题分成几个例子。</p><p>1770 年，<a href="https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem" target="_blank" rel="noopener">Joseph Louis Lagrange</a>证明了一个定理，称为四平方和定理，也称为 Bachet 猜想，它指出每个自然数都可以表示为四个整数平方和：</p><p><em>p=a_{0}^{2}+a_{1}^{2}+a_{2}^{2}+a_{3}^{2}</em></p><p>其中 <em>a_{0},a_{1},a_{2},a_{3}</em> 表示整数。</p><p>例如，3，31 可以被表示为四平方和如下：<br><img src="./p__3=1%5E%7B2%7D+1%5E%7B2%7D+1%5E%7B2%7D+0%5E%7B2%7D_qquad_31=5%5E%7B2%7D+2%5E%7B2%7D+1%5E%7B2%7D+1%5E%7B2%7D_.png" alt="3=1^{2}+1^{2}+1^{2}+0^{2}\qquad31=5^{2}+2^{2}+1^{2}+1^{2} "> </p><p>情况 1：拉格朗日四平方定理设置了问题结果的上界，即如果数 <code>n</code> 不能分解为较少的完全平方数，则至少可以分解为 4个完全平方数之和，即 <img src="./p__text%7BnumSquares%7D_n__le_4_.png" alt="\text{numSquares}(n)\le4 "> 。</p><p>正如我们在上面的例子中可能注意到的，数字 0 也被认为是一个完全平方数，因此我们可以认为数字 3 可以分解为 3 个或  4 个完全平方数。</p><p>然而，拉格朗日四平方定理并没有直接告诉我们用最小平方数来分解自然数。</p><p>后来，在 1797 年，<a href="https://en.wikipedia.org/wiki/Adrien-Marie_Legendre" target="_blank" rel="noopener">Adrien Marie Legendre</a>用他的三平方定理完成了四平方定理，证明了正整数可以表示为三个平方和的一个特殊条件：</p><p><img src="./p__n_ne_4%5E%7Bk%7D_8m+7__iff_n_=_a_%7B0%7D%5E%7B2%7D+a_%7B1%7D%5E%7B2%7D+a_%7B2%7D%5E%7B2%7D_.png" alt="n\ne4^{k}(8m+7)\iffn=a_{0}^{2}+a_{1}^{2}+a_{2}^{2} "> </p><p>其中 <em>k</em> 和 <em>m</em> 是整数。</p><p>情况 2：与四平方定理不同，Adrien-Marie-Legendre 的三平方定理给了我们一个充分必要的条件来检验这个数是否只能分解成 4 个平方。</p><p>从三平方定理看我们在第 2 种情况下得出的结论可能很难。让我们详细说明一下推论过程。</p><p>首先，三平方定理告诉我们，如果 <code>n</code> 的形式是 <em>n = 4^{k}(8m+7)</em>，那么 <code>n</code> 不能分解为 3 个平方的和。此外，我们还可以断言 <code>n</code> 不能分解为两个平方和，数本身也不是完全平方数。因为假设数 <code>n</code> 可以分解为 <em>n = a_{0}^{2}+a_{1}^{2}</em>，然后通过在表达式中添加平方数 0，即 <em>n = a_{0}^{2}+a_{1}^{2} + 0^2</em>，我们得到了数 <code>n</code> 可以分解为 3 个平方的结论，这与三平方定理相矛盾。因此，结合四平方定理，我们可以断言，如果这个数不满足三平方定理的条件，它只能分解成四个平方和。</p><p>如果这个数满足三平方定理的条件，则可以分解成三个完全平方数。但我们不知道的是，如果这个数可以分解成更少的完全平方数，即一个或两个完全平方数。</p><p>所以在我们把这个数视为底部情况（三平方定理）之前，还有两种情况需要检查，即：</p><p>情况 3.1：如果数字本身是一个完全平方数，这很容易检查，例如 <code>n == int(sqrt(n)) ^ 2</code>。</p><p>情况 3.2：如果这个数可以分解成两个完全平方数和。不幸的是，没有任何数学定理可以帮助我们检查这个情况。我们需要使用枚举方法。</p><p><strong>算法：</strong></p><p>可以按照上面的例子来实现解决方案。</p><ul><li>首先，我们检查数字 <code>n</code> 的形式是否为 <em>n = 4^{k}(8m+7)</em>，如果是，则直接返回 4。</li><li>否则，我们进一步检查这个数本身是否是一个完全平方数，或者这个数是否可以分解为两个完全平方数和。</li><li>在底部的情况下，这个数可以分解为 3 个平方和，但我们也可以根据四平方定理，通过加零，把它分解为 4 个平方。但是我们被要求找出最小的平方数。</li></ul><details>    <summary>数学运算Python</summary><figure class="highlight python"><figcaption><span>[solution5-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSquare</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        sq = int(math.sqrt(n))</span><br><span class="line">        <span class="keyword">return</span> sq*sq == n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># four-square and three-square theorems</span></span><br><span class="line">        <span class="keyword">while</span> (n &amp; <span class="number">3</span>) == <span class="number">0</span>:</span><br><span class="line">            n &gt;&gt;= <span class="number">2</span>      <span class="comment"># reducing the 4^k factor from number</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">7</span>) == <span class="number">7</span>: <span class="comment"># mod 8</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.isSquare(n):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># check if the number can be decomposed into sum of two squares</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(n**(<span class="number">0.5</span>)) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.isSquare(n - i*i):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="comment"># bottom case from the three-square theorem</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></details><details>    <summary>数学运算Java</summary><figure class="highlight java"><figcaption><span>[solution5-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isSquare</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sq = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    <span class="keyword">return</span> n == sq * sq;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// four-square and three-square theorems.</span></span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">      n /= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">8</span> == <span class="number">7</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isSquare(n))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// enumeration to check if the number can be decomposed into sum of two squares.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isSquare(n - i * i))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bottom case of three-square theorem.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>参见<a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>337. 打家劫舍III</title>
    <link href="http://yoursite.com/2020/09/03/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/"/>
    <id>http://yoursite.com/2020/09/03/337. 打家劫舍III/</id>
    <published>2020-09-03T09:08:12.000Z</published>
    <updated>2020-09-03T10:29:43.500Z</updated>
    
    <content type="html"><![CDATA[<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><a id="more"></a><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>示例 1:</p><pre><code>输入: [3,2,3,null,3,null,1]     3    / \   2   3    \   \      3   1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</code></pre><p>示例 2:</p><pre><code>输入: [3,4,5,1,3,null,1]     3    / \   4   5  / \   \  1   3   1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</code></pre><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p><strong>思路与算法</strong></p><p>简化一下这个问题：一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。</p><p>我们可以用 <em>f(o)</em> 表示选择 <em>o</em> 节点的情况下，<em>o</em> 节点的子树上被选择的节点的最大权值和；<em>g(o)</em> 表示不选择 <em>o</em> 节点的情况下，<em>o</em> 节点的子树上被选择的节点的最大权值和；<em>l</em> 和 <em>r</em> 代表 <em>o</em> 的左右孩子。</p><ul><li>当 <em>o</em> 被选中时，<em>o</em> 的左右孩子都不能被选中，故 <em>o</em> 被选中情况下子树上被选中点的最大权值和为 <em>l</em> 和 <em>r</em> 不被选中的最大权值和相加，即 <em>f(o) = g(l) + g(r)</em>。</li><li>当 <em>o</em> 不被选中时，<em>o</em> 的左右孩子可以被选中，也可以不被选中。对于 <em>o</em> 的某个具体的孩子 <em>x</em>，它对 <em>o</em> 的贡献是 <em>x</em> 被选中和不被选中情况下权值和的较大值。故<code>g(o)=max{f(l),g(l)}+max{f(r),g(r)}</code>。</li></ul><p>至此，我们可以用哈希映射来存 <em>f</em> 和 <em>g</em> 的函数值，用深度优先搜索的办法后序遍历这棵二叉树，我们就可以得到每一个节点的 <em>f</em> 和 <em>g</em>。根节点的 <em>f</em> 和 <em>g</em> 的最大值就是我们要找的答案。</p><p>我们不难给出这样的实现：</p><details>    <summary>动态规划C++</summary><figure class="highlight cpp"><figcaption><span>[sol0-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode*, <span class="keyword">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(o-&gt;left);</span><br><span class="line">        dfs(o-&gt;right);</span><br><span class="line">        f[o] = o-&gt;val + g[o-&gt;left] + g[o-&gt;right];</span><br><span class="line">        g[o] = max(f[o-&gt;left], g[o-&gt;left]) + max(f[o-&gt;right], g[o-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        dfs(o);</span><br><span class="line">        <span class="keyword">return</span> max(f[o], g[o]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol0-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; f = <span class="keyword">new</span> HashMap&lt;TreeNode, Integer&gt;();</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; g = <span class="keyword">new</span> HashMap&lt;TreeNode, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(f.getOrDefault(root, <span class="number">0</span>), g.getOrDefault(root, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        dfs(node.right);</span><br><span class="line">        f.put(node, node.val + g.getOrDefault(node.left, <span class="number">0</span>) + g.getOrDefault(node.right, <span class="number">0</span>));</span><br><span class="line">        g.put(node, Math.max(f.getOrDefault(node.left, <span class="number">0</span>), g.getOrDefault(node.left, <span class="number">0</span>)) + Math.max(f.getOrDefault(node.right, <span class="number">0</span>), g.getOrDefault(node.right, <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol0-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> g = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        dfs(node.right);</span><br><span class="line">        f.set(node, node.val + (g.get(node.left) || <span class="number">0</span>) + (g.get(node.right) || <span class="number">0</span>));</span><br><span class="line">        g.set(node, <span class="built_in">Math</span>.max(f.get(node.left) || <span class="number">0</span>, g.get(node.left) || <span class="number">0</span>) + <span class="built_in">Math</span>.max(f.get(node.right) || <span class="number">0</span>, g.get(node.right) || <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(f.get(root) || <span class="number">0</span>, g.get(root) || <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>假设二叉树的节点个数为 <em>n</em>。</p><p>我们可以看出，以上的算法对二叉树做了一次后序遍历，时间复杂度是 <em>O(n)</em>；由于递归会使用到栈空间，空间代价是 <em>O(n)</em>，哈希映射的空间代价也是 <em>O(n)</em>，故空间复杂度也是 <em>O(n)</em>。</p><p>我们可以做一个小小的优化，我们发现无论是 <em>f(o)</em> 还是 <em>g(o)<em>，他们最终的值只和 *f(l)</em>、<em>g(l)</em>、<em>f(r)</em>、*g(r)</em> 有关，所以对于每个节点，我们只关心它的孩子节点们的 <em>f</em> 和 <em>g</em> 是多少。我们可以设计一个结构，表示某个节点的 <em>f</em> 和 <em>g</em> 值，在每次递归返回的时候，都把这个点对应的 <em>f</em> 和 <em>g</em> 返回给上一级调用，这样可以省去哈希映射的空间。</p><p>代码如下。</p><p><strong>代码</strong></p><details>    <summary>动态规划C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubtreeStatus</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> selected;</span><br><span class="line">    <span class="keyword">int</span> notSelected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SubtreeStatus <span class="title">dfs</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l = dfs(o-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = dfs(o-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> selected = o-&gt;val + l.notSelected + r.notSelected;</span><br><span class="line">        <span class="keyword">int</span> notSelected = max(l.selected, l.notSelected) + max(r.selected, r.notSelected);</span><br><span class="line">        <span class="keyword">return</span> &#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rootStatus = dfs(o);</span><br><span class="line">        <span class="keyword">return</span> max(rootStatus.selected, rootStatus.notSelected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rootStatus = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rootStatus[<span class="number">0</span>], rootStatus[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dfs(TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(node.right);</span><br><span class="line">        <span class="keyword">int</span> selected = node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> l = dfs(node.left);</span><br><span class="line">        <span class="keyword">const</span> r = dfs(node.right);</span><br><span class="line">        <span class="keyword">const</span> selected = node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> notSelected = <span class="built_in">Math</span>.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + <span class="built_in">Math</span>.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> [selected, notSelected];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> rootStatus = dfs(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(rootStatus[<span class="number">0</span>], rootStatus[<span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    val := dfs(root)</span><br><span class="line">    <span class="keyword">return</span> max(val[<span class="number">0</span>], val[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l, r := dfs(node.Left), dfs(node.Right)</span><br><span class="line">    selected := node.Val + l[<span class="number">1</span>] + r[<span class="number">1</span>]</span><br><span class="line">    notSelected := max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + max(r[<span class="number">0</span>], r[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;selected, notSelected&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubtreeStatus</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> selected;</span><br><span class="line">    <span class="keyword">int</span> notSelected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct SubtreeStatus <span class="title">dfs</span><span class="params">(struct TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> (struct SubtreeStatus)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SubtreeStatus</span> <span class="title">l</span> = <span class="title">dfs</span>(<span class="title">root</span>-&gt;<span class="title">left</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SubtreeStatus</span> <span class="title">r</span> = <span class="title">dfs</span>(<span class="title">root</span>-&gt;<span class="title">right</span>);</span></span><br><span class="line">    <span class="keyword">int</span> selected = root-&gt;val + l.notSelected + r.notSelected;</span><br><span class="line">    <span class="keyword">int</span> notSelected = fmax(l.selected, l.notSelected) + fmax(r.selected, r.notSelected);</span><br><span class="line">    <span class="keyword">return</span> (struct SubtreeStatus)&#123;selected, notSelected&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(struct TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SubtreeStatus</span> <span class="title">rootStatus</span> = <span class="title">dfs</span>(<span class="title">root</span>);</span></span><br><span class="line">    <span class="keyword">return</span> fmax(rootStatus.selected, rootStatus.notSelected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)</em>。上文中已分析。</li><li>空间复杂度：<em>O(n)</em>。虽然优化过的版本省去了哈希映射的空间，但是栈空间的使用代价依旧是 <em>O(n)</em>，故空间复杂度不变。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>213. 打家劫舍II</title>
    <link href="http://yoursite.com/2020/09/03/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/"/>
    <id>http://yoursite.com/2020/09/03/213. 打家劫舍II/</id>
    <published>2020-09-03T08:57:12.000Z</published>
    <updated>2020-09-03T09:07:32.382Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><a id="more"></a><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><pre><code>输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</code></pre><p>示例 2:</p><pre><code>输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><h2 id="总体思路："><a href="#总体思路：" class="headerlink" title="总体思路："></a>总体思路：</h2><ul><li><p><strong>此题是 <a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/" target="_blank" rel="noopener">198. 打家劫舍</a> 的拓展版：</strong> 唯一的区别是此题中的房间是<strong>环状排列</strong>的（即首尾相接），而 <em>198.</em> 题中的房间是<strong>单排排列</strong>的；而这也是此题的难点。</p></li><li><p><strong>环状排列</strong>意味着第一个房子和最后一个房子中<strong>只能选择一个偷窃</strong>，因此可以把此<strong>环状排列房间</strong>问题约化为两个<strong>单排排列房间</strong>子问题：</p><ol><li>在不偷窃第一个房子的情况下（即 <em>nums[1:]*），最大金额是 *p_1</em> ；</li><li>在不偷窃最后一个房子的情况下（即 <em>nums[:n-1]*），最大金额是 *p_2</em> 。</li></ol><ul><li><strong>综合偷窃最大金额：</strong> 为以上两种情况的较大值，即 <em>max(p1,p2)</em> 。</li></ul></li><li><p>下面的任务则是解决 <strong>单排排列房间（即 <a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/" target="_blank" rel="noopener">198. 打家劫舍</a>）</strong> 问题。推荐可以先把 <em>198.</em> 做完再做这道题。</p></li></ul><h2 id="198-解题思路："><a href="#198-解题思路：" class="headerlink" title="198. 解题思路："></a>198. 解题思路：</h2><p>典型的动态规划，以下按照标准流程解题。</p><ul><li><strong>状态定义：</strong><ul><li>设动态规划列表 <em>dp</em> ，<em>dp[i]</em> 代表前 <em>i</em> 个房子在满足条件下的能偷窃到的最高金额。</li></ul></li><li><strong>转移方程：</strong><ul><li><strong>设：</strong> 有 <em>n</em> 个房子，前 <em>n</em> 间能偷窃到的最高金额是 <em>dp[n]</em> ，前 <em>n-1</em> 间能偷窃到的最高金额是 <em>dp[n-1]</em> ，此时向这些房子后加一间房，此房间价值为 <em>num</em> ；</li><li><strong>加一间房间后：</strong> 由于不能抢相邻的房子，意味着抢第 <em>n+1</em> 间就不能抢第 <em>n</em> 间；那么前 <em>n+1</em> 间房能偷取到的最高金额 <em>dp[n+1]</em> 一定是以下两种情况的 <strong>较大值</strong> ：<ol><li>不抢第 <em>n+1</em> 个房间，因此等于前 <em>n</em> 个房子的最高金额，即 <em>dp[n+1] = dp[n]</em> ；</li><li>抢第 <em>n+1</em> 个房间，此时不能抢第 <em>n</em> 个房间；因此等于前 <em>n-1</em> 个房子的最高金额加上当前房间价值，即 <em>dp[n+1] = dp[n-1] + num</em> ；</li></ol></li><li><strong>细心的我们发现：</strong> 难道在前 <em>n</em> 间的最高金额 <em>dp[n]</em> 情况下，第 <em>n</em> 间一定被偷了吗？假设没有被偷，那 <em>n+1</em> 间的最大值应该也可能是  <em>dp[n+1] = dp[n] + num</em> 吧？其实这种假设的情况可以被省略，这是因为：<ol><li>假设第 <em>n</em> 间没有被偷，那么此时 <em>dp[n] = dp[n-1]</em> ，此时 <em>dp[n+1] = dp[n] + num = dp[n-1] + num</em> ，即可以将 <strong>两种情况合并为一种情况</strong> 考虑；</li><li>假设第 <em>n</em> 间被偷，那么此时 <em>dp[n+1] = dp[n] + num</em> <strong>不可取</strong> ，因为偷了第 <em>n</em> 间就不能偷第 <em>n+1</em> 间。</li></ol></li><li><strong>最终的转移方程：</strong> <em>dp[n+1] = max(dp[n],dp[n-1]+num)</em></li></ul></li><li><strong>初始状态：</strong><ul><li>前 <em>0</em> 间房子的最大偷窃价值为 <em>0</em> ，即 <em>dp[0] = 0</em> 。</li></ul></li><li><strong>返回值：</strong><ul><li>返回 <em>dp</em> 列表最后一个元素值，即所有房间的最大偷窃价值。</li></ul></li><li><strong>简化空间复杂度：</strong><ul><li>我们发现 <em>dp[n]</em> 只与 <em>dp[n-1]</em> 和 <em>dp[n-2]</em> 有关系，因此我们可以设两个变量 <code>cur</code>和 <code>pre</code> 交替记录，将空间复杂度降到 <em>O(1)</em> 。</li></ul></li></ul><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul><li><p><strong>时间复杂度 <em>O(N)</em> ：</strong> 两次遍历 <code>nums</code> 需要线性时间；</p></li><li><p><strong>空间复杂度 <em>O(1)</em> ：</strong> <code>cur</code>和 <code>pre</code> 使用常数大小的额外空间。</p><p><a href="https://pic.leetcode-cn.com/ae512395fc10a22fdc4e22e2fcab394c3321eac42d8d1f28b306fefe1fa43b11-Picture1.png" target="_blank" rel="noopener">Picture1.png</a> <a href="https://pic.leetcode-cn.com/8c0542b663c975914a70e9d4c5753e50c00b10272846118f2c8f21717a5db639-Picture2.png" target="_blank" rel="noopener">Picture2.png</a> <a href="https://pic.leetcode-cn.com/0c802bf6ed5137d747794b406ee97d3b49772bf0c14e044914f86b01a72b9a94-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/cf6e6cab02fb996d9e6b77972758f4ff5ca9a0163c5224fd4b5d50778101f1a0-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> <a href="https://pic.leetcode-cn.com/e5b4e986b1e815760226205fbb4aaa4aedace195c4b29e84cc0138b374605798-Picture5.png" target="_blank" rel="noopener">Picture5.png</a> <a href="https://pic.leetcode-cn.com/34e1af2897fda8d541a93cb79072e250feca60691dfa0a46150082ebf79603c1-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/b466bb392ca7bdef75cfaeae18dcbcd8722ad08e913c43dbcbac83fa9868b8f9-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/7e645390e53efb4f7754ac218875bd5fa3c639da577eedb24b198d7b50b4ac5a-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> </p></li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>动态规划python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">my_rob</span><span class="params">(nums)</span>:</span></span><br><span class="line">            cur, pre = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                cur, pre = max(pre + num, cur), cur</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> max(my_rob(nums[:<span class="number">-1</span>]),my_rob(nums[<span class="number">1</span>:])) <span class="keyword">if</span> len(nums) != <span class="number">1</span> <span class="keyword">else</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(myRob(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>)), </span><br><span class="line">                        myRob(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">myRob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>, tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = Math.max(pre + num, cur);</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这种方法注意数组长度仅为2时拆分后不要数组越界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>198. 打家劫舍</title>
    <link href="http://yoursite.com/2020/09/03/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://yoursite.com/2020/09/03/198. 打家劫舍/</id>
    <published>2020-09-03T07:57:12.000Z</published>
    <updated>2020-09-03T11:39:33.665Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><a id="more"></a><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><pre><code>输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p>示例 2：</p><pre><code>输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><p>提示：</p><pre><code>0 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 400</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="0c807bbf-a976-48e3-8db5-cfbe7a9c80d7">198.打家劫舍.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：动态规划-滚动数组"><a href="#方法一：动态规划-滚动数组" class="headerlink" title="方法一：动态规划 + 滚动数组"></a>方法一：动态规划 + 滚动数组</h2><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 <em>k~(k&gt;2)</em> 间房屋，有两个选项：</p><ol><li><p>偷窃第 <em>k</em> 间房屋，那么就不能偷窃第 <em>k-1</em> 间房屋，偷窃总金额为前 <em>k-2</em> 间房屋的最高总金额与第 <em>k</em> 间房屋的金额之和。</p></li><li><p>不偷窃第 <em>k</em> 间房屋，偷窃总金额为前 <em>k-1</em> 间房屋的最高总金额。</p></li></ol><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 <em>k</em> 间房屋能偷窃到的最高总金额。</p><p>用 <em>dp[i]</em> 表示前 <em>i</em> 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><pre><code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</code></pre><p>边界条件为：</p><pre><code>dp[0]=nums[0]       只有一间房屋，则偷窃该房屋dp[1]=max(nums[0],nums[1])  只有两间房屋，选择其中金额较高的房屋进行偷窃</code></pre><p>最终的答案即为dp[n-1] ，其中 <em>n</em> 是数组的长度。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/198/1.PNG" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/198/2.PNG" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/198/3.PNG" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/198/4.PNG" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/198/5.PNG" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/198/6.PNG" target="_blank" rel="noopener">fig6</a> </p><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * size</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, size):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-2</span>] + nums[i], dp[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p><details>    <summary>动态规划 + 滚动数组Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 滚动数组C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>], second = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 滚动数组Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        first, second = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, size):</span><br><span class="line">            first, second = second, max(first + nums[i], second)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 滚动数组golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    first := nums[<span class="number">0</span>]</span><br><span class="line">    second := max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        first, second = second, max(first + nums[i], second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组长度。只需要对数组遍历一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 <em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年9月" scheme="http://yoursite.com/categories/2020%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>124. 二叉树中的最大路径和</title>
    <link href="http://yoursite.com/2020/08/31/124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yoursite.com/2020/08/31/124. 二叉树中的最大路径和/</id>
    <published>2020-08-31T07:20:12.000Z</published>
    <updated>2020-08-31T08:28:38.431Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空二叉树，返回其最大路径和。</p><a id="more"></a><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>示例 1:</p><pre><code>输入: [1,2,3]       1      / \     2   3输出: 6</code></pre><p>示例 2:</p><pre><code>输入: [-10,9,20,null,null,15,7]   -10   / \  9  20    /  \   15   7输出: 42</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="0fc716bb-576b-482f-8ec4-a1659b427b4f">124. 二叉树中的最大路径.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><p>首先，考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p><p>具体而言，该函数的计算如下。</p><ul><li><p>空节点的最大贡献值等于 <em>0</em>。</p></li><li><p>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</p></li></ul><p>例如，考虑如下二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> -10</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>叶节点 <em>9</em>、<em>15<em>、</em>7</em> 的最大贡献值分别为 <em>9</em>、<em>15</em>、<em>7</em>。</p><p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 <em>20</em> 的最大贡献值等于 20+max(15,7)=35，节点 <em>-10</em> 的最大贡献值等于-10+max(9,35)=25  。</p><p>上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p><p>根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/124/1.PNG" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/124/2.PNG" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/124/3.PNG" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/124/4.PNG" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/124/5.PNG" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/124/6.PNG" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/124/7.PNG" target="_blank" rel="noopener">fig7</a> </p><p>这题目的难点在于理解题意和转化题意。<br>我们可以结合 数组的最大子数组和 的思路去解题。</p><ol><li><p>「可以从任意节点出发, 到达任意节点」 的路径,<br>一定是先上升（ 0 ～ n 个）节点, 到达顶点, 后下降（ 0 ～ n 个）节点。<br>我们可以通过枚举顶点的方式来枚举路径。</p></li><li><p>我们枚举顶点时, 可以把路径分拆成3部分： 左侧路径、右侧路径和顶点。</p><pre><code> 如下面的路径, 顶点为 20, 左侧路径为 6 -&gt; 15, 右侧为 6 -&gt; 7。   -10   / \  9 [20]    /  \  [15] [7]  /    / \[6]   4  [6]   </code></pre><p>以当前节点为顶点的路径中, 最大和为 两侧路径的最大和 + 节点的值。<br>需要注意的是, 两侧路径也可能不选, 此时取 0。</p></li><li><p>如何求两侧路径最大和？ 看一个类似问题：求数组的最大子数组和。<br>动态规划： dp[i] 代表以 nums[i] 为结尾的子数组的最大和。<br>转移方程： dp[i] = max(dp[i-1], 0) + nums[i]。</p></li><li><p>在树上, 设 dp[C] 代表以当前节点为结尾的最大上升路径和,<br>则我们需要对节点的左右子树做一个选择, 有<br>dp[C] = max(max(dp[L], 0), max(dp[R], 0)) + C.val<br>式中, C,L,R 分别代指 当前节点、左子节点、右子节点。</p></li><li><p>最后, 以当前节点为顶点的路径中, 最大的和为<br>max(dp[L], 0) + max(dp[R], 0) + C.val。<br>我们枚举顶点, 并记录最大答案。</p></li></ol><details>    <summary>递归Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.maxSum = float(<span class="string">"-inf"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxGain</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归计算左右子节点的最大贡献值</span></span><br><span class="line">            <span class="comment"># 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">            leftGain = max(maxGain(node.left), <span class="number">0</span>)</span><br><span class="line">            rightGain = max(maxGain(node.right), <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">            priceNewpath = node.val + leftGain + rightGain</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新答案</span></span><br><span class="line">            self.maxSum = max(self.maxSum, priceNewpath)</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 返回节点的最大贡献值</span></span><br><span class="line">            <span class="keyword">return</span> node.val + max(leftGain, rightGain)</span><br><span class="line">   </span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> self.maxSum</span><br></pre></td></tr></table></figure></details><details>    <summary>递归C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = max(maxGain(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = max(maxGain(node-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node-&gt;val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxSum := math.MinInt32</span><br><span class="line">    <span class="keyword">var</span> maxGain <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">maxGain</span> = <span class="title">func</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        leftGain := max(maxGain(node.Left), <span class="number">0</span>)</span><br><span class="line">        rightGain := max(maxGain(node.Right), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        priceNewPath := node.Val + leftGain + rightGain</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = max(maxSum, priceNewPath)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.Val + max(leftGain, rightGain)</span><br><span class="line">    &#125;</span><br><span class="line">    maxGain(root)</span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="keyword">int</span>.MinValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxPathSum</span>(<span class="params">TreeNode root</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MaxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MaxGain</span>(<span class="params">TreeNode node</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = Math.Max(MaxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = Math.Max(MaxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.Max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.Max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是二叉树中的节点个数。对每个节点访问不超过 <em>2</em> 次。</p></li><li><p>空间复杂度：<em>O(N)*，其中 *N</em> 是二叉树中的节点个数。空间复杂度主要取决于递归调用层数，最大层数等于二叉树的高度，最坏情况下，二叉树的高度等于二叉树中的节点个数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空二叉树，返回其最大路径和。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="http://yoursite.com/2020/08/31/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/08/31/128. 最长连续序列/</id>
    <published>2020-08-31T07:20:12.000Z</published>
    <updated>2020-09-03T07:54:39.379Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><a id="more"></a><p>要求算法的时间复杂度为 O(n)。</p><p>示例:</p><pre><code>输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></pre><h1 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h1><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>排序</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max 最终结果, curr 当前长度, last 上个数字</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>, curr = <span class="number">1</span>, last = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == last) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == last + <span class="number">1</span>) curr++; <span class="comment">// 符合连续，长度 +1</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curr); <span class="comment">// 连不上了，记录长度</span></span><br><span class="line">            curr = <span class="number">1</span>; <span class="comment">// 重新开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        last = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, curr); <span class="comment">// 别忘了最后一段的连续区间</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>## 复杂度分析<ul><li>时间复杂度：<em>O(nlog(n))</em></li><li>空间复杂度：<em>O(1)</em><ul><li>副作用：影响原数组</li></ul></li></ul><hr><h1 id="方法二：集合"><a href="#方法二：集合" class="headerlink" title="方法二：集合"></a>方法二：集合</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用 <em>O(1)</em> 时间复杂度「查询是否有下一个」</li><li>优化：如果有比自己小一点的，那自己不查，让小的去查（详见代码）<ul><li>贪心思想？</li></ul></li></ul><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>集合</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length, max = <span class="number">1</span>;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) set.add(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) &#123;</span><br><span class="line">        <span class="comment">// 技巧：如果有比自己小一点的，那自己不查，让小的去查</span></span><br><span class="line">        <span class="keyword">if</span> (set.contains(v - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = v; <span class="comment">// r: right 表示「以 v 开头，能连续到多少」</span></span><br><span class="line">        <span class="keyword">while</span> (set.contains(r + <span class="number">1</span>)) r++; <span class="comment">// 逐个查看</span></span><br><span class="line">        max = Math.max(max, r - v + <span class="number">1</span>); <span class="comment">// 记录区间 [v, r] 长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>## 复杂度分析<ul><li>时间复杂度：<em>O(n)</em><ul><li>虽 <code>for</code> 内有 <code>while</code>，但每个元素最多被查 <code>2</code> 次</li><li>第一次在 <code>set.contains(v - 1)</code>，如元素 <code>5</code> 被 <code>6</code> 查</li><li>第二次在 <code>set.contains(r + 1)</code>，如元素 <code>5</code> 被 <code>4</code> 查</li></ul></li><li>空间复杂度：<em>O(n)</em></li></ul><hr><h1 id="方法三：哈希表"><a href="#方法三：哈希表" class="headerlink" title="方法三：哈希表"></a>方法三：哈希表</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>虽然代码结构与上述 「方法二：集合」十分相似，但思路由差异，值得提及</li><li>少了方法二的优化：只对小的执行查询</li><li>利用前面已知的右边界，快速找到当前需要的右边界（详见代码）<ul><li>记忆化</li></ul></li></ul><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>哈希表</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 记录区间 [v, r]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) map.put(v, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = v;</span><br><span class="line">        <span class="keyword">while</span> (map.containsKey(r + <span class="number">1</span>))</span><br><span class="line">            r = map.get(r + <span class="number">1</span>); <span class="comment">// 利用前面已知的右边界，快速找到当前需要的右边界</span></span><br><span class="line">        map.put(v, r);</span><br><span class="line">        max = Math.max(max, r - v + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>## 复杂度分析<ul><li>时间复杂度：<em>O(n)</em></li><li>空间复杂度：<em>O(n)</em></li></ul><hr><h1 id="方法四：并查集"><a href="#方法四：并查集" class="headerlink" title="方法四：并查集"></a>方法四：并查集</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>初始：所有元素各自为战</li><li>首次遍历：所有元素 <code>x</code> 向各自邻居 <code>x + 1</code>，发起结盟，并「以大者为领队」<ul><li>若有邻居，才结盟成功</li><li>领队，即 区间右边界</li><li>不只是元素 <code>x</code> 与邻居 <code>x + 1</code> 结盟，而是整个 <code>x</code> 所在队伍与整个 <code>x + 1</code> 所在队伍结盟<ul><li>如 <code>[1, 2, 3]</code> 与 <code>[4, 5]</code> 两个队伍结盟</li></ul></li></ul></li><li>二次遍历：记录所有人与其领队距离<ul><li>距离，即 区间右边界 - 当前元素 + 1</li></ul></li></ul><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>并查集</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首次遍历，与邻居结盟</span></span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums)</span><br><span class="line">        uf.union(v, v + <span class="number">1</span>); <span class="comment">// uf.union() 结盟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二次遍历，记录领队距离</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums)</span><br><span class="line">        max = Math.max(max, uf.find(v) - v + <span class="number">1</span>); <span class="comment">// uf.find() 查找领队</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>并查集定义，放在一起即可通过</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//还剩几支队伍</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; parent; <span class="comment">// (curr, leader)</span></span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        count = arr.length;</span><br><span class="line">        parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : arr)</span><br><span class="line">            parent.put(v, v); <span class="comment">// 初始时，各自为战，自己是自己的领队</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结盟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不只是 p 与 q 结盟，而是整个 p 所在队伍 与 q 所在队伍结盟</span></span><br><span class="line">        <span class="comment">// 结盟需各领队出面，而不是小弟出面</span></span><br><span class="line">        Integer rootP = find(p), rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rootP == <span class="keyword">null</span> || rootQ == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结盟</span></span><br><span class="line">        parent.put(rootP, rootQ); <span class="comment">// 谁大听谁</span></span><br><span class="line">        <span class="comment">// 应取 max，而本题已明确 p &lt; q 才可这么写</span></span><br><span class="line">        <span class="comment">// 当前写法有损封装性，算法题可不纠结</span></span><br><span class="line"></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找领队</span></span><br><span class="line">    <span class="function">Integer <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!parent.containsKey(p))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归向上找领队</span></span><br><span class="line">        <span class="keyword">int</span> root = p;</span><br><span class="line">        <span class="keyword">while</span> (root != parent.get(root))</span><br><span class="line">            root = parent.get(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 路径压缩：扁平化管理，避免日后找领队层级过深</span></span><br><span class="line">        <span class="keyword">while</span> (p != parent.get(p)) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = p;</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">            parent.put(curr, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>## 复杂度分析<ul><li>时间复杂度：<em>O(n)</em></li><li>空间复杂度：<em>O(n)</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>395. 至少有K个重复字符的最长子串</title>
    <link href="http://yoursite.com/2020/08/31/395.%20%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/08/31/395. 至少有K个重复字符的最长子串/</id>
    <published>2020-08-31T02:40:12.000Z</published>
    <updated>2020-08-31T07:17:03.148Z</updated>
    
    <content type="html"><![CDATA[<p>找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。</p><a id="more"></a><p>示例 1:</p><pre><code>输入:s = &quot;aaabb&quot;, k = 3输出:3</code></pre><p>最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。<br>示例 2:</p><pre><code>输入:s = &quot;ababbc&quot;, k = 2输出:5</code></pre><p>最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。</p><h1 id="Java递归"><a href="#Java递归" class="headerlink" title="Java递归"></a>Java递归</h1><p>解题思路：递归拆分子串，分治。先统计出每个字符出现的频次，维护一对双指针，从首尾开始统计，从首尾往中间排除，如果出现次数小于k则不可能出现在最终子串中，排除并挪动指针，然后得到临时子串，依次从头遍历，一旦发现出现频次小于k的字符，以该字符为分割线，分别递归求其最大值返回。</p><details>    <summary>递归</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestSubstring(String s, int k) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        if (len == 0 || k &gt; len) return 0;</span><br><span class="line">        if (k &lt; 2) return len;</span><br><span class="line"></span><br><span class="line">        return count(s.toCharArray(), k, 0, len - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int count(char[] chars, int k, int p1, int p2) &#123;</span><br><span class="line">        if (p2 - p1 + 1 &lt; k) return 0;</span><br><span class="line">        int[] times = new int[26];  //  26个字母</span><br><span class="line">        //  统计出现频次</span><br><span class="line">        for (int i = p1; i &lt;= p2; ++i) &#123;</span><br><span class="line">            ++times[chars[i] - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        //  如果该字符出现频次小于k，则不可能出现在结果子串中</span><br><span class="line">        //  分别排除，然后挪动两个指针</span><br><span class="line">        while (p2 - p1 + 1 &gt;= k &amp;&amp; times[chars[p1] - &apos;a&apos;] &lt; k) &#123;</span><br><span class="line">            ++p1;</span><br><span class="line">        &#125;</span><br><span class="line">        while (p2 - p1 + 1 &gt;= k &amp;&amp; times[chars[p2] - &apos;a&apos;] &lt; k) &#123;</span><br><span class="line">            --p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (p2 - p1 + 1 &lt; k) return 0;</span><br><span class="line">        //  得到临时子串，再递归处理</span><br><span class="line">        for (int i = p1; i &lt;= p2; ++i) &#123;</span><br><span class="line">            //  如果第i个不符合要求，切分成左右两段分别递归求得</span><br><span class="line">            if (times[chars[i] - &apos;a&apos;] &lt; k) &#123;</span><br><span class="line">                return Math.max(count(chars, k, p1, i - 1), count(chars, k, i + 1, p2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p2 - p1 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer51.数组中的逆序对</title>
    <link href="http://yoursite.com/2020/08/26/%E5%89%91%E6%8C%87%20offer51.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://yoursite.com/2020/08/26/剑指 offer51.数组中的逆序对/</id>
    <published>2020-08-26T07:15:12.000Z</published>
    <updated>2020-08-26T10:06:27.373Z</updated>
    
    <content type="html"><![CDATA[<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><a id="more"></a><p>示例 1: </p><pre><code>输入: [7,5,6,4]输出: 5 </code></pre><p> 限制： </p><p> 0 &lt;= 数组长度 &lt;= 50000</p><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="0a3b59f0-4902-4b35-b605-cf2ded591a8b">面试题 51. 数组中的逆序对.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：归并排序"><a href="#方法一：归并排序" class="headerlink" title="方法一：归并排序"></a>方法一：归并排序</h2><p><strong>预备知识</strong></p><p>「归并排序」是分治思想的典型应用，它包含这样三个步骤：</p><ul><li><strong>分解：</strong> 待排序的区间为 <em>[l, r]*，令m=(l+r)/2，我们把 *[l, r]</em> 分成 <em>[l, m]</em> 和 <em>[m + 1, r]</em></li><li><strong>解决：</strong> 使用归并排序递归地排序两个子序列</li><li><strong>合并：</strong> 把两个已经排好序的子序列 <em>[l, m]</em> 和 <em>[m + 1, r]</em> 合并起来</li></ul><p>在待排序序列长度为 <em>1</em> 的时候，递归开始「回升」，因为我们默认长度为 <em>1</em> 的序列是排好序的。</p><p><strong>思路</strong></p><p>那么求逆序对和归并排序又有什么关系呢？关键就在于「归并」当中「并」的过程。我们通过一个实例来看看。假设我们有两个已排序的序列等待合并，分别是 L={8,12,16,22,100} 和 R={9,26,55,64,91}。一开始我们用指针 <code>lPtr = 0</code> 指向 <em>L</em> 的首部，<code>rPtr = 0</code> 指向 <em>R</em> 的头部。记已经合并好的部分为 <em>M</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure><p>我们发现 <code>lPtr</code> 指向的元素小于 <code>rPtr</code> 指向的元素，于是把 <code>lPtr</code> 指向的元素放入答案，并把 <code>lPtr</code> 后移一位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure><p>这个时候我们把左边的 <em>8</em> 加入了答案，我们发现右边没有数比 <em>8</em> 小，所以 <em>8</em> 对逆序对总数的「贡献」为 <em>0</em>。</p><p>接着我们继续合并，把 <em>9</em> 加入了答案，此时 <code>lPtr</code> 指向 <em>12</em>，<code>rPtr</code> 指向 <em>26</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure><p>此时 <code>lPtr</code> 比 <code>rPtr</code> 小，把 <code>lPtr</code> 对应的数加入答案，并考虑它对逆序对总数的贡献为 <code>rPtr</code> 相对 <em>R</em> 首位置的偏移 <em>1</em>（即右边只有一个数比 <em>12</em> 小，所以只有它和 <em>12</em> 构成逆序对），以此类推。</p><p>我们发现用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 <code>lPtr</code> 右移的时候计算，是基于这样的事实：当前 <code>lPtr</code> 指向的数字比 <code>rPtr</code> 小，但是比 <em>R</em> 中 <code>[0 ... rPtr - 1]</code> 的其他数字大，<code>[0 ... rPtr - 1]</code> 的其他数字本应当排在 <code>lPtr</code> 对应数字的左边，但是它排在了右边，所以这里就贡献了 <code>rPtr</code> 个逆序对。</p><p>利用这个思路，我们可以写出如下代码。官方题解写的比较晦涩，我在Java版代码里换了一种相当容易理解的形式。</p><p><strong>代码</strong></p><details>    <summary>归并排序C++ </summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, pos = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[pos] = nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">                inv_count += (j - (mid + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[pos] = nums[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= mid; ++k) &#123;</span><br><span class="line">            tmp[pos++] = nums[k];</span><br><span class="line">            inv_count += (j - (mid + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt;= r; ++k) &#123;</span><br><span class="line">            tmp[pos++] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        copy(tmp.begin() + l, tmp.begin() + r + <span class="number">1</span>, nums.begin() + l);</span><br><span class="line">        <span class="keyword">return</span> inv_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(n);</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>归并排序Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, nums, tmp, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        inv_count = self.mergeSort(nums, tmp, l, mid) + self.mergeSort(nums, tmp, mid + <span class="number">1</span>, r)</span><br><span class="line">        i, j, pos = l, mid + <span class="number">1</span>, l</span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">                tmp[pos] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                inv_count += (j - (mid + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[pos] = nums[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(i, mid + <span class="number">1</span>):</span><br><span class="line">            tmp[pos] = nums[k]</span><br><span class="line">            inv_count += (j - (mid + <span class="number">1</span>))</span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(j, r + <span class="number">1</span>):</span><br><span class="line">            tmp[pos] = nums[k]</span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        nums[l:r+<span class="number">1</span>] = tmp[l:r+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> inv_count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        tmp = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(nums, tmp, <span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>归并排序Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePairs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := start + (end - start)/<span class="number">2</span></span><br><span class="line">    cnt := mergeSort(nums, start, mid) + mergeSort(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">    tmp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    i, j := start, mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= end &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j] &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, nums[i])</span><br><span class="line">            cnt += j - (mid + <span class="number">1</span>)</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, nums[j])</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt;= mid; i++ &#123;</span><br><span class="line">        tmp = <span class="built_in">append</span>(tmp, nums[i])</span><br><span class="line">        cnt += end - (mid + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; j &lt;= end; j++ &#123;</span><br><span class="line">        tmp = <span class="built_in">append</span>(tmp, nums[j])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">        nums[i] = tmp[i - start]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>归并排序java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeCount(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeCount</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span> || nums == <span class="keyword">null</span> || left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeCount(nums, left, mid);</span><br><span class="line">        mergeCount(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(nums, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nums[left..mid] 有序，nums[mid + 1..right] 有序，计算逆序对个数并且排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = help.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//保存中间的位置，因为后面mid的值会改变</span></span><br><span class="line">        <span class="keyword">int</span> temp = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (mid &gt;= left &amp;&amp; right &gt;= temp) &#123;</span><br><span class="line">            <span class="comment">//记录下当前两个有序数组中的逆序对个数</span></span><br><span class="line">            result = nums[mid] &gt; nums[right] ? result + right - temp+<span class="number">1</span> : result;</span><br><span class="line">            <span class="comment">//help数组里从右向左开始降序存储nums数组中的元素</span></span><br><span class="line">            help[p--] = nums[mid] &gt; nums[right] ? nums[mid--] : nums[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (mid &gt;= left) &#123;</span><br><span class="line">            help[p--] = nums[mid--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= temp) &#123;</span><br><span class="line">            help[p--] = nums[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//help数组存储的是两个合并后的有序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">            nums[left + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度**<p>记序列长度为 <em>n</em>。</p><ul><li>时间复杂度：同归并排序 O(nlogn) 。</li><li>空间复杂度：同归并排序 <em>O(n)</em>，因为归并排序需要用到一个临时数组。</li></ul><h2 id="方法二：离散化树状数组"><a href="#方法二：离散化树状数组" class="headerlink" title="方法二：离散化树状数组"></a>方法二：离散化树状数组</h2><p><strong>预备知识</strong></p><p>「树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：</p><ul><li><strong>单点更新 <code>update(i, v)</code>：</strong> 把序列 <em>i</em> 位置的数加上一个值 <em>v</em>，这题 <em>v = 1</em></li><li><strong>区间查询 <code>query(i)</code>：</strong> 查询序列[1,…,i] 区间的区间和，即 <em>i</em> 位置的前缀和</li></ul><p>修改和查询的时间代价都是 O(logn) ，其中 <em>n</em> 为需要维护前缀和的序列的长度。</p><p><strong>思路</strong></p><p>记题目给定的序列为 <em>a</em>，我们规定 <em>a_i</em> 的取值集合为 <em>a</em> 的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设a={5,5,2,3,6} ，那么遍历这个序列得到的桶是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index  -&gt;  1 2 3 4 5 6 7 8 9</span><br><span class="line">value  -&gt;  0 1 1 0 2 1 0 0 0</span><br></pre></td></tr></table></figure><p>我们可以看出它第 <em>i - 1</em> 位的前缀和表示「有多少个数比 <em>i</em> 小」。那么我们可以从后往前遍历序列 <em>a</em>，记当前遍历到的元素为 <em>a_i*，我们把 *a_i</em> 对应的桶的值自增 <em>1</em>，把 <em>i - 1</em> 位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的 <em>i - 1</em> 位置的前缀和就是「已入桶」的元素中比 <em>a_i</em> 小的元素的总和，而这些元素在原序列中排在 <em>a_i</em> 的后面，但它们本应该排在 <em>a_i</em> 的前面，这样就形成了逆序对。</p><p>我们显然可以用数组来实现这个桶，可问题是如果 <em>a_i</em> 中有很大的元素，比如 <em>10^9*，我们就要开一个大小为 *10^9</em> 的桶，内存中是存不下的。这个桶数组中很多位置是 <em>0</em>，有效位置是稀疏的，我们要想一个办法让有效的位置全聚集到一起，减少无效位置的出现，这个时候我们就需要用到一个方法——离散化。</p><p>离散化一个序列的前提是我们只关心这个序列里面元素的相对大小，而不关心绝对大小（即只关心元素在序列中的排名）；离散化的目的是让原来分布零散的值聚集到一起，减少空间浪费。那么如何获得元素排名呢，我们可以对原序列排序后去重，对于每一个 <em>a_i</em> 通过二分查找的方式计算排名作为离散化之后的值。当然这里也可以不去重，不影响排名。</p><p><strong>代码</strong></p><details>    <summary>离散化树状数组C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="keyword">int</span> _n): n(_n), tree(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ret += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">            ++tree[x];</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = nums;</span><br><span class="line">        <span class="comment">// 离散化</span></span><br><span class="line">        sort(tmp.begin(), tmp.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num: nums) &#123;</span><br><span class="line">            num = lower_bound(tmp.begin(), tmp.end(), num) - tmp.begin() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 树状数组统计逆序对</span></span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans += bit.query(nums[i] - <span class="number">1</span>);</span><br><span class="line">            bit.update(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>离散化树状数组Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.tree = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowbit</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            ret += self.tree[x]</span><br><span class="line">            x -= BIT.lowbit(x)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x &lt;= self.n:</span><br><span class="line">            self.tree[x] += <span class="number">1</span></span><br><span class="line">            x += BIT.lowbit(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># 离散化</span></span><br><span class="line">        tmp = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums[i] = bisect.bisect_left(tmp, nums[i]) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 树状数组统计逆序对</span></span><br><span class="line">        bit = BIT(n)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            ans += bit.query(nums[i] - <span class="number">1</span>)</span><br><span class="line">            bit.update(nums[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>离散化树状数组Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePairs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     n := <span class="built_in">len</span>(nums)</span><br><span class="line">     tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">     <span class="built_in">copy</span>(tmp, nums)</span><br><span class="line">     sort.Ints(tmp)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">         nums[i] = sort.SearchInts(tmp, nums[i]) + <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     bit := BIT&#123;</span><br><span class="line">         n: n,</span><br><span class="line">         tree: <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>),</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ans := <span class="number">0</span></span><br><span class="line">     <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">         ans += bit.query(nums[i] - <span class="number">1</span>)</span><br><span class="line">         bit.update(nums[i])</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BIT <span class="keyword">struct</span> &#123;</span><br><span class="line">    n <span class="keyword">int</span></span><br><span class="line">    tree []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BIT)</span> <span class="title">lowbit</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x &amp; (-x) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BIT)</span> <span class="title">query</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ret += b.tree[x]</span><br><span class="line">        x -= b.lowbit(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BIT)</span> <span class="title">update</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x &lt;= b.n &#123;</span><br><span class="line">        b.tree[x]++</span><br><span class="line">        x += b.lowbit(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度</strong></p><ul><li>时间复杂度：离散化的过程中使用了时间代价为O(nlogn) 的排序，单次二分的时间代价为O(logn)，一共有 <em>n</em> 次，总时间代价为 O(nlogn)；循环执行 <em>n</em> 次，每次进行 O(logn) 的修改和 O(logn) 的查找，总时间代价为  O(nlogn)。故渐进时间复杂度为  O(nlogn)。</li><li>空间复杂度：树状数组需要使用长度为 <em>n</em> 的数组作为辅助空间，故渐进空间复杂度为 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>315. 计算右侧小于当前元素的个数</title>
    <link href="http://yoursite.com/2020/08/26/315.%20%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/08/26/315. 计算右侧小于当前元素的个数/</id>
    <published>2020-08-26T06:12:12.000Z</published>
    <updated>2020-08-31T07:17:30.728Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><a id="more"></a><p>示例：</p><pre><code>输入：nums = [5,2,6,1]输出：[2,1,1,0] 解释：5 的右侧有 2 个更小的元素 (2 和 1)2 的右侧仅有 1 个更小的元素 (1)6 的右侧有 1 个更小的元素 (1)1 的右侧有 0 个更小的元素</code></pre><p>提示：</p><p>0 &lt;= nums.length &lt;= 10^5<br>-10^4 &lt;= nums[i] &lt;= 10^4</p><h1 id="方法一：离散化树状数组"><a href="#方法一：离散化树状数组" class="headerlink" title="方法一：离散化树状数组"></a>方法一：离散化树状数组</h1><p><strong>预备知识</strong></p><p>「树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：</p><ul><li><strong>单点更新 <code>update(i, v)</code>：</strong> 把序列 <em>i</em> 位置的数加上一个值 <em>v</em>，在该题中 <em>v = 1</em></li><li><strong>区间查询 <code>query(i)</code>：</strong> 查询序列 [1,…,i] 区间的区间和，即 <em>i</em> 位置的前缀和</li></ul><p>修改和查询的时间代价都是 O(logn) ，其中 <em>n</em> 为需要维护前缀和的序列的长度。</p><p><strong>思路与算法</strong></p><p>记题目给定的序列为 <em>a</em>，我们规定 <em>a_i</em> 的取值集合为 <em>a</em> 的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设{5,5,2,3,6} ，那么遍历这个序列得到的桶是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index  -&gt;  1 2 3 4 5 6 7 8 9</span><br><span class="line">value  -&gt;  0 1 1 0 2 1 0 0 0</span><br></pre></td></tr></table></figure><p><strong>转化为动态维护前缀和问题</strong> </p><p>记 <code>value</code> 序列为 <em>v</em>，我们可以看出它第 <em>i - 1</em> 位的前缀和表示「有多少个数比 <em>i</em> 小」。那么我们可以从后往前遍历序列 <em>a</em>，记当前遍历到的元素为 <em>a_i*，我们把 *a_i</em> 对应的桶的值自增 <em>1</em>，记 <em>a_i = p*，把 *v</em> 序列 <em>p - 1</em> 位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的 <em>p - 1</em> 位置的前缀和就是「已入桶」的元素中比 <em>p</em> 小的元素的个数总和。<strong>这种动态维护前缀和的问题我们可以用「树状数组」来解决</strong>。</p><p><strong>用离散化优化空间</strong> </p><p>我们显然可以用数组来实现这个桶，可问题是如果 <em>a_i</em> 中有很大的元素，比如 <em>10^9*，我们就要开一个大小为 *10^9</em> 的桶，内存中是存不下的。这个桶数组中很多位置是 <em>0</em>，有效位置是稀疏的，我们要想一个办法让有效的位置全聚集到一起，减少无效位置的出现，这个时候我们就需要用到一个方法——离散化。<strong>离散化的方法有很多，但是目的是一样的，即把原序列的值域映射到一个连续的整数区间，并保证它们的偏序关系不变。</strong> 这里我们将原数组去重后排序，原数组每个数映射到去重排序后这个数对应位置的下标，我们称这个下标为这个对应数字的 id。已知数字获取 id  可以在去重排序后的数组里面做二分查找，已知id 获取数字可以直接把id作为下标访问去重排序数组的对应位置。大家可以参考代码和图来理解这个过程。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/315/1.png" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/315/2.png" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/315/3.png" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/315/4.png" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/315/5.png" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/315/6.png" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/315/7.png" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/315/8.png" target="_blank" rel="noopener">fig8</a> <a href="https://assets.leetcode-cn.com/solution-static/315/9.png" target="_blank" rel="noopener">fig9</a> <a href="https://assets.leetcode-cn.com/solution-static/315/10.png" target="_blank" rel="noopener">fig10</a> </p><p>其实，计算每个数字右侧小于当前元素的个数，这个问题我们在 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">「剑指 Offer 51. 数组中的逆序对」</a> 题解的「方法二：离散化树状数组」中遇到过，在统计逆序对的时候，只需要统计每个位置右侧小于当前元素的个数，再对它们求和，就可以得到逆序对的总数。这道逆序对的题可以作为本题的补充练习。</p><p>代码如下。</p><p><strong>代码</strong></p><details>    <summary>离散化树状数组C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"><span class="keyword">int</span> length</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Array.Fill(c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">LowBit</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="keyword">int</span> pos</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; c.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            c[pos] += <span class="number">1</span>;</span><br><span class="line">            pos += LowBit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Query</span>(<span class="params"><span class="keyword">int</span> pos</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += c[pos];</span><br><span class="line">            pos -= LowBit(pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Discretization</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = (<span class="keyword">int</span>[])nums.Clone();</span><br><span class="line">        <span class="keyword">var</span> hashSet = <span class="keyword">new</span> HashSet&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">        a = hashSet.ToArray();</span><br><span class="line">        Array.Sort(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">GetId</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Array.BinarySearch(a, x) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="keyword">int</span>&gt; <span class="title">CountSmaller</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> resultList = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(); </span><br><span class="line"></span><br><span class="line">        Discretization(nums);</span><br><span class="line"></span><br><span class="line">        Init(nums.Length + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> id = GetId(nums[i]);</span><br><span class="line">            resultList.Add(Query(id - <span class="number">1</span>));</span><br><span class="line">            Update(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resultList.Reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>离散化树状数组java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">        discretization(nums);</span><br><span class="line">        init(nums.length + <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = getId(nums[i]);</span><br><span class="line">            resultList.add(query(id - <span class="number">1</span>));</span><br><span class="line">            update(id);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(resultList);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        c = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Arrays.fill(c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; c.length) &#123;</span><br><span class="line">            c[pos] += <span class="number">1</span>;</span><br><span class="line">            pos += lowBit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret += c[pos];</span><br><span class="line">            pos -= lowBit(pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">discretization</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = set.size();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">            a[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.binarySearch(a, x) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>离散化树状数组C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        c.resize(length, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; c.size()) &#123;</span><br><span class="line">            c[pos] += <span class="number">1</span>;</span><br><span class="line">            pos += LowBit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret += c[pos];</span><br><span class="line">            pos -= LowBit(pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Discretization</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        a.assign(nums.begin(), nums.end());</span><br><span class="line">        sort(a.begin(), a.end());</span><br><span class="line">        a.erase(unique(a.begin(), a.end()), a.end());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(a.begin(), a.end(), x) - a.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; resultList;</span><br><span class="line"></span><br><span class="line">        Discretization(nums);</span><br><span class="line"></span><br><span class="line">        Init(nums.size() + <span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = getId(nums[i]);</span><br><span class="line">            resultList.push_back(Query(id - <span class="number">1</span>));</span><br><span class="line">            Update(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(resultList.begin(), resultList.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>离散化树状数组golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, c []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    resultList := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    discretization(nums)</span><br><span class="line">    c = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums) + <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        id := getId(nums[i])</span><br><span class="line">        resultList = <span class="built_in">append</span>(resultList, query(id - <span class="number">1</span>))</span><br><span class="line">        update(id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(resultList)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        resultList[i], resultList[<span class="built_in">len</span>(resultList)<span class="number">-1</span>-i] = resultList[<span class="built_in">len</span>(resultList)<span class="number">-1</span>-i], resultList[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowBit</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(pos <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> pos &lt; <span class="built_in">len</span>(c) &#123;</span><br><span class="line">        c[pos]++</span><br><span class="line">        pos += lowBit(pos)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(pos <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> pos &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ret += c[pos]</span><br><span class="line">        pos -= lowBit(pos)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">discretization</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    set := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        set[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> num := <span class="keyword">range</span> set &#123;</span><br><span class="line">        a = <span class="built_in">append</span>(a, num)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getId</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.SearchInts(a, x) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>离散化树状数组C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span>* c, <span class="keyword">int</span> n, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; n) &#123;</span><br><span class="line">        c[pos] += <span class="number">1</span>;</span><br><span class="line">        pos += LowBit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span>* c, <span class="keyword">int</span> n, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += c[pos];</span><br><span class="line">        pos -= LowBit(pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>&#123; <span class="keyword">return</span> (*(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Discretization</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, nums, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    qsort(a, n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), comp);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[m]) &#123;</span><br><span class="line">            a[++m] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    <span class="keyword">int</span>* c = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numsSize + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span>* ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numsSize + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = Discretization(a, nums, numsSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = lower_bound(a, m, nums[i]) + <span class="number">1</span>;</span><br><span class="line">        ret[i] = Query(c, m + <span class="number">1</span>, id - <span class="number">1</span>);</span><br><span class="line">        Update(c, m + <span class="number">1</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>假设题目给出的序列长度为 <em>n</em>。</p><ul><li>时间复杂度：我们梳理一下这个算法的流程，这里离散化使用哈希表去重，然后再对去重的数组进行排序，时间代价为 O(nlogn)；初始化树状数组的时间代价是 <em>O(n)</em>；通过值获取离散化 id  的操作单次时间代价为O(logn) ；对于每个序列中的每个元素，都会做一次查询 id、单点修改和前缀和查询，总的时间代价为 O(nlogn) 。故渐进时间复杂度为O(nlogn)。</li><li>空间复杂度：这里用到的离散化数组、树状数组、哈希表的空间代价都是 <em>O(n)</em>，故渐进空间复杂度为 <em>O(n)</em>。</li></ul><h1 id="方法二：归并排序"><a href="#方法二：归并排序" class="headerlink" title="方法二：归并排序"></a>方法二：归并排序</h1><p><strong>预备知识</strong></p><p>这里假设读者已经知道如何使用归并排序的方法计算序列的逆序对数，如果读者还不知道的话可以参考 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">「剑指 Offer 51. 数组中的逆序对」</a> 的官方题解哦。</p><p><strong>思路与算法</strong></p><p>我们发现「离散化树状数组」的方法几乎于 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">「剑指 Offer 51. 数组中的逆序对」</a> 中的完全相同，那么我们可不可以借鉴逆序对问题中的归并排序的方法呢？</p><p>我们还是要在「归并排序」的「并」中做文章。我们通过一个实例来看看。假设我们有两个已排序的序列等待合并，分别是L={8,12,16,22,100}和R={7,26,55,64,91}。一开始我们用指针 <code>lPtr = 0</code> 指向 <em>L</em> 的头部，<code>rPtr = 0</code> 指向 <em>R</em> 的头部。记已经合并好的部分为 <em>M</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [8, 12, 16, 22, 100]   R = [7, 26, 55, 64, 91]  M = []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure><p>我们发现 <code>lPtr</code> 指向的元素大于 <code>rPtr</code> 指向的元素，于是把 <code>rPtr</code> 指向的元素放入答案，并把 <code>rPtr</code> 后移一位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [8, 12, 16, 22, 100]   R = [7, 26, 55, 64, 91]  M = [7]</span><br><span class="line">     |                              |</span><br><span class="line">    lPtr                          rPtr</span><br></pre></td></tr></table></figure><p>接着我们继续合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [8, 12, 16, 22, 100]   R = [7, 26, 55, 64, 91]  M = [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure><p>此时 <code>lPtr</code> 比 <code>rPtr</code> 小，把 <code>lPtr</code> 对应的数加入答案。如果我们要统计 <em>8</em> 的右边比 <em>8</em> 小的元素，这里 <em>7</em> 对它做了一次贡献。如果带合并的序列 L={8,12,16,22,100} ，R={7,7,7,26,55,64,91} ，那么一定有一个时刻，<code>lPtr</code> 和 <code>rPtr</code> 分别指向这些对应的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [8, 12, 16, 22, 100]   R = [7, 7, 7, 26, 55, 64, 91]  M = [7, 7, 7]</span><br><span class="line">     |                                   |</span><br><span class="line">    lPtr                                rPtr</span><br></pre></td></tr></table></figure><p>下一步我们就是把 <em>8</em> 加入 <em>M</em> 中，此时三个 <em>7</em> 对 <em>8</em> 的右边比 <em>8</em> 小的元素的贡献为 <em>3</em>。以此类推，我们可以一边合并一边计算 <em>R</em> 的头部到 <code>rPtr</code> 前一个数字对当前 <code>lPtr</code> 指向的数字的贡献。</p><p>我们发现用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 <code>lPtr</code> 右移的时候计算，是基于这样的事实：当前 <code>lPtr</code> 指向的数字比 <code>rPtr</code> 小，但是比 <em>R</em> 中 <code>[0 ... rPtr - 1]</code> 的其他数字大，<code>[0 ... rPtr - 1]</code> 的数字是在 <code>lPtr</code> 右边但是比 <code>lPtr</code> 对应数小的数字，贡献为这些数字的个数。</p><p>但是我们又遇到了新的问题，在「并」的过程中 <em>8</em> 的位置一直在发生改变，我们应该把计算的贡献保存到哪里呢？这个时候我们引入一个新的数组，来记录每个数字对应的原数组中的下标，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    a = [8, 9, 1, 5, 2]</span><br><span class="line">index = [0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>排序的时候原数组和这个下标数组同时变化，则排序后我们得到这样的两个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    a = [1, 2, 5, 8, 9]</span><br><span class="line">index = [2, 4, 3, 0, 1]</span><br></pre></td></tr></table></figure><p>我们用一个数组 <code>ans</code> 来记录贡献。我们对某个元素计算贡献的时候，如果它对应的下标为 <code>p</code>，我们只需要在 <code>ans[p]</code> 上加上贡献即可。</p><p>大家可以参考代码来理解这个过程。Java版的这种解法我还是没有吃透，可以参见<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">「剑指 Offer 51. 数组中的逆序对」</a> 的相应博客中有一种相对易于理解的解法。</p><p><strong>代码</strong></p><details>    <summary>归并排序C#</summary><figure class="highlight csharp"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tempIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Merge</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, p = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp[p] = a[i];</span><br><span class="line">                tempIndex[p] = index[i];</span><br><span class="line">                ans[index[i]] += (j - mid - <span class="number">1</span>);</span><br><span class="line">                ++i;</span><br><span class="line">                ++p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                temp[p] = a[j];</span><br><span class="line">                tempIndex[p] = index[j];</span><br><span class="line">                ++j;</span><br><span class="line">                ++p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) </span><br><span class="line">        &#123;</span><br><span class="line">            temp[p] = a[i];</span><br><span class="line">            tempIndex[p] = index[i];</span><br><span class="line">            ans[index[i]] += (j - mid - <span class="number">1</span>);</span><br><span class="line">            ++i;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[p] = a[j];</span><br><span class="line">            tempIndex[p] = index[j];</span><br><span class="line">            ++j;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            index[k] = tempIndex[k];</span><br><span class="line">            a[k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MergeSort</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        MergeSort(a, l, mid);</span><br><span class="line">        MergeSort(a, mid + <span class="number">1</span>, r);</span><br><span class="line">        Merge(a, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="keyword">int</span>&gt; <span class="title">CountSmaller</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length];</span><br><span class="line">        <span class="keyword">this</span>.temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length];</span><br><span class="line">        <span class="keyword">this</span>.tempIndex = <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length];</span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            index[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.Length - <span class="number">1</span>;</span><br><span class="line">        MergeSort(nums, l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>归并排序Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] aux;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        counter = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        index = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) index[i] = i；</span><br><span class="line">        <span class="comment">//归并排序并统计</span></span><br><span class="line">        mergeAndCount(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历获取统计结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res.add(counter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并排序入口</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeAndCount</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        mergeAndCount(nums, l, m);</span><br><span class="line">        mergeAndCount(nums, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">//检查已排序的部分</span></span><br><span class="line">        <span class="keyword">if</span> (nums[index[m]] &gt; nums[index[m + <span class="number">1</span>]]) &#123;</span><br><span class="line">            sortAndCount(nums, l, m, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子数组排序并统计</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortAndCount</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) aux[i] = index[i];</span><br><span class="line">        <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; m) &#123;</span><br><span class="line">                index[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">                index[k] = aux[i++];</span><br><span class="line">                <span class="comment">//排序的是索引数组，仍然可以通过索引找到原来数组中的元素，并更新统计值</span></span><br><span class="line">                <span class="comment">//右边先走完，那么右边的都是逆序</span></span><br><span class="line">                counter[index[k]] += (r - m);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[aux[i]] &lt;= nums[aux[j]]) &#123;</span><br><span class="line">                index[k] = aux[i++];</span><br><span class="line">                <span class="comment">//插入左边的元素时，统计已经产生的逆序部分</span></span><br><span class="line">                counter[index[k]] += (j - m - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index[k] = aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn)，即归并排序的时间复杂度。</li><li>空间复杂度：<em>O(n)</em>，这里归并排序的临时数组、下标映射数组以及答案数组的空间代价均为 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Binary Indexed Tree" scheme="http://yoursite.com/tags/Binary-Indexed-Tree/"/>
    
      <category term="Segment Tree" scheme="http://yoursite.com/tags/Segment-Tree/"/>
    
      <category term="Divide and Conque" scheme="http://yoursite.com/tags/Divide-and-Conque/"/>
    
  </entry>
  
  <entry>
    <title>287. 寻找重复数</title>
    <link href="http://yoursite.com/2020/08/25/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2020/08/25/287. 寻找重复数/</id>
    <published>2020-08-25T08:12:12.000Z</published>
    <updated>2020-08-26T06:33:03.611Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [1,3,4,2,2]输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [3,1,3,4,2]输出: 3</code></pre><p>说明：</p><pre><code>不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="95ade126-7621-420e-97fb-4fe2784fad01">287. 寻找重复数.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><p><strong>思路和算法</strong></p><p>我们定义 cnt[i] 表示 nums[]  数组中小于等于 <em>i</em> 的数有多少个，假设我们重复的数是 target ，那么 [1,target-1] 里的所有数满足 cnt[i] &lt;=i，<em>[target,n]</em> 里的所有数满足 cnt[i] &gt; i，具有单调性。</p><p>以示例 1 为例，我们列出每个数字的 cnt  值：</p><table><thead><tr><th align="center">nums</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">cnt</td><td align="center">1</td><td align="center">3</td><td align="center">4</td><td align="center">5</td></tr></tbody></table><p>示例中重复的整数是 <em>2</em>，我们可以看到 <em>[1,1]</em> 中的数满足 cnt[i] &lt;=i，<em>[2,4]</em> 中的数满足cnt[i] &gt; i 。</p><p>如果知道  cnt[]  数组随数字 <em>i</em> 逐渐增大具有单调性（即 target  前 cnt[i] &lt;=i，target  后 cnt[i] &gt; i，那么我们就可以直接利用二分查找来找到重复的数。</p><p>但这个性质一定是正确的吗？考虑 nums[]  数组一共有 <em>n+1</em> 个位置，我们填入的数字都在 <em>[1,n]</em> 间，有且只有一个数重复放了两次以上。对于所有测试用例，考虑以下两种情况：</p><ul><li><p>如果测试用例的数组中target 出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于 target 的数 <em>i</em> 满足 cnt[i]=i ，大于等于 target  的数 <em>j</em> 满足 <em>cnt[j]=j+1</em>。</p></li><li><p>如果测试用例的数组中 target 出现了三次及以上，那么必然有一些数不在 nums[]  数组中了，这个时候相当于我们用 target 去替换了这些数，我们考虑替换的时候对 cnt[]数组的影响。如果替换的数 <em>i</em> 小于 target ，那么[i,target-1] 的 cnt值均减一，其他不变，满足条件。如果替换的数 <em>j</em> 大于等于 target，那么[target,j-1]的 cnt 值均加一，其他不变，亦满足条件。</p></li></ul><p>因此我们生成的数组一定具有上述性质的。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cnt += nums[i] &lt;= mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    l, r := <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        cnt := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= mid &#123;</span><br><span class="line">                cnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt &lt;= mid &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">            ans = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogn)  ，其中 <em>n</em> 为 nums[] 数组的长度。二分查找最多需要二分 O(logn)次，每次判断的时候需要<em>O(n)</em> 遍历 nums[]  数组求解小于等于mid的数的个数，因此总时间复杂度为O(nlogn)。</p></li><li><p>空间复杂度：<em>O(1)</em>。我们只需要常数空间存放若干变量。</p></li></ul><h2 id="方法二：二进制"><a href="#方法二：二进制" class="headerlink" title="方法二：二进制"></a>方法二：二进制</h2><p><strong>思路和算法</strong></p><p>这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 <em>1</em> 还是 <em>0</em> 就可以按位还原出重复的数是什么。</p><p>考虑到第 <em>i</em> 位，我们记 nums[] 数组中二进制展开后第 <em>i</em> 位为 <em>1</em> 的数有 <em>x</em> 个，数字 <em>[1,n]</em> 这 <em>n</em> 个数二进制展开后第 <em>i</em> 位为 <em>1</em> 的数有 <em>y</em> 个，那么重复的数第 <em>i</em> 位为 <em>1</em> 当且仅当 <em>x&gt;y</em>。</p><p>仍然以示例 1 为例，如下的表格列出了每个数字二进制下每一位是 <em>1</em> 还是 <em>0</em> 以及对应位的 <em>x</em> 和 <em>y</em> 是多少：</p><table><thead><tr><th align="center">&nbsp;</th><th align="center">1</th><th align="center">3</th><th align="center">4</th><th align="center">2</th><th align="center">2</th><th align="center">x</th><th align="center">y</th></tr></thead><tbody><tr><td align="center">第 0 位</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">第 1 位</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">第 2 位</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>更多思路详解见<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/xun-zhao-zhong-fu-shu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><details>    <summary>二进制C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 确定二进制下最高位是多少</span></span><br><span class="line">        <span class="keyword">int</span> bit_max = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">while</span> (!((n - <span class="number">1</span>) &gt;&gt; bit_max)) &#123;</span><br><span class="line">            bit_max -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bit = <span class="number">0</span>; bit &lt;= bit_max; ++bit) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &amp; (<span class="number">1</span> &lt;&lt; bit)) &#123;</span><br><span class="line">                    x += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; bit))) &#123;</span><br><span class="line">                    y += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 确定二进制下最高位是多少</span></span><br><span class="line">    <span class="keyword">let</span> bit_max = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (!((n - <span class="number">1</span>) &gt;&gt; bit_max)) &#123;</span><br><span class="line">        bit_max -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> bit = <span class="number">0</span>; bit &lt;= bit_max; ++bit) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &amp; (<span class="number">1</span> &lt;&lt; bit)) &#123;</span><br><span class="line">                x += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; bit))) &#123;</span><br><span class="line">                y += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bit_max = <span class="number">31</span>;</span><br><span class="line">        <span class="comment">//令bit_max为n-1的最高位数</span></span><br><span class="line">        <span class="keyword">while</span> (((n - <span class="number">1</span>) &gt;&gt; bit_max) == <span class="number">0</span>) &#123;</span><br><span class="line">            bit_max -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bit = <span class="number">0</span>; bit &lt;= bit_max; ++bit) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[i] &amp; (<span class="number">1</span> &lt;&lt; bit)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    x += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (((i &amp; (<span class="number">1</span> &lt;&lt; bit)) != <span class="number">0</span>)) &#123;</span><br><span class="line">                    y += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    bit_max := <span class="number">31</span></span><br><span class="line">    <span class="keyword">for</span> ((n<span class="number">-1</span>) &gt;&gt; bit_max) == <span class="number">0</span> &#123;</span><br><span class="line">        bit_max--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> bit := <span class="number">0</span>; bit &lt;= bit_max; bit++ &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &amp; (<span class="number">1</span> &lt;&lt; bit)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                x++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; bit)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                y++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; bit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度证明</strong></p><ul><li><p>时间复杂度：O(nlogn)。</p></li><li><p>空间复杂度：<em>O(1)</em>。我们只需要常数空间存放若干变量。</p></li></ul><h2 id="方法三：快慢指针"><a href="#方法三：快慢指针" class="headerlink" title="方法三：快慢指针"></a>方法三：快慢指针</h2><p>更多思路详解见<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/xun-zhao-zhong-fu-shu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><details>    <summary>快慢指针C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>快慢指针golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    slow, fast := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> slow, fast = nums[slow], nums[nums[fast]]; slow != fast; slow, fast = nums[slow], nums[nums[fast]] &#123; &#125;</span><br><span class="line">    slow = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em>。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。</p></li><li><p>空间复杂度：<em>O(1)</em>。我们只需要常数空间存放若干变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>162. 寻找峰值</title>
    <link href="http://yoursite.com/2020/08/24/162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>http://yoursite.com/2020/08/24/162. 寻找峰值/</id>
    <published>2020-08-24T09:55:12.000Z</published>
    <updated>2020-08-25T08:00:48.057Z</updated>
    
    <content type="html"><![CDATA[<p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p><a id="more"></a><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞。</p><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。</code></pre><p>说明:</p><p>你的解法应该是 O(logN) 时间复杂度的。</p><h1 id="方法一-线性扫描"><a href="#方法一-线性扫描" class="headerlink" title="方法一: 线性扫描"></a>方法一: 线性扫描</h1><p>本方法利用了连续的两个元素 <em>nums[j]</em> 和 <em>nums[j + 1]</em> 不会相等这一事实。于是，我们可以从头开始遍历 <em>nums</em> 数组。每当我们遇到数字 <em>nums[i]*，只需要检查它是否大于下一个元素 *nums[i+1]</em> 即可判断 <em>nums[i]</em> 是否是峰值。可以通过分别讨论问题的全部三种可能情况来理解本方法的思路。</p><p>情况 1. </p><p>所有的数字以降序排列。这种情况下，第一个元素即为峰值。我们首先检查当前元素是否大于下个元素。第一个元素满足这一条件，因此被正确判断为峰值。此时，我们不需要继续向下判断，也就不会有需要判断 <em>nums[i]</em> 和上一个元素 <em>nums[i-1]</em> 的大小的情况。</p><p><a href="https://pic.leetcode-cn.com/fafef6e2070c9c444541d03e5d24c6c06f2f50f94026a22a9a86903e9d5ffcb1-image.png" target="_blank" rel="noopener">image.png</a></p><p>情况 2. </p><p>所有的数字以升序排列。这种情况下，我们会一直比较 <em>nums[i]</em> 与 <em>nums[i+1]</em> 以判断 <em>nums[i]</em> 是否是峰值元素。没有元素符合这一条件，说明处于上坡而非峰值。于是，在结尾，我们返回末尾元素作为峰值元素，得到正确结果。在这种情况下，我们同样不需要比较 <em>nums[i]</em> 和上一个元素 <em>nums[i-1]*，因为处于上坡是 *nums[i]</em> 不是峰值的充分条件。</p><p><a href="https://pic.leetcode-cn.com/06cbc777aee1d0d0a906aefd408e539014f783727e401f136b66581d0856aa6d-image.png" target="_blank" rel="noopener">image.png</a></p><p>情况 3. </p><p>峰值出现在中间某处。这种情况下，当遍历上升部分时，与情况 2 相同，没有元素满足 <em>nums[i] &gt; nums[i + 1]*。我们不需要比较 *nums[i]</em> 和上一个元素 <em>nums[i-1]<em>。当到达峰值元素时，</em>nums[i] &gt; nums[i + 1]</em> 条件满足。此时，我们同样不需要比较 <em>nums[i]</em> 和上一个元素 <em>nums[i-1]*。这是由于“遍历会到达第i个元素”本身就说明上一个元素（第i- 1个）不满足 *nums[i] &gt; nums[i + 1]</em> 这一条件，也就说明 <em>nums[i-1] &lt; nums[i]</em>。于是，我们同样可以得到正确结果。</p><p><a href="https://pic.leetcode-cn.com/802bad70c4444bf708f4c63e30e054a33c27ace43b3c7b4fa64a0ffb8201fb7d-image.png" target="_blank" rel="noopener">image.png</a></p><details>    <summary>线性扫描</summary><figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(n)*。 我们对长度为 *n</em> 的数组 <em>nums</em> 只进行一次遍历。</li><li>空间复杂度 : <em>O(1)</em>。 只使用了常数空间。<br><br></li></ul><hr><h1 id="方法二：递归二分查找"><a href="#方法二：递归二分查找" class="headerlink" title="方法二：递归二分查找"></a>方法二：递归二分查找</h1><p><strong>算法</strong></p><p>我们可以将 <em>nums</em> 数组中的任何给定序列视为交替的升序和降序序列。通过利用这一点，以及“可以返回任何一个峰作为结果”的要求，我们可以利用二分查找来找到所需的峰值元素。</p><p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 <em>nums</em> 中找到中间的元素 <em>mid*。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 *nums[i]</em> 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 <em>mid</em> 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p><p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 <em>nums[i]</em> 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 <em>mid</em> 的右边，并在右侧子数组上重复上述过程。</p><p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p><p>为了理解本方法的原理，让我们再次讨论前文提到的全部三种情况。</p><p>情况 1. 这种情况下，首先找到中间元素 <em>3</em>。由于它处于下降坡度，将搜索空间缩小到 <code>[1, 2, 3]</code>。对于此子数组，<em>2</em> 为中间元素，也处于下降坡度中，于是将搜索空间缩小到 <code>[1, 2]</code>。现在 <em>1</em> 是中间元素并同样处于下降坡度，于是将搜索空间缩小到 <code>[1]</code>。 最终 <em>1</em> 作为答案被正确返回。</p><p> <a href="https://pic.leetcode-cn.com/63177d2c44aab77a657c0eb4589f7b7f45e754cf3408d9872bc3371e680c5908-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/317e900368f211d02e3f107e288824a0e351d39963aae9a210b1fe3730ef1eec-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/1a26071c6f370ccd84a417a4edbfcf7178b1daf78ed3270285861af4f77c6496-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/8a511427f1c0c1b7c58776fa238124f44c300fc632d13658e1f381f6fd23fa03-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/17974218262fc0e235fac8bfe9252058015de312546ce35ac217ab428360b780-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/7d34f6f13915860f01f1e18409534a06db73504ffa3ab7dc66422801697a8a39-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/e2edf7bcc45863a10d438dd92b8c4c6b6b63ff834aa11f05e4a104b5cbf859fc-image.png" target="_blank" rel="noopener">image.png</a> </p><p>情况 2. 这种情况下，首先找到中间元素 <em>3</em>。由于它处于上升坡度，将搜索空间缩小到 <code>[4, 5]</code>。对于此子数组，<em>4</em> 为中间元素，也处于上升坡度中，于是将搜索空间缩小到 <code>[5]</code>。 最终 <em>5</em> 作为答案被正确返回。</p><p> <a href="https://pic.leetcode-cn.com/935aeb721c5901d8f70a64aafc0bff14be030db7cf44605c051e5c87de2890c0-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/fb6d1262315867c62d818b0606b2628b6537d4b1b9c337bbaf3708fad257391c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6de90b2f77920d015f7a45191090b9265a49dae0c4585e8d514b1aaa39afd2b9-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d359a685a16480ac4d6ad3d7e5df1f3b00524a74580982920bc01de72a9dd837-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/a976733e8b2e4817b2d88616b519bc58ca471ca15e9ee3f77fcc377a329e0d46-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/b0c6a62e9a0ebdc7a92995a1d633da7176cc82f9f3fe5e9e8f4b921b3d8fc4cc-image.png" target="_blank" rel="noopener">image.png</a> </p><p>情况 3. 这种情况下， 峰值位于中间某处。第一个中间元素是 <em>4</em>。它位于上升坡度，表明峰值在其右侧。于是，搜索空间缩小为 <code>[5, 1]</code>。 现在，<em>5</em> 位于下降坡度（相对其右侧相邻元素）, 搜索空间下降为 <code>[5]</code>。于是，<em>5</em> 被正确识别。</p><p> <a href="https://pic.leetcode-cn.com/3e49bacacecbf67aed75bcee9387dab5ccb7e7160dcc7c33be1be9e7a3acc563-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/8ee64c7b12c6b64b282324be43ecb89d29ac70d15dc3a35f2c62113cea7c23d8-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/78f6084e3bdfe12c05f2304d6a8b8c15e224f1b7f01f254bc04c0832c24c53b2-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/94cae61b8d045a3682d6a479417069776cabf13cc8bed930d07e088bcc2df575-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/03d56e48600ff839e6a6c8819d859d488e8bafd4c052fc61b7bdba09ed78ff8c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/95f33e0a46ed380e3e5c2db5cb5a93479bb65463e7fcf6a7c953e3a039fe0461-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>递归二分查找</summary><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> search(nums, l, mid);</span><br><span class="line">        <span class="keyword">return</span> search(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 :  O(log_2(n)) 。每一步都将搜索空间减半。因此，总的搜索空间只需要 <em>log_2(n)</em> 步。其中 <em>n</em> 为 <em>nums</em> 数组的长度。</li><li>空间复杂度: O(log_2(n))  。每一步都将搜索空间减半。因此，总的搜索空间只需要 <em>log_2(n)</em> 步。于是，递归树的深度为 <em>log_2(n)</em>。<br><br></li></ul><hr><h1 id="方法三：迭代二分查找"><a href="#方法三：迭代二分查找" class="headerlink" title="方法三：迭代二分查找"></a>方法三：迭代二分查找</h1><p><strong>算法</strong></p><p>上述二分查找方法使用了递归。我们可以通过迭代达到同样的效果。本方法即为迭代实现二分查找。</p><details>    <summary>迭代二分查找</summary><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度 : O(log_2(n))。 每一步都将搜索空间减半。因此，总的搜索空间只需要 <em>log_2(n)</em> 步。其中 <em>n</em> 为 <em>nums</em> 数组的长度。</li><li>空间复杂度 : <em>O(1)</em>。 只使用了常数空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
</feed>
