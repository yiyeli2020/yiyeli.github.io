<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-01-06T09:34:00.065Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA 学习笔记（数据库）</title>
    <link href="http://yoursite.com/2022/01/06/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/06/JAVA 学习笔记（数据库）/</id>
    <published>2022-01-06T02:12:12.000Z</published>
    <updated>2022-01-06T09:34:00.065Z</updated>
    
    <content type="html"><![CDATA[<p>存储引擎，索引，事务，锁等概念</p><a id="more"></a><p>[TOC]</p><details>    <summary></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></details><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。</p><h2 id="InnoDB（B-树）"><a href="#InnoDB（B-树）" class="headerlink" title="InnoDB（B+树）"></a>InnoDB（B+树）</h2><p>InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。</p><p>适用场景：</p><p>1）经常更新的表，适合处理多重并发的更新请求。</p><p>2）支持事务。</p><p>3）可以从灾难中恢复（通过 bin-log 日志等）。</p><p>4）外键约束。只有他支持外键。</p><p>5）支持自动增加列属性 auto_increment</p><h2 id="TokuDB（Fractal-Tree-节点带数据）"><a href="#TokuDB（Fractal-Tree-节点带数据）" class="headerlink" title="TokuDB（Fractal Tree-节点带数据）"></a>TokuDB（Fractal Tree-节点带数据）</h2><p>TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree中，每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个Message Buffer 是一个 FIFO 的队列，用来缓存更新操作。</p><p>例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</p><p>TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p><h2 id="MyIASM"><a href="#MyIASM" class="headerlink" title="MyIASM"></a>MyIASM</h2><p>MyIASM是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织<br>成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。</p><p>缺点是它不 支持事务处理。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉。Memory同时支持散列索引和B树索引，B树索引可以使用部分查询和通配查询，也可以使用&lt;,&gt;和&gt;=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）</p><h2 id="常见索引原则"><a href="#常见索引原则" class="headerlink" title="常见索引原则"></a>常见索引原则</h2><ol><li><p>选择唯一性索引<br>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</p></li><li><p>为经常需要排序、分组和联合操作的字段建立索引：</p></li></ol><p>3．为常作为查询条件的字段建立索引。</p><p>4．限制索引的数目：  </p><p>越多的索引，会使更新表变得很浪费时间。</p><p>5．尽量使用数据量少的索引   </p><p>如果索引的值很长，那么查询的速度会受到影响。</p><p>6．尽量使用前缀来索引   </p><p>如果索引字段的值很长，最好使用值的前缀来索引。</p><p>7．删除不再使用或者很少使用的索引</p><ol start="8"><li><p>最左前缀匹配原则，非常重要的原则。</p></li><li><p>尽量选择区分度高的列作为索引    </p></li></ol><p>区分度的公式是表示字段不重复的比例</p><ol start="10"><li><p>索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</p></li><li><p>尽量的扩展索引，不要新建索引。</p></li></ol><h1 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h1><p>范式是具有最小冗余的表结构。3 范式具体如下：</p><h2 id="第一范式-1st-NF-－列都是不可再分"><a href="#第一范式-1st-NF-－列都是不可再分" class="headerlink" title="第一范式(1st NF －列都是不可再分)"></a>第一范式(1st NF －列都是不可再分)</h2><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）</p><h2 id="第二范式-2nd-NF－每个表只描述一件事情"><a href="#第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="第二范式(2nd NF－每个表只描述一件事情)"></a>第二范式(2nd NF－每个表只描述一件事情)</h2><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。</p><h2 id="第三范式-3rd-NF－-不存在对非主键列的传递依赖"><a href="#第三范式-3rd-NF－-不存在对非主键列的传递依赖" class="headerlink" title="第三范式(3rd NF－ 不存在对非主键列的传递依赖)"></a>第三范式(3rd NF－ 不存在对非主键列的传递依赖)</h2><p> 第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号</p><h1 id="数据库是事务"><a href="#数据库是事务" class="headerlink" title="数据库是事务"></a>数据库是事务</h1><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行。事务是一个不可分割的工作逻辑单元</p><p>事务必须具备以下四个属性，简称 ACID 属性：</p><h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h2><ol><li>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</li></ol><h2 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h2><ol start="2"><li>当事务完成时，数据必须处于一致状态。</li></ol><h2 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h2><ol start="3"><li>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</li></ol><h2 id="永久性（Durability）"><a href="#永久性（Durability）" class="headerlink" title="永久性（Durability）"></a>永久性（Durability）</h2><ol start="4"><li>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</li></ol><h1 id="存储过程-特定功能的-SQL-语句集"><a href="#存储过程-特定功能的-SQL-语句集" class="headerlink" title="存储过程(特定功能的 SQL 语句集)"></a>存储过程(特定功能的 SQL 语句集)</h1><p>一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。</p><h2 id="存储过程优化思路："><a href="#存储过程优化思路：" class="headerlink" title="存储过程优化思路："></a>存储过程优化思路：</h2><ol><li>尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。</li><li>中间结果存放于临时表，加索引。</li><li>少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。</li><li>事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。</li><li>使用 try-catch 处理错误异常。</li><li>查找语句尽量不要放在循环内。</li></ol><h1 id="触发器-一段能自动执行的程序"><a href="#触发器-一段能自动执行的程序" class="headerlink" title="触发器(一段能自动执行的程序)"></a>触发器(一段能自动执行的程序)</h1><p>触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、alter、drop 语句。</p><p>SQL（Structure Query Language）结构化查询语言</p><p>DQL（data query language）数据查询语言 select操作</p><p>DML（data manipulation language）数据操作语言，主要是数据库增删改三种操作</p><p>DDL（data defination language）数据库定义语言，主要是建表、删除表、修改表字段等操作</p><p>DCL（data control language）数据库控制语言，如commit，revoke之类的，在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</p><h1 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h1><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，</p><p>以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。</p><h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：</p><ol><li>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li><li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li><li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li></ol><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><h2 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h2><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</p><h1 id="基于-Redis-分布式锁"><a href="#基于-Redis-分布式锁" class="headerlink" title="基于 Redis 分布式锁"></a>基于 Redis 分布式锁</h1><ol><li>获取锁的时候，使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁。</li><li>获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ol><h1 id="分区分表"><a href="#分区分表" class="headerlink" title="分区分表"></a>分区分表</h1><p>分库分表有垂直切分和水平切分两种。</p><h2 id="垂直切分-按照功能模块"><a href="#垂直切分-按照功能模块" class="headerlink" title="垂直切分(按照功能模块)"></a>垂直切分(按照功能模块)</h2><p> 将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</p><h2 id="水平切分-按照规则划分存储"><a href="#水平切分-按照规则划分存储" class="headerlink" title="水平切分(按照规则划分存储)"></a>水平切分(按照规则划分存储)</h2><p> 当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。</p><h1 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h1><p>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。</p><p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</p><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并<br>最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><h2 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h2><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="同步阻塞问题"><a href="#同步阻塞问题" class="headerlink" title="同步阻塞问题"></a>同步阻塞问题</h3><p>1、执行过程中，所有参与节点都是事务阻塞型的。</p><h3 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h3><p>2、由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。</p><h3 id="数据不一致（脑裂问题）"><a href="#数据不一致（脑裂问题）" class="headerlink" title="数据不一致（脑裂问题）"></a>数据不一致（脑裂问题）</h3><p>3、在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。</p><h2 id="二阶段无法解决的问题（数据状态不确定）"><a href="#二阶段无法解决的问题（数据状态不确定）" class="headerlink" title="二阶段无法解决的问题（数据状态不确定）"></a>二阶段无法解决的问题（数据状态不确定）</h2><p>4、协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><h1 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h1><p>三阶段提交（ Three-phase commit ） ， 也 叫 三 阶 段 提 交 协 议 （ Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。</p><p>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p><h2 id="CanCommit-阶段"><a href="#CanCommit-阶段" class="headerlink" title="CanCommit 阶段"></a>CanCommit 阶段</h2><p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p><h2 id="PreCommit-阶段"><a href="#PreCommit-阶段" class="headerlink" title="PreCommit 阶段"></a>PreCommit 阶段</h2><p>协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。</p><p>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行</p><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><h2 id="doCommit-阶段"><a href="#doCommit-阶段" class="headerlink" title="doCommit 阶段"></a>doCommit 阶段</h2><p>该阶段进行真正的事务提交，主要包含 </p><p>1.协调者发送提交请求 </p><p>2.参与者提交事务 </p><p>3.参与者响应反馈（ 事务提交完之后，向协调者发送 Ack 响应。）</p><p>4.协调者确定完成事务。</p><h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><h2 id="一致性Consistency（C）："><a href="#一致性Consistency（C）：" class="headerlink" title="一致性Consistency（C）："></a>一致性Consistency（C）：</h2><ol><li>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li></ol><h2 id="可用性Availability（A）："><a href="#可用性Availability（A）：" class="headerlink" title="可用性Availability（A）："></a>可用性Availability（A）：</h2><ol start="2"><li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li></ol><h2 id="分区容忍性Partition-tolerance（P）："><a href="#分区容忍性Partition-tolerance（P）：" class="headerlink" title="分区容忍性Partition tolerance（P）："></a>分区容忍性Partition tolerance（P）：</h2><ol start="3"><li>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li></ol><p>翻译过来就是说系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务。</p><p>分区容错性和拓展性息息相关，因为越大的分布式系统越有可能出现机器宕机，网络阻塞等情况。即使这些意外情况发生，系统仍然能保持稳定是系统拓展的前提。在分布式系统当中出现的问题可能性很多，既可能出现部分机器宕机，也有可能出现内网阻隔，使得整个集群被拆分成互相不能通信的几个部分。分区容错性需要保证即使这些情况发生，系统也一样可以保证一致性和可用性。</p><p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p><h3 id="舍弃A，保留CP"><a href="#舍弃A，保留CP" class="headerlink" title="舍弃A，保留CP"></a>舍弃A，保留CP</h3><p>一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。</p><p>对于有些系统而言，一致性是安身立命之本，比如Hbase、Redis这种分布式存储，数据一致性是最基本的要求。不满足一致性的存储显然不会有用户愿意使用。</p><p>ZooKeeper也是一样，任何时候访问ZK都可以获得一致性的结果。它的职责就是保证管辖下的服务保持同步和一致，显然不可能放弃一致性。但是在极端情况下，ZK可能会丢弃调一些请求，消费者需要重新请求才能获得结果。</p><p>如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件，因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足</p><h3 id="舍弃C，保留AP"><a href="#舍弃C，保留AP" class="headerlink" title="舍弃C，保留AP"></a>舍弃C，保留AP</h3><p>这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。比如淘宝购物以及12306购票等等，前面说过淘宝可以做到全年可用性5个9的超高级别，但是此时就无法保证数据一致性了。</p><p>举个例子，我们在12306买票的时候就经常会遇到。在我们点击购买的时候，系统并没有提示没票。等我们输入了验证码，付款的时候才会告知，已经没有票了。这就是因为我们在点击购买的时候，数据没有达成一致性，在付款校验的时候才检验出余票不足。这种设计会牺牲一些用户体验，但是可以保证高可用，让用户不至于无法访问或者是长时间等待，也算是一种取舍吧。</p><h3 id="舍弃P，保留CA"><a href="#舍弃P，保留CA" class="headerlink" title="舍弃P，保留CA"></a>舍弃P，保留CA</h3><p>很遗憾，这种情况几乎不存在。因为分布式系统，网络分区是必然的。如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在的。</p><p>比如一般的关系型数据库，像是MySQL或者是Oracle，它们都保证了一致性和可用性，但是并不是分布式系统。从这点上来说CAP并不是等价的，我们并不能通过牺牲CA来提升P。要想提升分区容错性，只能通过提升基础设施的稳定性来达到。也就是说这并不是一个软件问题。</p><h1 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h1><h2 id="柔性事务-1"><a href="#柔性事务-1" class="headerlink" title="柔性事务"></a>柔性事务</h2><p>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。</p><h3 id="基本可用（Basically-Available）"><a href="#基本可用（Basically-Available）" class="headerlink" title="基本可用（Basically Available）"></a>基本可用（Basically Available）</h3><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p><p>响应时间上的损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。<br>功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><h3 id="柔性状态（Soft-State）"><a href="#柔性状态（Soft-State）" class="headerlink" title="柔性状态（Soft State）"></a>柔性状态（Soft State）</h3><p>什么是柔性状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>柔性状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>上面说柔性状态，然后不可能一直是柔性状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p><p>而在实际工程实践中，最终一致性分为5种：以下五种是从百科摘来的，仅供了解。</p><h4 id="因果一致性（Causal-consistency）"><a href="#因果一致性（Causal-consistency）" class="headerlink" title="因果一致性（Causal consistency）"></a>因果一致性（Causal consistency）</h4><p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p><h4 id="读己之所写（Read-your-writes）"><a href="#读己之所写（Read-your-writes）" class="headerlink" title="读己之所写（Read your writes）"></a>读己之所写（Read your writes）</h4><p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p><h4 id="会话一致性（Session-consistency）"><a href="#会话一致性（Session-consistency）" class="headerlink" title="会话一致性（Session consistency）"></a>会话一致性（Session consistency）</h4><p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p><h4 id="单调读一致性（Monotonic-read-consistency）"><a href="#单调读一致性（Monotonic-read-consistency）" class="headerlink" title="单调读一致性（Monotonic read consistency）"></a>单调读一致性（Monotonic read consistency）</h4><p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p><h4 id="单调写一致性（Monotonic-write-consistency）"><a href="#单调写一致性（Monotonic-write-consistency）" class="headerlink" title="单调写一致性（Monotonic write consistency）"></a>单调写一致性（Monotonic write consistency）</h4><p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p><p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p><p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p><p>通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。</p><h3 id="两阶段型"><a href="#两阶段型" class="headerlink" title="两阶段型"></a>两阶段型</h3><p>1、就是分布式事务两阶段提交，对应技术上的 XA、JTA/JTS。这是分布式环境下事务处理的典型模式。</p><h3 id="补偿型"><a href="#补偿型" class="headerlink" title="补偿型"></a>补偿型</h3><p>2、TCC 型事务（Try/Confirm/Cancel）可以归为补偿型</p><p>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成。</p><p>但是如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。</p><h3 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h3><p>3、通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。</p><h3 id="最大努力通知型（多次尝试）"><a href="#最大努力通知型（多次尝试）" class="headerlink" title="最大努力通知型（多次尝试）"></a>最大努力通知型（多次尝试）</h3><p>4、这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, 允许在达到最大重试次数之后正常结束事务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储引擎，索引，事务，锁等概念&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（负载均衡）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（负载均衡）/</id>
    <published>2022-01-05T13:12:12.000Z</published>
    <updated>2022-01-06T02:15:54.887Z</updated>
    
    <content type="html"><![CDATA[<p>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带<br>宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><a id="more"></a><p>[TOC]</p><h1 id="四层负载均衡-vs-七层负载均衡"><a href="#四层负载均衡-vs-七层负载均衡" class="headerlink" title="四层负载均衡 vs 七层负载均衡"></a>四层负载均衡 vs 七层负载均衡</h1><h2 id="四层负载均衡（目标地址和端口交换）"><a href="#四层负载均衡（目标地址和端口交换）" class="headerlink" title="四层负载均衡（目标地址和端口交换）"></a>四层负载均衡（目标地址和端口交换）</h2><p>主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>以常见的 TCP 为例，负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有：</p><p>F5：硬件负载均衡器，功能很好，但是成本很高。</p><p>lvs：重量级的四层负载软件。</p><p>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。</p><p>haproxy：模拟四层转发，较灵活。</p><h2 id="七层负载均衡（内容交换）"><a href="#七层负载均衡（内容交换）" class="headerlink" title="七层负载均衡（内容交换）"></a>七层负载均衡（内容交换）</h2><p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>七层应用负载的好处，是使得整个网络更智能化。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。实现七层负载均衡的软件有：</p><p>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；</p><p>nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多；</p><p>apache：功能较差</p><p>Mysql proxy：功能尚可。</p><h1 id="负载均衡算法-策略"><a href="#负载均衡算法-策略" class="headerlink" title="负载均衡算法/策略"></a>负载均衡算法/策略</h1><h2 id="轮循均衡（Round-Robin）"><a href="#轮循均衡（Round-Robin）" class="headerlink" title="轮循均衡（Round Robin）"></a>轮循均衡（Round Robin）</h2><p>每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p><h2 id="权重轮循均衡（Weighted-Round-Robin）"><a href="#权重轮循均衡（Weighted-Round-Robin）" class="headerlink" title="权重轮循均衡（Weighted Round Robin）"></a>权重轮循均衡（Weighted Round Robin）</h2><p>根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p><h2 id="随机均衡（Random）"><a href="#随机均衡（Random）" class="headerlink" title="随机均衡（Random）"></a>随机均衡（Random）</h2><p>把来自网络的请求随机分配给内部中的多个服务器。</p><h2 id="权重随机均衡（Weighted-Random）"><a href="#权重随机均衡（Weighted-Random）" class="headerlink" title="权重随机均衡（Weighted Random）"></a>权重随机均衡（Weighted Random）</h2><p>此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。</p><h2 id="响应速度均衡（Response-Time-探测时间）"><a href="#响应速度均衡（Response-Time-探测时间）" class="headerlink" title="响应速度均衡（Response Time 探测时间）"></a>响应速度均衡（Response Time 探测时间）</h2><p>负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</p><h2 id="最少连接数均衡（Least-Connection）"><a href="#最少连接数均衡（Least-Connection）" class="headerlink" title="最少连接数均衡（Least Connection）"></a>最少连接数均衡（Least Connection）</h2><p>最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。</p><h2 id="处理能力均衡（CPU、内存）"><a href="#处理能力均衡（CPU、内存）" class="headerlink" title="处理能力均衡（CPU、内存）"></a>处理能力均衡（CPU、内存）</h2><p>此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。</p><h2 id="DNS-响应均衡（Flash-DNS）"><a href="#DNS-响应均衡（Flash-DNS）" class="headerlink" title="DNS 响应均衡（Flash DNS）"></a>DNS 响应均衡（Flash DNS）</h2><p>在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，则客户端将以最先收到的域名解析IP地址来继续请求服务，而忽略其它的IP地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。</p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>一致性哈希一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><h2 id="IP-地址散列（保证客户端服务器对应关系稳定）"><a href="#IP-地址散列（保证客户端服务器对应关系稳定）" class="headerlink" title="IP 地址散列（保证客户端服务器对应关系稳定）"></a>IP 地址散列（保证客户端服务器对应关系稳定）</h2><p>通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p><h2 id="URL-散列"><a href="#URL-散列" class="headerlink" title="URL 散列"></a>URL 散列</h2><p>通过管理客户端请求 URL 信息的散列，将发送至相同 URL 的请求转发至同一服务器的算法。</p><h1 id="LVS-Linux-Virtual-Servers-Linux-虚拟服务器）"><a href="#LVS-Linux-Virtual-Servers-Linux-虚拟服务器）" class="headerlink" title="LVS (Linux Virtual Servers Linux 虚拟服务器）"></a>LVS (Linux Virtual Servers Linux 虚拟服务器）</h1><h2 id="LVS-原理"><a href="#LVS-原理" class="headerlink" title="LVS 原理"></a>LVS 原理</h2><h3 id="IPVS（IP-Virtual-ServerIP虚拟服务器）"><a href="#IPVS（IP-Virtual-ServerIP虚拟服务器）" class="headerlink" title="IPVS（IP Virtual ServerIP虚拟服务器）"></a>IPVS（IP Virtual ServerIP虚拟服务器）</h3><p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server列表中选取一个服务节点响应用户的请求。在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。</p><p>ipvs ： 工作于内核空间，主要用于使用户定义的策略生效</p><p>ipvsadm : 工作于用户空间，主要用于用户定义和管理集群服务的工具</p><p>ipvs 工作于内核空间的 INPUT 链上，当收到用户请求某集群服务时，经过 PREROUTING 链，经检查本机路由表，送往 INPUT 链；在进入 netfilter 的 INPUT 链时，ipvs 强行将请求报文通过ipvsadm 定义的集群服务策略的路径改为 FORWORD 链，将报文转发至后端真实提供服务的主机。</p><h2 id="LVS-NAT-模式（Network-Address-Translation，网络地址转换）"><a href="#LVS-NAT-模式（Network-Address-Translation，网络地址转换）" class="headerlink" title="LVS NAT 模式（Network Address Translation，网络地址转换）"></a>LVS NAT 模式（Network Address Translation，网络地址转换）</h2><p>①客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP),后面统称为 CIP)，目标地址为 VIP(负载均衡器前端地址，后面统称为 VIP)。</p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。</p><p>③.报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，并将响应报文返还给 LVS。</p><p>④.然后 lvs 将此报文的源地址修改为本机并发送给客户端。</p><p>注意：在 NAT 模式中，Real Server 的网关必须指向 LVS，否则报文无法送达客户端</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1、NAT 技术将请求的报文和响应的报文都需要通过 LB (load balance负载均衡) 进行地址改写，因此网站访问量比较大的时候 LB 负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点</p><p>2、只需要在 LB 上配置一个公网 IP 地址就可以了。</p><p>3、每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。</p><p>4、NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>集群中的物理服务器可以使用任何支持 TCP/IP 操作系统，只有负载均衡器需要一个合法的 IP 地址。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>扩展性有限。当服务器节点（普通 PC 服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！</p><h2 id="LVS-DR-模式（直接路由模式，局域网改写-mac-地址）"><a href="#LVS-DR-模式（直接路由模式，局域网改写-mac-地址）" class="headerlink" title="LVS DR 模式（直接路由模式，局域网改写 mac 地址）"></a>LVS DR 模式（直接路由模式，局域网改写 mac 地址）</h2><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。</p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的源MAC 地址改为自己 DIP 的 MAC 地址，目标 MAC 改为了 RIP 的 MAC 地址，并将此包发送给 RS。</p><p>③.RS 发现请求报文中的目的 MAC 是自己，就会将次报文接收下来，处理完请求报文后，将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。</p><p>注意：需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、通过在调度器 LB 上修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP，目的地址仍然是 VIP 地址。</p><p>2、请求的报文经过调度器，而 RS 响应处理后的报文无需经过调度器 LB，因此并发访问量大时使用效率很高（和 NAT 模式比）</p><p>3、因为 DR 模式是通过 MAC 地址改写机制实现转发，因此所有 RS 节点和调度器 LB 只能在一个局域网里面</p><p>4、RS 主机需要绑定 VIP 地址在 LO 接口（掩码 32 位）上，并且需要配置 ARP 抑制。</p><p>5、RS 节点的默认网关不需要配置成 LB，而是直接配置为上级路由的网关，能让 RS 直接出网就可以。</p><p>6、由于 DR 模式的调度器仅做 MAC 地址的改写，所以调度器 LB 就不能改写目标端口，那么 RS服务器就得使用和 VIP 相同的端口提供服务。</p><p>7、直接对外的业务比如 WEB 等，RS 的 IP 最好是使用公网 IP。对外的服务，比如数据库等最好使用内网 IP。</p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>和 TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与 VS-TUN 相比，VS-DR 这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。</p><p>DR 模式的效率很高，但是配置稍微复杂一点，因此对于访问量不是特别大的公司可以用haproxy/nginx取代。日1000-2000W PV或者并发请求1万一下都可以考虑用haproxy/nginx。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>所有 RS 节点和调度器 LB 只能在一个局域网里面</p><h2 id="LVS-TUN-模式（IP-封装、跨网段）"><a href="#LVS-TUN-模式（IP-封装、跨网段）" class="headerlink" title="LVS TUN 模式（IP 封装、跨网段）"></a>LVS TUN 模式（IP 封装、跨网段）</h2><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。</p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为 DIP，目标地址改为 RIP,并将此包发送给 RS。</p><p>③.RS 收到请求报文后，会首先拆开第一层封装,然后发现里面还有一层 IP 首部的目标地址是自己lo 接口上的 VIP，所以会处理次请求报文，并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。</p><p>注意：需要设置 lo 接口的 VIP 不能在公网上出现。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>1.TUNNEL 模式必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址</p><p>2.TUNNEL 模式的 vip ——&gt;realserver 的包通信通过 TUNNEL 模式，不管是内网和外网都能通信，所以不需要 lvs vip 跟 realserver 在同一个网段内。</p><p>3.TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了</p><p>4.TUNNEL 模式走的隧道模式，所以运维起来比较难，所以一般不用。</p><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><p>负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。</p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分 Linux 系统上。</p><h2 id="LVS-FULLNAT-模式"><a href="#LVS-FULLNAT-模式" class="headerlink" title="LVS FULLNAT 模式"></a>LVS FULLNAT 模式</h2><p>无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则LVS 无法作为 RS 的网关。这引发的两个问题是：</p><p>1、同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。</p><p>2、LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。</p><p>Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题，而跨 VLAN 问题解决后，LVS 和 RS不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。</p><p>Full-NAT 相比 NAT 的主要改进是，在 SNAT/DNAT 的基础上，加上另一种转换，转换过程如下：</p><ol><li>在包从 LVS 转到 RS 的过程中，源地址从客户端 IP 被替换成了 LVS 的内网 IP。内网 IP 之间可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.</li><li>当 RS 处理完接受到的包，处理完成后返回时，将目标地址修改为 LVS ip，原地址修改为 RSIP，最终将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。</li><li>LVS 收到包后，在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP,并将原地址修改为 VIP。</li></ol><p>Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段；</p></li><li><p>full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10%</p></li></ol><h1 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a>Keepalive</h1><p>keepalive 起初是为 LVS 设计的，专门用来监控lvs各个服务节点的状态，后来加入了vrrp的功能，因此除了lvs，也可以作为其他服务（nginx，haproxy）的高可用软件。VRRP 是 virtual router redundancy protocal（虚拟路由器冗余协议）的缩写。VRRP 的出现就是为了解决静态路由出现的单点故障，它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVS cluster node healthcheck 功能，另一方面也具有 LVS director failover。</p><h1 id="Nginx-反向代理负载均衡"><a href="#Nginx-反向代理负载均衡" class="headerlink" title="Nginx 反向代理负载均衡"></a>Nginx 反向代理负载均衡</h1><p>普通的负载均衡软件，如 LVS，其实现的功能只是对请求数据包的转发、传递，从负载均衡下的节点服务器来看，接收到的请求还是来自访问负载均衡器的客户端的真实用户；而反向代理就不一样了，反向代理服务器在接收访问用户请求后，会代理用户重新发起请求代理下的节点服务器，最后把数据返回给客户端用户。在节点服务器看来，访问的节点服务器的客户端用户就是反向代理服务器，而非真实的网站访问用户。</p><h2 id="upstream-module-和健康检测"><a href="#upstream-module-和健康检测" class="headerlink" title="upstream_module 和健康检测"></a>upstream_module 和健康检测</h2><p>ngx_http_upstream_module 是负载均衡模块，可以实现网站的负载均衡功能即节点的健康检查，upstream模块允许Nginx定义一组或多组节点服务器组，使用时可通过 proxy_pass 代理方式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。</p><h2 id="proxy-pass-请求转发"><a href="#proxy-pass-请求转发" class="headerlink" title="proxy_pass 请求转发"></a>proxy_pass 请求转发</h2><p>proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，在实际的反向代理工作中，会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的请求通过 proyx_pass 抛给定义好的 upstream 节点池。</p><h1 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带&lt;br&gt;宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>686. 重复叠加字符串匹配</title>
    <link href="http://yoursite.com/2022/01/05/686.%20%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2022/01/05/686. 重复叠加字符串匹配/</id>
    <published>2022-01-05T08:12:12.000Z</published>
    <updated>2022-01-05T09:34:24.958Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</p><a id="more"></a><p>[TOC]</p><p>注意：字符串 “abc” 重复叠加 0 次是 “”，重复叠加 1 次是 “abc”，重复叠加 2 次是 “abcabc”。</p><p>示例 1：</p><pre><code>输入：a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;输出：3解释：a 重复叠加三遍后为 &quot;abcdabcdabcd&quot;, 此时 b 是其子串。</code></pre><p>示例 2：</p><pre><code>输入：a = &quot;a&quot;, b = &quot;aa&quot;输出：2</code></pre><p>示例 3：</p><pre><code>输入：a = &quot;a&quot;, b = &quot;a&quot;输出：1</code></pre><p>示例 4：</p><pre><code>输入：a = &quot;abc&quot;, b = &quot;wxyz&quot;输出：-1</code></pre><p>提示：</p><pre><code>1 &lt;= a.length &lt;= 1041 &lt;= b.length &lt;= 104a 和 b 由小写英文字母组成</code></pre><h1 id="方法一：Rabin-Karp-算法-1"><a href="#方法一：Rabin-Karp-算法-1" class="headerlink" title="方法一：Rabin-Karp 算法^1"></a>方法一：Rabin-Karp 算法<a href="https://leetcode-cn.com/problems/repeated-string-match/solution/zhong-fu-die-jia-zi-fu-chuan-pi-pei-by-l-vnye/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k2 = <span class="number">1337</span>;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> kMod1 = rand() % k1 + k1;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> kMod2 = rand() % k2 + k2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> hash_needle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : needle) &#123;</span><br><span class="line">            hash_needle = (hash_needle * kMod2 + c) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> hash_haystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            extra = (extra * kMod2) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            <span class="keyword">if</span> (hash_haystack == hash_needle) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash_haystack = (hash_haystack - extra * haystack[(i - m + <span class="number">1</span>) % n]) % kMod1;</span><br><span class="line">            hash_haystack = (hash_haystack + kMod1) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.size(), bn = b.size();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> kMod1 = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> kMod2 = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.length(), bn = b.length();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">1000000009</span>;</span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">1337</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> kMod1 = random.nextInt(k1) + k1;</span><br><span class="line">        <span class="keyword">int</span> kMod2 = random.nextInt(k2) + k2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> hashNeedle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = needle.charAt(i);</span><br><span class="line">            hashNeedle = (hashNeedle * kMod2 + c) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> hashHaystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;</span><br><span class="line">            extra = (extra * kMod2) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;</span><br><span class="line">            <span class="keyword">if</span> (hashHaystack == hashNeedle) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashHaystack = (hashHaystack - extra * haystack.charAt((i - m + <span class="number">1</span>) % n)) % kMod1;</span><br><span class="line">            hashHaystack = (hashHaystack + kMod1) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RepeatedStringMatch(string a, string b) &#123;</span><br><span class="line">        int an = a.Length, bn = b.Length;</span><br><span class="line">        int index = StrStr(a, b);</span><br><span class="line">        if (index == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (an - index &gt;= bn) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (bn + index - an - 1) / an + 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int StrStr(string haystack, string needle) &#123;</span><br><span class="line">        int n = haystack.Length, m = needle.Length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int k1 = 1000000009;</span><br><span class="line">        int k2 = 1337;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        int kMod1 = random.Next(k1, k1 * 2);</span><br><span class="line">        int kMod2 = random.Next(k2, k2 * 2);</span><br><span class="line"></span><br><span class="line">        long hashNeedle = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            char c = needle[i];</span><br><span class="line">            hashNeedle = (hashNeedle * kMod2 + c) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        long hashHaystack = 0, extra = 1;</span><br><span class="line">        for (int i = 0; i &lt; m - 1; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            extra = (extra * kMod2) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = m - 1; (i - m + 1) &lt; n; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            if (hashHaystack == hashNeedle) &#123;</span><br><span class="line">                return i - m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            hashHaystack = (hashHaystack - extra * haystack[(i - m + 1) % n]) % kMod1;</span><br><span class="line">            hashHaystack = (hashHaystack + kMod1) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span> *haystack, <span class="keyword">int</span> n, <span class="keyword">char</span> *needle, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k2 = <span class="number">1337</span>;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> kMod1 = rand() % k1 + k1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> kMod2 = rand() % k2 + k2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> hash_needle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        hash_needle = (hash_needle * kMod2 + needle[i]) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> hash_haystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">        extra = (extra * kMod2) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">        hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">        <span class="keyword">if</span> (hash_haystack == hash_needle) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_haystack = (hash_haystack - extra * haystack[(i - m + <span class="number">1</span>) % n]) % kMod1;</span><br><span class="line">        hash_haystack = (hash_haystack + kMod1) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="keyword">char</span> * a, <span class="keyword">char</span> * b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> an = <span class="built_in">strlen</span>(a), bn = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">int</span> index = strStr(a, an, b, bn);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> k1 <span class="keyword">int</span> = <span class="number">1000000000</span> + <span class="number">7</span></span><br><span class="line">    <span class="keyword">var</span> k2 <span class="keyword">int</span> = <span class="number">1337</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> kMod1 <span class="keyword">int64</span> = <span class="keyword">int64</span>(rand.Intn(k1)) + <span class="keyword">int64</span>(k1)</span><br><span class="line">    <span class="keyword">var</span> kMod2 <span class="keyword">int64</span> = <span class="keyword">int64</span>(rand.Intn(k2)) + <span class="keyword">int64</span>(k2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hash_needle <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        hash_needle = (hash_needle*kMod2 + <span class="keyword">int64</span>(needle[i])) % kMod1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hash_haystack <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> extra <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        hash_haystack = (hash_haystack*kMod2 + <span class="keyword">int64</span>(haystack[i%n])) % kMod1</span><br><span class="line">        extra = (extra * kMod2) % kMod1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++ &#123;</span><br><span class="line">        hash_haystack = (hash_haystack*kMod2 + <span class="keyword">int64</span>(haystack[i%n])) % kMod1</span><br><span class="line">        <span class="keyword">if</span> hash_haystack == hash_needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        hash_haystack = (hash_haystack - extra*<span class="keyword">int64</span>(haystack[(i-m+<span class="number">1</span>)%n])) % kMod1</span><br><span class="line">        hash_haystack = (hash_haystack + kMod1) % kMod1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedStringMatch</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    an, bn := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">    index := strStr(a, b)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> an-index &gt;= bn &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn+index-an<span class="number">-1</span>)/an + <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeatedStringMatch = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> an = a.length, bn = b.length;</span><br><span class="line">    <span class="keyword">const</span> index = strStr(a, b);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor((bn + index - an - <span class="number">1</span>) / an) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strStr = <span class="function">(<span class="params">haystack, needle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = haystack.length, m = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> k1 = <span class="number">1000000009</span>;</span><br><span class="line">    <span class="keyword">let</span> k2 = <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">let</span> kMod1 = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * k1) + k1;</span><br><span class="line">    <span class="keyword">let</span> kMod2 = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * k2) + k2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hashNeedle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = needle[i].charCodeAt();</span><br><span class="line">        hashNeedle = (hashNeedle * kMod2 + c) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> hashHaystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        hashHaystack = (hashHaystack * kMod2 + haystack[i % n].charCodeAt()) % kMod1;</span><br><span class="line">        extra = (extra * kMod2) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">        hashHaystack = (hashHaystack * kMod2 + haystack[i % n].charCodeAt()) % kMod1;</span><br><span class="line">        <span class="keyword">if</span> (hashHaystack === hashNeedle) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashHaystack = (hashHaystack - extra * haystack[(i - m + <span class="number">1</span>) % n].charCodeAt()) % kMod1;</span><br><span class="line">        hashHaystack = (hashHaystack + kMod1) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strstr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        k1 = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        k2 = <span class="number">1337</span></span><br><span class="line">        mod1 = randrange(k1) + k1</span><br><span class="line">        mod2 = randrange(k2) + k2</span><br><span class="line"></span><br><span class="line">        hash_needle = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> needle:</span><br><span class="line">            hash_needle = (hash_needle * mod2 + ord(c)) % mod1</span><br><span class="line">        hash_haystack = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>):</span><br><span class="line">            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1</span><br><span class="line">        extra = pow(mod2, m - <span class="number">1</span>, mod1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, n + m - <span class="number">1</span>):</span><br><span class="line">            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1</span><br><span class="line">            <span class="keyword">if</span> hash_haystack == hash_needle:</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">            hash_haystack = (hash_haystack - extra * ord(haystack[(i - m + <span class="number">1</span>) % n])) % mod1</span><br><span class="line">            hash_haystack = (hash_haystack + mod1) % mod1</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedStringMatch</span><span class="params">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(a), len(b)</span><br><span class="line">        index = self.strstr(a, b)</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n - index &gt;= m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (m + index - n - <span class="number">1</span>) // n + <span class="number">2</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)</em>, 其中 <em>n</em> 为 <em>a</em> 的长度，<em>m</em> 为 <em>b</em> 的长度。Rabin-Karp 算法的时间复杂度为 <em>O(n + m)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。只需要常数空间保存参数。</p></li></ul><h1 id="方法二：Knuth-Morris-Pratt-算法"><a href="#方法二：Knuth-Morris-Pratt-算法" class="headerlink" title="方法二：Knuth-Morris-Pratt 算法"></a>方法二：Knuth-Morris-Pratt 算法</h1><p><strong>前言</strong></p><p>关于 Knuth-Morris-Pratt 算法的具体实现，读者可以参阅官方题解「<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/" target="_blank" rel="noopener">28. 实现 strStr()</a>」，笔者就不作详细介绍了。</p><p><strong>思路与算法</strong></p><p>类似于方法一，我们也可以使用 Knuth-Morris-Pratt 算法来实现字符串匹配的功能。在应用 Knuth-Morris-Pratt 算法时，被匹配字符串是循环叠加的字符串，所以下标要进行取余操作，并且匹配终止的条件为 <em>b</em> 开始匹配的位置超过第一个叠加的 <em>a</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> &amp;haystack, <span class="built_in">string</span> &amp;needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pi(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] != needle[j]) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.size(), bn = b.size();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.length(), bn = b.length();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] pi = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i % n) != needle.charAt(j)) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i % n) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RepeatedStringMatch(string a, string b) &#123;</span><br><span class="line">        int an = a.Length, bn = b.Length;</span><br><span class="line">        int index = StrStr(a, b);</span><br><span class="line">        if (index == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (an - index &gt;= bn) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (bn + index - an - 1) / an + 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int StrStr(string haystack, string needle) &#123;</span><br><span class="line">        int n = haystack.Length, m = needle.Length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] pi = new int[m];</span><br><span class="line">        for (int i = 1, j = 0; i &lt; m; i++) &#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0, j = 0; i - j &lt; n; i++) &#123; // b 开始匹配的位置是否超过第一个叠加的 a</span><br><span class="line">            while (j &gt; 0 &amp;&amp; haystack[i % n] != needle[j]) &#123; // haystack 是循环叠加的字符串，所以取 i % n</span><br><span class="line">                j = pi[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == m) &#123;</span><br><span class="line">                return i - m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span> * haystack, <span class="keyword">int</span> n, <span class="keyword">char</span> * needle, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pi[m];</span><br><span class="line">    pi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] != needle[j]) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="keyword">char</span> * a, <span class="keyword">char</span> * b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> an = <span class="built_in">strlen</span>(a), bn = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">int</span> index = strStr(a, an, b, bn);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    pi := <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j] &#123;</span><br><span class="line">            j = pi[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> needle[i] == needle[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i-j &lt; n; i++ &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; haystack[i%n] != needle[j] &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">            j = pi[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> haystack[i%n] == needle[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == m &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedStringMatch</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    an, bn := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">    index := strStr(a, b)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> an-index &gt;= bn &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn+index-an<span class="number">-1</span>)/an + <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeatedStringMatch = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> an = a.length, bn = b.length;</span><br><span class="line">    <span class="keyword">const</span> index = strStr(a, b);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor((bn + index - an - <span class="number">1</span>) / an) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strStr = <span class="function">(<span class="params">haystack, needle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = haystack.length, m = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> pi = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] !== needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] === needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] !== needle[j]) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strstr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        pi = [<span class="number">0</span>] * m</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = pi[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            pi[i] = j</span><br><span class="line"></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i - j &lt; n:</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i % n] != needle[j]:</span><br><span class="line">                j = pi[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i % n] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == m:</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedStringMatch</span><span class="params">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(a), len(b)</span><br><span class="line">        index = self.strstr(a, b)</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n - index &gt;= m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (m + index - n - <span class="number">1</span>) // n + <span class="number">2</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)*，其中 *n</em> 为 <em>a</em> 的长度，<em>m</em> 为 <em>b</em> 的长度。Knuth-Morris-Pratt 算法的时间复杂度为 <em>O(n + m)</em>。</p></li><li><p>空间复杂度：<em>O(m)*。Knuth-Morris-Pratt 算法需要 *O(m)</em> 的空间来保存pi 数组。</p></li></ul><h1 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h1><p>一个完整的字符串s最终是要包含b的，所以a在只能有以下几种情况：</p><p>b出现了a中没有的字符，返回-1；</p><p>b和a包含的字符是一致的，此时又分为：</p><p>情况1：a = ‘abc’, b = ‘ab’，此时无需重复a，返回初始字符串；</p><p>情况2：a = ‘abcd’, b = ‘cdabcdab’，此时对a重复，返回重复的字符串，因为最差情况下b必然是起始使用了a的一部分，结尾使用了a的一部分；<br>可以使用repeat函数，计算初始要重复的次数ret = b.len() / a.len()，得出中间填充a的个数，情况一被规避，然后再分别在左、右添加一个a，情况2被规避。</p><details>    <summary>Go</summary><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedStringMatch</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">m, n, exist := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b), <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> a &#123;</span><br><span class="line">exist[ch-<span class="string">'a'</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> b &#123;</span><br><span class="line"><span class="keyword">if</span> !(exist[ch-<span class="string">'a'</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := n / m</span><br><span class="line">str := strings.Repeat(a, ret)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(str, b) &#123;</span><br><span class="line"><span class="keyword">return</span> ret + i</span><br><span class="line">&#125;</span><br><span class="line">str += a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span>[] exist = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : a.toCharArray()) &#123;</span><br><span class="line">exist[ch - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : b.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!exist[ch - <span class="string">'a'</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = b.length() / a.length();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(a.repeat(ret));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sb.toString().contains(b)) &#123;</span><br><span class="line"><span class="keyword">return</span> ret + i;</span><br><span class="line">&#125;</span><br><span class="line">sb.append(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="String Matching" scheme="http://yoursite.com/tags/String-Matching/"/>
    
      <category term="KMP Algorithm" scheme="http://yoursite.com/tags/KMP-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Cassandra）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Cassandra%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（Cassandra）/</id>
    <published>2022-01-05T08:12:12.000Z</published>
    <updated>2022-01-05T12:51:48.440Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL（non-relationa非关系型）数据库。Cassandra旨在处理多商品服务器上的大量数据，提供高可用性而无需担心单点故障。</p><a id="more"></a><p>[TOC]</p><p>此篇有很多细节讲的不够清楚，看的有些迷糊。如果需要进一步学习还需要再看其它资料。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="Key-Space（对应-SQL-数据库中的-database）"><a href="#Key-Space（对应-SQL-数据库中的-database）" class="headerlink" title="Key Space（对应 SQL 数据库中的 database）"></a>Key Space（对应 SQL 数据库中的 database）</h2><ol><li>一个 Key Space 中可包含若干个 CF，如同 SQL 数据库中一个 database 可包含多个 table</li></ol><h2 id="Key（对应-SQL-数据库中的主键）"><a href="#Key（对应-SQL-数据库中的主键）" class="headerlink" title="Key（对应 SQL 数据库中的主键）"></a>Key（对应 SQL 数据库中的主键）</h2><ol start="2"><li>在 Cassandra 中，每一行数据记录是以 key/value 的形式存储的，其中 key 是唯一标识。</li></ol><h2 id="column（对应-SQL-数据库中的列）"><a href="#column（对应-SQL-数据库中的列）" class="headerlink" title="column（对应 SQL 数据库中的列）"></a>column（对应 SQL 数据库中的列）</h2><ol start="3"><li>Cassandra 中每个 key/value 对中的 value 又称为 column，它是一个三元组，即：name，value 和 timestamp，其中 name 需要是唯一的。</li></ol><h2 id="super-column（SQL-数据库不支持）"><a href="#super-column（SQL-数据库不支持）" class="headerlink" title="super column（SQL 数据库不支持）"></a>super column（SQL 数据库不支持）</h2><ol start="4"><li>cassandra 允许 key/value 中的 value 是一个 map(key/value_list)，即某个 column 有多个子列。</li></ol><h2 id="Standard-Column-Family（相对应-SQL-数据库中的-table）"><a href="#Standard-Column-Family（相对应-SQL-数据库中的-table）" class="headerlink" title="Standard Column Family（相对应 SQL 数据库中的 table）"></a>Standard Column Family（相对应 SQL 数据库中的 table）</h2><ol start="5"><li>每个 CF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 column。</li></ol><h2 id="Super-Column-Family（SQL-数据库不支持）"><a href="#Super-Column-Family（SQL-数据库不支持）" class="headerlink" title="Super Column Family（SQL 数据库不支持）"></a>Super Column Family（SQL 数据库不支持）</h2><ol start="6"><li>每个 SCF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 super column</li></ol><h1 id="Cassandra-一致-Hash-和虚拟节点"><a href="#Cassandra-一致-Hash-和虚拟节点" class="headerlink" title="Cassandra 一致 Hash 和虚拟节点"></a>Cassandra 一致 Hash 和虚拟节点</h1><h2 id="一致性-Hash（多米诺-down-机）"><a href="#一致性-Hash（多米诺-down-机）" class="headerlink" title="一致性 Hash（多米诺 down 机）"></a>一致性 Hash（多米诺 down 机）</h2><p>为每个节点分配一个 token，根据这个 token 值来决定节点在集群中的位置以及这个节点所存储的数据范围。</p><h2 id="虚拟节点（down-机多节点托管）"><a href="#虚拟节点（down-机多节点托管）" class="headerlink" title="虚拟节点（down 机多节点托管）"></a>虚拟节点（down 机多节点托管）</h2><p>由于这种方式会造成数据分布不均的问题，在 Cassandra1.2 以后采用了虚拟节点的思想：不需要为每个节点分配token，把圆环分成更多部分，让每个节点负责多个部分的数据，这样一个节点移除后，它所负责的多个 token 会托管给多个节点处理，这种思想解决了数据分布不均的问题。</p><p>如图所示，上面部分是标准一致性哈希，每个节点负责圆环中连续的一段，如果 Node2 突然down 掉，Node2 负责的数据托管给 Node1，即 Node1 负责 EFAB 四段，如果 Node1 里面有很多热点用户产生的数据导致 Node1 已经有点撑不住了，恰巧 B 也是热点用户产生的数据，这样一来 Node1 可能会接着 down 机，Node1down 机，Node6 还 hold 住吗？</p><p>下面部分是虚拟节点实现，每个节点不再负责连续部分，且圆环被分为更多的部分。如果 Node2突然 down 掉，Node2 负责的数据不全是托管给 Node1，而是托管给多个节点。而且也保持了一致性哈希的特点。</p><h1 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h1><p>Gossip 算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此 Gossip 有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。Gossip的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。因为Gossip不要求节点知道所有其他节点，因此又具有去中心化的特点，节点之间完全对等，不需要任何的中心节点。实际上 Gossip 可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。</p><h2 id="Gossip-节点的通信方式及收敛性"><a href="#Gossip-节点的通信方式及收敛性" class="headerlink" title="Gossip 节点的通信方式及收敛性"></a>Gossip 节点的通信方式及收敛性</h2><h3 id="Gossip-两个节点（A、B）之间存在三种通信方式（push、pull、push-amp-pull）"><a href="#Gossip-两个节点（A、B）之间存在三种通信方式（push、pull、push-amp-pull）" class="headerlink" title="Gossip 两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）"></a>Gossip 两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）</h3><ol><li>push: A 节点将数据(key,value,version)及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。</li><li>pull：A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据（Key,value,version）推送给 A，A 更新本地。</li><li>push/pull：与 pull 类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地。</li></ol><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push 需通信 1 次，pull 需 2 次，push/pull 则需 3 次，从效果上来讲，push/pull 最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull 的收敛速度是最快的。</p><h3 id="gossip-的协议和-seed-list（防止集群分列）"><a href="#gossip-的协议和-seed-list（防止集群分列）" class="headerlink" title="gossip 的协议和 seed list（防止集群分列）"></a>gossip 的协议和 seed list（防止集群分列）</h3><p>cassandra 使用称为 gossip 的协议来发现加入C集群中的其他节点的位置和状态信息。gossip进程每秒都在进行，并与至多三个节点交换状态信息。节点交换他们自己和所知道的信息，于是所有的节点很快就能学习到整个集群中的其他节点的信息。gossip 信息有一个相关的版本号，于是在一次 gossip 信息交换中，旧的信息会被新的信息覆盖重写。要阻止分区进行gossip交流，那么在集群中的所有节点中使用相同的 seed list，种子节点的指定除了启动起gossip进程外，没有其他的目的。种子节点不是一个单点故障，他们在集群操作中也没有其他的特殊目的，除了引导节点以外</p><h1 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h1><h2 id="Partitioners（计算-primary-key-token-的-hash-函数）"><a href="#Partitioners（计算-primary-key-token-的-hash-函数）" class="headerlink" title="Partitioners（计算 primary key token 的 hash 函数）"></a>Partitioners（计算 primary key token 的 hash 函数）</h2><p>在 Cassandra 中，table 的每行由唯一的 primarykey 标识，partitioner 实际上为一 hash 函数用以计算 primary key 的 token。Cassandra 依据这个 token 值在集群中放置对应的行</p><h2 id="两种可用的复制策略："><a href="#两种可用的复制策略：" class="headerlink" title="两种可用的复制策略："></a>两种可用的复制策略：</h2><h3 id="SimpleStrategy：仅用于单数据中心，"><a href="#SimpleStrategy：仅用于单数据中心，" class="headerlink" title="SimpleStrategy：仅用于单数据中心，"></a>SimpleStrategy：仅用于单数据中心，</h3><p>将第一个 replica 放在由 partitioner 确定的节点中，其余的 replicas 放在上述节点顺时针方向的后续节点中。</p><h3 id="NetworkTopologyStrategy：可用于较复杂的多数据中心。"><a href="#NetworkTopologyStrategy：可用于较复杂的多数据中心。" class="headerlink" title="NetworkTopologyStrategy：可用于较复杂的多数据中心。"></a>NetworkTopologyStrategy：可用于较复杂的多数据中心。</h3><p>可以指定在每个数据中心分别存储多少份 replicas。</p><p>复制策略在创建 keyspace 时指定，如</p><pre><code>CREATE KEYSPACE Excelsior WITH REPLICATION = { &apos;class&apos; :&apos;SimpleStrategy&apos;,&apos;replication_factor&apos; : 3 };CREATE KEYSPACE Excalibur WITH REPLICATION = {&apos;class&apos; :&apos;NetworkTopologyStrategy&apos;,&apos;dc1&apos; : 3, &apos;dc2&apos; : 2};</code></pre><h1 id="数据写请求和协调者"><a href="#数据写请求和协调者" class="headerlink" title="数据写请求和协调者"></a>数据写请求和协调者</h1><h2 id="协调者-coordinator"><a href="#协调者-coordinator" class="headerlink" title="协调者(coordinator)"></a>协调者(coordinator)</h2><p>协调者(coordinator)将 write 请求发送到拥有对应 row 的所有 replica 节点，只要节点可用便获取并执行写请求。写一致性级别(write consistency level)确定要有多少个 replica 节点必须返回成功的确认信息。成功意味着数据被正确写入了 commit log 和 memtable。</p><p>其中 dc1、dc2 这些数据中心名称要与 snitch 中配置的名称一致.上面的拓扑策略表示在 dc1 配置3 个副本,在 dc2 配置 2 个副本</p><h1 id="数据读请求和后台修复"><a href="#数据读请求和后台修复" class="headerlink" title="数据读请求和后台修复"></a>数据读请求和后台修复</h1><ol><li><p>协调者首先与一致性级别确定的所有 replica 联系，被联系的节点返回请求的数据。</p></li><li><p>若多个节点被联系，则来自各 replica 的 row 会在内存中作比较，若不一致，则协调者使用含最新数据的 replica 向 client 返回结果。那么比较操作过程中只需要传递时间戳就可以,因为要比较的只是哪个副本数据是最新的。</p></li><li><p>协调者在后台联系和比较来自其余拥有对应 row 的 replica 的数据，若不一致，会向过时的replica 发写请求用最新的数据进行更新 read repair。</p></li></ol><h1 id="数据存储（CommitLog、MemTable、SSTable）"><a href="#数据存储（CommitLog、MemTable、SSTable）" class="headerlink" title="数据存储（CommitLog、MemTable、SSTable）"></a>数据存储（CommitLog、MemTable、SSTable）</h1><p>写请求分别到 CommitLog 和 MemTable, 并且 MemTable 的数据会刷写到磁盘 SSTable 上. 除了写数据,还有索引也会保存到磁盘上.</p><p>先将数据写到磁盘中的 commitlog，同时追加到中内存中的数据结构 memtable 。这个时候就会返回客户端状态 ， memtable 内 容 超 出 指 定 容 量 后 会 被 放 进 将 被 刷 入 磁 盘 的 队 列(memtable_flush_queue_size 配置队列长度)。若将被刷入磁盘的数据超出了队列长度，将内存<br>数据刷进磁盘中的 SSTable,之后 commit log 被清空。</p><h2 id="SSTable-文件构成（BloomFilter、index、data、static）"><a href="#SSTable-文件构成（BloomFilter、index、data、static）" class="headerlink" title="SSTable 文件构成（BloomFilter、index、data、static）"></a>SSTable 文件构成（BloomFilter、index、data、static）</h2><p>SSTable 文件有 fileer（判断数据 key 是否存在，这里使用了BloomFilter提高效率），index（寻找对应column值所在data文件位置）文件，data（存储真实数据）文件，static（存储和统计column 和 row 大小）文件。</p><h1 id="二级索引（对要索引的-value-摘要，生成-RowKey）"><a href="#二级索引（对要索引的-value-摘要，生成-RowKey）" class="headerlink" title="二级索引（对要索引的 value 摘要，生成 RowKey）"></a>二级索引（对要索引的 value 摘要，生成 RowKey）</h1><p>在 Cassandra 中，数据都是以 Key-value 的形式保存的。</p><p>KeysIndex 所创建的二级索引也被保存在一张 ColumnFamily 中。在插入数据时，对需要进行索引的 value进行摘要，生成独一无二的key，将其作为 RowKey保存在索引的 ColumnFamily 中；</p><p>同时在 RowKey 上添加一个 Column，将插入数据的 RowKey 作为 name 域的值，value 域则赋空值，timestamp 域则赋为插入数据的时间戳。</p><p>如果有相同的 value 被索引了，则会在索引 ColumnFamily 中相同的 RowKey 后再添加新的Column。如果有新的 value 被索引，则会在索引 ColumnFamily 中添加新的 RowKey 以及对应新的 Column。</p><p>当对 value 进行查询时，只需计算该 value 的 RowKey，在索引 ColumnFamily 中的查找该RowKey，对其 Columns 进行遍历就能得到该 value 所有数据的 RowKey。</p><h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="数据写入和更新（数据追加）"><a href="#数据写入和更新（数据追加）" class="headerlink" title="数据写入和更新（数据追加）"></a>数据写入和更新（数据追加）</h2><p>Cassandra 的设计思路与这些系统不同，无论是 insert 还是 remove 操作，都是在已有的数据后面进行追加，而不修改已有的数据。这种设计称为 Log structured 存储，顾名思义就是系统中的数据是以日志的形式存在的，所以只会将新的数据追加到已有数据的后面。Log structured 存储</p><p>系统有两个主要优点：</p><h2 id="数据的写和删除效率极高"><a href="#数据的写和删除效率极高" class="headerlink" title="数据的写和删除效率极高"></a>数据的写和删除效率极高</h2><p> 传统的存储系统需要更新元信息和数据，因此磁盘的磁头需要反复移动，这是一个比较耗时的操作，而 Log structured的系统则是顺序写，可以充分利用文件系统的 cache，所以效率很高。</p><h2 id="错误恢复简单"><a href="#错误恢复简单" class="headerlink" title="错误恢复简单"></a>错误恢复简单</h2><p> 由于数据本身就是以日志形式保存，老的数据不会被覆盖，所以在设计 journal 的时候不需要考虑 undo，简化了错误恢复。</p><h2 id="读的复杂度高"><a href="#读的复杂度高" class="headerlink" title="读的复杂度高"></a>读的复杂度高</h2><p> 但是，Log structured 的存储系统也引入了一个重要的问题：读的复杂度和性能。理论上说，读操作需要从后往前扫描数据，以找到某个记录的最新版本。相比传统的存储系统，这是比较耗时的。</p><p>参考：<a href="https://blog.csdn.net/fs1360472174/article/details/55005335" target="_blank" rel="noopener">https://blog.csdn.net/fs1360472174/article/details/55005335</a></p><h2 id="数据删除（column-的墓碑）"><a href="#数据删除（column-的墓碑）" class="headerlink" title="数据删除（column 的墓碑）"></a>数据删除（column 的墓碑）</h2><p>如果一次删除操作在一个节点上失败了（总共 3 个节点，副本为 3， RF=3).整个删除操作仍然被认为成功的（因为有两个节点应答成功，使用 CL.QUORUM 一致性）。接下来如果读发生在该节点上就会变的不明确，因为结果返回是空，还是返回数据，没有办法确定哪一种是正确的。</p><p>Cassandra 总是认为返回数据是对的，那就会发生删除的数据又出现了的事情，这些数据可以叫”僵尸”，并且他们的表现是不可预见的。</p><h2 id="墓碑"><a href="#墓碑" class="headerlink" title="墓碑"></a>墓碑</h2><p>删除一个 column 其实只是插入一个关于这个 column 的墓碑（tombstone），并不直接删除原有的 column。该墓碑被作为对该 CF 的一次修改记录在 Memtable 和 SSTable 中。墓碑的内容是删除请求被执行的时间，该时间是接受客户端请求的存储节点在执行该请求时的本地时间（local delete time），称为本地删除时间。需要注意区分本地删除时间和时间戳，每个 CF 修改记录都有一个时间戳，这个时间戳可以理解为该 column 的修改时间，是由客户端给定的。</p><h2 id="垃圾回收-compaction"><a href="#垃圾回收-compaction" class="headerlink" title="垃圾回收 compaction"></a>垃圾回收 compaction</h2><p>由于被删除的 column 并不会立即被从磁盘中删除，所以系统占用的磁盘空间会越来越大，这就需要有一种垃圾回收的机制，定期删除被标记了墓碑的 column。垃圾回收是在 compaction 的过程中完成的。</p><h2 id="数据读取（memtable-SStables）"><a href="#数据读取（memtable-SStables）" class="headerlink" title="数据读取（memtable+SStables）"></a>数据读取（memtable+SStables）</h2><p>为了满足读 cassandra 读取的数据是 memtable 中的数据和 SStables 中数据的合并结果。读取SSTables 中的数据就是查找到具体的哪些的 SSTables 以及数据在这些 SSTables 中的偏移量(SSTables 是按主键排序后的数据块)。首先如果 row cache enable 了话，会检测缓存。缓存命中<br>直接返回数据，没有则查找 Bloom filter，查找可能的 SSTable。然后有一层 Partition key cache，找 partition key 的位置。如果有根据找到的 partition 去压缩偏移量映射表找具体的数据块。如果缓存没有，则要经过 Partition summary,Partition index 去找 partition key。然后经过压缩偏移<br>量映射表找具体的数据块。</p><ol><li>检查 memtable</li><li>如果 enabled 了,检查 row cache</li><li>检查 Bloom filter</li><li>如果 enable 了,检查 partition key 缓存</li><li>如果在 partition key 缓存中找到了 partition key,直接去 compression offset 命中，如果没<br>有，检查 partition summary</li><li>根据 compression offset map 找到数据位置</li><li>从磁盘的 SSTable 中取出数据</li></ol><p>MemTable：如果 memtable 有目标分区数据，这个数据会被读出来并且和从 SSTables 中读出来的数据进行合并。SSTable 的数据访问如下面所示的步骤。</p><h2 id="Row-Cache（SSTables-中频繁被访问的数据）"><a href="#Row-Cache（SSTables-中频繁被访问的数据）" class="headerlink" title="Row Cache（SSTables 中频繁被访问的数据）"></a>Row Cache（SSTables 中频繁被访问的数据）</h2><p>在 Cassandra2.2+，它们被存储在堆外内存，使用全新的实现避免造成垃圾回收对 JVM 造成压力。存在在 row cache 的子集数据可以在特定的一段时间内配置一定大小的内存。row cache 使用LRU(least-recently-userd)进行回收在申请内存。存储在 row cache 中的数据是 SSTables 中频繁被访问的数据。存储到row cache中后，数据就可以被后续的查询访问。row cache不是写更新。如果写某行了，这行的缓存就会失效，并且不会被继续缓存，直到这行被读到。类似的，如果一个partition更新了，整个partition的cache都会被移除，但目标的数据在row cache中找不到，就会去检查 Bloom filter。</p><h2 id="Bloom-Filter（查找数据可能对应的-SSTable）"><a href="#Bloom-Filter（查找数据可能对应的-SSTable）" class="headerlink" title="Bloom Filter（查找数据可能对应的 SSTable）"></a>Bloom Filter（查找数据可能对应的 SSTable）</h2><p>首先，Cassandra 检查 Bloom filter 去发现哪个 SSTables 中有可能有请求的分区数据。Bloom filter 是存储在堆外内存。每个 SSTable 都有一个关联的 Bloom filter。一个 Bloom filter 可以建立一个 SSTable 没有包含的特定的分区数据。同样也可以找到分区数据存在 SSTable 中的可能性。它可以加速查找 partition key 的查找过程。然而，因为 Bloom filter 是一个概率函数，所以可能会得到错误的结果，并不是所有的 SSTables 都可以被 Bloom filter 识别出是否有数据。如果Bloom filter 不能够查找到 SSTable，Cassandra 会检查 partition key cache。Bloom filter 大小增长很适宜，每 10 亿数据 1~2GB。在极端情况下，可以一个分区一行。都可以很轻松的将数十亿的 entries 存储在单个机器上。Bloom filter 是可以调节的，如果你愿意用内存来换取性能。</p><h2 id="Partition-Key-Cache（查找数据可能对应的-Partition-key）"><a href="#Partition-Key-Cache（查找数据可能对应的-Partition-key）" class="headerlink" title="Partition Key Cache（查找数据可能对应的 Partition key）"></a>Partition Key Cache（查找数据可能对应的 Partition key）</h2><p>partition key 缓存如果开启了，将 partition index 存储在堆外内存。key cache 使用一小块可配置大小的内存。在读的过程中，每个”hit”保存一个检索。如果在 key cache 中找到了 partition key。就直接到 compression offset map 中招对应的块。partition key cache 热启动后工作的更好，相比较冷启动，有很大的性能提升。如果一个节点上的内存非常受限制，可能的话，需要限<br>制保存在 key cache 中的 partition key 数目。如果一个在 key cache 中没有找到 partition key。就会去partition summary中去找。partition key cache 大小是可以配置的，意义就是存储在key cache 中的 partition keys 数目。</p><h2 id="Partition-Summary（内存中存储一些-partition-index-的样本）"><a href="#Partition-Summary（内存中存储一些-partition-index-的样本）" class="headerlink" title="Partition Summary（内存中存储一些 partition index 的样本）"></a>Partition Summary（内存中存储一些 partition index 的样本）</h2><p>partition summary 是存储在堆外内存的结构，存储一些 partition index 的样本。如果一个partition index 包含所有的 partition keys。鉴于一个partition summary 从每 X 个 keys 中取样，然后将每 X 个 key map 到 index 文件中。例如，如果一个 partition summary 设置了 20keys<br>进行取样。它就会存储 SSTable file 开始的一个 key,20th 个 key，以此类推。尽管并不知道partition key 的具体位置，partition summary 可以缩短找到 partition 数据位置。当找到了partition key 值可能的范围后，就会去找 partition index。通过配置取样频率，你可以用内存来换取性能，当 partition summary 包含的数据越多，使用的内存越多。可以通过表定义的 index interval 属性来改变样本频率。固定大小的内存可以通过 index_summary_capacity_in_mb 属性来设置，默认是堆大小的 5%。</p><h2 id="Partition-Index（磁盘中）"><a href="#Partition-Index（磁盘中）" class="headerlink" title="Partition Index（磁盘中）"></a>Partition Index（磁盘中）</h2><p>partition index 驻扎在磁盘中，索引所有 partition keys 和偏移量的映射。如果 partition summary 已经查到 partition keys 的范围，现在的检索就是根据这个范围值来检索目标 partitionkey。需要进行单次检索和顺序读。根据找到的信息。然后去 compression offset map 中去找磁<br>盘中有这个数据的块。如果 partition index 必须要被检索，则需要检索两次磁盘去找到目标数据。</p><h2 id="Compression-offset-map（磁盘中）"><a href="#Compression-offset-map（磁盘中）" class="headerlink" title="Compression offset map（磁盘中）"></a>Compression offset map（磁盘中）</h2><p>compression offset map 存储磁盘数据准确位置的指针。存储在堆外内存，可以被 partition key cache 或者 partition index 访问。一旦 compression offset map 识别出来磁盘中的数据位置，就会从正确的 SStable(s)中取出数据。查询就会收到结果集。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL（non-relationa非关系型）数据库。Cassandra旨在处理多商品服务器上的大量数据，提供高可用性而无需担心单点故障。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Cassandra" scheme="http://yoursite.com/tags/Cassandra/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（MongoDB）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88MongoDB%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（MongoDB）/</id>
    <published>2022-01-05T07:12:12.000Z</published>
    <updated>2022-01-05T07:37:26.957Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><a id="more"></a><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li> MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</li><li> 你可以在 MongoDB 记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。</li><li> 你可以通过本地或者网络创建数据镜像，这使得 MongoDB 有更强的扩展性。</li><li> 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li><li> Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li> MongoDb 使用 update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li><li> Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。</li><li> Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传给 Reduce 函数进行处理。</li><li> Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapreduce 命令来执行 MapReduce 操作。</li><li> GridFS 是 MongoDB 中的一个内置功能，可以用于存放大量小文件。</li><li> MongoDB 允许在服务端执行脚本，可以用 Javascript 编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Hbase）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Hbase%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（Hbase）/</id>
    <published>2022-01-05T02:12:12.000Z</published>
    <updated>2022-01-05T07:32:42.603Z</updated>
    
    <content type="html"><![CDATA[<p>base 是分布式、面向列的开源数据库（其实准确的说是面向列族）</p><a id="more"></a><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存<br>储和读取的分布式数据库解决方案。</p><h1 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h1><p>列方式所带来的重要好处之一就是，由于查询中的选择规则是通过列来定义的，因此整个数据库是自动索引化的。</p><p>这里的列式存储其实说的是列族存储，Hbase 是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。为了加深对 Hbase 列族的理解，下面是一个简单的关系型数据库的表和 Hbase 数据库的表：</p><h1 id="Hbase-核心概念"><a href="#Hbase-核心概念" class="headerlink" title="Hbase 核心概念"></a>Hbase 核心概念</h1><h2 id="Column-Family-列族"><a href="#Column-Family-列族" class="headerlink" title="Column Family 列族"></a>Column Family 列族</h2><p>Column Family 又叫列族，Hbase 通过列族划分数据的存储，列族下面可以包含任意多的列，实现灵活的数据存取。Hbase 表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须指定具体的列是一样的。Hbase 的列族不是越多越好，官方推荐的是列族最好小于或者等于 3。我们使用的场景一般是 1 个列族。</p><h2 id="Rowkey（Rowkey-查询，Rowkey-范围扫描，全表扫描）"><a href="#Rowkey（Rowkey-查询，Rowkey-范围扫描，全表扫描）" class="headerlink" title="Rowkey（Rowkey 查询，Rowkey 范围扫描，全表扫描）"></a>Rowkey（Rowkey 查询，Rowkey 范围扫描，全表扫描）</h2><p>Rowkey 的概念和 mysql 中的主键是完全一样的，Hbase 使用 Rowkey 来唯一的区分某一行的数据。Hbase 只支持 3 种查询方式：基于 Rowkey 的单行查询，基于 Rowkey 的范围扫描，全表扫描。</p><h2 id="Region-分区"><a href="#Region-分区" class="headerlink" title="Region 分区"></a>Region 分区</h2><p> Region：Region 的概念和关系型数据库的分区或者分片差不多。Hbase 会将一个大表的数据基于 Rowkey 的不同范围分配到不通的 Region 中，每个 Region 负责一定范围的数据访问和存储。这样即使是一张巨大的表，由于被切割到不通的 region，访问起来的时延也很低。</p><h2 id="TimeStamp-多版本"><a href="#TimeStamp-多版本" class="headerlink" title="TimeStamp 多版本"></a>TimeStamp 多版本</h2><p> TimeStamp 是实现 Hbase 多版本的关键。在Hbase中使用不同的timestame来标识相同rowkey行对应的不同版本的数据。在写入数据的时候，如果用户没有指定对应的timestamp，Hbase 会自动添加一个 timestamp，timestamp 和服务器时间保持一致。在Hbase 中，相同 rowkey 的数据按照 timestamp 倒序排列。默认查询的是最新的版本，用户可同指定 timestamp 的值来读取旧版本的数据。</p><h2 id="Hbase-核心架构"><a href="#Hbase-核心架构" class="headerlink" title="Hbase 核心架构"></a>Hbase 核心架构</h2><p>Hbase 是由 Client、Zookeeper、Master、HRegionServer、HDFS 等几个组建组成。</p><h2 id="Client："><a href="#Client：" class="headerlink" title="Client："></a>Client：</h2><p> Client 包含了访问 Hbase 的接口，另外 Client 还维护了对应的 cache 来加速 Hbase 的访问，比如 cache 的.META.元数据的信息。</p><p>元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。</p><h2 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h2><p> Hbase 通过 Zookeeper 来做 master 的高可用、RegionServer 的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：</p><ol><li>通过 Zoopkeeper 来保证集群中只有 1 个 master 在运行，如果 master 异常，会通过竞争机制产生新的 master 提供服务</li><li>通过 Zoopkeeper 来监控 RegionServer 的状态，当 RegionSevrer 有异常的时候，通过回调的形式通知 Master RegionServer 上下限的信息</li><li>通过 Zoopkeeper 存储元数据的统一入口地址。</li></ol><h2 id="Hmaster"><a href="#Hmaster" class="headerlink" title="Hmaster"></a>Hmaster</h2><p> master 节点的主要职责如下：</p><ol><li>为 RegionServer 分配 Region</li><li>维护整个集群的负载均衡</li><li>维护集群的元数据信息发现失效的 Region，并将失效的 Region 分配到正常RegionServer 上当 RegionSever 失效的时候，协调对应 Hlog 的拆分</li></ol><h2 id="HregionServer"><a href="#HregionServer" class="headerlink" title="HregionServer"></a>HregionServer</h2><p> HregionServer 直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如<br>下：</p><ol><li>管理 master 为其分配的 Region</li><li>处理来自客户端的读写请求</li><li>负责和底层 HDFS 的交互，存储数据到 HDFS</li><li>负责 Region 变大以后的拆分</li><li>负责 Storefile 的合并工作</li></ol><h2 id="Region-寻址方式（通过-zookeeper-META）"><a href="#Region-寻址方式（通过-zookeeper-META）" class="headerlink" title="Region 寻址方式（通过 zookeeper .META）"></a>Region 寻址方式（通过 zookeeper .META）</h2><p>第 1 步：Client 请求 ZK 获取.META.所在的 RegionServer 的地址。</p><p>第 2 步：Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。</p><p>第 3 步：Client 请求数据所在的 RegionServer，获取所需要的数据。</p><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p> HDFS 为 Hbase 提供最终的底层数据存储服务，同时为 Hbase 提供高可用（Hlog 存储在 HDFS）的支持。</p><h1 id="Hbase-的写逻辑"><a href="#Hbase-的写逻辑" class="headerlink" title="Hbase 的写逻辑"></a>Hbase 的写逻辑</h1><h2 id="Hbase-的写入流程"><a href="#Hbase-的写入流程" class="headerlink" title="Hbase 的写入流程"></a>Hbase 的写入流程</h2><h3 id="获取-RegionServer"><a href="#获取-RegionServer" class="headerlink" title="获取 RegionServer"></a>获取 RegionServer</h3><p>第 1 步：Client 获取数据写入的 Region 所在的 RegionServer</p><h3 id="请求写-Hlog"><a href="#请求写-Hlog" class="headerlink" title="请求写 Hlog"></a>请求写 Hlog</h3><p>第 2 步：请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来恢复数据。</p><h3 id="请求写-MemStore"><a href="#请求写-MemStore" class="headerlink" title="请求写 MemStore"></a>请求写 MemStore</h3><p>第 3 步：请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。MemStore 后续会逐渐刷到 HDFS 中。</p><h2 id="MemStore-刷盘"><a href="#MemStore-刷盘" class="headerlink" title="MemStore 刷盘"></a>MemStore 刷盘</h2><p>为了提高 Hbase 的写入性能，当写请求写入MemStore后，不会立即刷盘。而是会等到一定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢？总结成如下的几个场景：</p><h3 id="全局内存控制"><a href="#全局内存控制" class="headerlink" title="全局内存控制"></a>全局内存控制</h3><ol><li>这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比例的时候，会触发刷盘的操作。这个参数是hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个heap 内存的 35%。当flush到所有memstore占整个heap内存的比率为35%的时候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的目的。</li></ol><h3 id="MemStore-达到上限"><a href="#MemStore-达到上限" class="headerlink" title="MemStore 达到上限"></a>MemStore 达到上限</h3><ol start="2"><li>当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷盘，默认 128M 大小</li></ol><h3 id="RegionServer-的-Hlog-数量达到上限"><a href="#RegionServer-的-Hlog-数量达到上限" class="headerlink" title="RegionServer 的 Hlog 数量达到上限"></a>RegionServer 的 Hlog 数量达到上限</h3><ol start="3"><li>前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。</li></ol><h3 id="手工触发"><a href="#手工触发" class="headerlink" title="手工触发"></a>手工触发</h3><ol start="4"><li>可以通过 hbase shell 或者 java api 手工触发 flush 的操作。</li></ol><h3 id="关闭-RegionServer-触发"><a href="#关闭-RegionServer-触发" class="headerlink" title="关闭 RegionServer 触发"></a>关闭 RegionServer 触发</h3><ol start="5"><li>在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢复数据。</li></ol><h3 id="Region-使用-HLOG-恢复完数据后触发"><a href="#Region-使用-HLOG-恢复完数据后触发" class="headerlink" title="Region 使用 HLOG 恢复完数据后触发"></a>Region 使用 HLOG 恢复完数据后触发</h3><ol start="6"><li>：当 RegionServer 出现故障的时候，其上面的Region会迁移到其他正常的RegionServer上，在恢复完Region的数据后，会触发刷盘，当刷盘完成后才会提供给业务访问。</li></ol><h2 id="HBase-vs-Cassandra"><a href="#HBase-vs-Cassandra" class="headerlink" title="HBase vs Cassandra"></a>HBase vs Cassandra</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;base 是分布式、面向列的开源数据库（其实准确的说是面向列族）&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Hbase" scheme="http://yoursite.com/tags/Hbase/"/>
    
  </entry>
  
  <entry>
    <title>459. 重复的子字符串</title>
    <link href="http://yoursite.com/2022/01/04/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/01/04/459. 重复的子字符串/</id>
    <published>2022-01-04T10:12:12.000Z</published>
    <updated>2022-01-04T13:09:00.800Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</code></pre><p>示例 2:</p><pre><code>输入: &quot;aba&quot;输出: False</code></pre><p>示例 3:</p><pre><code>输入: &quot;abcabcabcabc&quot;</code></pre><p>输出: True</p><pre><code>解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</code></pre><h1 id="方法一：枚举-1"><a href="#方法一：枚举-1" class="headerlink" title="方法一：枚举^1"></a>方法一：枚举<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>如果一个长度为 <em>n</em> 的字符串 <em>s</em> 可以由它的一个长度为 <em>n’</em> 的子串 <em>s’</em> 重复多次构成，那么：</p><ul><li><p><em>n</em> 一定是 <em>n’</em> 的倍数；</p></li><li><p><em>s’</em> 一定是 <em>s</em> 的前缀；</p></li><li><p>对于任意的 i in [n’,n)，有 <em>s[i] = s[i-n’]</em>。</p></li></ul><p>也就是说，<em>s</em> 中长度为 <em>n’</em> 的前缀就是 <em>s’<em>，并且在这之后的每一个位置上的字符 *s[i]</em>，都需要与它之前的第 *n’</em> 个字符 <em>s[i-n’]</em> 相同。</p><p>因此，我们可以从小到大枚举 <em>n’*，并对字符串 *s</em> 进行遍历，进行上述的判断。注意到一个小优化是，因为子串至少需要重复一次，所以 <em>n’</em> 不会大于 <em>n</em> 的一半，我们只需要在 [1,n/2] 的范围内枚举 <em>n’</em> 即可。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(j) != s.charAt(j - i)) &#123;</span><br><span class="line">                        match = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> all(s[j] == s[j - i] <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span> &#123;</span><br><span class="line">            match := <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> s[j] != s[j - i] &#123;</span><br><span class="line">                    match = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> match &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是字符串 <em>s</em> 的长度。枚举 <em>i</em> 的时间复杂度为 <em>O(n)*，遍历 *s</em> 的时间复杂度为 <em>O(n)</em>，相乘即为总时间复杂度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：字符串匹配"><a href="#方法二：字符串匹配" class="headerlink" title="方法二：字符串匹配"></a>方法二：字符串匹配</h1><p><strong>思路与算法</strong></p><p>我们可以把字符串 <em>s</em> 写成</p><p>s’s’…s’s’</p><p>的形式，总计 n/n’  个 <em>s’*。但我们如何在不枚举 *n’</em> 的情况下，判断 <em>s</em> 是否能写成上述的形式呢？</p><p>如果我们移除字符串 <em>s</em> 的前 <em>n’</em> 个字符（即一个完整的 <em>s’<em>），再将这些字符保持顺序添加到剩余字符串的末尾，那么得到的字符串仍然是 *s</em>。由于 1&lt; = n’&lt;n ，那么如果将两个 *s</em> 连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含 <em>s</em>，即 <em>s</em> 是它的一个子串。</p><p>因此我们可以考虑这种方法：我们将两个 <em>s</em> 连在一起，并移除第一个和最后一个字符。如果 <em>s</em> 是该字符串的子串，那么 <em>s</em> 就满足题目要求。</p><p>注意到我们证明的是<strong>如果 <em>s</em> 满足题目要求，那么 <em>s</em> 有这样的性质</strong>，而我们使用的方法却是<strong>如果 <em>s</em> 有这样的性质，那么 <em>s</em> 满足题目要求</strong>。因此，只证明了充分性是远远不够的，我们还需要证明必要性。</p><blockquote><p>题解区的很多题解都忽略了这一点，但它是非常重要的。</p></blockquote><p>证明需要使用一些同余运算的小技巧，可以见方法三之后的「正确性证明」部分。这里先假设我们已经完成了证明，这样就可以使用非常简短的代码完成本题。在下面的代码中，我们可以从位置 <em>1</em> 开始查询，并希望查询结果不为位置 <em>n</em>，这与移除字符串的第一个和最后一个字符是等价的。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).indexOf(s, <span class="number">1</span>) != s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != len(s)</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">char</span> k[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">    k[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(k + <span class="number">1</span>, s) - k != n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>由于我们使用了语言自带的字符串查找函数，因此这里不深入分析其时空复杂度。</p><h1 id="方法三：KMP-算法"><a href="#方法三：KMP-算法" class="headerlink" title="方法三：KMP 算法"></a>方法三：KMP 算法</h1><p><strong>思路与算法</strong></p><p>在方法二中，我们使用了语言自带的字符串查找函数。同样我们也可以自己实现这个函数，例如使用比较经典的 KMP 算法。</p><p>读者需要注意以下几点：</p><ul><li><p>KMP 算法虽然有着良好的理论时间复杂度上限，但大部分语言自带的字符串查找函数并不是用 KMP 算法实现的。这是因为在实现 API 时，我们需要在平均时间复杂度和最坏时间复杂度二者之间权衡。普通的暴力匹配算法以及优化的 BM 算法拥有比 KMP 算法更为优秀的平均时间复杂度；</p></li><li><p>学习 KMP 算法时，一定要理解其本质。如果放弃阅读晦涩难懂的材料（即使大部分讲解 KMP 算法的材料都包含大量的图，但图毕竟只能描述特殊而非一般情况）而是直接去阅读代码，是永远无法学会 KMP 算法的。读者甚至无法理解 KMP 算法关键代码中的任意一行。</p></li></ul><p>由于本题就是在一个字符串中查询另一个字符串是否出现，可以直接套用 KMP 算法。因此这里对 KMP 算法本身不再赘述。读者可以自行查阅资料进行学习。这里留了三个思考题，读者可以在学习完毕后尝试回答这三个问题，检验自己的学习成果：</p><ul><li><p>设查询串的的长度为 <em>n</em>，模式串的长度为 <em>m</em>，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？</p></li><li><p>如果有多个查询串，平均长度为 <em>n</em>，数量为 <em>k</em>，那么总时间复杂度是多少？</p></li><li><p>在 KMP 算法中，对于模式串，我们需要预处理出一个 fail  数组（有时也称为next  数组、pi 数组等）。这个数组到底表示了什么？</p></li></ul><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; query, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = query.size();</span><br><span class="line">        <span class="keyword">int</span> m = pattern.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail(m, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">(String query, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = query.length();</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; pattern.charAt(j + <span class="number">1</span>) != pattern.charAt(i)) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(j + <span class="number">1</span>) == pattern.charAt(i)) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> match = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != -<span class="number">1</span> &amp;&amp; pattern.charAt(match + <span class="number">1</span>) != query.charAt(i)) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(match + <span class="number">1</span>) == query.charAt(i)) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(query: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">            n, m = len(query), len(pattern)</span><br><span class="line">            fail = [<span class="number">-1</span>] * m</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                j = fail[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">while</span> j != <span class="number">-1</span> <span class="keyword">and</span> pattern[j + <span class="number">1</span>] != pattern[i]:</span><br><span class="line">                    j = fail[j]</span><br><span class="line">                <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i]:</span><br><span class="line">                    fail[i] = j + <span class="number">1</span></span><br><span class="line">            match = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> match != <span class="number">-1</span> <span class="keyword">and</span> pattern[match + <span class="number">1</span>] != query[i]:</span><br><span class="line">                    match = fail[match]</span><br><span class="line">                <span class="keyword">if</span> pattern[match + <span class="number">1</span>] == query[i]:</span><br><span class="line">                    match += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> match == m - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kmp(s + s, s)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> kmp(s + s, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(query, pattern <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(query), <span class="built_in">len</span>(pattern)</span><br><span class="line">    fail := <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        fail[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        j := fail[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i] &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    match := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i] &#123;</span><br><span class="line">            match = fail[match]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pattern[match + <span class="number">1</span>] == query[i] &#123;</span><br><span class="line">            match++</span><br><span class="line">            <span class="keyword">if</span> match == m - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>* query, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(query);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="keyword">int</span> fail[m];</span><br><span class="line">    <span class="built_in">memset</span>(fail, <span class="number">-1</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">            j = fail[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">            match = fail[match];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">            ++match;</span><br><span class="line">            <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">char</span> k[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">    k[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="keyword">return</span> kmp(k, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是字符串 <em>s</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n)</em>。</p></li></ul><h2 id="正确性证明-1"><a href="#正确性证明-1" class="headerlink" title="正确性证明^1"></a>正确性证明<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></h2><p>一方面，如果长度为 <em>n</em> 的字符串 <em>s</em> 是字符串 <em>t=s+s</em> 的子串，并且 <em>s</em> 在 <em>t</em> 中的起始位置不为 <em>0</em> 或 <em>n</em>，那么 <em>s</em> 就满足题目的要求。证明过程如下：</p><ul><li>我们设 <em>s</em> 在 <em>t</em> 中的起始位置为 <em>i</em>，i in (0,n) 。也就是说，<em>t</em> 中从位置 <em>i</em> 开始的 <em>n</em> 个连续的字符，恰好就是字符串 <em>s</em>。那么我们有：</li></ul><p>s[0:n-1] = t[i:n+i-1]</p><p>由于 <em>t</em> 是由两个 <em>s</em> 拼接而成的，我们可以将 <em>t[i:n+i-1]</em> 分成位置 <em>n-1</em> 左侧和右侧两部分：</p><p>每一部分都可以对应回 <em>s</em>：</p><p>这说明，<em>s</em> 是一个「可旋转」的字符串：将 <em>s</em> 的前 <em>i</em> 个字符保持顺序，移动到 <em>s</em> 的末尾，得到的新字符串与 <em>s</em> 相同。也就是说，<strong>在模 <em>n</em> 的意义下</strong>，</p><p>s[j] = s[j+i]</p><p>对于任意的 <em>j</em> 恒成立。</p><blockquote><p>「在模 <em>n</em> 的意义下」可以理解为，所有的加法运算的结果都需要对 <em>n</em> 取模，使得结果保持在 <em>[0, n)</em> 中，这样加法就自带了「旋转」的效果。</p></blockquote><p>另一方面，如果 <em>s</em> 满足题目的要求，那么 <em>s</em> 包含若干个「部分」，<em>t=s+s</em> 包含两倍数量的「部分」，因此 <em>s</em> 显然是 <em>t</em> 的子串，并且起始位置可以不为 <em>0</em> 或 <em>n</em>：我们只需要选择 <em>t</em> 中第一个「部分」的起始位置即可。</p><p>综上所述，我们证明了：长度为 <em>n</em> 的字符串 <em>s</em> 是字符串 <em>t=s+s</em> 的子串，并且 <em>s</em> 在 <em>t</em> 中的起始位置不为 <em>0</em> 或 <em>n</em>，<strong>当且仅当</strong> <em>s</em> 满足题目的要求。因此，</p><h2 id="另一种证明方法-2"><a href="#另一种证明方法-2" class="headerlink" title="另一种证明方法^2"></a>另一种证明方法<a href="https://writings.sh/post/algorithm-repeated-string-pattern" target="_blank" rel="noopener">^2</a></h2><h2 id="思考题答案"><a href="#思考题答案" class="headerlink" title="思考题答案"></a>思考题答案</h2><ul><li><p>设查询串的的长度为 <em>n</em>，模式串的长度为 <em>m</em>，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？</p><ul><li><p>时间复杂度为 <em>O(n+m)</em>，用到了均摊分析（摊还分析）的方法。</p></li><li><p>具体地，无论在预处理过程还是查询过程中，虽然匹配失败时，指针会不断地根据 fail 数组向左回退，看似时间复杂度会很高。但考虑匹配成功时，指针会向右移动一个位置，这一部分对应的时间复杂度为 <em>O(n+m)</em>。又因为向左移动的次数不会超过向右移动的次数，因此总时间复杂度仍然为 <em>O(n+m)</em>。</p></li></ul></li><li><p>如果有多个查询串，平均长度为 <em>n</em>，数量为 <em>k</em>，那么总时间复杂度是多少？</p><ul><li>时间复杂度为 <em>O(nk+m)</em>。模式串只需要预处理一次。</li></ul></li><li><p>在 KMP 算法中，对于模式串，我们需要预处理出一个 fail 数组（有时也称为 next  数组、pi 数组等）。这个数组到底表示了什么？</p><ul><li>fail 等于满足下述要求的 <em>x</em> 的最大值：<em>s[0:i]</em> 具有长度为 <em>x+1</em> 的完全相同的前缀和后缀。这也是 KMP 算法最重要的一部分。</li></ul></li></ul><h1 id="方法四：优化的-KMP-算法"><a href="#方法四：优化的-KMP-算法" class="headerlink" title="方法四：优化的 KMP 算法"></a>方法四：优化的 KMP 算法</h1><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pattern.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; pattern.charAt(j + <span class="number">1</span>) != pattern.charAt(i)) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(j + <span class="number">1</span>) == pattern.charAt(i)) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fail[n - <span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol4-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(pattern: str)</span> -&gt; bool:</span></span><br><span class="line">            n = len(pattern)</span><br><span class="line">            fail = [<span class="number">-1</span>] * n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                j = fail[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">while</span> j != <span class="number">-1</span> <span class="keyword">and</span> pattern[j + <span class="number">1</span>] != pattern[i]:</span><br><span class="line">                    j = fail[j]</span><br><span class="line">                <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i]:</span><br><span class="line">                    fail[i] = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> <span class="keyword">and</span> n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kmp(s)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol4-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> kmp(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(pattern)</span><br><span class="line">    fail := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fail[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        j := fail[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i] &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol4-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="keyword">int</span> fail[n];</span><br><span class="line">    <span class="built_in">memset</span>(fail, <span class="number">-1</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">            j = fail[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kmp(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是字符串 <em>s</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n)</em>。</p></li></ul><h1 id="KMP算法简洁解释"><a href="#KMP算法简洁解释" class="headerlink" title="KMP算法简洁解释"></a>KMP算法简洁解释</h1><p>受到 题目28. 实现 strStr()的启发使用KMP算法来解决。</p><ol><li>先用next数组构造前缀表</li><li>经过对所有重复字符串的前缀表进行验证，他们的前缀表最后一位都不会为0，所以如果next[len - 1] == 0，就说明s是不重复的。</li><li>如果len % (len - (next[len - 1]) ) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被数组的长度整除，说明有该字符串有重复的子字符串。</li></ol><p>数组长度 - 最长相同前后缀的长度相当于是第一个周期的长度，如果这个周期可以被len整除，就说明整个数组就是这个周期的循环。</p><details>    <summary>KMP</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean repeatedSubstringPattern(String s) &#123;</span><br><span class="line"></span><br><span class="line">        int len = s.length();</span><br><span class="line">        //先使用KMP算法求出next数组，通过next数组的元素判断</span><br><span class="line">        int[] next = getNext(s);</span><br><span class="line">        /*</span><br><span class="line">        要判断字符串是否可以由它的一个子串重复多次构成。 </span><br><span class="line">        1. next[len-1]!=0</span><br><span class="line">        - next数组长度为len，如果最后一个元素的值为0，则该字符串不可能是由重复的小字符串构成的，</span><br><span class="line">        所以：</span><br><span class="line">        2. 字符串总长度 % 最小重复单元的长度 == 0</span><br><span class="line">        - len-next[len-1]的值表示的含义为该字符串中的最小重复单元的长度</span><br><span class="line">        */</span><br><span class="line">        if (next[len - 1] != 0 &amp;&amp; len % (len - next[len - 1]) == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private int[] getNext(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int[] next = new int[len];</span><br><span class="line">         for (int i = 1, j = 0; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s.charAt(j) != s.charAt(i)) &#123;</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s.charAt(j) == s.charAt(i)) j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="String Matching" scheme="http://yoursite.com/tags/String-Matching/"/>
    
      <category term="KMP Algorithm" scheme="http://yoursite.com/tags/KMP-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Kafka）</title>
    <link href="http://yoursite.com/2022/01/04/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Kafka%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/04/JAVA 学习笔记（Kafka）/</id>
    <published>2022-01-04T07:12:12.000Z</published>
    <updated>2022-01-04T15:12:41.749Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。</p><a id="more"></a><p>[TOC]</p><ol><li>broker：Kafka 服务器，负责消息存储和转发</li><li>topic：消息类别，Kafka 按照 topic 来分类消息</li><li>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个partition 上</li><li>offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号</li><li>Producer：消息生产者</li><li>Consumer：消息消费者</li><li>Consumer Group：消费者分组，每个 Consumer 必须属于一个 group</li><li>Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能</li></ol><h1 id="Kafka-数据存储设计"><a href="#Kafka-数据存储设计" class="headerlink" title="Kafka 数据存储设计"></a>Kafka 数据存储设计</h1><h2 id="partition-的数据文件（offset，MessageSize，data）"><a href="#partition-的数据文件（offset，MessageSize，data）" class="headerlink" title="partition 的数据文件（offset，MessageSize，data）"></a>partition 的数据文件（offset，MessageSize，data）</h2><p>partition 中的每条 Message 包含了以下三个属性：offset，MessageSize，data，其中 offset 表示 Message 在这个 partition 中的偏移量，offset 不是该 Message 在 partition 数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了 partition 中的一条 Message，可以认为 offset 是partition 中 Message 的 id；MessageSize 表示消息内容 data 的大小；data 为 Message 的具体内容。</p><h2 id="数据文件分段-segment（顺序读写、分段命令、二分查找）"><a href="#数据文件分段-segment（顺序读写、分段命令、二分查找）" class="headerlink" title="数据文件分段 segment（顺序读写、分段命令、二分查找）"></a>数据文件分段 segment（顺序读写、分段命令、二分查找）</h2><p>partition 物理上由多个 segment 文件组成，每个segment大小相等，顺序读写。每个segment数据文件以该段中最小的offset命名，文件扩展名为.log。这样在查找指定 offset 的 Message 的时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。</p><h2 id="数据文件索引（分段索引、稀疏存储）"><a href="#数据文件索引（分段索引、稀疏存储）" class="headerlink" title="数据文件索引（分段索引、稀疏存储）"></a>数据文件索引（分段索引、稀疏存储）</h2><p>Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。</p><h1 id="生产者设计"><a href="#生产者设计" class="headerlink" title="生产者设计"></a>生产者设计</h1><h2 id="负载均衡（partition-会均衡分布到不同-broker-上）"><a href="#负载均衡（partition-会均衡分布到不同-broker-上）" class="headerlink" title="负载均衡（partition 会均衡分布到不同 broker 上）"></a>负载均衡（partition 会均衡分布到不同 broker 上）</h2><p>由于消息 topic 由多个 partition 组成，且 partition 会均衡分布到不同 broker 上，因此，为了有效利用 broker 集群的性能，提高消息的吞吐量，producer 可以通过随机或者 hash 等方式，将消息平均发送到多个 partition 上，以实现负载均衡。</p><h2 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h2><p>是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，以一次请求的方式发送了批量的消息给 broker，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性，相当于以时延代价，换取更好的吞吐量。</p><h2 id="压缩（GZIP-或-Snappy）"><a href="#压缩（GZIP-或-Snappy）" class="headerlink" title="压缩（GZIP 或 Snappy）"></a>压缩（GZIP 或 Snappy）</h2><p>Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer端进行压缩之后，在Consumer端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是 CPU（压缩和解压会耗掉部分 CPU 资源）。</p><h1 id="消费者设计"><a href="#消费者设计" class="headerlink" title="消费者设计"></a>消费者设计</h1><h2 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h2><p>同一 Consumer Group 中的多个 Consumer 实例，不同时消费同一个 partition，等效于队列模式。partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（日志）</title>
    <link href="http://yoursite.com/2022/01/04/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/04/JAVA 学习笔记（日志）/</id>
    <published>2022-01-04T04:12:12.000Z</published>
    <updated>2022-01-04T07:27:19.877Z</updated>
    
    <content type="html"><![CDATA[<p>日志</p><a id="more"></a><p>[TOC]</p><h1 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h1><p>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带<br>的 java.util.logging.Logger 等。</p><h1 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h1><p>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。<br>Log4j 由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。</p><p>1.Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</p><p>2.Appenders : 指定了日志将打印到控制台还是文件中</p><p>3.Layout : 控制日志信息的显示格式</p><p>Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为DEBUG、INFO、WARN、ERROR和FATAL，当输出时，只有级别高过配置中规定的级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。</p><p>Log4j最近爆出了一个严重漏洞，可以自行搜索其漏洞产生原因</p><h1 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h1><p>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。</p><p>Logback 主要由三个模块组成：logback-core，logback-classic。logback-access</p><p>logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的通用机制。</p><p>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J；</p><p>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与HTTP 访问相关的功能</p><h2 id="Logback-优点"><a href="#Logback-优点" class="headerlink" title="Logback 优点"></a>Logback 优点</h2><ul><li> 同样的代码路径，Logback 执行更快</li><li> 更充分的测试</li><li> 原生实现了 SLF4J API（Log4J 还需要有一个中间转换层）</li><li> 内容更丰富的文档</li><li> 支持 XML 或者 Groovy 方式配置</li><li> 配置文件自动热加载</li><li> 从 IO 错误中优雅恢复</li><li> 自动删除日志归档</li><li> 自动压缩日志成为归档文件</li><li> 支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件</li><li> 支持配置文件中加入条件判断来适应不同的环境</li><li> 更强大的过滤器</li><li> 支持 SiftingAppender（可筛选 Appender）</li><li> 异常栈信息带有包信息</li></ul><h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><p>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。</p><p> Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。</p><p> Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。</p><p> Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>28. 实现 strStr()</title>
    <link href="http://yoursite.com/2022/01/03/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/"/>
    <id>http://yoursite.com/2022/01/03/28. 实现 strStr()/</id>
    <published>2022-01-03T13:12:12.000Z</published>
    <updated>2022-01-04T09:53:56.253Z</updated>
    
    <content type="html"><![CDATA[<p>实现 strStr() 函数。</p><a id="more"></a><p>[TOC]</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><p>示例 1：</p><pre><code>输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2</code></pre><p>示例 2：</p><pre><code>输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1</code></pre><p>示例 3：</p><pre><code>输入：haystack = &quot;&quot;, needle = &quot;&quot;输出：0</code></pre><p>提示：</p><p>0 &lt;= haystack.length, needle.length &lt;= 5 * 104</p><p>haystack 和 needle 仅由小写英文字符组成</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题是经典的字符串单模匹配的模型，因此可以使用字符串匹配算法解决，常见的字符串匹配算法包括暴力匹配、Knuth-Morris-Pratt算法、{Boyer-Moore 算法、Sunday 算法等，本文将讲解 Knuth-Morris-Pratt 算法。</p><p>因为哈希方法可能出现哈希值相等但是字符串不相等的情况，而strStr 函数要求匹配结果必定正确，因此本文不介绍哈希方法，有兴趣的读者可以自行了解滚动哈希的实现（如 Rabin-Karp  算法）。</p><h1 id="方法一：暴力匹配"><a href="#方法一：暴力匹配" class="headerlink" title="方法一：暴力匹配"></a>方法一：暴力匹配</h1><p><strong>思路及算法</strong></p><p>我们可以让字符串 needle 与字符串 haystack 的所有长度为 <em>m</em> 的子串均匹配一次。</p><p>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 <em>-1</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = haystack.length, m = needle.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">outer:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i+m &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> needle &#123;</span><br><span class="line">            <span class="keyword">if</span> haystack[i+j] != needle[j] &#123;</span><br><span class="line">                <span class="keyword">continue</span> outer</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span>* haystack, <span class="keyword">char</span>* needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(haystack), m = <span class="built_in">strlen</span>(needle);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：Knuth-Morris-Pratt-算法-1-3"><a href="#方法二：Knuth-Morris-Pratt-算法-1-3" class="headerlink" title="方法二：Knuth-Morris-Pratt 算法^1^3:"></a>方法二：Knuth-Morris-Pratt 算法<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/" target="_blank" rel="noopener">^1</a><a href="https://leetcode-cn.com/problems/implement-strstr/solution/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/" target="_blank" rel="noopener">^3</a>:</h1><p>KMP 算法的关键，就在回退这个步骤。</p><p>next 数组存放的是当前长度下的 最长相同前后缀 的长度</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pi(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line"><span class="comment">//自己敲一下子 前缀表不需要减一的实现方式</span></span><br><span class="line">        <span class="keyword">int</span> needleLength = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (needleLength == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        当needle是空字符串时，返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[needleLength];</span><br><span class="line"><span class="comment">//        定义好next数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">1</span>, left = <span class="number">0</span>; right &lt; needleLength; right++) &#123;</span><br><span class="line"><span class="comment">//            定义好两个指针right与left</span></span><br><span class="line"><span class="comment">//            在for循环中初始化指针right为1，left=0,开始计算next数组，right始终在left指针的后面</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; needle.charAt(left) != needle.charAt(right)) &#123;</span><br><span class="line"><span class="comment">//                如果不相等就让left指针回退，到0时就停止回退</span></span><br><span class="line">                left = next[left - <span class="number">1</span>];<span class="comment">//进行回退操作；</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(left) == needle.charAt(right)) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line"><span class="comment">// 这是从 1 开始的</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 循环结束的时候，next数组就已经计算完毕了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>; i &lt;haystack.length() ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;haystack.charAt(i)!=needle.charAt(j))&#123;</span><br><span class="line">                j=next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==needleLength) <span class="keyword">return</span> i-needleLength+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = haystack.length, m = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> pi = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] !== needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    pi := <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j] &#123;</span><br><span class="line">            j = pi[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> needle[i] == needle[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j] &#123;</span><br><span class="line">            j = pi[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> haystack[i] == needle[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == m &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span>* haystack, <span class="keyword">char</span>* needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(haystack), m = <span class="built_in">strlen</span>(needle);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pi[m];</span><br><span class="line">    pi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 strStr() 函数。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="String Matching" scheme="http://yoursite.com/tags/String-Matching/"/>
    
      <category term="KMP Algorithm" scheme="http://yoursite.com/tags/KMP-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（网络7层架构，TCP，HTTP和CDN原理）</title>
    <link href="http://yoursite.com/2022/01/03/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BD%91%E7%BB%9C7%E5%B1%82%E6%9E%B6%E6%9E%84%EF%BC%8CTCP%EF%BC%8CHTTP%E5%92%8CCDN%E5%8E%9F%E7%90%86%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/03/JAVA 学习笔记（网络7层架构，TCP，HTTP和CDN原理）/</id>
    <published>2022-01-03T13:12:12.000Z</published>
    <updated>2022-01-04T03:43:08.490Z</updated>
    
    <content type="html"><![CDATA[<p>网络7层架构，TCP，HTTP和CDN原理</p><a id="more"></a><p>[TOC]</p><h1 id="网络-7-层架构"><a href="#网络-7-层架构" class="headerlink" title="网络 7 层架构"></a>网络 7 层架构</h1><p>7 层模型主要包括：</p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。</li><li>数据链路层：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。</li><li>网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。</li><li>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。</li><li>会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）</li><li>表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））</li><li>应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。</li></ol><h1 id="TCP-IP-原理"><a href="#TCP-IP-原理" class="headerlink" title="TCP/IP 原理"></a>TCP/IP 原理</h1><p>TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。</p><h2 id="网络访问层-Network-Access-Layer"><a href="#网络访问层-Network-Access-Layer" class="headerlink" title="网络访问层(Network Access Layer)"></a>网络访问层(Network Access Layer)</h2><ol><li>网络访问层(Network Access Layer)在 TCP/IP 参考模型中并没有详细描述，只是指出主机必须使用某种协议与网络相连。</li></ol><h2 id="网络层-Internet-Layer"><a href="#网络层-Internet-Layer" class="headerlink" title="网络层(Internet Layer)"></a>网络层(Internet Layer)</h2><ol start="2"><li>网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。互联网层使用因特网协议(IP，Internet Protocol)。</li></ol><h2 id="传输层-Tramsport-Layer-TCP-UDP"><a href="#传输层-Tramsport-Layer-TCP-UDP" class="headerlink" title="传输层(Tramsport Layer-TCP/UDP)"></a>传输层(Tramsport Layer-TCP/UDP)</h2><ol start="3"><li>传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。TCP是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路<br>复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</li></ol><h1 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层(Application Layer)"></a>应用层(Application Layer)</h1><ol start="4"><li>应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。</li></ol><h1 id="TCP-三次握手-四次挥手"><a href="#TCP-三次握手-四次挥手" class="headerlink" title="TCP 三次握手/四次挥手"></a>TCP 三次握手/四次挥手</h1><p>TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”。</p><h2 id="数据包说明"><a href="#数据包说明" class="headerlink" title="数据包说明"></a>数据包说明</h2><ol><li>源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。</li><li>目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。</li><li>顺序号 seq（ 32 位）：用来标识从 TCP源端向TCP目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2 的 32 次方 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）。</li><li>确认号 ack（ 32 位）：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</li><li>TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。</li><li>保留位（ 6 位）：保留给将来使用，目前必须置为 0 。</li><li>控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为：</li></ol><ul><li>URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。</li><li>ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。</li><li>PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li><li>RST ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。</li><li>SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。</li><li>FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul><ol start="8"><li><p>窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。</p></li><li><p>校验和（ 16 位）：此校验和是对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。</p></li><li><p>紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p></li><li><p>选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。</p></li><li><p>数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p></li></ol><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器，主机 B由 SYN=1 知道，A 要求建立联机；</p><p>第二次握手：主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包</p><p>第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认seq 值与 ack=1 则连接建立成功</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。</p><p>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u</p><p>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。</p><p>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。</p><p>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。</p><p>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL  (Maximum Segment Lifetime，报文最大生存时间)后，A 才进入到close 状态。</p><h1 id="HTTP-原理"><a href="#HTTP-原理" class="headerlink" title="HTTP 原理"></a>HTTP 原理</h1><p>HTTP 是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。</p><h2 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h2><p>1：地址解析</p><p>如用客户端浏览器请求这个页面：<a href="http://localhost.com:8080/index.htm从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：" target="_blank" rel="noopener">http://localhost.com:8080/index.htm从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</a></p><pre><code>协议名：http主机名：localhost.com端口：8080对象路径：/index.htm</code></pre><p>在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。</p><p>2：封装 HTTP 请求数据包</p><p>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包</p><p>3：封装成 TCP 包并建立连接</p><p>封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）<br>4：客户机发送请求命</p><p>客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。</p><p>5：服务器响应</p><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME( Multipurpose Internet Mail Extensions 描述消息内容类型的因特网标准) 信息包括服务器信息、实体信息和可能的内容。</p><p>6：服务器关闭 TCP 连接</p><p> 服务器关闭 TCP 连接：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽</p><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><pre><code>状态码 原因短语消息响应100 Continue(继续)101 Switching Protocol(切换协议)200 OK(成功)201 Created(已创建)202 Accepted(已创建)203 Non-Authoritative Information(未授权信息)204 No Content(无内容)205 Reset Content(重置内容)206 Partial Content(部分内容)重定向300 Multiple Choice(多种选择)301 Moved Permanently(永久移动)302 Found(临时移动)303 See Other(查看其他位置)304 Not Modified(未修改)305 Use Proxy(使用代理)306 unused(未使用)307 Temporary Redirect(临时重定向)308 Permanent Redirect(永久重定向)客户端错误400 Bad Request(错误请求)401 Unauthorized(未授权)402 Payment Required(需要付款)403 Forbidden(禁止访问)404 Not Found(未找到)405 Method Not Allowed(不允许使用该方法)406 Not Acceptable(无法接受)407 Proxy Authentication Required(要求代理身份验证)408 Request Timeout(请求超时)409 Conflict(冲突)410 Gone(已失效)411 Length Required(需要内容长度头)412 Precondition Failed(预处理失败)413 Request Entity Too Large(请求实体过长)414 Request-URI Too Long(请求网址过长)415 Unsupported Media Type(媒体类型不支持)416 Requested Range Not Satisfiable(请求范围不合要求)417 Expectation Failed(预期结果失败)服务器端错误500 Internal Server Error(内部服务器错误)501 Implemented(未实现)502 Bad Gateway(网关错误)503 Service Unavailable(服务不可用)504 Gateway Timeout (网关超时)505 HTTP Version Not Supported(HTTP 版本不受支持)</code></pre><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下：</p><h3 id="建立连接获取证书"><a href="#建立连接获取证书" class="headerlink" title="建立连接获取证书"></a>建立连接获取证书</h3><p>1） SSL 客户端通过 TCP 和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。</p><h3 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h3><p>2） Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</p><h3 id="数据加密和传输"><a href="#数据加密和传输" class="headerlink" title="数据加密和传输"></a>数据加密和传输</h3><p>3） 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</p><h1 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h1><p>CND 一般包含分发服务系统、负载均衡系统和管理系统</p><h2 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h2><p>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。</p><p>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。</p><p>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</p><h2 id="负载均衡系统："><a href="#负载均衡系统：" class="headerlink" title="负载均衡系统："></a>负载均衡系统：</h2><p>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</p><p>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。</p><p>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。</p><p>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。</p><h2 id="管理系统："><a href="#管理系统：" class="headerlink" title="管理系统："></a>管理系统：</h2><p>分为运营管理和网络管理子系统。</p><p>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。</p><p>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。包括用户管理、产品管理、计费管理、统计分析等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络7层架构，TCP，HTTP和CDN原理&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>796. 旋转字符串</title>
    <link href="http://yoursite.com/2022/01/03/796.%20%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/01/03/796. 旋转字符串/</id>
    <published>2022-01-03T12:44:12.000Z</published>
    <updated>2022-01-03T12:57:41.736Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串, A和B。</p><p>A的旋转操作就是将A 最左边的字符移动到最右边。例如,若A=’abcde’，在移动一次之后结果就是’bcdea’。如果在若干次旋转操作之后，A能变成B，那么返回True。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: A = &apos;abcde&apos;, B = &apos;cdeab&apos;输出: true</code></pre><p>示例 2:</p><pre><code>输入: A = &apos;abcde&apos;, B = &apos;abced&apos;输出: false</code></pre><p>注意：</p><p>A 和B长度不超过100。</p><h1 id="方法一：穷举法"><a href="#方法一：穷举法" class="headerlink" title="方法一：穷举法"></a>方法一：穷举法</h1><p>将字符串 <code>A</code> 旋转 <code>s</code> 次后，得到的字符串为 <code>A[s], A[s + 1], A[s + 2], ...</code>，因此我们只要枚举 <code>s</code>，并检查是否有 <code>A[s] == B[0], A[s + 1] == B[1], A[s + 2] == B[2], ...</code> 即可。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.length() != B.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (A.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        search:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; A.length(); ++s) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A.charAt((s+i) % A.length()) != B.charAt(i))</span><br><span class="line">                        <span class="keyword">continue</span> search;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(A) != len(B):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">if</span> all(A[(s+i) % len(A)] == B[i] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A))):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N^2)*，其中 *N</em> 是字符串 <code>A</code> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：判断子串"><a href="#方法二：判断子串" class="headerlink" title="方法二：判断子串"></a>方法二：判断子串</h1><p>由于 <code>A + A</code> 包含了所有可以通过旋转操作从 <code>A</code> 得到的字符串，因此我们只需要判断 <code>B</code> 是否为 <code>A + A</code> 的子串即可。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.length() == B.length() &amp;&amp; (A + A).contains(B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(A) == len(B) <span class="keyword">and</span> B <span class="keyword">in</span> A+A</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N^2)*，其中 *N</em> 是字符串 <code>A</code> 的长度。</p></li><li><p>空间复杂度：<em>O(N)</em>，即 <code>A + A</code> 需要的空间。</p></li></ul><h1 id="方法三：Rabin-Karp-字符串哈希"><a href="#方法三：Rabin-Karp-字符串哈希" class="headerlink" title="方法三：Rabin-Karp 字符串哈希"></a>方法三：Rabin-Karp 字符串哈希</h1><p>我们可以优化方法二中判断 <code>B</code> 是否为 <code>A + A</code> 的子串时使用的算法，例如使用 Rabin-Karp 字符串哈希算法。设 <code>A2 = A + A</code>，我们求出子串 <code>A2[0:N], A2[1:N + 1], A2[2:N + 2], ...</code> 的哈希值，如果与 <code>B</code> 的哈希值相同，那么这两个字符串很有可能相同。</p><p>我们通过 <code>hash(S) = (S[0] * P**0 + S[1] * P**1 + S[2] * P**2 + ...) % MOD</code> 计算字符串 <code>S</code> 的哈希值，其中 <code>S[i]</code> 是 <code>S</code> 中第 <code>i</code> 个字母的 <code>ASCII</code> 编码值，<code>X**Y</code> 表示指数运算。对于两个字符串 <code>S</code> 和 <code>T</code>，如果它们的哈希值相同，即 <code>hash(S) == hash(T)</code>，那么 <code>S</code> 和 <code>T</code> 很有可能相同。</p><p>当我们计算出 <code>A</code> 的哈希值 <code>hash(A)</code>（即为序列 <code>A[0], A[1], ..., A[N - 1]</code> 的哈希值），下一步是计算 <code>A</code> 经过一次旋转操作，序列 <code>A[1], A[2], ..., A[N - 1], A[0]</code> 的哈希值，这可以通过将 <code>hash(A)</code> 减去 <code>A[0]</code>，除以 <code>P</code>，再加上 <code>A[0] * P**(N - 1)</code> 得到。其中除以 <code>P</code> 的操作是在对 <code>MOD</code> 取模的意义下的，等价于乘以 <code>P</code> 的乘法逆元。如果 <code>MOD</code> 为质数，<code>P</code> 的乘法逆元 <code>Pinv</code> 为 <code>P**(MOD - 2)</code> 对 <code>MOD</code> 取模的结果。这可以根据费马小定理推导出。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.equals(B)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="keyword">int</span> P = <span class="number">113</span>;</span><br><span class="line">        <span class="keyword">int</span> Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> hb = <span class="number">0</span>, power = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x: B.toCharArray()) &#123;</span><br><span class="line">            hb = (hb + power * x) % MOD;</span><br><span class="line">            power = power * P % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> ha = <span class="number">0</span>; power = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ca = A.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x: ca) &#123;</span><br><span class="line">            ha = (ha + power * x) % MOD;</span><br><span class="line">            power = power * P % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ca.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = ca[i];</span><br><span class="line">            ha += power * x - x;</span><br><span class="line">            ha %= MOD;</span><br><span class="line">            ha *= Pinv;</span><br><span class="line">            ha %= MOD;</span><br><span class="line">            <span class="keyword">if</span> (ha == hb &amp;&amp; (A.substring(i+<span class="number">1</span>) + A.substring(<span class="number">0</span>, i+<span class="number">1</span>)).equals(B))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        P = <span class="number">113</span></span><br><span class="line">        Pinv = pow(P, MOD<span class="number">-2</span>, MOD)</span><br><span class="line"></span><br><span class="line">        hb = <span class="number">0</span></span><br><span class="line">        power = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> B:</span><br><span class="line">            code = ord(x) - <span class="number">96</span></span><br><span class="line">            hb = (hb + power * code) % MOD</span><br><span class="line">            power = power * P % MOD</span><br><span class="line"></span><br><span class="line">        ha = <span class="number">0</span></span><br><span class="line">        power = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            code = ord(x) - <span class="number">96</span></span><br><span class="line">            ha = (ha + power * code) % MOD</span><br><span class="line">            power = power * P % MOD</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ha == hb <span class="keyword">and</span> A == B: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            code = ord(x) - <span class="number">96</span></span><br><span class="line">            ha += power * code</span><br><span class="line">            ha -= code</span><br><span class="line">            ha *= Pinv</span><br><span class="line">            ha %= MOD</span><br><span class="line">            <span class="keyword">if</span> ha == hb <span class="keyword">and</span> A[i+<span class="number">1</span>:] + A[:i+<span class="number">1</span>] == B:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是字符串 <code>A</code> 的长度。</p></li><li><p>空间复杂度：<em>O(N)</em>。</p></li></ul><h1 id="方法四：KMP-算法"><a href="#方法四：KMP-算法" class="headerlink" title="方法四：KMP 算法"></a>方法四：KMP 算法</h1><p>判断一个串是否为另一个串的子串的最优时间复杂度的算法是 KMP 算法。和方法二相同，我们只需要用 KMP 算法判断 <code>B</code> 是否为 <code>A + A</code> 的子串即可。KMP 算法较难理解，这里给出了力扣第 28 题 <a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现 strstr()</a> 讨论区中一个高赞 <a href="https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/" target="_blank" rel="noopener">KMP 算法详解</a>，以及著名博主 Matrix67 的 <a href="http://www.matri***/blog/archives/115" target="_blank" rel="noopener">KMP 算法详解</a>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length();</span><br><span class="line">        <span class="keyword">if</span> (N != B.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Compute shift table</span></span><br><span class="line">        <span class="keyword">int</span>[] shifts = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(shifts, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; N; ++right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; (B.charAt(left) != B.charAt(right)))</span><br><span class="line">                left -= shifts[left];</span><br><span class="line">            shifts[right + <span class="number">1</span>] = right - left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Find match of B in A+A</span></span><br><span class="line">        <span class="keyword">int</span> matchLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: (A+A).toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (matchLen &gt;= <span class="number">0</span> &amp;&amp; B.charAt(matchLen) != c)</span><br><span class="line">                matchLen -= shifts[matchLen];</span><br><span class="line">            <span class="keyword">if</span> (++matchLen == N) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        N = len(A)</span><br><span class="line">        <span class="keyword">if</span> N != len(B): <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Compute shift table</span></span><br><span class="line">        shifts = [<span class="number">1</span>] * (N+<span class="number">1</span>)</span><br><span class="line">        left = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> B[left] != B[right]:</span><br><span class="line">                left -= shifts[left]</span><br><span class="line">            shifts[right + <span class="number">1</span>] = right - left</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Find match of B in A+A</span></span><br><span class="line">        match_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> A+A:</span><br><span class="line">            <span class="keyword">while</span> match_len &gt;= <span class="number">0</span> <span class="keyword">and</span> B[match_len] != char:</span><br><span class="line">                match_len -= shifts[match_len]</span><br><span class="line"></span><br><span class="line">            match_len += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> match_len == N:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是字符串 <code>A</code> 的长度。</p></li><li><p>空间复杂度：<em>O(N)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串, A和B。&lt;/p&gt;
&lt;p&gt;A的旋转操作就是将A 最左边的字符移动到最右边。例如,若A=’abcde’，在移动一次之后结果就是’bcdea’。如果在若干次旋转操作之后，A能变成B，那么返回True。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="String Matching" scheme="http://yoursite.com/tags/String-Matching/"/>
    
  </entry>
  
  <entry>
    <title>417. 太平洋大西洋水流问题</title>
    <link href="http://yoursite.com/2022/01/03/417.%20%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2022/01/03/417. 太平洋大西洋水流问题/</id>
    <published>2022-01-03T03:12:12.000Z</published>
    <updated>2022-01-03T12:37:14.203Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 </p><a id="more"></a><p>[TOC]</p><p>提示：</p><p>输出坐标的顺序不重要<br>m 和 n 都小于150</p><p>示例：</p><p>给定下面的 5x5 矩阵:</p><pre><code>太平洋 ~   ~   ~   ~   ~      ~  1   2   2   3  (5) *     ~  3   2   3  (4) (4) *     ~  2   4  (5)  3   1  *     ~ (6) (7)  1   4   5  *     ~ (5)  1   1   2   4  *        *   *   *   *   * 大西洋</code></pre><p>返回:</p><p>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</p><ul><li>思路：准备两个表示是否能流向某个海岸线的矩阵，沿着海岸线‘’逆流而上‘’，最后统计两个大洋都能流向的坐标</li><li>复杂度：时间复杂度<code>O(m*n)</code>,m、n分别是坐标矩阵的长宽。空间复杂度<code>O(m * n)</code></li></ul><details>    <summary>Java写法1</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    private int[][] dirs = &#123;&#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    private boolean[][] visited = null;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123;</span><br><span class="line">        int m = heights.length, n = heights[0].length;</span><br><span class="line">        visited = new boolean[m][n];</span><br><span class="line">        boolean[][] canReachA = new boolean[m][n];</span><br><span class="line">        boolean[][] canReachP = new boolean[m][n];</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(heights, i, 0, canReachA, m, n);</span><br><span class="line">            dfs(heights, i, n-1, canReachP, m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(heights, 0, i, canReachA, m, n);</span><br><span class="line">            dfs(heights, m - 1, i, canReachP, m, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (canReachA[i][j] &amp;&amp; canReachP[i][j]) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    list.add(j);</span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[][] heights, int x, int y, boolean[][] temp, int m, int n) &#123;</span><br><span class="line">        temp[x][y] = true;</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int nx = x + dirs[i][0];</span><br><span class="line">            int ny = y + dirs[i][1];</span><br><span class="line">            if (isIn(nx,ny,m,n) &amp;&amp; !temp[nx][ny] &amp;&amp; heights[x][y] &lt;= heights[nx][ny]) &#123;</span><br><span class="line">                dfs(heights, nx, ny, temp, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isIn(int x, int y, int m, int n) &#123;</span><br><span class="line">        return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java写法2</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    class Solution &#123;</span><br><span class="line">    // 用来返回的返回值</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    // 方向转换的数组</span><br><span class="line">    private int[][] dirs = &#123;&#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    // 大西洋和太平洋共享的访问数组</span><br><span class="line">    private boolean[][] visited = null;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123;</span><br><span class="line">        int n = heights.length, m = heights[0].length;</span><br><span class="line">        visited = new boolean[n][m];</span><br><span class="line">        // temp 是用来记录当前深度优先搜索访问过的点</span><br><span class="line">        boolean[][] temp = new boolean[n][m];</span><br><span class="line">        // 首先从太平洋出发，看看都能遇到哪些点</span><br><span class="line">        for (int x = 0; x &lt; n; ++x) &#123;</span><br><span class="line">            for (int y = 0; y &lt; m; ++y) &#123;</span><br><span class="line">                // x == 0 || y == 0 表示要从太平洋出发需要满足的条件，flag == false 意味着是从太平洋出发的</span><br><span class="line">                if ((x == 0 || y == 0) &amp;&amp; !temp[x][y]) dfs(heights, x, y, temp, n, m, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同上，temp 是用来标记当前深度优先搜索访问到的点</span><br><span class="line">        temp = new boolean[n][m];</span><br><span class="line">        // 然后再从大西洋出发，看看能遇到哪些点，如果遇到的点 在 visited 中之前已经被标记为 true， 那么说明双方都可到达</span><br><span class="line">        for (int x = 0; x &lt; n; ++x) &#123;</span><br><span class="line">            for (int y = 0; y &lt; m; ++y) &#123;</span><br><span class="line">                // x == n - 1 || y == m - 1 表示从大西洋出发</span><br><span class="line">                if ((x == n - 1 || y == m - 1) &amp;&amp; !temp[x][y]) dfs(heights, x, y, temp, n, m, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param x         深度优先搜索的起始点坐标 x</span><br><span class="line">     * @param y         起始点坐标 y</span><br><span class="line">     * @param temp      用来标记当前深度优先搜索已经访问过哪些点了</span><br><span class="line">     * @param flag      为 true 时意味着是大西洋来的，为 false 意味着是太平洋来的</span><br><span class="line">     */</span><br><span class="line">    private void dfs(int[][] heights, int x, int y, boolean[][] temp, int n, int m, boolean flag) &#123;</span><br><span class="line">        // 如果是大西洋来的，而且 太平洋已经访问过 &#123;x, y&#125; 了，就放到返回值中</span><br><span class="line">        if (flag &amp;&amp; visited[x][y]) &#123;</span><br><span class="line">            List&lt;Integer&gt; buf = new ArrayList&lt;&gt;();</span><br><span class="line">            buf.add(x);</span><br><span class="line">            buf.add(y);</span><br><span class="line">            ans.add(buf);</span><br><span class="line">            // 顺便把该点置为 false，防止重复记录</span><br><span class="line">            visited[x][y] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果是从太平洋来的，需要将 &#123;x, y&#125; 标记为已来过</span><br><span class="line">        if (!flag) visited[x][y] = true;</span><br><span class="line">        // 然后切换四个方向，逐个检查</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int nx = x + dirs[i][0];</span><br><span class="line">            int ny = y + dirs[i][1];</span><br><span class="line">            // 检查新的坐标是否合法，以及当前深度优先搜索是否来过，最后还要满足 逆向 条件</span><br><span class="line">            if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; !temp[nx][ny] &amp;&amp; heights[nx][ny] &gt;= heights[x][y]) &#123;</span><br><span class="line">                temp[nx][ny] = true;    // 然后在当前深度优先搜索中标记为已来过</span><br><span class="line">                dfs(heights, nx, ny, temp, n, m, flag); // 继续深度优先搜索</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java写法3</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    class Solution &#123;</span><br><span class="line">    // 用来返回的返回值</span><br><span class="line">    private List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    // 方向转换的数组</span><br><span class="line">    private int[][] dirs = &#123;&#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    // 大西洋和太平洋共享的访问数组</span><br><span class="line">    private boolean[][] visited = null;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) &#123;</span><br><span class="line">        int n = heights.length, m = heights[0].length;</span><br><span class="line">        visited = new boolean[n][m];</span><br><span class="line">        // temp 是用来记录当前深度优先搜索访问过的点</span><br><span class="line">        boolean[][] temp = new boolean[n][m];</span><br><span class="line">        // 首先从太平洋出发，看看都能遇到哪些点</span><br><span class="line">        for (int x = 0; x &lt; n; ++x) &#123;</span><br><span class="line">            for (int y = 0; y &lt; m; ++y) &#123;</span><br><span class="line">                // x == 0 || y == 0 表示要从太平洋出发需要满足的条件，flag == false 意味着是从太平洋出发的</span><br><span class="line">                if ((x == 0 || y == 0) &amp;&amp; !temp[x][y]) dfs(heights, x, y, temp, n, m, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同上，temp 是用来标记当前深度优先搜索访问到的点</span><br><span class="line">        temp = new boolean[n][m];</span><br><span class="line">        // 然后再从大西洋出发，看看能遇到哪些点，如果遇到的点 在 visited 中之前已经被标记为 true， 那么说明双方都可到达</span><br><span class="line">        for (int x = 0; x &lt; n; ++x) &#123;</span><br><span class="line">            for (int y = 0; y &lt; m; ++y) &#123;</span><br><span class="line">                // x == n - 1 || y == m - 1 表示从大西洋出发</span><br><span class="line">                if ((x == n - 1 || y == m - 1) &amp;&amp; !temp[x][y]) dfs(heights, x, y, temp, n, m, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param x         深度优先搜索的起始点坐标 x</span><br><span class="line">     * @param y         起始点坐标 y</span><br><span class="line">     * @param temp      用来标记当前深度优先搜索已经访问过哪些点了</span><br><span class="line">     * @param flag      为 true 时意味着是大西洋来的，为 false 意味着是太平洋来的</span><br><span class="line">     */</span><br><span class="line">    private void dfs(int[][] heights, int x, int y, boolean[][] temp, int n, int m, boolean flag) &#123;</span><br><span class="line">        // 如果是大西洋来的，而且 太平洋已经访问过 &#123;x, y&#125; 了，就放到返回值中</span><br><span class="line">        if (flag &amp;&amp; visited[x][y]) &#123;</span><br><span class="line">            List&lt;Integer&gt; buf = new ArrayList&lt;&gt;();</span><br><span class="line">            buf.add(x);</span><br><span class="line">            buf.add(y);</span><br><span class="line">            ans.add(buf);</span><br><span class="line">            // 顺便把该点置为 false，防止重复记录</span><br><span class="line">//            visited[x][y] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果是从太平洋来的，需要将 &#123;x, y&#125; 标记为已来过</span><br><span class="line">        if (!flag) visited[x][y] = true;</span><br><span class="line">        temp[x][y] = true;</span><br><span class="line">        // 然后切换四个方向，逐个检查</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int nx = x + dirs[i][0];</span><br><span class="line">            int ny = y + dirs[i][1];</span><br><span class="line">            // 检查新的坐标是否合法，以及当前深度优先搜索是否来过，最后还要满足 逆向 条件</span><br><span class="line">            if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; !temp[nx][ny] &amp;&amp; heights[nx][ny] &gt;= heights[x][y]) &#123;</span><br><span class="line">                temp[nx][ny] = true;    // 然后在当前深度优先搜索中标记为已来过</span><br><span class="line">                dfs(heights, nx, ny, temp, n, m, flag); // 继续深度优先搜索</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。&lt;/p&gt;
&lt;p&gt;规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。&lt;/p&gt;
&lt;p&gt;请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 &lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（NIO）</title>
    <link href="http://yoursite.com/2022/01/03/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88NIO%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/03/JAVA 学习笔记（NIO）/</id>
    <published>2022-01-03T00:12:12.000Z</published>
    <updated>2022-01-03T07:35:21.802Z</updated>
    
    <content type="html"><![CDATA[<p>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p><a id="more"></a><p>[TOC]</p><p>本文摘自美团点评技术团队<a href="https://zhuanlan.zhihu.com/p/23488863" target="_blank" rel="noopener">^1</a>，仅供初步学习NIO</p><p>NIO的本质是什么样的呢？它是怎样与事件模型结合来解放线程、提高系统吞吐的呢？</p><p>本文会从传统的阻塞I/O和线程池模型面临的问题讲起，然后对比几种常见I/O模型，一步步分析NIO怎么利用事件模型处理I/O，解决线程池瓶颈处理海量连接，包括利用面向事件的方式编写服务端/客户端程序。最后延展到一些高级主题，如Reactor与Proactor模型的对比、Selector的唤醒、Buffer的选择等。</p><p>注：本文的代码都是伪代码，主要是为了示意，不可用于生产环境。</p><h1 id="传统BIO模型分析"><a href="#传统BIO模型分析" class="headerlink" title="传统BIO模型分析"></a>传统BIO模型分析</h1><p>让我们先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型：</p><details>    <summary>传统BIO模型</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> ExecutorService executor = Excutors.newFixedThreadPollExecutor(100);//线程池</span><br><span class="line"></span><br><span class="line"> ServerSocket serverSocket = new ServerSocket();</span><br><span class="line"> serverSocket.bind(8088);</span><br><span class="line"> while(!Thread.currentThread.isInturrupted())&#123;//主线程死循环等待新连接到来</span><br><span class="line"> Socket socket = serverSocket.accept();</span><br><span class="line"> executor.submit(new ConnectIOnHandler(socket));//为新的连接创建新的线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConnectIOnHandler extends Thread&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    public ConnectIOnHandler(Socket socket)&#123;</span><br><span class="line">       this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">      while(!Thread.currentThread.isInturrupted()&amp;&amp;!socket.isClosed())&#123;死循环处理读写事件</span><br><span class="line">          String someThing = socket.read()....//读取数据</span><br><span class="line">          if(someThing!=null)&#123;</span><br><span class="line">             ......//处理数据</span><br><span class="line">             socket.write()....//写数据</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。其实这也是所有使用多线程的本质：</p><ul><li>利用多核。</li><li>当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</li></ul><p>现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。</p><p>不过，这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：</p><ul><li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。</li><li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li><li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</li><li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li></ul><p>所以，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I/O处理模型。</p><h1 id="NIO是怎么工作的"><a href="#NIO是怎么工作的" class="headerlink" title="NIO是怎么工作的"></a>NIO是怎么工作的</h1><p>很多刚接触NIO的人，第一眼看到的就是Java相对晦涩的API，比如：Channel，Selector，Socket什么的；然后就是一坨上百行的代码来演示NIO的服务端Demo……瞬间头大有没有？</p><p>我们不管这些，抛开现象看本质，先分析下NIO是怎么工作的。</p><h1 id="常见I-O模型对比"><a href="#常见I-O模型对比" class="headerlink" title="常见I/O模型对比"></a>常见I/O模型对比</h1><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。</p><p>下图是几种常见I/O模型的对比：</p><p>以socket.read()为例子：</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p><p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。</p><h1 id="如何结合事件模型使用NIO同步非阻塞特性"><a href="#如何结合事件模型使用NIO同步非阻塞特性" class="headerlink" title="如何结合事件模型使用NIO同步非阻塞特性"></a>如何结合事件模型使用NIO同步非阻塞特性</h1><p>回忆BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能”傻等”，即使通过各种估算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，没有好的办法利用CPU。</p><p>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</p><p>下面具体看下如何利用事件模型单线程处理所有I/O请求：</p><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p><p>我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。</p><p>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p><p>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p><p>所以我们的程序大概的模样是：</p><details>    <summary>Reactor</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">interface ChannelHandler&#123;</span><br><span class="line">     void channelReadable(Channel channel);</span><br><span class="line">     void channelWritable(Channel channel);</span><br><span class="line">  &#125;</span><br><span class="line">  class Channel&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Event event;//读，写或者连接</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //IO线程主循环:</span><br><span class="line">  class IoThread extends Thread&#123;</span><br><span class="line">  public void run()&#123;</span><br><span class="line">  Channel channel;</span><br><span class="line">  while(channel=Selector.select())&#123;//选择就绪的事件和对应的连接</span><br><span class="line">     if(channel.event==accept)&#123;</span><br><span class="line">        registerNewChannelHandler(channel);//如果是新连接，则注册一个新的读写处理器</span><br><span class="line">     &#125;</span><br><span class="line">     if(channel.event==write)&#123;</span><br><span class="line">        getChannelHandler(channel).channelWritable(channel);//如果可以写，则执行写事件</span><br><span class="line">     &#125;</span><br><span class="line">     if(channel.event==read)&#123;</span><br><span class="line">         getChannelHandler(channel).channelReadable(channel);//如果可以读，则执行读事件</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;Channel，ChannelHandler&gt; handlerMap;//所有channel的对应事件处理器</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></details><p>这个程序很简短，也是最简单的Reactor模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。</p><h1 id="优化线程模型"><a href="#优化线程模型" class="headerlink" title="优化线程模型"></a>优化线程模型</h1><p>由上面的示例我们大概可以总结出NIO是怎么解决掉线程的瓶颈并处理海量连接的：</p><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p><p>并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p><p>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。</p><p>仔细分析一下我们需要的线程，其实主要包括以下几种：</p><ul><li>事件分发器，单线程选择就绪的事件。</li><li>I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。</li><li>业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li></ul><p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</p><p>另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p><h1 id="NIO在客户端的魔力"><a href="#NIO在客户端的魔力" class="headerlink" title="NIO在客户端的魔力"></a>NIO在客户端的魔力</h1><p>通过上面的分析，可以看出NIO在服务端对于解放线程，优化I/O和处理海量连接方面，确实有自己的用武之地。那么在客户端上，NIO又有什么使用场景呢?</p><p>常见的客户端BIO+连接池模型，可以建立n个连接，然后当某一个连接被I/O占用的时候，可以使用其他连接来提高性能。</p><p>但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。</p><h1 id="每连接顺序请求的Redis"><a href="#每连接顺序请求的Redis" class="headerlink" title="每连接顺序请求的Redis"></a>每连接顺序请求的Redis</h1><p>对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了。</p><p>伪代码如下：</p><details>    <summary>Redis</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">class RedisClient Implements ChannelHandler&#123;</span><br><span class="line"> private BlockingQueue CmdQueue;</span><br><span class="line"> private EventLoop eventLoop;</span><br><span class="line"> private Channel channel;</span><br><span class="line"> class Cmd&#123;</span><br><span class="line">  String cmd;</span><br><span class="line">  Future result;</span><br><span class="line"> &#125;</span><br><span class="line"> public Future get(String key)&#123;</span><br><span class="line">   Cmd cmd= new Cmd(key);</span><br><span class="line">   queue.offer(cmd);</span><br><span class="line">   eventLoop.submit(new Runnable()&#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        queue.drainTo(list);</span><br><span class="line">        if(channel.isWritable())&#123;</span><br><span class="line">         channel.writeAndFlush(list);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> public void ChannelReadFinish(Channel channel，Buffer Buffer)&#123;</span><br><span class="line">    List result = handleBuffer();//处理数据</span><br><span class="line">    //从cmdQueue取出future，并设值，future.done();</span><br><span class="line">&#125;</span><br><span class="line"> public void ChannelWritable(Channel channel)&#123;</span><br><span class="line">   channel.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这样做，能够充分的利用pipeline来提高I/O能力，同时获取异步处理能力。</p><h1 id="多连接短连接的HttpClient"><a href="#多连接短连接的HttpClient" class="headerlink" title="多连接短连接的HttpClient"></a>多连接短连接的HttpClient</h1><p>类似于竞对抓取的项目，往往需要建立无数的HTTP短连接，然后抓取，然后销毁，当需要单机抓取上千网站线程数又受制的时候，怎么保证性能呢?</p><p>何不尝试NIO，单线程进行连接、写、读操作？如果连接、读、写操作系统没有能力处理，简单的注册一个事件，等待下次循环就好了。</p><p>如何存储不同的请求/响应呢？由于http是无状态没有版本的协议，又没有办法使用队列，好像办法不多。比较笨的办法是对于不同的socket，直接存储socket的引用作为map的key。</p><h1 id="常见的RPC框架，如Thrift，Dubbo"><a href="#常见的RPC框架，如Thrift，Dubbo" class="headerlink" title="常见的RPC框架，如Thrift，Dubbo"></a>常见的RPC框架，如Thrift，Dubbo</h1><p>这种框架内部一般维护了请求的协议和请求号，可以维护一个以请求号为key，结果的result为future的map，结合NIO+长连接，获取非常不错的性能。</p><h1 id="NIO高级主题"><a href="#NIO高级主题" class="headerlink" title="NIO高级主题"></a>NIO高级主题</h1><h2 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h2><p>一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。 </p><p>事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊:谁谁谁的快递到了，快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p><p>涉及到事件分发器的两种模式称为：Reactor和Proactor。 </p><p>Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p><p>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。</p><p>举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（写操作类似）。</p><h2 id="在Reactor中实现读"><a href="#在Reactor中实现读" class="headerlink" title="在Reactor中实现读"></a>在Reactor中实现读</h2><ul><li>注册读就绪事件和相应的事件处理器。</li><li>事件分发器等待事件。</li><li>事件到来，激活分发器，分发器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><h2 id="在Proactor中实现读："><a href="#在Proactor中实现读：" class="headerlink" title="在Proactor中实现读："></a>在Proactor中实现读：</h2><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分发器等待操作完成事件。</li><li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li><li>事件分发器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li></ul><p>可以看出，两个模式的相同点，都是对某个I/O事件的事件通知（即告诉某个模块，这个I/O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I/O操作已经完成；同步情况下（Reactor)，回调handler时，表示I/O设备可以进行某个操作（can read 或 can write)。</p><p>下面，我们将尝试应对为Proactor和Reactor模式建立可移植框架的挑战。在改进方案中，我们将Reactor原来位于事件处理器内的Read/Write操作移至分发器（不妨将这个思路称为“模拟异步”），以此寻求将Reactor多路同步I/O转化为模拟异步I/O。以读操作为例子，改进过程如下：</p><ul><li>注册读就绪事件和相应的事件处理器。并为分发器提供数据缓冲区地址，需要读取数据量等信息。</li><li>分发器等待事件（如在select()上等待）。</li><li>事件到来，激活分发器。分发器执行一个非阻塞读操作（它有完成这个操作所需的全部信息），最后调用对应处理器。</li><li>事件处理器处理用户自定义缓冲区的数据，注册新的事件（当然同样要给出数据缓冲区地址，需要读取的数据量等信息），最后将控制权返还分发器。</li></ul><p>如我们所见，通过对多路I/O模式功能结构的改造，可将Reactor转化为Proactor模式。改造前后，模型实际完成的工作量没有增加，只不过参与者间对工作职责稍加调换。没有工作量的改变，自然不会造成性能的削弱。对如下各步骤的比较，可以证明工作量的恒定：</p><h2 id="标准-典型的Reactor："><a href="#标准-典型的Reactor：" class="headerlink" title="标准/典型的Reactor："></a>标准/典型的Reactor：</h2><ul><li>步骤1：等待事件到来（Reactor负责）。</li><li>步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。</li><li>步骤3：读数据（用户处理器负责）。</li><li>步骤4：处理数据（用户处理器负责）。</li></ul><h2 id="改进实现的模拟Proactor："><a href="#改进实现的模拟Proactor：" class="headerlink" title="改进实现的模拟Proactor："></a>改进实现的模拟Proactor：</h2><ul><li>步骤1：等待事件到来（Proactor负责）。</li><li>步骤2：得到读就绪事件，执行读数据（现在由Proactor负责）。</li><li>步骤3：将读完成事件分发给用户处理器（Proactor负责）。</li><li>步骤4：处理数据（用户处理器负责）。</li></ul><p>对于不提供异步I/O API的操作系统来说，这种办法可以隐藏Socket API的交互细节，从而对外暴露一个完整的异步接口。借此，我们就可以进一步构建完全可移植的，平台无关的，有通用对外接口的解决方案。</p><p>代码示例如下：</p><details>    <summary>Proactor</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">interface ChannelHandler&#123;</span><br><span class="line">      void channelReadComplate(Channel channel，byte[] data);</span><br><span class="line">      void channelWritable(Channel channel);</span><br><span class="line">   &#125;</span><br><span class="line">   class Channel&#123;</span><br><span class="line">     Socket socket;</span><br><span class="line">     Event event;//读，写或者连接</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //IO线程主循环：</span><br><span class="line">   class IoThread extends Thread&#123;</span><br><span class="line">   public void run()&#123;</span><br><span class="line">   Channel channel;</span><br><span class="line">   while(channel=Selector.select())&#123;//选择就绪的事件和对应的连接</span><br><span class="line">      if(channel.event==accept)&#123;</span><br><span class="line">         registerNewChannelHandler(channel);//如果是新连接，则注册一个新的读写处理器</span><br><span class="line">         Selector.interested(read);</span><br><span class="line">      &#125;</span><br><span class="line">      if(channel.event==write)&#123;</span><br><span class="line">         getChannelHandler(channel).channelWritable(channel);//如果可以写，则执行写事件</span><br><span class="line">      &#125;</span><br><span class="line">      if(channel.event==read)&#123;</span><br><span class="line">          byte[] data = channel.read();</span><br><span class="line">          if(channel.read()==0)//没有读到数据，表示本次数据读完了</span><br><span class="line">          &#123;</span><br><span class="line">          getChannelHandler(channel).channelReadComplate(channel，data;//处理读完成事件</span><br><span class="line">          &#125;</span><br><span class="line">          if(过载保护)&#123;</span><br><span class="line">          Selector.interested(read);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   Map&lt;Channel，ChannelHandler&gt; handlerMap;//所有channel的对应事件处理器</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><h1 id="Selector-wakeup"><a href="#Selector-wakeup" class="headerlink" title="Selector.wakeup()"></a>Selector.wakeup()</h1><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><p>解除阻塞在Selector.select()/select(long)上的线程，立即返回。</p><p>两次成功的select之间多次调用wakeup等价于一次调用。</p><p>如果当前没有阻塞在select上，则本次wakeup调用将作用于下一次select——“记忆”作用。</p><p>为什么要唤醒？</p><p>注册了新的channel或者事件。</p><p>channel关闭，取消注册。</p><p>优先级更高的事件触发（如定时器事件），希望及时处理。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Linux上利用pipe调用创建一个管道，Windows上则是一个loopback的tcp连接。这是因为win32的管道无法加入select的fd set，将管道或者TCP连接加入select fd set。</p><p>wakeup往管道或者连接写入一个字节，阻塞的select因为有I/O事件就绪，立即返回。可见，wakeup的调用开销不可忽视。</p><h1 id="Buffer的选择"><a href="#Buffer的选择" class="headerlink" title="Buffer的选择"></a>Buffer的选择</h1><p>通常情况下，操作系统的一次写操作分为两步：</p><ol><li><p>将数据从用户空间拷贝到系统空间。</p></li><li><p>从系统空间往网卡写。同理，读操作也分为两步：</p></li></ol><p>① 将数据从网卡拷贝到系统空间；</p><p>② 将数据从系统空间拷贝到用户空间。</p><p>对于NIO来说，缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能。</p><p>如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer。</p><h1 id="NIO存在的问题"><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h1><p>使用NIO != 高性能，当连接数&lt;1000，并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p><p>NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。</p><p>推荐大家使用成熟的NIO框架，如Netty，MINA等。解决了很多NIO的陷阱，并屏蔽了操作系统的差异，有较好的性能和编程模型。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结一下到底NIO给我们带来了些什么：</p><ul><li>事件驱动模型</li><li>避免多线程</li><li>单线程处理多任务</li><li>非阻塞I/O，I/O读写不再阻塞，而是返回0</li><li>基于block的传输，通常比基于流的传输更高效</li><li>更高级的IO函数，zero-copy</li><li>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Netty 与 RPC）</title>
    <link href="http://yoursite.com/2022/01/02/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Netty%20%E4%B8%8E%20RPC%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/02/JAVA 学习笔记（Netty 与 RPC）/</id>
    <published>2022-01-02T13:12:12.000Z</published>
    <updated>2022-01-03T09:11:36.406Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA中，微服务是一种面向服务的架构风格，其中应用程序被构建为多个不同的小型服务的集合而不是单个应用程序。</p><a id="more"></a><p>[TOC]</p><h1 id="Netty-原理"><a href="#Netty-原理" class="headerlink" title="Netty 原理"></a>Netty 原理</h1><p>Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。</p><h1 id="Netty-高性能"><a href="#Netty-高性能" class="headerlink" title="Netty 高性能"></a>Netty 高性能</h1><p>在 IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 IO 多路复用技术进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O 多路复用的<br>最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。</p><p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel两种不同的套接字通道实现。</p><h2 id="多路复用通讯方式"><a href="#多路复用通讯方式" class="headerlink" title="多路复用通讯方式"></a>多路复用通讯方式</h2><p>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下：</p><p>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。</p><h2 id="异步通讯-NIO-1"><a href="#异步通讯-NIO-1" class="headerlink" title="异步通讯 NIO^1"></a>异步通讯 NIO<a href="https://zhuanlan.zhihu.com/p/23488863" target="_blank" rel="noopener">^1</a></h2><p>异步IO(Async I/O)</p><p>NIO（Non-blocking I/O，在Java领域，也称为New I/O）<br>由于 Netty 采用了异步通信模式，一个 IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><h2 id="零拷贝（DIRECT-BUFFERS-使用堆外直接内存）"><a href="#零拷贝（DIRECT-BUFFERS-使用堆外直接内存）" class="headerlink" title="零拷贝（DIRECT BUFFERS 使用堆外直接内存）"></a>零拷贝（DIRECT BUFFERS 使用堆外直接内存）</h2><ol><li><p>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p></li><li><p>Netty 提供了组合 Buffer 对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的Buffer。</p></li><li><p>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环 write 方式导致的内存拷贝问题</p></li></ol><h2 id="内存池（基于内存池的缓冲区重用机制）"><a href="#内存池（基于内存池的缓冲区重用机制）" class="headerlink" title="内存池（基于内存池的缓冲区重用机制）"></a>内存池（基于内存池的缓冲区重用机制）</h2><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。</p><h2 id="高效的-Reactor-线程模型"><a href="#高效的-Reactor-线程模型" class="headerlink" title="高效的 Reactor 线程模型"></a>高效的 Reactor 线程模型</h2><p>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模<br>型。</p><h3 id="Reactor-单线程模型"><a href="#Reactor-单线程模型" class="headerlink" title="Reactor 单线程模型"></a>Reactor 单线程模型</h3><p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：</p><pre><code>1) 作为 NIO 服务端，接收客户端的 TCP 连接；2) 作为 NIO 客户端，向服务端发起 TCP 连接；3) 读取通信对端的请求或者应答消息；4) 向通信对端发送消息请求或者应答消息</code></pre><p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。</p><h1 id="Reactor-多线程模型"><a href="#Reactor-多线程模型" class="headerlink" title="Reactor 多线程模型"></a>Reactor 多线程模型</h1><p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个NIO 线程-Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求； 网络 IO 操作-读、写等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；</p><h1 id="主从-Reactor-多线程模型"><a href="#主从-Reactor-多线程模型" class="headerlink" title="主从 Reactor 多线程模型"></a>主从 Reactor 多线程模型</h1><p>服务端用于接收客户端连接的不再是个 1 个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</p><h2 id="无锁设计、线程绑定"><a href="#无锁设计、线程绑定" class="headerlink" title="无锁设计、线程绑定"></a>无锁设计、线程绑定</h2><p>Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列多个工作线程模型性能更优。</p><p>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用<br>到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p><h2 id="高性能的序列化框架"><a href="#高性能的序列化框架" class="headerlink" title="高性能的序列化框架"></a>高性能的序列化框架</h2><p>Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。</p><ol><li>SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K。</li></ol><h3 id="小包封大包，防止网络阻塞"><a href="#小包封大包，防止网络阻塞" class="headerlink" title="小包封大包，防止网络阻塞"></a>小包封大包，防止网络阻塞</h3><ol start="2"><li>SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法。</li></ol><h3 id="软中断-Hash-值和-CPU-绑定"><a href="#软中断-Hash-值和-CPU-绑定" class="headerlink" title="软中断 Hash 值和 CPU 绑定"></a>软中断 Hash 值和 CPU 绑定</h3><ol start="3"><li>软中断：开启 RPS 后可以实现软中断，提升网络吞吐量。RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu，从上层来看，也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上，提升网络并行处理性能。</li></ol><h1 id="Netty-RPC-实现"><a href="#Netty-RPC-实现" class="headerlink" title="Netty RPC 实现"></a>Netty RPC 实现</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC 可以很好的解耦系统，如 WebService 就是一种基于 Http 协议的 RPC。这个 RPC 整体框架如下：</p><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><ol><li>服务发布与订阅：服务端使用 Zookeeper 注册服务地址，客户端从 Zookeeper 获取可用的服务地址。</li><li>通信：使用 Netty 作为通信框架。</li><li>Spring：使用 Spring 配置服务，加载 Bean，扫描注解。</li><li>动态代理：客户端使用代理模式透明化服务调用。</li><li>消息编解码：使用 Protostuff 序列化和反序列化消息。</li></ol><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub 找到服务地址，并将消息发送到服务端；</li><li>server stub 收到消息后进行解码；</li><li>server stub 根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给 server stub；</li><li>server stub 将返回结果打包成消息并发送至消费方；</li><li>client stub 接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>RPC 的目标就是要 2~8 这些步骤都封装起来，让用户对这些细节透明。JAVA 一般使用动态代理方式实现远程调用。</p><h2 id="消息编解码"><a href="#消息编解码" class="headerlink" title="消息编解码"></a>消息编解码</h2><h3 id="消息数据结构（接口名称-方法名-参数类型和参数值-超时时间-requestID）"><a href="#消息数据结构（接口名称-方法名-参数类型和参数值-超时时间-requestID）" class="headerlink" title="消息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID）"></a>消息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID）</h3><p> 客户端的请求消息结构一般需要包括以下内容：</p><ol><li>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</li><li>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</li><li>参数类型和参数值：参数类型有很多，比如有 bool、int、long、double、string、map、list，甚至如 struct（class）；以及相应的参数值；</li><li>超时时间：</li><li>requestID，标识唯一请求 id，在下面一节会详细描述 requestID 的用处。</li><li>服务端返回的消息 ： 一般包括以下内容。返回值+状态 code+requestID</li></ol><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架，这些都是久经考验的解决方案。</p><h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><h3 id="核心问题-线程暂停、消息乱序"><a href="#核心问题-线程暂停、消息乱序" class="headerlink" title="核心问题(线程暂停、消息乱序)"></a>核心问题(线程暂停、消息乱序)</h3><p>如果使用 netty 的话，一般会用 channel.writeAndFlush()方法来发送消息二进制串，这个方法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的，即对于当前线程来说，将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息的形式发送给客户端的。于是这里出现以下两个问题：</p><ol><li>怎么让当前线程“暂停”，等结果回来后，再向后执行？</li><li>如果有多个线程同时进行远程方法调用，这时建立在 client server 之间的 socket 连接上会有很多双方发送的消息传递，前后顺序也可能是随机的，server 处理完结果后，将结果消息发送给 client，client 收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？如下图所示，线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB，socket 先后将 requestB 和 requestA 发送至 server，而 server 可能将 responseB 先返<br>回，尽管 requestB 请求到达时间更晚。我们需要一种机制保证 responseA 丢给ThreadA，responseB 丢给 ThreadB。</li></ol><h3 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h3><h4 id="requestID-生成-AtomicLong"><a href="#requestID-生成-AtomicLong" class="headerlink" title="requestID 生成-AtomicLong"></a>requestID 生成-AtomicLong</h4><ol><li>client 线程每次通过 socket 调用一次远程接口前，生成一个唯一的 ID，即 requestID（requestID 必需保证在一个 Socket 连接里面是唯一的），一般常常使用 AtomicLong从 0 开始累计数字生成唯一 ID；</li></ol><h4 id="存放回调对象-callback-到全局-ConcurrentHashMap"><a href="#存放回调对象-callback-到全局-ConcurrentHashMap" class="headerlink" title="存放回调对象 callback 到全局 ConcurrentHashMap"></a>存放回调对象 callback 到全局 ConcurrentHashMap</h4><ol start="2"><li>将 处 理 结 果 的 回 调 对 象 callback ， 存 放 到 全 局 ConcurrentHashMap 里 面put(requestID, callback)；</li></ol><h4 id="synchronized-获取回调对象-callback-的锁并自旋-wait"><a href="#synchronized-获取回调对象-callback-的锁并自旋-wait" class="headerlink" title="synchronized 获取回调对象 callback 的锁并自旋 wait"></a>synchronized 获取回调对象 callback 的锁并自旋 wait</h4><ol start="3"><li>当线程调用 channel.writeAndFlush()发送消息后，紧接着执行 callback 的 get()方法试图获取远程返回的结果。在 get()内部，则使用 synchronized 获取回调对象 callback 的锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的wait()方法，释放callback上的锁，让当前线程处于等待状态。</li></ol><h4 id="监听消息的线程收到消息，找到-callback-上的锁并唤醒"><a href="#监听消息的线程收到消息，找到-callback-上的锁并唤醒" class="headerlink" title="监听消息的线程收到消息，找到 callback 上的锁并唤醒"></a>监听消息的线程收到消息，找到 callback 上的锁并唤醒</h4><ol start="4"><li>服务端接收到请求并处理后，将 response结果（此结果中包含了前面的requestID）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果，取到requestID ， 再 从 前 面 的 ConcurrentHashMap 里 面 get(requestID) ， 从 而 找 到callback 对象，再用 synchronized 获取 callback 上的锁，将方法调用结果设置到callback 对象里，再调用 callback.notifyAll()唤醒前面处于等待状态的线程。</li></ol><details>    <summary>通讯流程</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object get() &#123;</span><br><span class="line">    synchronized (this) &#123; // 旋锁</span><br><span class="line">        while (true) &#123; // 是否有结果了</span><br><span class="line">            If （!isDone）&#123;</span><br><span class="line">                wait(); //没结果释放锁，让当前线程处于等待状态</span><br><span class="line">            &#125;else&#123;//获取数据并处理</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void setDone(Response res) &#123;</span><br><span class="line">    this.res = res;</span><br><span class="line">    isDone = true;</span><br><span class="line">    synchronized (this) &#123; //获取锁，因为前面 wait()已经释放了 callback 的锁了</span><br><span class="line">        notifyAll(); // 唤醒处于等待的线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="RMI-实现方式"><a href="#RMI-实现方式" class="headerlink" title="RMI 实现方式"></a>RMI 实现方式</h1><p> Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li><li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li><li>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;</li><li>启动一个 RMI 注册表，以便驻留这些服务;</li><li>在 RMI 注册表中注册服务；</li><li>客户端查找远程对象，并调用远程方法；</li></ol><details>    <summary>RMI 实现方式</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1：创建远程接口，继承 java.rmi.Remote 接口</span><br><span class="line">public interface GreetService extends java.rmi.Remote &#123;</span><br><span class="line">    String sayHello(String name) throws RemoteException;</span><br><span class="line">&#125;</span><br><span class="line">2：实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类</span><br><span class="line">public class GreetServiceImpl extends java.rmi.server.UnicastRemoteObject</span><br><span class="line">        implements GreetService &#123;</span><br><span class="line">    private static final long serialVersionUID = 3434060152387200042L;</span><br><span class="line">    public GreetServiceImpl() throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) throws RemoteException &#123;</span><br><span class="line">        return &quot;Hello &quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3：生成 Stub 和 Skeleton;</span><br><span class="line">4：执行 rmiregistry 命令注册服务</span><br><span class="line">5：启动服务</span><br><span class="line">LocateRegistry.createRegistry(1098);</span><br><span class="line">Naming.bind(&quot;rmi://10.108.1.138:1098/GreetService&quot;, new GreetServiceImpl());</span><br><span class="line">6.客户端调用</span><br><span class="line">GreetService greetService = (GreetService)</span><br><span class="line">        Naming.lookup(&quot;rmi://10.108.1.138:1098/GreetService&quot;);</span><br><span class="line">System.out.println(greetService.sayHello(&quot;Jobs&quot;));</span><br></pre></td></tr></table></figure></details><h1 id="Protoclol-Buffer"><a href="#Protoclol-Buffer" class="headerlink" title="Protoclol Buffer"></a>Protoclol Buffer</h1><p>protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如XML，不过它比xml更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p><ol><li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li><li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li></ol><p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p><ol><li>a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li><li>b. 采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li></ol><h1 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h1><p>Apache Thrift 是 Facebook实现的一种高效的、支持多种编程语言的远程服务调用的框架。本文将从Java 开发人员角度详细介绍 Apache Thrift的架构、开发和部署，并且针对不同的传输协议和服务类型给出相应的 Java 实例，同时详细介绍 Thrift异步客户端的实现，最后提出使用 Thrift 需要注意的事项。</p><p>目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架Apache Thrift，它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa,Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。本文将详细介绍Thrift的使用，并且提供丰富的实例代码加以解释说明，帮助使用者快速构建服务。</p><p>为什么要 Thrift：</p><p>1、多语言开发的需要<br>2、性能问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA中，微服务是一种面向服务的架构风格，其中应用程序被构建为多个不同的小型服务的集合而不是单个应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（微服务）</title>
    <link href="http://yoursite.com/2021/12/31/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/31/JAVA 学习笔记（微服务）/</id>
    <published>2021-12-31T10:12:12.000Z</published>
    <updated>2022-01-02T12:57:24.914Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA中，微服务是一种面向服务的架构风格，其中应用程序被构建为多个不同的小型服务的集合而不是单个应用程序。</p><a id="more"></a><p>[TOC]</p><h1 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a>服务注册发现</h1><p>服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有Netflix家的eureka等。服务注册有两种形式：客户端注册和第三方注册。</p><h2 id="客户端注册（zookeeper）"><a href="#客户端注册（zookeeper）" class="headerlink" title="客户端注册（zookeeper）"></a>客户端注册（zookeeper）</h2><p>客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</p><h2 id="第三方注册（独立的服务-Registrar）"><a href="#第三方注册（独立的服务-Registrar）" class="headerlink" title="第三方注册（独立的服务 Registrar）"></a>第三方注册（独立的服务 Registrar）</h2><p>第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后Registrar负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统，否则注册工作没法进展。</p><h2 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h2><p>客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑</p><h2 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h2><p>服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。</p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>相较于etcd、zookeeper，consul最大的特点就是：它整合了用户服务发现普遍的需求，开箱即用，降低了使用的门槛，并不需要任何第三方的工具。代码实现上也足够简单。</p><p>展开了说，consul的功能有：</p><ul><li>通过DNS或HTTP，应用能轻易地找到它们依赖的系统</li><li>提供了多种健康检查方式：http返回码200，内存是否超限，tcp连接是否成功</li><li>kv存储，并提供http api</li><li>多数据中心，这点是zookeeper所不具备的。</li></ul><p>相比于zookeeper的服务发现使用，consul并不需要专门的sdk集成到服务中，因此它不限制任何语言的使用。我们看看consul一般是怎么使用的。</p><ul><li>每台服务器上都要安装一个consul agent。</li><li>consul agent支持通过配置文件注册服务，或者在服务中通过http接口来注册服务。</li><li>注册服务后，consul agent通过指定的健康检查方式，定期检查服务是否存活。</li><li>如果服务想查询其他服务的存活状态，只需要与本机的consul agent发起一次http请求或者dns请求即可。</li></ul><p>简单点说，consul的使用不依赖任何sdk，依靠简单的http请求就能满足服务发现的所有逻辑。不过，服务每次都从consul agent获取其他服务的存活状态，相比于zookeeper的watcher机制，实时性稍差一点，需考虑如何尽可能提高实时性，问题不会很大。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.简单易用，不需要集成sdk</p><p>2.自带健康检查</p><p>3.支持多数据中心</p><p>4.提供web管理界面</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不能实时获取服务信息的变化通知</p><p>接口是http/dns，一致性算法采用Raft</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h2 id="SmartStack"><a href="#SmartStack" class="headerlink" title="SmartStack"></a>SmartStack</h2><h2 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h2><p>etcd是一个采用http协议的分布式键值对存储系统，因其易用，简单。很多系统都采用或支持etcd作为服务发现的一部分，比如kubernetes。但因为其只是一个存储系统，如果想要提供完整的服务发现功能，必须搭配一些第三方的工具。</p><p>比如配合etcd、Registrator、confd组合，就能搭建一个非常简单而强大的服务发现框架。但这种搭建操作就稍微麻烦了点，尤其是相对consul来说。所以etcd大部分场景都是被用来做kv存储，比如kubernetes。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>1.简单易用，不需要集成sdk</p><p>2.可配置性强</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>1.没有健康检查</p><p>2.需配合第三方工具一起完成服务发现</p><p>3.不支持多数据中心</p><p>接口是http，一致性算法采用Raft</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>1.功能强大，不仅仅只是服务发现</p><p>2.提供watcher机制能实时获取服务提供者的状态</p><p>3.dubbo等框架支持</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>1.没有健康检查</p><p>2.需在服务中集成sdk，复杂度高</p><p>3.不支持多数据中心</p><p>接口是sdk，一致性算法采用Paxos</p><h1 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h1><p>API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的 API Gateway。</p><p>API Gateway 负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。</p><h2 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h2><p>服务转发主要是对客户端的请求按照微服务的负载转发到不同的服务上</p><h2 id="响应合并"><a href="#响应合并" class="headerlink" title="响应合并"></a>响应合并</h2><p>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。</p><h2 id="协议转换"><a href="#协议转换" class="headerlink" title="协议转换"></a>协议转换</h2><p>重点是支持 SOAP，JMS，Rest 间的协议转换。</p><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>重点是支持 XML 和 Json 之间的报文格式转换能力（可选）</p><h2 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h2><ol><li>基于 Token 的客户端访问控制和安全策略</li><li>传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包</li><li>基于 Https 的传输加密，客户端和服务端数字证书支持</li><li>基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）</li></ol><h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问。</p><h2 id="zookeeper-配置中心"><a href="#zookeeper-配置中心" class="headerlink" title="zookeeper 配置中心"></a>zookeeper 配置中心</h2><p>实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。</p><h2 id="配置中心数据分类"><a href="#配置中心数据分类" class="headerlink" title="配置中心数据分类"></a>配置中心数据分类</h2><h1 id="事件调度（kafka）"><a href="#事件调度（kafka）" class="headerlink" title="事件调度（kafka）"></a>事件调度（kafka）</h1><p>消息服务和事件的统一调度，常用用 kafka ，activemq 等。</p><h1 id="服务跟踪（starter-sleuth）"><a href="#服务跟踪（starter-sleuth）" class="headerlink" title="服务跟踪（starter-sleuth）"></a>服务跟踪（starter-sleuth）</h1><p>随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， Spring Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个。</p><ol><li>为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID的记录，我们就能将所有请求过程日志关联起来。</li><li>为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。</li><li>在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth 组件的实现。在 Spring Boot应用中，通过在工程中引入 spring-cloudstarter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：</li></ol><ul><li>通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息中间件）传递的请求。</li><li>通过 Zuul 代理传递的请求。</li><li>通过 RestTemplate 发起的请求。</li></ul><h1 id="服务熔断（Hystrix）"><a href="#服务熔断（Hystrix）" class="headerlink" title="服务熔断（Hystrix）"></a>服务熔断（Hystrix）</h1><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p><h1 id="Hystrix-断路器机制"><a href="#Hystrix-断路器机制" class="headerlink" title="Hystrix 断路器机制"></a>Hystrix 断路器机制</h1><p>断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认50%),断路器会切换到开路状态(Open).这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒),自动切换到半开路状态(HALF-OPEN).这时会判断下一次请求的返回情况,如果请求成功,断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p><h1 id="API-管理"><a href="#API-管理" class="headerlink" title="API 管理"></a>API 管理</h1><p>SwaggerAPI 管理工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA中，微服务是一种面向服务的架构风格，其中应用程序被构建为多个不同的小型服务的集合而不是单个应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Microservice" scheme="http://yoursite.com/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（IoC控制反转）</title>
    <link href="http://yoursite.com/2021/12/30/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88IoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/30/JAVA 学习笔记（IoC控制反转）/</id>
    <published>2021-12-30T10:12:12.000Z</published>
    <updated>2021-12-31T03:38:41.796Z</updated>
    
    <content type="html"><![CDATA[<p>Spring提供的容器又称为IoC容器，什么是IoC？</p><p>IoC全称Inversion of Control，直译为控制反转。IoC又称为依赖注入（DI：Dependency Injection）</p><a id="more"></a><p>[TOC]</p><h1 id="控制反转-1"><a href="#控制反转-1" class="headerlink" title="控制反转^1"></a>控制反转<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282381977747489" target="_blank" rel="noopener">^1</a></h1><p>那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p><p>我们假定一个在线书店，通过BookService获取书籍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    private HikariConfig config = new HikariConfig();</span><br><span class="line">    private DataSource dataSource = new HikariDataSource(config);</span><br><span class="line"></span><br><span class="line">    public Book getBook(long bookId) &#123;</span><br><span class="line">        try (Connection conn = dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            return book;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了从数据库查询书籍，BookService持有一个DataSource。为了实例化一个HikariDataSource，又不得不实例化一个HikariConfig。</p><p>现在，我们继续编写UserService获取用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    private HikariConfig config = new HikariConfig();</span><br><span class="line">    private DataSource dataSource = new HikariDataSource(config);</span><br><span class="line"></span><br><span class="line">    public User getUser(long userId) &#123;</span><br><span class="line">        try (Connection conn = dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            return user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为UserService也需要访问数据库，因此，我们不得不也实例化一个HikariDataSource。</p><p>在处理用户购买的CartServlet中，我们需要实例化UserService和BookService：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CartServlet extends HttpServlet &#123;</span><br><span class="line">    private BookService bookService = new BookService();</span><br><span class="line">    private UserService userService = new UserService();</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        long currentUserId = getFromCookie(req);</span><br><span class="line">        User currentUser = userService.getUser(currentUserId);</span><br><span class="line">        Book book = bookService.getBook(req.getParameter(&quot;bookId&quot;));</span><br><span class="line">        cartService.addToCart(currentUser, book);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，在购买历史HistoryServlet中，也需要实例化UserService和BookService：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class HistoryServlet extends HttpServlet &#123;</span><br><span class="line">    private BookService bookService = new BookService();</span><br><span class="line">    private UserService userService = new UserService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述每个组件都采用了一种简单的通过new创建实例并持有的方式。仔细观察，会发现以下缺点：</p><p>实例化一个组件其实很难，例如，BookService和UserService要创建HikariDataSource，实际上需要读取配置，才能先实例化HikariConfig，再实例化HikariDataSource。</p><p>没有必要让BookService和UserService分别创建DataSource实例，完全可以共享同一个DataSource，但谁负责创建DataSource，谁负责获取其他组件已经创建的DataSource，不好处理。类似的，CartServlet和HistoryServlet也应当共享BookService实例和UserService实例，但也不好处理。</p><p>很多组件需要销毁以便释放资源，例如DataSource，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</p><p>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</p><p>测试某个组件，例如BookService，是复杂的，因为必须要在真实的数据库环境下执行。</p><p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p><p>因此，核心问题是：</p><ul><li>谁负责创建组件？</li><li>谁负责根据依赖关系组装组件？</li><li>销毁时，如何按依赖顺序正确销毁？<br>解决这一问题的核心方案就是IoC。</li></ul><p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p><p>CartServlet创建了BookService，在创建BookService的过程中，又创建了DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p><p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，BookService自己并不会创建DataSource，而是等待外部通过setDataSource()方法来注入一个DataSource：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不直接new一个DataSource，而是注入一个DataSource，这个小小的改动虽然简单，却带来了一系列好处：</p><ul><li>BookService不再关心如何创建DataSource，因此，不必编写读取数据库配置之类的代码；</li><li>DataSource实例被注入到BookService，同样也可以注入到UserService，因此，共享一个组件非常简单；</li><li>测试BookService更容易，因为注入的是DataSource，可以使用内存数据库，而不是真实的MySQL配置。</li></ul><h1 id="依赖注入（DI：Dependency-Injection）"><a href="#依赖注入（DI：Dependency-Injection）" class="headerlink" title="依赖注入（DI：Dependency Injection）"></a>依赖注入（DI：Dependency Injection）</h1><p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。</p><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p><h1 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h1><p>我们从上面的代码可以看到，依赖注入可以通过set()方法实现。但依赖注入也可以通过构造方法实现。</p><p>很多Java类都具有带参数的构造方法，如果我们把BookService改造为通过构造方法注入，那么实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookService &#123;</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public BookService(DataSource dataSource) &#123;</span><br><span class="line">        this.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p><h1 id="无侵入容器"><a href="#无侵入容器" class="headerlink" title="无侵入容器"></a>无侵入容器</h1><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p><ul><li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li><li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li></ul><h1 id="控制反转（IOC）和依赖注入（DI）的区别-2"><a href="#控制反转（IOC）和依赖注入（DI）的区别-2" class="headerlink" title="控制反转（IOC）和依赖注入（DI）的区别^2"></a>控制反转（IOC）和依赖注入（DI）的区别<a href="https://www.cnblogs.com/jett010/p/10984020.html" target="_blank" rel="noopener">^2</a></h1><p>IOC   inversion of control  控制反转</p><p>DI   Dependency Injection  依赖注入</p><p>要理解这两个概念，首先要搞清楚以下几个问题：</p><ul><li>参与者都有谁？</li><li>依赖：谁依赖于谁？为什么需要依赖？</li><li>注入：谁注入于谁？到底注入什么？</li><li>控制反转：谁控制谁？控制什么？为何叫反转（有反转就应该有正转了）？</li><li>依赖注入和控制反转是同一概念吗？</li></ul><p>下面就来简要的回答一下上述问题，把这些问题搞明白了，IoC/DI也就明白了。</p><h2 id="参与者都有谁："><a href="#参与者都有谁：" class="headerlink" title="参与者都有谁："></a>参与者都有谁：</h2><p>一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。</p><p>又要名词解释一下，某个对象指的就是任意的、普通的Java对象;IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序；对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。</p><h2 id="谁依赖于谁："><a href="#谁依赖于谁：" class="headerlink" title="谁依赖于谁："></a>谁依赖于谁：</h2><p>当然是某个对象依赖于IoC/DI的容器</p><h2 id="为什么需要依赖："><a href="#为什么需要依赖：" class="headerlink" title="为什么需要依赖："></a>为什么需要依赖：</h2><p>对象需要IoC/DI的容器来提供对象需要的外部资源</p><h2 id="谁注入于谁："><a href="#谁注入于谁：" class="headerlink" title="谁注入于谁："></a>谁注入于谁：</h2><p>很明显是IoC/DI的容器 注入 某个对象</p><h2 id="到底注入什么："><a href="#到底注入什么：" class="headerlink" title="到底注入什么："></a>到底注入什么：</h2><p>就是注入某个对象所需要的外部资源</p><h2 id="谁控制谁："><a href="#谁控制谁：" class="headerlink" title="谁控制谁："></a>谁控制谁：</h2><p>当然是IoC/DI的容器来控制对象了</p><h2 id="控制什么："><a href="#控制什么：" class="headerlink" title="控制什么："></a>控制什么：</h2><p>主要是控制对象实例的创建</p><h2 id="为何叫反转："><a href="#为何叫反转：" class="headerlink" title="为何叫反转："></a>为何叫反转：</h2><p>反转是相对于正向而言的，那么什么算是正向的呢？考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。</p><h2 id="依赖注入和控制反转是同一概念吗？"><a href="#依赖注入和控制反转是同一概念吗？" class="headerlink" title="依赖注入和控制反转是同一概念吗？"></a>依赖注入和控制反转是同一概念吗？</h2><p>根据上面的讲述，应该能看出来，依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。</p><p>依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：</p><p>应用程序依赖容器创建并注入它所需要的外部资源；</p><p>而控制反转是从容器的角度在描述，描述完整点：</p><p>容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>其实IoC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。</p><p>这么小小的一个改变其实是编程思想的一个大进步，这样就有效的分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</p><h2 id="接下演示一下依赖注入机制的过程"><a href="#接下演示一下依赖注入机制的过程" class="headerlink" title="接下演示一下依赖注入机制的过程"></a>接下演示一下依赖注入机制的过程</h2><details>    <summary>待注入的业务对象Content.java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zj.ioc.di.ctor;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness &#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public MyBusiness(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusiness()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusiness()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>MyBusniess类展示了一个业务组件，它的实现需要对象Content的注入。分别演示构造子注入（Constructor Injection），设值注入（Setter Injection）和接口注入（Interface Injection）三种方式。</p><details>    <summary>构造子注入（Constructor Injection）MyBusiness.java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zj.ioc.di.ctor;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness &#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public MyBusiness(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusiness()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusiness()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>设值注入（Setter Injection） MyBusiness.java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public interface InContent &#123;</span><br><span class="line">    void createContent(Content content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>设置注入接口InContent.java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public interface InContent &#123;</span><br><span class="line">    void createContent(Content content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>接口注入（Interface Injection）MyBusiness.java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line">package com.zj.ioc.di.iface;</span><br><span class="line">import com.zj.ioc.di.Content;</span><br><span class="line"> </span><br><span class="line">public class MyBusiness implements InContent&#123;</span><br><span class="line">    private Content myContent;</span><br><span class="line"> </span><br><span class="line">    public void createContent(Content content) &#123;</span><br><span class="line">       myContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doBusniess()&#123;</span><br><span class="line">       myContent.BusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void doAnotherBusniess()&#123;</span><br><span class="line">       myContent.AnotherBusniessContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring提供的容器又称为IoC容器，什么是IoC？&lt;/p&gt;
&lt;p&gt;IoC全称Inversion of Control，直译为控制反转。IoC又称为依赖注入（DI：Dependency Injection）&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Bean）</title>
    <link href="http://yoursite.com/2021/12/30/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Bean%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/30/JAVA 学习笔记（Bean）/</id>
    <published>2021-12-30T07:12:12.000Z</published>
    <updated>2021-12-30T09:26:14.302Z</updated>
    
    <content type="html"><![CDATA[<p>Bean的概念</p><a id="more"></a><p>[TOC]</p><h1 id="什么是Bean-1-3"><a href="#什么是Bean-1-3" class="headerlink" title="什么是Bean^1^3"></a>什么是Bean<a href="https://www.runoob.com/jsp/jsp-javabean." target="_blank" rel="noopener">^1</a><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680" target="_blank" rel="noopener">^3</a></h1><p>你<br>一种规范，表达实体和信息的规范，便于封装重用。</p><p>Bean的中文含义是“豆子”，顾名思义JavaBean是一段Java小程序。JavaBean实际上是指一种特殊的Java类，它通常用来实现一些比较常用的简单功能，并可以很容易的被重用或者是插入其他应用程序中去。所有遵循一定编程原则的Java类都可以被称作JavaBean。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1、若干private实例字段；</p><p>2、提供一个默认的无参构造函数；</p><p>3、可能有一系列的 getter 或 setter 方法；</p><p>4、需要被序列化并且实现serializable接口；</p><h1 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h1><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><p>保持向后兼容性</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bean的概念&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Spring 原理）</title>
    <link href="http://yoursite.com/2021/12/30/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Spring%20%E5%8E%9F%E7%90%86%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/30/JAVA 学习笔记（Spring 原理）/</id>
    <published>2021-12-30T02:12:12.000Z</published>
    <updated>2021-12-31T10:01:06.783Z</updated>
    
    <content type="html"><![CDATA[<p>Spring是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。</p><a id="more"></a><p>[TOC]</p><h1 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点</h1><h2 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h2><p>从大小与开销两方面而言Spring都是轻量级的，完整的Spring框架可以在一个大小只有1M多的JAR文件里发布，并且所需的处理开销也是微不足道的。所以可以在小型设备中使用。</p><p>此外，Spring是非侵入式的：典型的，Spring应用中的对象不依赖于Spring的特定类。</p><h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>控制反转（IOC）：通过控制反转实现解耦，大大降低代码量，促进了低耦合</p><p>当应用了IOC，一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。</p><h2 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h2><p>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p><p>在事务处理、日志管理、权限控制、异常处理这些板块有很明显的优势</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Spring提供了容器功能，容器可以管理对象的生命周期、对象与对象间的关系、我们可以通过编写XML来设置对象关系和初始值，这样容器在启动之后，所有的对象都直接可以使用，不用编写任何编码来产生对象。Spring有两种不同的容器：Bean工厂以及应用上下文</p><p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容齐，你可以配置你的每个bean如何被创建。。。基于一个可配置原型，你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例以及它们是如何关联的。</p><h2 id="框架集合"><a href="#框架集合" class="headerlink" title="框架集合"></a>框架集合</h2><p>Spring可以将简单的组件配置，组合成为复杂的应用。</p><p>在Spring中，应用对象被声明式的组合，典型的是在一个XML文件里。</p><p>Spring也提供了很多基础功能（事务管理，持久化框架集成等），将应用逻辑的开发留给开发者。</p><p>可以集成mybatis， hibernate等框架</p><h1 id="Spring-核心组件"><a href="#Spring-核心组件" class="headerlink" title="Spring 核心组件"></a>Spring 核心组件</h1><h1 id="Spring-常用模块"><a href="#Spring-常用模块" class="headerlink" title="Spring 常用模块"></a>Spring 常用模块</h1><h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><p>核心容器提供Spring框架的基本功能，核心容器的主要组件是BeanFactory，它是工厂模式的实现，BeanFactory使用控制反转（IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p><h2 id="Spring上下文"><a href="#Spring上下文" class="headerlink" title="Spring上下文"></a>Spring上下文</h2><p>Spring上下文是一个配置文件，向Spring框架提供上下文信息，Spring上下文包括企业服务，例如JNDI，EJB，电子邮件，国际化，校验和调度功能。</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>通过配置管理特性，Spring AOP模块直接将面向切面的编程功能集成到了Spring框架中，可以将一些通用任务，如安全，事务，日志等集中进行管理，提高了复用性和管理的便捷性。</p><h2 id="Spring-DAO"><a href="#Spring-DAO" class="headerlink" title="Spring DAO"></a>Spring DAO</h2><p>为JDBC DAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商跑出的错误消息，异常层次结构简化了错误处理，并且极大地降低了需要便携的异常代码数量（例如打开和关闭连接）。Spring DAO的面向JDBC的异常遵从通用的DAO异常层次结构。</p><h2 id="Spring-ORM"><a href="#Spring-ORM" class="headerlink" title="Spring ORM"></a>Spring ORM</h2><p>Spring框架插入了若干个ORM框架，从而提供了ORM的对象关系工具。其中包括JDO，Hiberinate和iBatis SQL Map。所有这些都遵从Spring的通用事务和DAO异常层次结构。</p><h2 id="Spring-Web模块"><a href="#Spring-Web模块" class="headerlink" title="Spring Web模块"></a>Spring Web模块</h2><p>WEb上下文模块建立在应用恒旭上下文模块之上，为基于Web的应用程序提供了上下文。所以，Spring框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><h2 id="Spring-MVC框架"><a href="#Spring-MVC框架" class="headerlink" title="Spring MVC框架"></a>Spring MVC框架</h2><p>MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术。MVC容纳了大量视图技术，其中包括JSP，Velocity，Tiles，iText和POI。</p><h1 id="Spring-主要包"><a href="#Spring-主要包" class="headerlink" title="Spring 主要包"></a>Spring 主要包</h1><h2 id="Core-Container-核心容器"><a href="#Core-Container-核心容器" class="headerlink" title="Core Container 核心容器"></a>Core Container 核心容器</h2><p>容器是Spring的核心部分，Core Container 模块是Spring框架的基础，所有模块都构建于核心模块之上。</p><p>Beans ： Beans模块是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Depen-dency Injection（IoC/DI）操作相关的所有类。</p><p>Core  ： Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件要都要使用到这个包里的类，Core模块是其他组件的基本核心。当然你也可以在自己的应用系统中使用这些工具类。</p><p>Context  :  Spring的上下文即IoC容器，通过上下文可以获得容器中的Bean。ApplicationContext接口是Context模块的关键。  Context模块构建于Core和Beans模块基础之上，提供了一种类似于JNDI注册器的框架式的对象访问方法。</p><p>SpEl  :  Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操纵对象。</p><h1 id="Spring-常用注解"><a href="#Spring-常用注解" class="headerlink" title="Spring 常用注解"></a>Spring 常用注解</h1><p>bean 注入与装配的的方式有很多种，可以通过 xml，get set 方式，构造函数或者注解等。简单易用的方式就是使用 Spring 的注解了，Spring 提供了大量的注解方式。</p><h2 id="声明bean的注解"><a href="#声明bean的注解" class="headerlink" title="声明bean的注解"></a>声明bean的注解</h2><p>@Component 泛指组件，没有明确的角色，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@Service 在业务逻辑层使用（service层）</p><p>@Repository 在数据访问层使用（dao层）</p><p>@Controller 在展现层使用，控制器的声明（C），用于标注控制层组件。</p><h2 id="注入bean的注解"><a href="#注入bean的注解" class="headerlink" title="注入bean的注解"></a>注入bean的注解</h2><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><h2 id="java配置类相关注解"><a href="#java配置类相关注解" class="headerlink" title="java配置类相关注解"></a>java配置类相关注解</h2><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><h2 id="切面（AOP）相关注解"><a href="#切面（AOP）相关注解" class="headerlink" title="切面（AOP）相关注解"></a>切面（AOP）相关注解</h2><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面（类上）<br>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><p>@After 在方法执行之后执行（方法上） </p><p>@Before 在方法执行之前执行（方法上） </p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut 声明切点<br>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><h2 id="Bean的属性支持"><a href="#Bean的属性支持" class="headerlink" title="@Bean的属性支持"></a>@Bean的属性支持</h2><p>@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）<br>其设置类型包括：</p><p>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）, </p><p>Protetype （每次调用新建一个bean）, </p><p>Request （web项目中，给每个http request新建一个bean）, </p><p>Session （web项目中，给每个http session新建一个bean）, </p><p>GlobalSession（给每一个 global http session新建一个Bean实例）</p><p>@StepScope 在Spring Batch中还有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><h2 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h2><p>@Value 为属性注入值（属性上）<br>支持如下方式的注入：</p><p>》注入普通字符</p><pre><code>@Value(&quot;Michael Jackson&quot;)String name;</code></pre><p>》注入操作系统属性</p><pre><code>@Value(&quot;#{systemProperties[&apos;os.name&apos;]}&quot;)String osName;</code></pre><p>》注入表达式结果</p><pre><code>@Value(&quot;#{ T(java.lang.Math).random() * 100 }&quot;) String randomNumber;</code></pre><p>》注入其它bean属性</p><pre><code>@Value(&quot;#{domeClass.name}&quot;)String name;</code></pre><p>》注入文件资源</p><pre><code>@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)String Resource file;</code></pre><p>》注入网站资源</p><pre><code>@Value(&quot;http://www.cznovel.com&quot;)Resource url;</code></pre><p>》注入配置文件</p><pre><code>@Value(&quot;${book.name}&quot;)String bookName;</code></pre><p>注入配置使用方法： </p><p>① 编写配置文件（test.properties）</p><pre><code>book.name=《三体》</code></pre><p>② @PropertySource 加载配置文件(类上)</p><pre><code>@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)</code></pre><p>③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。</p><h2 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h2><p>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p><p>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><h2 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h2><p>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</p><p>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</p><h2 id="定时任务相关"><a href="#定时任务相关" class="headerlink" title="定时任务相关"></a>定时任务相关</h2><p>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</p><p>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><h2 id="Enable-注解说明"><a href="#Enable-注解说明" class="headerlink" title="@Enable*注解说明"></a>@Enable*注解说明</h2><p>这些注解主要用来开启对xxx的支持。<br>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</p><p>@EnableAsync 开启异步方法的支持</p><p>@EnableScheduling 开启计划任务的支持</p><p>@EnableWebMvc 开启Web MVC的配置支持</p><p>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</p><p>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableTransactionManagement 开启注解式事务的支持</p><p>@EnableCaching 开启注解式的缓存支持</p><h2 id="测试相关注解"><a href="#测试相关注解" class="headerlink" title="测试相关注解"></a>测试相关注解</h2><p>@RunWith 运行器，Spring中通常用于对JUnit的支持</p><p>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes={TestConfig.class})public class KjtTest {    private static Logger logger = LoggerFactory.getLogger(&quot;KjtTest&quot;);    @Autowired    Service service;    @Test    public void test() {    }}</code></pre><h2 id="SpringMVC部分"><a href="#SpringMVC部分" class="headerlink" title="SpringMVC部分"></a>SpringMVC部分</h2><p>@EnableWebMvc 在配置类中开启WebMVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p><p>@Controller 声明该类为SpringMVC中的Controller</p><p>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， </p><p>这对所有注解了 @RequestMapping的控制器内的方法有效。</p><p>@ExceptionHandler 用于全局处理控制器里的异常</p><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p><h1 id="Spring-第三方框架结合"><a href="#Spring-第三方框架结合" class="headerlink" title="Spring 第三方框架结合"></a>Spring 第三方框架结合</h1><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h3><p>java的一个安全框架</p><p>认证、授权、加密、会话管理、与Web集成、缓存</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="Ehcache"><a href="#Ehcache" class="headerlink" title="Ehcache"></a>Ehcache</h3><p>是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider</p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>一个开源的使用ANSIC语言便携、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库</p><h2 id="持久层框架"><a href="#持久层框架" class="headerlink" title="持久层框架"></a>持久层框架</h2><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>是支持普通SQL查询，存储过程和高级映射的优秀持久层框架</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="quartz"><a href="#quartz" class="headerlink" title="quartz"></a>quartz</h3><p>一个开源的作业调度框架，由java编写，在.NET平台为Quartz.Net ，通过Quart可以快速完成任务调度的工作</p><h3 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring-Task"></a>Spring-Task</h3><p>可以将它比作一个轻量级的Quartz，而且使用起来很简单，除spring相关的包外不需要额外的包，而且支持注解和配置文件两种形式</p><h2 id="校验框架"><a href="#校验框架" class="headerlink" title="校验框架"></a>校验框架</h2><h3 id="Hibernate-validator"><a href="#Hibernate-validator" class="headerlink" title="Hibernate validator"></a>Hibernate validator</h3><p>常用来验证bean的字段，基于注解，方便快捷高效</p><h3 id="Oval"><a href="#Oval" class="headerlink" title="Oval"></a>Oval</h3><p>一个可扩展的Java对象数据验证框架，验证的规则可以通过配置文件、Annotation、POJOs进行设定，可以使用纯Java语言、JavaScript，Groovy、BeanShell等进行规则的编写。</p><h1 id="Spring-IOC-原理-Inversion-of-Control，控制反转"><a href="#Spring-IOC-原理-Inversion-of-Control，控制反转" class="headerlink" title="Spring IOC 原理 (Inversion of Control，控制反转)"></a>Spring IOC 原理 (Inversion of Control，控制反转)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p><h2 id="Spring-容器高层视图"><a href="#Spring-容器高层视图" class="headerlink" title="Spring 容器高层视图"></a>Spring 容器高层视图</h2><p>Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现</p><h2 id="IOC-容器实现"><a href="#IOC-容器实现" class="headerlink" title="IOC 容器实现"></a>IOC 容器实现</h2><h3 id="BeanFactory-框架基础设施"><a href="#BeanFactory-框架基础设施" class="headerlink" title="BeanFactory-框架基础设施"></a>BeanFactory-框架基础设施</h3><p>BeanFactory 是 Spring 框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory</p><h4 id="BeanDefinitionRegistry-注册表"><a href="#BeanDefinitionRegistry-注册表" class="headerlink" title="BeanDefinitionRegistry 注册表"></a>BeanDefinitionRegistry 注册表</h4><ol><li>Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册BeanDefinition 对象的方法。</li></ol><h4 id="BeanFactory-顶层接口"><a href="#BeanFactory-顶层接口" class="headerlink" title="BeanFactory 顶层接口"></a>BeanFactory 顶层接口</h4><ol start="2"><li>位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的Bean，BeanFactory的功能通过其他的接口得到不断扩展：</li></ol><h4 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h4><ol start="3"><li>该接口定义了访问容器中 Bean基本信息的若干方法，如查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包括某一 Bean 等方法；</li></ol><h4 id="HierarchicalBeanFactory-父子级联"><a href="#HierarchicalBeanFactory-父子级联" class="headerlink" title="HierarchicalBeanFactory 父子级联"></a>HierarchicalBeanFactory 父子级联</h4><ol start="4"><li>父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的Bean位于父容器中。这样，展现层Bean就可以引用业务层和持久层的Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</li></ol><h4 id="ConfigurableBeanFactory"><a href="#ConfigurableBeanFactory" class="headerlink" title="ConfigurableBeanFactory"></a>ConfigurableBeanFactory</h4><ol start="5"><li>是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li></ol><h4 id="AutowireCapableBeanFactory-自动装配"><a href="#AutowireCapableBeanFactory-自动装配" class="headerlink" title="AutowireCapableBeanFactory 自动装配"></a>AutowireCapableBeanFactory 自动装配</h4><ol start="6"><li>定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li></ol><h4 id="SingletonBeanRegistry-运行期间注册单例-Bean"><a href="#SingletonBeanRegistry-运行期间注册单例-Bean" class="headerlink" title="SingletonBeanRegistry 运行期间注册单例 Bean"></a>SingletonBeanRegistry 运行期间注册单例 Bean</h4><ol start="7"><li>定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从IoC 容器的缓存中获取 Bean 实例。Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，它是一个用 HashMap 实现的缓存器，单实例的 Bean 以beanName 为键保存在这个 HashMap 中。</li></ol><h4 id="依赖日志框框"><a href="#依赖日志框框" class="headerlink" title="依赖日志框框"></a>依赖日志框框</h4><ol start="8"><li>在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用 Log4J， 即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错。</li></ol><h3 id="ApplicationContext-面向开发应用"><a href="#ApplicationContext-面向开发应用" class="headerlink" title="ApplicationContext 面向开发应用"></a>ApplicationContext 面向开发应用</h3><p>ApplicationContext 由 BeanFactory 派 生 而 来 ， 提 供 了 更 多 面 向 实 际 应 用 的 功 能 。ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：</p><ol><li>ClassPathXmlApplicationContext：默认从类路径加载配置文件</li><li>FileSystemXmlApplicationContext：默认从文件系统中装载配置文件</li><li>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</li><li>MessageSource：为应用提供 i18n 国际化消息访问的功能；</li><li>ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</li><li>LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li><li>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用refresh()即可启动应用上下文，在已经启动的状态下，调用refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用上下文。</li></ol><h3 id="WebApplication-体系架构"><a href="#WebApplication-体系架构" class="headerlink" title="WebApplication 体系架构"></a>WebApplication 体系架构</h3><p>WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext中，以便 Web 应用环境可以访问 Spring 应用上下文。</p><h2 id="Spring-Bean-作用域"><a href="#Spring-Bean-作用域" class="headerlink" title="Spring Bean 作用域"></a>Spring Bean 作用域</h2><p>Spring 3 中为 Bean 定义了 5 中作用域，分别为 singleton（单例）、prototype（原型）、request、session 和 global session，5 种作用域说明如下：</p><h3 id="singleton：单例模式（多线程下不安全）"><a href="#singleton：单例模式（多线程下不安全）" class="headerlink" title="singleton：单例模式（多线程下不安全）"></a>singleton：单例模式（多线程下不安全）</h3><ol><li>singleton：单例模式，Spring IoC 容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式，配置为：</li></ol><bean id="userDao" class="com.ioc.UserDaoImpl" scope="singleton"><h3 id="prototype-原型模式每次使用时创建"><a href="#prototype-原型模式每次使用时创建" class="headerlink" title="prototype:原型模式每次使用时创建"></a>prototype:原型模式每次使用时创建</h3><ol start="2"><li>prototype:原型模式，每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态，而 singleton 全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton<br>作用域。</li></ol><h3 id="Request：一次-request-一个实例"><a href="#Request：一次-request-一个实例" class="headerlink" title="Request：一次 request 一个实例"></a>Request：一次 request 一个实例</h3><ol start="3"><li>request：在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的 Bean，而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean实例也将会被销毁。</li></ol><bean id="loginAction" class="com.cnblogs.Login" scope="request"><h3 id="session（会话）"><a href="#session（会话）" class="headerlink" title="session（会话）"></a>session（会话）</h3><ol start="4"><li>session：在一次 Http Session 中，容器会返回该 Bean 的同一实例。而对不同的 Session 请求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。</li></ol><bean id="userPreference" class="com.ioc.UserPreference" scope="session"><h3 id="global-Session"><a href="#global-Session" class="headerlink" title="global Session"></a>global Session</h3><ol start="5"><li>global Session：在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效</li></ol><h2 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h2><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><ol><li>实例化一个 Bean，也就是我们常说的 new。</li></ol><h3 id="IOC-依赖注入"><a href="#IOC-依赖注入" class="headerlink" title="IOC 依赖注入"></a>IOC 依赖注入</h3><ol start="2"><li>按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入。</li></ol><h3 id="setBeanName-实现"><a href="#setBeanName-实现" class="headerlink" title="setBeanName 实现"></a>setBeanName 实现</h3><ol start="3"><li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值</li></ol><h3 id="BeanFactoryAware-实现"><a href="#BeanFactoryAware-实现" class="headerlink" title="BeanFactoryAware 实现"></a>BeanFactoryAware 实现</h3><ol start="4"><li>如果这个 Bean 已经实现了 BeanFactoryAware接口，会调用它实现的setBeanFactory，setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它 Bean，只需在 Spring 配置文件中配置一个普通的 Bean 就可以）。</li></ol><h3 id="ApplicationContextAware-实现"><a href="#ApplicationContextAware-实现" class="headerlink" title="ApplicationContextAware 实现"></a>ApplicationContextAware 实现</h3><ol start="5"><li>如果这个 Bean 已经实现了 ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤 4 的内容，但比 4 更好，因为 ApplicationContext 是 BeanFactory 的子接口，有更多的实现方法）</li></ol><h3 id="postProcessBeforeInitialization-接口实现-初始化预处理"><a href="#postProcessBeforeInitialization-接口实现-初始化预处理" class="headerlink" title="postProcessBeforeInitialization 接口实现-初始化预处理"></a>postProcessBeforeInitialization 接口实现-初始化预处理</h3><ol start="6"><li>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用 postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用<br>作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。</li></ol><h3 id="init-method"><a href="#init-method" class="headerlink" title="init-method"></a>init-method</h3><ol start="7"><li>如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。</li></ol><h3 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h3><ol start="8"><li>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。</li></ol><p>注：以上工作完成以后就可以应用这个 Bean 了，那这个 Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在 Spring 配置文件中也可以配置非 Singleton。</p><h3 id="Destroy-过期自动清理阶段"><a href="#Destroy-过期自动清理阶段" class="headerlink" title="Destroy 过期自动清理阶段"></a>Destroy 过期自动清理阶段</h3><ol start="9"><li>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用那个其实现的 destroy()方法；</li></ol><h3 id="destroy-method-自配置清理"><a href="#destroy-method-自配置清理" class="headerlink" title="destroy-method 自配置清理"></a>destroy-method 自配置清理</h3><ol start="10"><li>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</li></ol><ol start="11"><li>bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。</li></ol><bean id class init-method="初始化方法" destroy-method="销毁方法"><h2 id="Spring-依赖注入四种方式"><a href="#Spring-依赖注入四种方式" class="headerlink" title="Spring 依赖注入四种方式"></a>Spring 依赖注入四种方式</h2><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><details>    <summary>构造器注入</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*带参数，方便利用构造器进行注入*/</span><br><span class="line"> public CatDaoImpl(String message)&#123;</span><br><span class="line">    this. message = message;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;bean id=&quot;CatDaoImpl&quot; class=&quot;com.CatDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot; message &quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></details><h3 id="setter-方法注入"><a href="#setter-方法注入" class="headerlink" title="setter 方法注入"></a>setter 方法注入</h3><details>    <summary>setter 方法注入</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Id &#123;</span><br><span class="line">     private int id;</span><br><span class="line">     public int getId() &#123; return id; &#125;</span><br><span class="line">     public void setId(int id) &#123; this.id = id; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=&quot;id&quot; class=&quot;com.id &quot;&gt; &lt;property name=&quot;id&quot; value=&quot;123&quot;&gt;&lt;/property&gt; &lt;/bean&gt;</span><br></pre></td></tr></table></figure></details><h3 id="静态工厂注入"><a href="#静态工厂注入" class="headerlink" title="静态工厂注入"></a>静态工厂注入</h3><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 spring 注入的形式获取：</p><details>    <summary></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DaoFactory &#123; //静态工厂</span><br><span class="line">    public static final FactoryDao getStaticFactoryDaoImpl()&#123;</span><br><span class="line">        return new StaticFacotryDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SpringAction &#123;</span><br><span class="line">    private FactoryDao staticFactoryDao; //注入对象</span><br><span class="line">    //注入对象的 set 方法</span><br><span class="line">    public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123;</span><br><span class="line">        this.staticFactoryDao = staticFactoryDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span><br><span class="line"> &lt;bean name=&quot;springAction&quot; class=&quot; SpringAction&quot; &gt;</span><br><span class="line"> &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line"> &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> &lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;</span><br><span class="line">&lt;bean name=&quot;staticFactoryDao&quot; class=&quot;DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></details><h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><p>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先 new 工厂类，再调用普通的实例方法：</p><details>    <summary>实例工厂</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DaoFactory &#123; //实例工厂</span><br><span class="line">        public FactoryDao getFactoryDaoImpl()&#123;</span><br><span class="line">            return new FactoryDaoImpl();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class SpringAction &#123;</span><br><span class="line">        private FactoryDao factoryDao; //注入对象</span><br><span class="line">        public void setFactoryDao(FactoryDao factoryDao) &#123;</span><br><span class="line">            this.factoryDao = factoryDao;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &lt;bean name=&quot;springAction&quot; class=&quot;SpringAction&quot;&gt;</span><br><span class="line">     &lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line">     &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line">     &lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;</span><br><span class="line">    &lt;bean name=&quot;daoFactory&quot; class=&quot;com.DaoFactory&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot;</span><br><span class="line">            factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></details><h2 id="5-种不同方式的自动装配"><a href="#5-种不同方式的自动装配" class="headerlink" title="5 种不同方式的自动装配"></a>5 种不同方式的自动装配</h2><p>Spring 装配包括手动装配和自动装配，手动装配是有基于 xml 装配、构造方法、setter 方法等自动装配有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p><ol><li>no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。</li><li>byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。</li><li>byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</li><li>constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li>autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式。</li></ol><h1 id="Spring-AOP-原理（Aspect-Oriented-Programming-面向切面编程）"><a href="#Spring-AOP-原理（Aspect-Oriented-Programming-面向切面编程）" class="headerlink" title="Spring AOP 原理（Aspect Oriented Programming 面向切面编程）"></a>Spring AOP 原理（Aspect Oriented Programming 面向切面编程）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>使用”横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><p>AOP 主要应用场景有：</p><ol><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading 懒加载</li><li>Debugging 调试</li><li>logging, tracing, profiling and monitoring 记录跟踪 优化 校准</li><li>Performance optimization 性能优化</li><li>Persistence 持久化</li><li>Resource pooling 资源池</li><li>Synchronization 同步</li><li>Transactions 事务</li></ol><h2 id="AOP-核心概念"><a href="#AOP-核心概念" class="headerlink" title="AOP 核心概念"></a>AOP 核心概念</h2><p>1、切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</p><p>一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式或者基于@Aspect注解的方式实现，可以简单地认为, 使用 @Aspect 注解的类就是切面。</p><p>2、横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。</p><p>3、连接点（join point）：被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。</p><p>在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。</p><p>4、切入点（point cut）：对连接点进行拦截的定义</p><p>匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</p><p>5、通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类。</p><p>在切面的某个特定的连接点上执行的动作，许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</p><p>6、目标对象（Target Object)：代理的目标对象</p><p>被一个或多个切面所通知的对象。也被成为被通知（advised）对象,既然Spring AOP是通过运行时代理所实现的，这个对象永远是一个被代理(Proxied)对象</p><p>7、织入（weaving）：将切面应用到目标对象并导致代理对象创建的过程</p><p>把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象，这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其它纯Java AOP框架一样，在运行时完成织入。</p><p>8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。</p><p>用来给一个类型声明额外的方法或属性（也被成为连接类型声明（inter-type declaration)).Spring允许引入新的接口及对应的实现到任何被代理的对象。例如可以使用引入来使一个bean实现IsModified接口，一边简化缓存机制。</p><ol start="9"><li>AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li></ol><p>参考：<a href="https://segmentfault.com/a/1190000007469968" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007469968</a></p><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="前置通知（Before-advice）"><a href="#前置通知（Before-advice）" class="headerlink" title="前置通知（Before advice）"></a>前置通知（Before advice）</h4><p>在某连接点之前执行的通知，但这个通知不能组织连接点之前的执行流程（除非它抛出一个异常）</p><h4 id="后置通知（After-returning-advice）"><a href="#后置通知（After-returning-advice）" class="headerlink" title="后置通知（After returning advice）"></a>后置通知（After returning advice）</h4><p>在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p><h4 id="异常通知（After-throwing-advice）"><a href="#异常通知（After-throwing-advice）" class="headerlink" title="异常通知（After throwing advice）"></a>异常通知（After throwing advice）</h4><p>在方法抛出异常退出时执行的通知</p><h4 id="最终通知（After-Finally-advice）"><a href="#最终通知（After-Finally-advice）" class="headerlink" title="最终通知（After/Finally advice）"></a>最终通知（After/Finally advice）</h4><p>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）</p><h4 id="环绕通知（Around-Advice）"><a href="#环绕通知（Around-Advice）" class="headerlink" title="环绕通知（Around Advice）"></a>环绕通知（Around Advice）</h4><p>包围一个连接点的通知，如方法调用，这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p><h2 id="彻底理解-aspect-join-point-point-cut-advice"><a href="#彻底理解-aspect-join-point-point-cut-advice" class="headerlink" title="彻底理解 aspect, join point, point cut, advice"></a>彻底理解 aspect, join point, point cut, advice</h2><p>参考自：<a href="https://segmentfault.com/a/1190000007469968" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007469968</a></p><p>下面以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系.</p><p>让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.</p><p>来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系.</p><p>首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 爪哇的小县城里的百姓, point cut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问.<br>为什么可以这样类比呢?</p><p>join point –&gt; 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.</p><p>point cut –&gt; 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里 凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.</p><p>advice –&gt; 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.</p><p>aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: “根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问” 这一整个动作可以被认为是一个 aspect.</p><p>或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 定语, 被动句 之类的概念, 那么可以做一个不严谨的类比, 即 joinpoint 可以认为是一个 宾语, 而 pointcut 则可以类比为修饰 joinpoint 的定语, 那么整个 aspect 就可以描述为: 满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.</p><h2 id="AOP-两种代理方式"><a href="#AOP-两种代理方式" class="headerlink" title="AOP 两种代理方式"></a>AOP 两种代理方式</h2><p>Spring 提供了两种方式来生成代理对象:JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。</p><h3 id="JDK-动态接口代理"><a href="#JDK-动态接口代理" class="headerlink" title="JDK 动态接口代理"></a>JDK 动态接口代理</h3><ol><li>JDK 动态代理主要涉及到 java.lang.reflect包中的两个类：Proxy和InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</li></ol><h3 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h3><ol start="2"><li>CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以再运行期动态生成新的 class。和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。</li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><details>    <summary>CGLib</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class TransactionDemo &#123;</span><br><span class="line">    @Pointcut(value=&quot;execution(* com.yangxin.core.service.*.*.*(..))&quot;)</span><br><span class="line">    public void point()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Before(value=&quot;point()&quot;)</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;transaction begin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @AfterReturning(value = &quot;point()&quot;)</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;transaction commit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Around(&quot;point()&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">        System.out.println(&quot;transaction begin&quot;);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(&quot;transaction commit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="Spring-MVC-原理"><a href="#Spring-MVC-原理" class="headerlink" title="Spring MVC 原理"></a>Spring MVC 原理</h1><p>Spring 的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p><h2 id="Http-请求到-DispatcherServlet"><a href="#Http-请求到-DispatcherServlet" class="headerlink" title="Http 请求到 DispatcherServlet"></a>Http 请求到 DispatcherServlet</h2><p>(1) 客户端请求提交到 DispatcherServlet。</p><h2 id="HandlerMapping-寻找处理器"><a href="#HandlerMapping-寻找处理器" class="headerlink" title="HandlerMapping 寻找处理器"></a>HandlerMapping 寻找处理器</h2><p>(2) 由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller。</p><h2 id="调用处理器-Controller"><a href="#调用处理器-Controller" class="headerlink" title="调用处理器 Controller"></a>调用处理器 Controller</h2><p>(3) DispatcherServlet 将请求提交到 Controller。</p><h2 id="Controller-调用业务逻辑处理后，返回-ModelAndView"><a href="#Controller-调用业务逻辑处理后，返回-ModelAndView" class="headerlink" title="Controller 调用业务逻辑处理后，返回 ModelAndView"></a>Controller 调用业务逻辑处理后，返回 ModelAndView</h2><p>(4)(5)调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。</p><h2 id="DispatcherServlet-查询-ModelAndView"><a href="#DispatcherServlet-查询-ModelAndView" class="headerlink" title="DispatcherServlet 查询 ModelAndView"></a>DispatcherServlet 查询 ModelAndView</h2><p>(6)(7)处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图。</p><h2 id="ModelAndView-反馈浏览器-HTTP"><a href="#ModelAndView-反馈浏览器-HTTP" class="headerlink" title="ModelAndView 反馈浏览器 HTTP"></a>ModelAndView 反馈浏览器 HTTP</h2><p>(8) Http 响应：视图负责将结果显示到客户端。</p><h2 id="MVC常用注解"><a href="#MVC常用注解" class="headerlink" title="MVC常用注解"></a>MVC常用注解</h2><h1 id="Spring-Boot-原理"><a href="#Spring-Boot-原理" class="headerlink" title="Spring Boot 原理"></a>Spring Boot 原理</h1><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application<br>development)成为领导者。其特点如下：</p><ol><li>创建独立的 Spring 应用程序</li><li>嵌入的 Tomcat，无需部署 WAR 文件</li><li>简化 Maven 配置</li><li>自动配置 Spring</li><li>提供生产就绪型功能，如指标，健康检查和外部配置</li><li>绝对没有代码生成和对 XML 没有要求配置</li></ol><h1 id="JPA-原理（Java-Persistence-API）Java持久化API"><a href="#JPA-原理（Java-Persistence-API）Java持久化API" class="headerlink" title="JPA 原理（Java Persistence API）Java持久化API"></a>JPA 原理（Java Persistence API）Java持久化API</h1><p>是一套Sun公司Java官方制定的ORM 方案,是规范，是标准 ，sun公司自己并没有实现</p><p>关注点：ORM ，标准 概念 （关键字）</p><p>ORM是什么？</p><p>ORM（Object Relational Mapping）对象关系映射。</p><p>问：ORM有什么用？</p><p>在操作数据库之前，先把数据表与实体类关联起来。然后通过实体类的对象操作（增删改查）数据库表，这个就是ORM的行为！</p><p>所以：ORM是一个实现使用对象操作数据库的设计思想</p><p>通过这句话，我们知道JPA的作用就是通过对象操作数据库的，不用编写sql语句。</p><p>JPA的实现者</p><p>既然我们说JPA是一套标准，意味着，它只是一套实现ORM理论的接口。没有实现的代码。</p><p>那么我们必须要有具体的实现者才可以完成ORM操作功能的实现</p><p>市场上的主流的JPA框架（实现者）有：Hibernate （JBoos）、EclipseTop（Eclipse社区）、OpenJPA （Apache基金会）。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性(Atomicity)、一致性(Consistency)、隔离性 (Isolation) 和持久性 (Durabilily)。</p><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>紧密依赖于底层资源管理器（例如数据库连接)，事务处理局限在当前事务资源内。此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连接中使用本地事务示例如下：</p><details>    <summary>本地事务</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void transferAccount() &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    Statement stmt = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        conn = getDataSource().getConnection();</span><br><span class="line">        // 将自动提交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交</span><br><span class="line">        conn.setAutoCommit(false);</span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        // 将 A 账户中的金额减少 500</span><br><span class="line">        stmt.execute(&quot;update t_account set amount = amount - 500 where account_id = &apos;A&apos;&quot;);</span><br><span class="line">        // 将 B 账户中的金额增加 500</span><br><span class="line">        stmt.execute(&quot;update t_account set amount = amount + 500 where account_id = &apos;B&apos;&quot;);</span><br><span class="line">        // 提交事务</span><br><span class="line">        conn.commit();</span><br><span class="line">        // 事务提交：转账的两步操作同时成功</span><br><span class="line">    &#125; catch(SQLException sqle)&#123;</span><br><span class="line">        // 发生异常，回滚在本事务中的操做</span><br><span class="line">        conn.rollback();</span><br><span class="line">        // 事务回滚：转账的两步操作完全撤销</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction Service)为J2EE平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。</p><details>    <summary>分布式事务</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void transferAccount() &#123;</span><br><span class="line">    UserTransaction userTx = null;</span><br><span class="line">    Connection connA = null; Statement stmtA = null;</span><br><span class="line">    Connection connB = null; Statement stmtB = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        // 获得 Transaction 管理对象</span><br><span class="line">        userTx = (UserTransaction)getContext().lookup(&quot;java:comp/UserTransaction&quot;);</span><br><span class="line">        connA = getDataSourceA().getConnection();// 从数据库 A 中取得数据库连接</span><br><span class="line">        connB = getDataSourceB().getConnection();// 从数据库 B 中取得数据库连接</span><br><span class="line">        userTx.begin(); // 启动事务</span><br><span class="line">        stmtA = connA.createStatement();// 将 A 账户中的金额减少 500</span><br><span class="line">        stmtA.execute(&quot;update t_account set amount = amount - 500 where account_id = &apos;A&apos;&quot;);</span><br><span class="line">        // 将 B 账户中的金额增加 500</span><br><span class="line">        stmtB = connB.createStatement();</span><br><span class="line">        stmtB.execute(&quot;update t_account set amount = amount + 500 where account_id = &apos;B&apos;&quot;);</span><br><span class="line">        userTx.commit();// 提交事务</span><br><span class="line">        // 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新）</span><br><span class="line">    &#125; catch(SQLException sqle)&#123;</span><br><span class="line">        // 发生异常，回滚在本事务中的操纵</span><br><span class="line">        userTx.rollback();// 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销</span><br><span class="line">    &#125; catch(Exception ne)&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段是指：第一阶段：准备阶段；第二阶段：提交阶段</p><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><h3 id="提交阶段："><a href="#提交阶段：" class="headerlink" title="提交阶段："></a>提交阶段：</h3><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p>将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作。</p><h1 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h1><p>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的sqlsession 是可以共享的</p><h2 id="Mybatis-的一级缓存原理（sqlsession-级别）"><a href="#Mybatis-的一级缓存原理（sqlsession-级别）" class="headerlink" title="Mybatis 的一级缓存原理（sqlsession 级别）"></a>Mybatis 的一级缓存原理（sqlsession 级别）</h2><p>第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map。</p><p>key：MapperID+offset+limit+Sql+所有的入参</p><p>value：用户信息</p><p>同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。</p><h2 id="二级缓存原理（mapper-基本）"><a href="#二级缓存原理（mapper-基本）" class="headerlink" title="二级缓存原理（mapper 基本）"></a>二级缓存原理（mapper 基本）</h2><p>二级缓存的范围是 mapper 级别（mapper 同一个命名空间），mapper 以命名空间为单位创建缓存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor其实是 Executor 的代理对象。所有的查询操作，在CacheExecutor中都会先匹配缓存中是否存在，不存在则查询数据库。</p><p>key：MapperID+offset+limit+Sql+所有的入参</p><p>具体使用需要配置：</p><ol><li>Mybatis 全局配置中启用二级缓存配置</li><li>在对应的 Mapper.xml 中配置 cache 节点</li><li>在对应的 select 查询节点中添加 useCache=true</li></ol><h1 id="Tomcat-架构"><a href="#Tomcat-架构" class="headerlink" title="Tomcat 架构"></a>Tomcat 架构</h1><p><a href="http://www.importnew.com/21112.html" target="_blank" rel="noopener">http://www.importnew.com/21112.html</a></p></bean></bean></bean></bean>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（异常，反射，注解，内部类，泛型，序列化，复制）</title>
    <link href="http://yoursite.com/2021/12/29/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%8F%8D%E5%B0%84%EF%BC%8C%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A4%8D%E5%88%B6%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/29/JAVA 学习笔记（异常，反射，注解，内部类，泛型，序列化，复制）/</id>
    <published>2021-12-29T08:50:12.000Z</published>
    <updated>2021-12-30T02:12:32.097Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA 学习笔记（异常，反射，注解，内部类，泛型，序列化，复制）</p><a id="more"></a><p>[TOC]</p><h1 id="JAVA-异常分类及处理"><a href="#JAVA-异常分类及处理" class="headerlink" title="JAVA 异常分类及处理"></a>JAVA 异常分类及处理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception </p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ol><li>Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</li></ol><h3 id="Exception（RuntimeException、CheckedException）"><a href="#Exception（RuntimeException、CheckedException）" class="headerlink" title="Exception（RuntimeException、CheckedException）"></a>Exception（RuntimeException、CheckedException）</h3><ol start="2"><li>Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是CheckedException。</li></ol><p>RuntimeException 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</p><p>如果出现RuntimeException，那么一定是程序员的错误</p><p>检查异常 CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面：</p><ol><li>试图在文件尾部读取数据</li><li>试图打开一个错误格式的 URL</li><li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</li></ol><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><p>遇到问题不进行具体处理，而是继续抛给调用者 （throw,throws）抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。</p><details>    <summary>异常的处理方式</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abc&quot;;</span><br><span class="line">        if(s.equals(&quot;abc&quot;)) &#123;</span><br><span class="line">            throw new NumberFormatException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int div(int a,int b) throws Exception&#123;</span><br><span class="line">        return a/b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><h2 id="Throw-和-throws-的区别："><a href="#Throw-和-throws-的区别：" class="headerlink" title="Throw 和 throws 的区别："></a>Throw 和 throws 的区别：</h2><h3 id="位置不同"><a href="#位置不同" class="headerlink" title="位置不同"></a>位置不同</h3><ol><li>throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。</li></ol><h3 id="功能不同："><a href="#功能不同：" class="headerlink" title="功能不同："></a>功能不同：</h3><ol start="2"><li>throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。</li><li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li></ol><h1 id="JAVA-反射"><a href="#JAVA-反射" class="headerlink" title="JAVA 反射"></a>JAVA 反射</h1><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</p><h2 id="反射机制概念-（运行状态中知道类所有的属性和方法）"><a href="#反射机制概念-（运行状态中知道类所有的属性和方法）" class="headerlink" title="反射机制概念 （运行状态中知道类所有的属性和方法）"></a>反射机制概念 （运行状态中知道类所有的属性和方法）</h2><p>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能是 Java 语言的反射机制。</p><h2 id="反射的应用场合"><a href="#反射的应用场合" class="headerlink" title="反射的应用场合"></a>反射的应用场合</h2><h3 id="编译时类型和运行时类型"><a href="#编译时类型和运行时类型" class="headerlink" title="编译时类型和运行时类型"></a>编译时类型和运行时类型</h3><p>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：</p><pre><code>Person p=new Student();</code></pre><p>其中编译时类型为 Person，运行时类型为 Student。</p><h3 id="编译时类型无法获取具体方法"><a href="#编译时类型无法获取具体方法" class="headerlink" title="编译时类型无法获取具体方法"></a>编译时类型无法获取具体方法</h3><p>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。<br>然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p><h2 id="Java-反射-API"><a href="#Java-反射-API" class="headerlink" title="Java 反射 API"></a>Java 反射 API</h2><p>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><ol><li>Class 类：反射的核心类，可以获取类的属性，方法等信息。</li><li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li>Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li>Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。</li></ol><h2 id="反射使用步骤（获取-Class-对象、调用对象方法）"><a href="#反射使用步骤（获取-Class-对象、调用对象方法）" class="headerlink" title="反射使用步骤（获取 Class 对象、调用对象方法）"></a>反射使用步骤（获取 Class 对象、调用对象方法）</h2><ol><li>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。</li><li>调用 Class 类中的方法，既就是反射的使用阶段。</li><li>使用反射 API 来操作这些信息。</li></ol><h2 id="获取-Class-对象的-3-种方法"><a href="#获取-Class-对象的-3-种方法" class="headerlink" title="获取 Class 对象的 3 种方法"></a>获取 Class 对象的 3 种方法</h2><p>调用某个对象的 getClass()方法</p><pre><code>Person p=new Person();Class clazz=p.getClass();</code></pre><p>调用某个类的 class 属性来获取该类对应的 Class 对象</p><pre><code>Class clazz=Person.class;</code></pre><p>使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><pre><code>Class clazz=Class.forName(&quot;类的全路径&quot;); (最常用)</code></pre><p>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性。</p><details>    <summary>获取 Class 对象的 3 种方法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//获取 Person 类的 Class 对象</span><br><span class="line">Class clazz=Class.forName(&quot;reflection.Person&quot;);</span><br><span class="line">//获取 Person 类的所有方法信息</span><br><span class="line">Method[] method=clazz.getDeclaredMethods();</span><br><span class="line">for(Method m:method)&#123;</span><br><span class="line">    System.out.println(m.toString());</span><br><span class="line">&#125;</span><br><span class="line">//获取 Person 类的所有成员属性信息</span><br><span class="line">Field[] field=clazz.getDeclaredFields();</span><br><span class="line">for(Field f:field)&#123;</span><br><span class="line">    System.out.println(f.toString());</span><br><span class="line">&#125;</span><br><span class="line">//获取 Person 类的所有构造方法信息</span><br><span class="line">Constructor[] constructor=clazz.getDeclaredConstructors();</span><br><span class="line">for(Constructor c:constructor)&#123;</span><br><span class="line">    System.out.println(c.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h2><h3 id="Class-对象的-newInstance"><a href="#Class-对象的-newInstance" class="headerlink" title="Class 对象的 newInstance()"></a>Class 对象的 newInstance()</h3><ol><li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求<br>该 Class 对象对应的类有默认的空构造器。</li></ol><h3 id="调用-Constructor-对象的-newInstance"><a href="#调用-Constructor-对象的-newInstance" class="headerlink" title="调用 Constructor 对象的 newInstance()"></a>调用 Constructor 对象的 newInstance()</h3><ol start="2"><li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()<br>方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</li></ol><details>    <summary>newInstance</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//获取 Person 类的 Class 对象</span><br><span class="line"> Class clazz=Class.forName(&quot;reflection.Person&quot;);</span><br><span class="line"> //使用.newInstane 方法创建对象</span><br><span class="line"> Person p=(Person) clazz.newInstance();</span><br><span class="line">//获取构造方法并创建对象</span><br><span class="line"> Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class);</span><br><span class="line"> //创建对象并设置属性</span><br><span class="line"> Person p1=(Person) c.newInstance(&quot;李四&quot;,&quot;男&quot;,20);</span><br></pre></td></tr></table></figure></details><h1 id="JAVA-注解"><a href="#JAVA-注解" class="headerlink" title="JAVA 注解"></a>JAVA 注解</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该 Annotation 对象来获取注解中的元数据信息。</p><h2 id="4-种标准元注解"><a href="#4-种标准元注解" class="headerlink" title="4 种标准元注解"></a>4 种标准元注解</h2><p>元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p><h3 id="Target-修饰的对象范围"><a href="#Target-修饰的对象范围" class="headerlink" title="@Target 修饰的对象范围"></a>@Target 修饰的对象范围</h3><p>@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标</p><h3 id="Retention-定义-被保留的时间长短"><a href="#Retention-定义-被保留的时间长短" class="headerlink" title="@Retention 定义 被保留的时间长短"></a>@Retention 定义 被保留的时间长短</h3><p>Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：</p><ul><li>SOURCE:在源文件中有效（即源文件保留）</li><li>CLASS:在 class 文件中有效（即 class 保留）</li><li>RUNTIME:在运行时有效（即运行时保留）</li></ul><h3 id="Documented-描述-javadoc"><a href="#Documented-描述-javadoc" class="headerlink" title="@Documented 描述-javadoc"></a>@Documented 描述-javadoc</h3><p>@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p><h3 id="Inherited-阐述了某个被标注的类型是被继承的"><a href="#Inherited-阐述了某个被标注的类型是被继承的" class="headerlink" title="@Inherited 阐述了某个被标注的类型是被继承的"></a>@Inherited 阐述了某个被标注的类型是被继承的</h3><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。</p><h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。</p><details>    <summary>注解处理器</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"> 1：定义注解</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@interface FruitProvider &#123;</span><br><span class="line">    /**供应商编号*/</span><br><span class="line">    public int id() default -1;</span><br><span class="line">    /*** 供应商名称*/</span><br><span class="line">    public String name() default &quot;&quot;; /** * 供应商地址*/</span><br><span class="line">    public String address() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//2：注解使用</span><br><span class="line">public class Apple &#123;</span><br><span class="line">    @FruitProvider(id = 1, name = &quot;陕西红富士集团&quot;, address = &quot;陕西省西安市延安路&quot;)</span><br><span class="line">    private String appleProvider;</span><br><span class="line">    public void setAppleProvider(String appleProvider) &#123;</span><br><span class="line">        this.appleProvider = appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getAppleProvider() &#123;</span><br><span class="line">        return appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*********** 3：注解处理器 ***************/</span><br><span class="line">class FruitInfoUtil &#123;</span><br><span class="line">    public static void getFruitInfo(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        String strFruitProvicer = &quot;供应商信息：&quot;;</span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();//通过反射获取处理注解</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            if (field.isAnnotationPresent(FruitProvider.class)) &#123;</span><br><span class="line">                FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class);</span><br><span class="line">                //注解信息的处理地方</span><br><span class="line">                strFruitProvicer = &quot; 供应商编号：&quot; + fruitProvider.id() + &quot; 供应商名称：&quot;</span><br><span class="line">                        + fruitProvider.name() + &quot; 供应商地址：&quot;+ fruitProvider.address();</span><br><span class="line">                System.out.println(strFruitProvicer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FruitRun &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FruitInfoUtil.getFruitInfo(Apple.class);</span><br><span class="line">        /***********输出结果***************/</span><br><span class="line">        // 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="JAVA-内部类"><a href="#JAVA-内部类" class="headerlink" title="JAVA 内部类"></a>JAVA 内部类</h1><p>Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根<br>据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>定义在类内部的静态类，就是静态内部类。</p><details>    <summary>静态内部类</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Out &#123;</span><br><span class="line">            private static int a;</span><br><span class="line">            private int b;</span><br><span class="line">            public static class Inner &#123;</span><br><span class="line">                public void print() &#123;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></details><ol><li><p>静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。</p></li><li><p>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</p></li><li><p>其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：</p><p> Out.Inner inner =new Out.Inner();inner.print();</p></li><li><p>Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</p></li></ol><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</p><details>    <summary>成员内部类</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">    private static int a;</span><br><span class="line">    private int b;</span><br><span class="line">    public class Inner &#123;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="局部内部类（定义在方法中的类）"><a href="#局部内部类（定义在方法中的类）" class="headerlink" title="局部内部类（定义在方法中的类）"></a>局部内部类（定义在方法中的类）</h2><p>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p><details>    <summary>局部内部类</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Out &#123;</span><br><span class="line">        private static int a;</span><br><span class="line">        private int b;</span><br><span class="line">        public void test(final int c) &#123;</span><br><span class="line">            final int d = 1;</span><br><span class="line">            class Inner &#123;</span><br><span class="line">                public void print() &#123;</span><br><span class="line">                    System.out.println(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><h2 id="匿名内部类（要继承一个父类或者实现一个接口、直接使用new-来生成一个对象的引用）"><a href="#匿名内部类（要继承一个父类或者实现一个接口、直接使用new-来生成一个对象的引用）" class="headerlink" title="匿名内部类（要继承一个父类或者实现一个接口、直接使用new 来生成一个对象的引用）"></a>匿名内部类（要继承一个父类或者实现一个接口、直接使用new 来生成一个对象的引用）</h2><p>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。</p><details>    <summary>匿名内部类</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Bird &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        public abstract int fly();</span><br><span class="line">    &#125;</span><br><span class="line">    public class Test &#123;</span><br><span class="line">        public void test(Bird bird)&#123;</span><br><span class="line">            System.out.println(bird.getName() + &quot;能够飞 &quot; + bird.fly() + &quot;米&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            Test test = new Test();</span><br><span class="line">            test.test(new Bird() &#123;</span><br><span class="line">                public int fly() &#123;</span><br><span class="line">                    return 10000;</span><br><span class="line">                &#125;</span><br><span class="line">                public String getName() &#123;</span><br><span class="line">                    return &quot;大雁&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><h1 id="JAVA-泛型"><a href="#JAVA-泛型" class="headerlink" title="JAVA 泛型"></a>JAVA 泛型</h1><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。</p><h2 id="泛型方法（）"><a href="#泛型方法（）" class="headerlink" title="泛型方法（）"></a>泛型方法（<e>）</e></h2><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><details>    <summary>泛型方法（<e>）</e></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 泛型方法 printArray</span><br><span class="line">public static &lt; E &gt; void printArray( E[] inputArray )</span><br><span class="line">&#123;</span><br><span class="line">    for ( E element : inputArray )&#123;</span><br><span class="line">        System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>1. <? extends T>表示该通配符所代表的类型是 T 类型的子类。2. <? super T>表示该通配符所代表的类型是 T 类型的父类。<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类<t></t></h2><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><details>    <summary>泛型类<t></t></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">     private T t;</span><br><span class="line">     public void add(T t) &#123;</span><br><span class="line">     this.t = t;</span><br><span class="line">     &#125;</span><br><span class="line">     public T get() &#123;</span><br><span class="line">     return t;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></details><h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h2><p>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在逻辑上是List<string>,List<integer> 等所有 List&lt;具体类型实参&gt;的父类。</integer></string></p><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List<object>和 List<string>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</string></object></p><h1 id="JAVA-序列化-创建可复用的-Java-对象"><a href="#JAVA-序列化-创建可复用的-Java-对象" class="headerlink" title="JAVA 序列化(创建可复用的 Java 对象)"></a>JAVA 序列化(创建可复用的 Java 对象)</h1><h2 id="保存-持久化-对象及其状态到内存或者磁盘"><a href="#保存-持久化-对象及其状态到内存或者磁盘" class="headerlink" title="保存(持久化)对象及其状态到内存或者磁盘"></a>保存(持久化)对象及其状态到内存或者磁盘</h2><p>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。</p><p>Java 对象序列化就能够帮助我们实现该功能。</p><h2 id="序列化对象以字节数组保持-静态成员不保存"><a href="#序列化对象以字节数组保持-静态成员不保存" class="headerlink" title="序列化对象以字节数组保持-静态成员不保存"></a>序列化对象以字节数组保持-静态成员不保存</h2><p>使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。</p><h2 id="序列化用户远程对象传输"><a href="#序列化用户远程对象传输" class="headerlink" title="序列化用户远程对象传输"></a>序列化用户远程对象传输</h2><p>除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。</p><h2 id="Serializable-实现序列化"><a href="#Serializable-实现序列化" class="headerlink" title="Serializable 实现序列化"></a>Serializable 实现序列化</h2><p>在 Java 中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化</p><h2 id="ObjectOutputStream-和-ObjectInputStream-对对象进行序列化及反序列化"><a href="#ObjectOutputStream-和-ObjectInputStream-对对象进行序列化及反序列化" class="headerlink" title="ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化"></a>ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化</h2><p>通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。</p><h2 id="writeObject-和-readObject-自定义序列化策略"><a href="#writeObject-和-readObject-自定义序列化策略" class="headerlink" title="writeObject 和 readObject 自定义序列化策略"></a>writeObject 和 readObject 自定义序列化策略</h2><p>在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。</p><h2 id="序列化-ID"><a href="#序列化-ID" class="headerlink" title="序列化 ID"></a>序列化 ID</h2><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID是否一致（就是 private static final long serialVersionUID）</p><h2 id="序列化并不保存静态变量"><a href="#序列化并不保存静态变量" class="headerlink" title="序列化并不保存静态变量"></a>序列化并不保存静态变量</h2><h2 id="序列化子父类说明"><a href="#序列化子父类说明" class="headerlink" title="序列化子父类说明"></a>序列化子父类说明</h2><p>要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。</p><h2 id="Transient-关键字阻止该变量被序列化到文件中"><a href="#Transient-关键字阻止该变量被序列化到文件中" class="headerlink" title="Transient 关键字阻止该变量被序列化到文件中"></a>Transient 关键字阻止该变量被序列化到文件中</h2><ol><li>在变量声明前加上 Transient关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int型的是0，对象型的是 null。</li><li>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li></ol><h1 id="JAVA-复制"><a href="#JAVA-复制" class="headerlink" title="JAVA 复制"></a>JAVA 复制</h1><p>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</p><h2 id="直接赋值复制"><a href="#直接赋值复制" class="headerlink" title="直接赋值复制"></a>直接赋值复制</h2><p>直接赋值。在 Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</p><h2 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h2><p>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。</p><details>    <summary>浅复制<t></t></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Resume implements Cloneable&#123;</span><br><span class="line">     public Object clone() &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             return (Resume)super.clone();</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">             return null;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></details><h2 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h2><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</p><details>    <summary>深复制<t></t></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Cloneable &#123;</span><br><span class="line">         String name;</span><br><span class="line">         int age;</span><br><span class="line">         Professor p;</span><br><span class="line">         Student(String name, int age, Professor p) &#123;</span><br><span class="line">             this.name = name;</span><br><span class="line">             this.age = age;</span><br><span class="line">             this.p = p;</span><br><span class="line">         &#125;</span><br><span class="line">         public Object clone() &#123;</span><br><span class="line">             Student o = null;</span><br><span class="line">             try &#123;</span><br><span class="line">                 o = (Student) super.clone();</span><br><span class="line">             &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">                 System.out.println(e.toString());</span><br><span class="line">             &#125;</span><br><span class="line">             o.p = (Professor) p.clone();</span><br><span class="line">             return o;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></details><h2 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h2><p>创建一个指向对象的引用变量的拷贝，他们都指向了一个相同的对象。 这就叫做引用拷贝。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><p>创建对象本身的一个副本，它们的地址是不同的，也就是说创建了新的对象，而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝。</p><h2 id="深复制与浅复制的区别和相同点"><a href="#深复制与浅复制的区别和相同点" class="headerlink" title="深复制与浅复制的区别和相同点"></a>深复制与浅复制的区别和相同点</h2><p>深拷贝和浅拷贝都是对象拷贝</p><p>浅拷贝</p><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p><p>简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p><p>深拷贝</p><p>深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p>简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p><h2 id="序列化（深-clone-一中实现）"><a href="#序列化（深-clone-一中实现）" class="headerlink" title="序列化（深 clone 一中实现）"></a>序列化（深 clone 一中实现）</h2><p>在 Java 语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA 学习笔记（异常，反射，注解，内部类，泛型，序列化，复制）&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
