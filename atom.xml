<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-05-12T03:32:00.845Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>批量克隆项目</title>
    <link href="http://yoursite.com/2023/05/12/%E6%89%B9%E9%87%8F%E5%85%8B%E9%9A%86%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2023/05/12/%E6%89%B9%E9%87%8F%E5%85%8B%E9%9A%86%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-05-12T03:12:12.000Z</published>
    <updated>2023-05-12T03:32:00.845Z</updated>
    
    <content type="html"><![CDATA[<p>批量克隆项目</p><span id="more"></span><p>[TOC]</p><p>下载项目可以考虑批量用脚本克隆</p><details>    <sumamry>批量克隆</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">https://blog.csdn.net/qq_39965424/article/details/113260316</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">project_addr = [</span><br><span class="line">    &#x27;git@example.git&#x27;</span><br><span class="line">]</span><br><span class="line"># os.mkdir(&#x27;/Users/userName/IdeaProjects/MRV&#x27;)</span><br><span class="line">os.chdir(&#x27;/Users/userName/IdeaProjects/MRV&#x27;)</span><br><span class="line">command = &#x27;git clone &#x27;</span><br><span class="line">for i in project_addr:</span><br><span class="line">    try:</span><br><span class="line">        os.popen(command + str(i))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print( i + &quot; 拉取完毕！&quot;)</span><br><span class="line">    except:</span><br><span class="line">        print( i + &quot; 拉取异常！&quot;)</span><br><span class="line"></span><br><span class="line">print(&#x27;当前项目组已全部拉取完毕&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <sumamry>批量拉取最新分支</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">dir_route = &#x27;/Users/userName/IdeaProjects/MRV&#x27;</span><br><span class="line"># 切换到test目录</span><br><span class="line">os.chdir(dir_route)</span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line">dirs = os.listdir()</span><br><span class="line"># 定义git命令</span><br><span class="line">command = &#x27;git pull origin test&#x27;</span><br><span class="line">for code_dir in dirs:</span><br><span class="line">    # 拼接路径(当前目录+代码目录)</span><br><span class="line">    full_path = os.path.join(current_directory, code_dir)</span><br><span class="line">    try:</span><br><span class="line">        os.chdir(full_path)</span><br><span class="line">        os.system(command)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(code_dir + &quot; 拉取完毕！&quot;)</span><br><span class="line">    except:</span><br><span class="line">        print(f&quot;&#123;full_path&#125;文件拉取异常&quot;)</span><br><span class="line">    finally:</span><br><span class="line">        os.chdir(dir_route)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <sumamry>批量获取项目git地址</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">https://blog.csdn.net/wwwsq/article/details/97106096</span><br><span class="line">批量获取gitlab里面所有项目的代码</span><br><span class="line">https://docs.gitlab.com/ee/api/projects.html#list-all-projects</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line"># 在Python3.0测试通过</span><br><span class="line"># 需要在gitlab里面新建一个AccessToken填入gitlabToken</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line">if sys.version_info &lt; (3, 0):</span><br><span class="line">    import urllib</span><br><span class="line">else:</span><br><span class="line">    from urllib.request import urlopen</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">import subprocess, shlex</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">gitlabAddr  = &#x27;201.1.2.115:8099&#x27;</span><br><span class="line">gitlabToken = &#x27;Nzyg92-123456aa4ay__y&#x27;</span><br><span class="line"> </span><br><span class="line">for index in range(10):</span><br><span class="line">    url     = &quot;http://%s/api/v4/projects?private_token=%s&amp;per_page=100&amp;page=%d&amp;order_by=name&quot; % (gitlabAddr, gitlabToken, index)</span><br><span class="line">    print(url)</span><br><span class="line">    </span><br><span class="line">    if sys.version_info &lt; (3, 0):</span><br><span class="line">        allProjects     = urllib.urlopen(url)</span><br><span class="line">    else:</span><br><span class="line">        allProjects     = urlopen(url)</span><br><span class="line">        </span><br><span class="line">    allProjectsDict = json.loads(allProjects.read().decode(encoding=&#x27;UTF-8&#x27;))</span><br><span class="line">    if len(allProjectsDict) == 0:</span><br><span class="line">        break</span><br><span class="line">    for thisProject in allProjectsDict: </span><br><span class="line">        try:</span><br><span class="line">            thisProjectURL  = thisProject[&#x27;http_url_to_repo&#x27;]</span><br><span class="line">            thisProjectPath = thisProject[&#x27;path_with_namespace&#x27;]</span><br><span class="line">            print(thisProjectURL + &#x27; &#x27; + thisProjectPath)</span><br><span class="line">            </span><br><span class="line">            if os.path.exists(thisProjectPath):</span><br><span class="line">                command     = shlex.split(&#x27;git -C &quot;%s&quot; pull&#x27; % (thisProjectPath))</span><br><span class="line">            else:</span><br><span class="line">                command     = shlex.split(&#x27;git clone %s %s&#x27; % (thisProjectURL, thisProjectPath))</span><br><span class="line">            </span><br><span class="line">            resultCode  = subprocess.Popen(command)</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error on %s: %s&quot; % (thisProjectURL, e.strerror))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;批量克隆项目&lt;/p&gt;</summary>
    
    
    
    <category term="2023年5月" scheme="http://yoursite.com/categories/2023%E5%B9%B45%E6%9C%88/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>找素数</title>
    <link href="http://yoursite.com/2023/05/09/%E6%89%BE%E7%B4%A0%E6%95%B0/"/>
    <id>http://yoursite.com/2023/05/09/%E6%89%BE%E7%B4%A0%E6%95%B0/</id>
    <published>2023-05-09T09:12:12.000Z</published>
    <updated>2023-05-12T03:33:25.473Z</updated>
    
    <content type="html"><![CDATA[<p>给定区间[L, R] ，请计算区间中素数的个数。2 &lt;&#x3D; L &lt;&#x3D; R &lt;&#x3D; 2147483647 R-L &lt;&#x3D; 1000000</p><span id="more"></span><p>[TOC]</p><h1 id="算法提高-找素数-1"><a href="#算法提高-找素数-1" class="headerlink" title="算法提高 找素数^1"></a>算法提高 找素数<a href="https://www.lanqiao.cn/problems/1558/learning/?page=1&first_category_id=1&sort=students_count&name=%E6%89%BE%E7%B4%A0%E6%95%B0">^1</a></h1><h2 id="判断素数普通版-2"><a href="#判断素数普通版-2" class="headerlink" title="判断素数普通版 ^2"></a>判断素数普通版 <a href="https://blog.csdn.net/weixin_50014971/article/details/120356582">^2</a></h2><details>    <summary>判断素数普通版</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool primeNum(int n)&#123;</span><br><span class="line">    if(n==2)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n%2==0)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i*i&lt;=n;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="判断素数进阶版-2"><a href="#判断素数进阶版-2" class="headerlink" title="判断素数进阶版^2"></a>判断素数进阶版<a href="https://blog.csdn.net/weixin_50014971/article/details/120356582">^2</a></h2><details>    <summary>判断素数进阶版</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">一个数能整除另一个数，那么必能整除另一个数的因数</span><br><span class="line">一个数不能整除另一个数，那么必不能整除另一个数的倍数</span><br><span class="line"></span><br><span class="line">从5开始，6n、6n+1、6n+2、6n+3、6n+4、6n+5中，6n、6n+2、6n+3、6n+4都可以整除2或3，则这些数不是素数；</span><br><span class="line">只需判断剩下的6n+1、6n+5（即6m-1、6m+1，6m两侧的数）是不是素数即可；</span><br><span class="line">6n+1、6n+5不能整除2或3，则这些数不能整除（6i、6i+2、6i+3、6i+4），</span><br><span class="line">所以只需进一步判断能否整除6i+1、6i+5（不包括1，从5开始；即5+6i、5+6i+2）即可（循环的步长变为6）</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">bool primeNumPro(int n)&#123;</span><br><span class="line">    if(n==1 || n==4)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n==2 || n==3)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n%2==0)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n%6!=1 &amp;&amp; n%6!=5)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=5;i*i&lt;=n;i+=6)&#123;</span><br><span class="line">        if((n%i==0) || (n%(i+2)==0))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="埃氏筛-3"><a href="#埃氏筛-3" class="headerlink" title="埃氏筛^3"></a>埃氏筛<a href="https://blog.csdn.net/GD_ONE/article/details/104660294">^3</a></h2><details>    <summary>埃氏筛</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int primeArray[1000000];</span><br><span class="line">int eratosthenes(int l, int r)&#123;</span><br><span class="line">    for(int i=2;i&lt;=r/i;i++)&#123;</span><br><span class="line">        if(primeArray[i]==0)&#123;</span><br><span class="line">            for(int j=i*i;j&lt;=r;j+=i)&#123;</span><br><span class="line">                primeArray[j]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        if(primeArray[i]==0)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="欧拉筛算法-4"><a href="#欧拉筛算法-4" class="headerlink" title="欧拉筛算法^4"></a>欧拉筛算法<a href="https://www.aiforus.cn/">^4</a></h1><p>欧拉筛算法是一种高效的筛质数的算法，它的时间复杂度为O(n)。以下是C++代码和算法解释：</p><details>    <summary>欧拉筛</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> prime[MAXN];</span><br><span class="line"><span class="type">bool</span> is_prime[MAXN];</span><br><span class="line"><span class="type">int</span> eulerSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="built_in">sizeof</span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    eulerSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            prime[++eulerSize] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= eulerSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>算法解释：</p><p>首先，我们建立一个长度为n的布尔数组is_prime，将其中所有的元素初始化为true。is_prime的下标i代表的是数字i是否为质数。</p><p>然后，我们遍历2～n的每一个数字i，如果is_prime[i]为true，说明i是质数，我们将其存入一个数组prime中，并且记录下当前已经找到的质数的个数。注意：我们不需要对1进行判断，因为1不是质数也不是合数。</p><p>接下来，我们遍历之前已经找到的所有质数prime[j]，对当前数字i进行筛选。如果i * prime[j]大于了n，那么我们就结束当前质数的筛选。如果i * prime[j]不大于n，我们就将is_prime[i * prime[j]]设置为false，因为i * prime[j]一定不是质数。同时，如果i % prime[j]等于0，意味着i中包含了prime[j]这个质因子，那么就可以结束当前数字i的筛选，因为我们已经找到了它的所有质因子。</p><p>最终，is_prime中为true的数字即为质数，我们可以将其输出或者处理。</p><p>总的来说，欧拉筛算法的核心思想是：每个合数（非质数）都可以用其中最小的质数来筛选，且每个数字至多被标记一次。这种思想使得欧拉筛算法比传统的筛法更为高效。</p><p>例如，我们求解1~100的质数，可以调用euler(100)函数，得到prime数组中存放了14个质数。其中，prime[1]&#x3D;2，prime[2]&#x3D;3，prime[3]&#x3D;5，以此类推。</p><p>对于时间复杂度的分析，每个数字最多被标记一次，所以总的时间复杂度是 O(n)。</p><p>欧拉筛算法的优点在于它可以同时筛选出所有小于等于n的质数，这使得它在许多需要筛质数的场合中特别有用。当n非常大时，欧拉筛算法的优势更为明显。</p><p>欧拉筛算法在空间上仅需要O(n)的空间，这使得它可以在很多场合中使用。</p><p>希望这一篇解释能够对你有所帮助，如果你还有什么问题，可以随时向我提出。</p><h2 id="欧拉筛核心"><a href="#欧拉筛核心" class="headerlink" title="欧拉筛核心"></a>欧拉筛核心</h2><p>欧拉筛妙就妙在它的核心处</p><p> 若 i是prime[j]的整数倍k</p><p> 则  i · prime[j+1] &#x3D; k · prime[j] · prime[j+1] &#x3D; k · prime[j+1] · prime[j]</p><p> i · prime[j+1]为 prime[j] 的整数倍，不需要被标记，prime[j+2]…prime[j+…] 同理</p><p> 故该推导告诉我们不需要去标记后面的数，直接跳出循环即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定区间[L, R] ，请计算区间中素数的个数。2 &amp;lt;&amp;#x3D; L &amp;lt;&amp;#x3D; R &amp;lt;&amp;#x3D; 2147483647 R-L &amp;lt;&amp;#x3D; 1000000&lt;/p&gt;</summary>
    
    
    
    <category term="2023年5月" scheme="http://yoursite.com/categories/2023%E5%B9%B45%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Prime" scheme="http://yoursite.com/tags/Prime/"/>
    
  </entry>
  
  <entry>
    <title>75. 颜色分类</title>
    <link href="http://yoursite.com/2022/11/11/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2022/11/11/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</id>
    <published>2022-11-11T03:12:12.000Z</published>
    <updated>2023-05-12T03:32:45.833Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><span id="more"></span><p>[TOC]</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p>示例 1：</p><pre><code>输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]</code></pre><p>示例 2：</p><pre><code>输入：nums = [2,0,1]输出：[0,1,2]</code></pre><p>提示：</p><pre><code>n == nums.length1 &lt;= n &lt;= 300nums[i] 为 0、1 或 2</code></pre><p>进阶：</p><pre><code>你可以不使用代码库中的排序函数来解决这道题吗？你能想出一个仅使用常数空间的一趟扫描算法吗？</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode.cn/problems/sort-colors/solutions/437968/yan-se-fen-lei-by-leetcode-solution/">^1</a></h1><p>本题是经典的「荷兰国旗问题」，由计算机科学家 Edsger W. Dijkstra 首先提出。</p><p>根据题目中的提示，我们可以统计出数组中 0,1,2  的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。</p><h1 id="方法一：单指针"><a href="#方法一：单指针" class="headerlink" title="方法一：单指针"></a>方法一：单指针</h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 000 交换到数组的头部。在第二次遍历中，我们将数组中所有的 111 交换到头部的 000 之后。此时，所有的 222 都出现在数组的尾部，这样我们就完成了排序。</p><p>具体地，我们使用一个指针 ptr 表示「头部」的范围，ptr 中存储了一个整数，表示数组 nums 从位置 000 到位置 ptr−1 都属于「头部」。ptr 的初始值为 000，表示还没有数处于「头部」。</p><p>在第一次遍历中，我们从左向右遍历整个数组，如果找到了 000，那么就需要将 000 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 000 都被交换到「头部」的范围，并且「头部」只包含 000。</p><p>在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 111，那么就需要将 111 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 111 都被交换到「头部」的范围，并且都在 000 之后，此时 222 只出现在「头部」之外的位置，因此排序完成。</p><details>    <summary></summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年11月" scheme="http://yoursite.com/categories/2022%E5%B9%B411%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
    <category term="Sorting" scheme="http://yoursite.com/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>912. 排序数组</title>
    <link href="http://yoursite.com/2022/10/11/912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2022/10/11/912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-10-11T06:50:12.000Z</published>
    <updated>2022-10-14T09:31:44.351Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组nums，请你将该数组升序排列。写出来后，也要把下面这几个点考虑下：时间&#x2F;空间复杂度计算， 轴点随机取值， 为什么与轴点相等也要换位</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [5,2,3,1]输出：[1,2,3,5]</code></pre><p>示例 2：</p><pre><code>输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5]</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 5 * 104-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode.cn/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/">^1</a></h1><p>本题你可以选择直接调用库函数来对序列进行排序，但意义不大。由于排序算法有很多，本文只介绍三种常见的基于比较的复杂度较低的排序。</p><h1 id="方法一：快速排序"><a href="#方法一：快速排序" class="headerlink" title="方法一：快速排序"></a>方法一：快速排序</h1><h2 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h2><p>快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123;</span><br><span class="line">        int pivot = nums[r];</span><br><span class="line">        int i = l - 1;</span><br><span class="line">        for (int j = l; j &lt;= r - 1; ++j) &#123;</span><br><span class="line">            if (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + 1;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i + 1], nums[r]);</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int randomized_partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123;</span><br><span class="line">        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元</span><br><span class="line">        swap(nums[r], nums[i]);</span><br><span class="line">        return partition(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    void randomized_quicksort(vector&lt;int&gt;&amp; nums, int l, int r) &#123;</span><br><span class="line">        if (l &lt; r) &#123;</span><br><span class="line">            int pos = randomized_partition(nums, l, r);</span><br><span class="line">            randomized_quicksort(nums, l, pos - 1);</span><br><span class="line">            randomized_quicksort(nums, pos + 1, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        srand((unsigned)time(NULL));</span><br><span class="line">        randomized_quicksort(nums, 0, (int)nums.size() - 1);</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortArray(int[] nums) &#123;</span><br><span class="line">        randomizedQuicksort(nums, 0, nums.length - 1);</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void randomizedQuicksort(int[] nums, int l, int r) &#123;</span><br><span class="line">        if (l &lt; r) &#123;</span><br><span class="line">            int pos = randomizedPartition(nums, l, r);</span><br><span class="line">            randomizedQuicksort(nums, l, pos - 1);</span><br><span class="line">            randomizedQuicksort(nums, pos + 1, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int randomizedPartition(int[] nums, int l, int r) &#123;</span><br><span class="line">        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元</span><br><span class="line">        swap(nums, r, i);</span><br><span class="line">        return partition(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int partition(int[] nums, int l, int r) &#123;</span><br><span class="line">        int pivot = nums[r];</span><br><span class="line">        int i = l - 1;</span><br><span class="line">        for (int j = l; j &lt;= r - 1; ++j) &#123;</span><br><span class="line">            if (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + 1;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i + 1, r);</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def randomized_partition(self, nums, l, r):</span><br><span class="line">        pivot = random.randint(l, r)</span><br><span class="line">        nums[pivot], nums[r] = nums[r], nums[pivot]</span><br><span class="line">        i = l - 1</span><br><span class="line">        for j in range(l, r):</span><br><span class="line">            if nums[j] &lt; nums[r]:</span><br><span class="line">                i += 1</span><br><span class="line">                nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">        i += 1</span><br><span class="line">        nums[i], nums[r] = nums[r], nums[i]</span><br><span class="line">        return i</span><br><span class="line"></span><br><span class="line">    def randomized_quicksort(self, nums, l, r):</span><br><span class="line">        if r - l &lt;= 0:</span><br><span class="line">            return</span><br><span class="line">        mid = self.randomized_partition(nums, l, r)</span><br><span class="line">        self.randomized_quicksort(nums, l, mid - 1)</span><br><span class="line">        self.randomized_quicksort(nums, mid + 1, r)</span><br><span class="line"></span><br><span class="line">    def sortArray(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        self.randomized_quicksort(nums, 0, len(nums) - 1)</span><br><span class="line">        return nums</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(nlog⁡n ，其中  n 为数组的长度。详细证明过程可以见《算法导论》第七章，这里不再大篇幅赘述。</p><p>空间复杂度：O(h) ，其中 hhh 为快速排序递归调用的层数。我们需要额外的 O(h) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为  nlogn，空间复杂度为 O(log⁡ n)。</p><h1 id="方法二：堆排序"><a href="#方法二：堆排序" class="headerlink" title="方法二：堆排序"></a>方法二：堆排序</h1><p>预备知识</p><p>堆</p><h2 id="思路和算法-1"><a href="#思路和算法-1" class="headerlink" title="思路和算法"></a>思路和算法</h2><p>堆排序的思想就是先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n−1  个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。</p><p>想要了解堆排序的更具体实现思路<a href="https://blog.csdn.net/Jacky_kplin/article/details/121133089">^2</a></p><p>官方题解的这个堆排序感觉不太详细，可以参考<a href="https://leetcode.cn/problems/sort-an-array/solutions/1311934/duo-chong-pai-xu-yi-wang-da-jin-kuai-pai-wgz4/?topicTags=dui-pai-xu">^4</a></p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void maxHeapify(vector&lt;int&gt;&amp; nums, int i, int len) &#123;</span><br><span class="line">        for (; (i &lt;&lt; 1) + 1 &lt;= len;) &#123;</span><br><span class="line">            int lson = (i &lt;&lt; 1) + 1;</span><br><span class="line">            int rson = (i &lt;&lt; 1) + 2;</span><br><span class="line">            int large;</span><br><span class="line">            if (lson &lt;= len &amp;&amp; nums[lson] &gt; nums[i]) &#123;</span><br><span class="line">                large = lson;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                large = i;</span><br><span class="line">            &#125;</span><br><span class="line">            if (rson &lt;= len &amp;&amp; nums[rson] &gt; nums[large]) &#123;</span><br><span class="line">                large = rson;</span><br><span class="line">            &#125;</span><br><span class="line">            if (large != i) &#123;</span><br><span class="line">                swap(nums[i], nums[large]);</span><br><span class="line">                i = large;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void buildMaxHeap(vector&lt;int&gt;&amp; nums, int len) &#123;</span><br><span class="line">        for (int i = len / 2; i &gt;= 0; --i) &#123;</span><br><span class="line">            maxHeapify(nums, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void heapSort(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = (int)nums.size() - 1;</span><br><span class="line">        buildMaxHeap(nums, len);</span><br><span class="line">        for (int i = len; i &gt;= 1; --i) &#123;</span><br><span class="line">            swap(nums[i], nums[0]);</span><br><span class="line">            len -= 1;</span><br><span class="line">            maxHeapify(nums, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> */</span><br><span class="line">public int[] sortArray(int[] nums) &#123;</span><br><span class="line">    heapSort(nums);</span><br><span class="line">    return nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 堆排序(宇宙无敌的JAVA)</span><br><span class="line"> *  第一步: 构建大顶堆</span><br><span class="line"> *  第二步: 交换堆点元素(堆点元素与当前处理的二叉树最后一个元素交换)</span><br><span class="line"> *  第三步: 去除二叉树最后一个节点, 对二叉树根节点堆化(heapify)</span><br><span class="line"> *  第四步: 重复第二、第三步直至结束</span><br><span class="line"> */</span><br><span class="line">private void heapSort(int[] nums) &#123;</span><br><span class="line">    int len = nums.length;</span><br><span class="line">    //第一步: 构建大顶堆</span><br><span class="line">    buildMaxHead(nums, len);</span><br><span class="line">    //第四步: 重复第二、第三步直至结束</span><br><span class="line">    for (int i = len - 1; i &gt;= 1; i--) &#123;</span><br><span class="line">        //第二步: 交换堆点元素(堆点元素与当前处理的二叉树最后一个元素交换)</span><br><span class="line">        swap(nums, i, 0);</span><br><span class="line">        //第三步: 去除二叉树最后一个节点, 对二叉树根节点堆化(heapify)</span><br><span class="line">        //  元素少于两个没有必要再处理, 这里不特殊判断处理</span><br><span class="line">        heapify(nums, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构建大顶堆</span><br><span class="line"> */</span><br><span class="line">private void buildMaxHead(int[] nums, int len) &#123;</span><br><span class="line">    //从倒数第二层数的节点开始, 一直到二叉树根节点, 进行堆化(heapify)</span><br><span class="line">    //  求取最后一个节点的父节点, 父节点索引为 int parentIndex = (i - 1) / 2</span><br><span class="line">    int lastNodeIndex = ((len - 1) - 1) / 2;</span><br><span class="line">    for (int i = lastNodeIndex; i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(nums, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void heapify(int[] nums, int len, int cur) &#123;</span><br><span class="line">    if (cur &gt;= len)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //第一个子节点的索引位置 int c1 = 2 * i + 1</span><br><span class="line">    //第二个子节点的索引位置 int c2 = 2 * i + 2</span><br><span class="line">    int c1 = 2 * cur + 1;</span><br><span class="line">    int c2 = 2 * cur + 2;</span><br><span class="line">    //求最大值的索引</span><br><span class="line">    int maxIndex = cur;</span><br><span class="line">    if (c1 &lt; len &amp;&amp; nums[c1] &gt; nums[maxIndex])&#123;</span><br><span class="line">        maxIndex = c1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (c2 &lt; len &amp;&amp; nums[c2] &gt; nums[maxIndex])&#123;</span><br><span class="line">        maxIndex = c2;</span><br><span class="line">    &#125;</span><br><span class="line">    //当前节点cur不是该堆的最大值, 交换元素值, 并递归被交换点进行堆化(heapify)</span><br><span class="line">    if (cur != maxIndex)&#123;</span><br><span class="line">        swap(nums, cur, maxIndex);</span><br><span class="line">        heapify(nums, len, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 交换元素值</span><br><span class="line"> */</span><br><span class="line">private void swap(int[] nums, int x, int y) &#123;</span><br><span class="line">    int temp = nums[x];</span><br><span class="line">    nums[x] = nums[y];</span><br><span class="line">    nums[y] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def max_heapify(self, heap, root, heap_len):</span><br><span class="line">        p = root</span><br><span class="line">        while p * 2 + 1 &lt; heap_len:</span><br><span class="line">            l, r = p * 2 + 1, p * 2 + 2</span><br><span class="line">            if heap_len &lt;= r or heap[r] &lt; heap[l]:</span><br><span class="line">                nex = l</span><br><span class="line">            else:</span><br><span class="line">                nex = r</span><br><span class="line">            if heap[p] &lt; heap[nex]:</span><br><span class="line">                heap[p], heap[nex] = heap[nex], heap[p]</span><br><span class="line">                p = nex</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        </span><br><span class="line">    def build_heap(self, heap):</span><br><span class="line">        for i in range(len(heap) - 1, -1, -1):</span><br><span class="line">            self.max_heapify(heap, i, len(heap))</span><br><span class="line"></span><br><span class="line">    def heap_sort(self, nums):</span><br><span class="line">        self.build_heap(nums)</span><br><span class="line">        for i in range(len(nums) - 1, -1, -1):</span><br><span class="line">            nums[i], nums[0] = nums[0], nums[i]</span><br><span class="line">            self.max_heapify(nums, 0, i)</span><br><span class="line">            </span><br><span class="line">    def sortArray(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        self.heap_sort(nums)</span><br><span class="line">        return nums</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(nlog⁡n )。初始化建堆的时间复杂度为 O(n) ，建完堆以后需要进行 n−1  次调整，一次调整（即 maxHeapify） 的时间复杂度为 O(log⁡n ，那么 n−1 次调整即需要 O(nlog⁡n  的时间复杂度。因此，总时间复杂度为 O(n+nlog⁡n)&#x3D;O(nlog⁡ n)O(n+nlogn)&#x3D;O(nlogn)。</p><p>空间复杂度：O(1) 。只需要常数的空间存放若干变量。</p><h1 id="方法三：归并排序"><a href="#方法三：归并排序" class="headerlink" title="方法三：归并排序"></a>方法三：归并排序</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>归并排序利用了分治的思想来对序列进行排序。对一个长为 n 的待排序的序列，我们将其分解成两个长度为 n&#x2F;2<br>  的子序列。每次先递归调用函数使两个子序列有序，然后我们再线性合并两个有序的子序列使整个序列有序。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    void mergeSort(vector&lt;int&gt;&amp; nums, int l, int r) &#123;</span><br><span class="line">        if (l &gt;= r) return;</span><br><span class="line">        int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">        mergeSort(nums, l, mid);</span><br><span class="line">        mergeSort(nums, mid + 1, r);</span><br><span class="line">        int i = l, j = mid + 1;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            if (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt;= mid) &#123;</span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt;= r) &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; r - l + 1; ++i) &#123;</span><br><span class="line">            nums[i + l] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        tmp.resize((int)nums.size(), 0);</span><br><span class="line">        mergeSort(nums, 0, (int)nums.size() - 1);</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] tmp;</span><br><span class="line"></span><br><span class="line">    public int[] sortArray(int[] nums) &#123;</span><br><span class="line">        tmp = new int[nums.length];</span><br><span class="line">        mergeSort(nums, 0, nums.length - 1);</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int[] nums, int l, int r) &#123;</span><br><span class="line">        if (l &gt;= r) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">        mergeSort(nums, l, mid);</span><br><span class="line">        mergeSort(nums, mid + 1, r);</span><br><span class="line">        int i = l, j = mid + 1;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            if (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt;= mid) &#123;</span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt;= r) &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int k = 0; k &lt; r - l + 1; ++k) &#123;</span><br><span class="line">            nums[k + l] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge_sort(self, nums, l, r):</span><br><span class="line">        if l == r:</span><br><span class="line">            return</span><br><span class="line">        mid = (l + r) // 2</span><br><span class="line">        self.merge_sort(nums, l, mid)</span><br><span class="line">        self.merge_sort(nums, mid + 1, r)</span><br><span class="line">        tmp = []</span><br><span class="line">        i, j = l, mid + 1</span><br><span class="line">        while i &lt;= mid or j &lt;= r:</span><br><span class="line">            if i &gt; mid or (j &lt;= r and nums[j] &lt; nums[i]):</span><br><span class="line">                tmp.append(nums[j])</span><br><span class="line">                j += 1</span><br><span class="line">            else:</span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">                i += 1</span><br><span class="line">        nums[l: r + 1] = tmp</span><br><span class="line"></span><br><span class="line">    def sortArray(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        self.merge_sort(nums, 0, len(nums) - 1)</span><br><span class="line">        return nums</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(nlog⁡n 。由于归并排序每次都将当前待排序的序列折半成两个子序列递归调用，然后再合并两个有序的子序列，而每次合并两个有序的子序列需要 O(n)  的时间复杂度，所以我们可以列出归并排序运行时间 T(n)  的递归表达式：<br>T(n)&#x3D;2T(n,2)+O(n)根据主定理我们可以得出归并排序的时间复杂度为  )O(nlogn)。</p><p>空间复杂度：O(n)。我们需要额外 O(n)空间的 tmp 数组，且归并排序递归调用的层数最深为 log⁡2n，所以我们还需要额外的 O(log⁡  的栈空间，所需的空间复杂度即为 O(n+log⁡n)&#x3D;O(n。</p><h1 id="快速排序优化-5"><a href="#快速排序优化-5" class="headerlink" title="快速排序优化^5"></a>快速排序优化<a href="https://zhuanlan.zhihu.com/p/384708371">^5</a></h1><h2 id="为什么与轴点相等也要换位"><a href="#为什么与轴点相等也要换位" class="headerlink" title="为什么与轴点相等也要换位"></a>为什么与轴点相等也要换位</h2><p>元素与枢纽元素相等时指针也要停下。这样看起来做了额外的交换，但是可以保证在输入元素全部相等的情况下每次会将输入数组切分成一半。如果相等时指针不停下，快速排序就会在有大量重复元素的输入时复杂度退化为O(n^2)。</p><p>因为重复的元素越多会给算法带来越多的无用功，会涉及以下一个问题：</p><p>简单说是遇到与枢纽元相等的元素时，左右索引指针的平移需要停止吗？</p><p>如果只有一个停止：这将导致所有等于枢纽元pivot的元素都移动到同一侧(S1或S2)，在极端情况下所有元素都是重复，会产生最坏情况O(n^2)<br>如果都不停止：在极端情况下所有元素都是重复，整个过程枢纽元pivot相当于对整个数组进行了一次遍历，时间复杂度是(n + n-1 +…+2+1)&#x3D;(1&#x2F;2)(1+n)*n， 即时间复杂度O(n^2)，其实推演一下会发现基于快速排序的执行规则这种情况跟情况1是等价的，都不停止相当于始终只有一个指针在平移，而且是一直平移到末尾才停止。<br>如果都停止：在极端情况下所有元素都是重复，虽然看似会进行很多次“无意义”的交换，但由于每次双指针相遇的地点都是数组的中点，这个时候恰好将序列分为两个均等分配的子序列，还是归并排序的原理，达到分治法效率最大化，以此类推会让枢纽元pivot以logn的速度走完整个数组。所以这种方法最坏情况的时间复杂度为O(nlogn)</p><h2 id="双路三路快速排序-6-7"><a href="#双路三路快速排序-6-7" class="headerlink" title="双路三路快速排序^6 ^7"></a>双路三路快速排序<a href="https://segmentfault.com/a/1190000021726667">^6</a> <a href="https://www.jianshu.com/p/779bc4b61254">^7</a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个整数数组nums，请你将该数组升序排列。写出来后，也要把下面这几个点考虑下：时间&amp;#x2F;空间复杂度计算， 轴点随机取值， 为什么与轴点相等也要换位&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
    <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
    <category term="Sorting" scheme="http://yoursite.com/tags/Sorting/"/>
    
    <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
    <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
    <category term="Radix Sort" scheme="http://yoursite.com/tags/Radix-Sort/"/>
    
    <category term="Merge Sort" scheme="http://yoursite.com/tags/Merge-Sort/"/>
    
    <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
  </entry>
  
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <link href="http://yoursite.com/2022/10/10/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2022/10/10/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2022-10-10T09:36:12.000Z</published>
    <updated>2022-10-10T09:32:42.496Z</updated>
    
    <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。此题比较经典，对于两种解法我还有些没吃透，需要再次认真温习。</p><span id="more"></span><p>[TOC]</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>示例 1:</p><pre><code>输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><p>示例 2:</p><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><p>说明:</p><pre><code>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</code></pre><h1 id="📖文字题解-1"><a href="#📖文字题解-1" class="headerlink" title="📖文字题解^1"></a>📖文字题解<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">^1</a></h1><ul><li><p>约定：假设这里数组的长度为 <em>n</em>。</p></li><li><p>题目分析：本题希望我们返回数组排序之后的倒数第 <em>k</em> 个位置。</p></li></ul><h1 id="方法一：基于快速排序的选择方法"><a href="#方法一：基于快速排序的选择方法" class="headerlink" title="方法一：基于快速排序的选择方法"></a>方法一：基于快速排序的选择方法</h1><p><strong>思路和算法</strong></p><p>我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 <em>k</em> 个位置，这样平均时间复杂度是 O(nlogn)  ，但其实我们可以做的更快。</p><p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l…r]做快速排序的过程是（参考《算法导论》）：</p><ul><li><strong>分解：</strong> 将数组 a[l…r] 「划分」成两个子数组 a[l…q-1]<br>、a[q+1…r]，使得 a[l…q-1]中的每个元素小于等于 *a[q]*，且 <em>a[q]</em> 小于等于a[q+1…r]中的每个元素。其中，计算下标 <em>q</em> 也是「划分」过程的一部分。</li><li><strong>解决：</strong> 通过递归调用快速排序，对子数组 a[l…q-1]<br>、a[q+1…r] 进行排序。</li><li><strong>合并：</strong> 因为子数组都是原址排序的，所以不需要进行合并操作，a[l…r]  已经有序。</li><li>上文中提到的 <strong>「划分」</strong> 过程是：从子数组 a[l…r]   中选择任意一个元素 <em>x</em> 作为主元，<strong>调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它，</strong> <em>x</em> 的最终位置就是 <em>q</em>。</li></ul><p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 <em>x</em> 的最终位置为 <em>q</em>，并且保证 a[l…q-1] 中的每个元素小于等于 <em>a[q]<em>，且 <em>a[q]</em> 小于等于 a[q+1…r]中的每个元素。**所以只要某次划分的 <em>q</em> 为倒数第 <em>k</em> 个下标的时候，我们就已经找到了答案。</em></em> 我们只关心这一点，至于 a[l…q-1] 和a[q+1…r]  是否是有序的，我们不关心。</p><p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 <em>q</em> 正好就是我们需要的下标，就直接返回 *a[q]*；否则，如果 <em>q</em> 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p><p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 <em>n</em> 的问题我们都划分成 <em>1</em> 和 <em>n - 1</em>，每次递归的时候又向 <em>n - 1</em> 的集合中递归，这种情况是最坏的，时间代价是 *O(n ^ 2)*。我们可以引入随机化来加速这个过程，它的时间代价的期望是 *O(n)*，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</p><p>我试了一下<code>Arrays.sort(nums);</code>居然也过了，因为题目并没有要求不能用库函数所以其实两行代码就能解决问题</p><p><strong>代码</strong></p><details>    <summary>C++</summary>    <figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">randomPartition</span>(a, l, r);</span><br><span class="line">        <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q &lt; index ? <span class="built_in">quickSelect</span>(a, q + <span class="number">1</span>, r, index) : <span class="built_in">quickSelect</span>(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">randomPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[r]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[i + <span class="number">1</span>], a[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums.<span class="built_in">size</span>() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> randomPartition(a, l, r);</span><br><span class="line">        <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index) : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(a, i, r);</span><br><span class="line">        <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a, ++i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">            <span class="type">int</span> t = a[++i];</span><br><span class="line">            a[i] = a[j], a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = a[i + <span class="number">1</span>];</span><br><span class="line">    a[i + <span class="number">1</span>] = a[r], a[r] = t;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = rand() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">    <span class="type">int</span> t = a[i];</span><br><span class="line">    a[i] = a[r], a[r] = t;</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> q = randomPartition(a, l, r);</span><br><span class="line">    <span class="keyword">if</span> (q == index) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">                         : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>, numsSize - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="built_in">len</span>(nums)-k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSelect</span><span class="params">(a []<span class="type">int</span>, l, r, index <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    q := randomPartition(a, l, r)</span><br><span class="line">    <span class="keyword">if</span> q == index &#123;</span><br><span class="line">        <span class="keyword">return</span> a[q]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> q &lt; index &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(a, q + <span class="number">1</span>, r, index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(a, l, q - <span class="number">1</span>, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPartition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := rand.Int() % (r - l + <span class="number">1</span>) + l</span><br><span class="line">    a[i], a[r] = a[r], a[i]</span><br><span class="line">    <span class="keyword">return</span> partition(a, l, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="type">int</span>, l, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x := a[r]</span><br><span class="line">    i := l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j := l; j &lt; r; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt;= x &#123;</span><br><span class="line">            i++</span><br><span class="line">            a[i], a[j] = a[j], a[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i+<span class="number">1</span>], a[r] = a[r], a[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*O(n)*，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。</li><li>空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为O(logn)。</li></ul><h1 id="方法二：基于堆排序的选择方法"><a href="#方法二：基于堆排序的选择方法" class="headerlink" title="方法二：基于堆排序的选择方法"></a>方法二：基于堆排序的选择方法</h1><p><strong>思路和算法</strong></p><p>我们也可以使用堆排序来解决这个问题——建立一个大根堆，做 <em>k - 1</em> 次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程。</p><p><strong>友情提醒：「堆排」在很多大公司的面试中都很常见，不了解的同学建议参考《算法导论》或者大家的数据结构教材，一定要学会这个知识点哦! ^_^</strong></p><p>  <a href="https://assets.leetcode-cn.com/solution-static/215/1.png">fig1</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/2.png">fig2</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/3.png">fig3</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/4.png">fig4</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/5.png">fig5</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/6.png">fig6</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/7.png">fig7</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/8.png">fig8</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/9.png">fig9</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/10.png">fig10</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/11.png">fig11</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/12.png">fig12</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/13.png">fig13</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/14.png">fig14</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/15.png">fig15</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/16.png">fig16</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/17.png">fig17</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/18.png">fig18</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/19.png">fig19</a>  <a href="https://assets.leetcode-cn.com/solution-static/215/20.png">fig20</a> </p><p><strong>代码</strong></p><details>    <summary>C++</summary>    <figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maxHeapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[largest]);</span><br><span class="line">            <span class="built_in">maxHeapify</span>(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> heapSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">buildMaxHeap</span>(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">            --heapSize;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> t = a[i];</span><br><span class="line">        a[i] = a[largest], a[largest] = t;</span><br><span class="line">        maxHeapify(a, largest, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        maxHeapify(a, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> heapSize = numsSize;</span><br><span class="line">    buildMaxHeap(nums, heapSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = numsSize - <span class="number">1</span>; i &gt;= numsSize - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> t = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i], nums[i] = t;</span><br><span class="line">        --heapSize;</span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    heapSize := <span class="built_in">len</span>(nums)</span><br><span class="line">    buildMaxHeap(nums, heapSize)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt;= <span class="built_in">len</span>(nums) - k + <span class="number">1</span>; i-- &#123;</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        heapSize--</span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMaxHeap</span><span class="params">(a []<span class="type">int</span>, heapSize <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := heapSize/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        maxHeapify(a, i, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxHeapify</span><span class="params">(a []<span class="type">int</span>, i, heapSize <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    l, r, largest := i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>, i</span><br><span class="line">    <span class="keyword">if</span> l &lt; heapSize &amp;&amp; a[l] &gt; a[largest] &#123;</span><br><span class="line">        largest = l</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r &lt; heapSize &amp;&amp; a[r] &gt; a[largest] &#123;</span><br><span class="line">        largest = r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        a[i], a[largest] = a[largest], a[i]</span><br><span class="line">        maxHeapify(a, largest, heapSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn) ，建堆的时间代价是 *O(n)*，删除的总代价是 O(klogn) ，因为 <em>k &lt; n</em>，故渐进时间复杂为 O(n+klogn) 。</li><li>空间复杂度：O(nlogn)，即递归使用栈空间的空间代价。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。此题比较经典，对于两种解法我还有些没吃透，需要再次认真温习。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
    <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>25. K 个一组翻转链表</title>
    <link href="http://yoursite.com/2022/10/10/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/10/10/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-10-10T09:12:12.000Z</published>
    <updated>2022-10-10T09:03:02.786Z</updated>
    
    <content type="html"><![CDATA[<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5]</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5]</code></pre><p>提示：</p><pre><code>链表中的节点数目为 n1 &lt;= k &lt;= n &lt;= 50000 &lt;= Node.val &lt;= 1000</code></pre><p>进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？</p><p>从字节跳动的高频题过来的，<a href="https://codetop.cc/home%EF%BC%8C">https://codetop.cc/home，</a> 这道题出了很多次</p><h1 id="方法一：参考92-反转链表-1"><a href="#方法一：参考92-反转链表-1" class="headerlink" title="方法一：参考92.反转链表^1"></a>方法一：参考92.反转链表<a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">^1</a></h1><p>这道题和92.反转链表<a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">^1</a>方法二的思路非常接近，没看官方题解的前提下做出来了。就是遇到几次空指针的错误。</p><p>就是先统计一下链表长度，然后以类似冒泡的方法在每K个节点内部做反转。</p><details>    <summary>我的解法Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode prev = dummyHead;</span><br><span class="line">        ListNode p1 = dummyHead;</span><br><span class="line">        int length = 0;</span><br><span class="line">        while (p1.next != null) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; length / k; i++) &#123;</span><br><span class="line">            ListNode cur = prev.next;</span><br><span class="line">            for (int j = 1; j &lt; k; j++) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = next.next;</span><br><span class="line">                next.next = prev.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="方法二：图解模拟-2"><a href="#方法二：图解模拟-2" class="headerlink" title="方法二：图解模拟^2"></a>方法二：图解模拟<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/">^2</a></h1><p>一图胜千言，根据图片看代码，马上就懂了</p><p>步骤分解:</p><pre><code>链表分区为已翻转部分+待翻转部分+未翻转部分每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可</code></pre><p>时间复杂度为 O(n∗K) 最好的情况为 O(n) 最差的情况未 O(n^2)<br>空间复杂度为 O(1) 除了几个必须的节点指针外，我们并没有占用其他空间</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">    ListNode dummy = new ListNode(0);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    ListNode end = dummy;</span><br><span class="line"></span><br><span class="line">    while (end.next != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;</span><br><span class="line">        if (end == null) break;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        end.next = null;</span><br><span class="line">        pre.next = reverse(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        pre = start;</span><br><span class="line"></span><br><span class="line">        end = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ListNode reverse(ListNode head) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    while (curr != null) &#123;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="方法三：模拟-3"><a href="#方法三：模拟-3" class="headerlink" title="方法三：模拟^3"></a>方法三：模拟<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/">^3</a></h1><p>思路与算法</p><p>本题的目标非常清晰易懂，不涉及复杂的算法，但是实现过程中需要考虑的细节比较多，容易写出冗长的代码。主要考查面试者设计的能力。</p><p>我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。</p><p>接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206. 反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。如下图所示：</p><p>因此，在翻转子链表的时候，我们不仅需要子链表头节点 head，还需要有 head 的上一个节点 pre，以便翻转完后把子链表再接回 pre。</p><p>但是对于第一个子链表，它的头节点 head 前面是没有节点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点，把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个节点，我们就可以避开链表头部的边界条件。这么做还有一个好处，下面我们会看到。</p><p>反复移动指针 head 与 pre，对 head 所指向的子链表进行翻转，直到结尾，我们就得到了答案。下面我们该返回函数值了。</p><p>有的同学可能发现这又是一件麻烦事：链表翻转之后，链表的头节点发生了变化，那么应该返回哪个节点呢？照理来说，前 k 个节点翻转之后，链表的头节点应该是第 k 个节点。那么要在遍历过程中记录第 k 个节点吗？但是如果链表里面没有 k 个节点，答案又还是原来的头节点。我们又多了一大堆循环和判断要写，太崩溃了！</p><p>等等！还记得我们创建了节点 pre 吗？这个节点一开始被连接到了头节点的前面，而无论之后链表有没有翻转，它的 next 指针都会指向正确的头节点。那么我们只要返回它的下一个节点就好了。至此，问题解决。</p><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 翻转一个子链表，并且返回新的头与尾</span><br><span class="line">    def reverse(self, head: ListNode, tail: ListNode):</span><br><span class="line">        prev = tail.next</span><br><span class="line">        p = head</span><br><span class="line">        while prev != tail:</span><br><span class="line">            nex = p.next</span><br><span class="line">            p.next = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        return tail, head</span><br><span class="line"></span><br><span class="line">    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        hair = ListNode(0)</span><br><span class="line">        hair.next = head</span><br><span class="line">        pre = hair</span><br><span class="line"></span><br><span class="line">        while head:</span><br><span class="line">            tail = pre</span><br><span class="line">            # 查看剩余部分长度是否大于等于 k</span><br><span class="line">            for i in range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                if not tail:</span><br><span class="line">                    return hair.next</span><br><span class="line">            nex = tail.next</span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            # 把子链表重新接回原链表</span><br><span class="line">            pre.next = head</span><br><span class="line">            tail.next = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.next</span><br><span class="line">        </span><br><span class="line">        return hair.next</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 翻转一个子链表，并且返回新的头与尾</span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; myReverse(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode* hair = new ListNode(0);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line"></span><br><span class="line">        while (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            // 查看剩余部分长度是否大于等于 k</span><br><span class="line">            for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                if (!tail) &#123;</span><br><span class="line">                    return hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            // 这里是 C++17 的写法，也可以写成</span><br><span class="line">            // pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span><br><span class="line">            // head = result.first;</span><br><span class="line">            // tail = result.second;</span><br><span class="line">            tie(head, tail) = myReverse(head, tail);</span><br><span class="line">            // 把子链表重新接回原链表</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">        ListNode hair = new ListNode(0);</span><br><span class="line">        hair.next = head;</span><br><span class="line">        ListNode pre = hair;</span><br><span class="line"></span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">            ListNode tail = pre;</span><br><span class="line">            // 查看剩余部分长度是否大于等于 k</span><br><span class="line">            for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                if (tail == null) &#123;</span><br><span class="line">                    return hair.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode nex = tail.next;</span><br><span class="line">            ListNode[] reverse = myReverse(head, tail);</span><br><span class="line">            head = reverse[0];</span><br><span class="line">            tail = reverse[1];</span><br><span class="line">            // 把子链表重新接回原链表</span><br><span class="line">            pre.next = head;</span><br><span class="line">            tail.next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return hair.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode[] myReverse(ListNode head, ListNode tail) &#123;</span><br><span class="line">        ListNode prev = tail.next;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        while (prev != tail) &#123;</span><br><span class="line">            ListNode nex = p.next;</span><br><span class="line">            p.next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        return new ListNode[]&#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const myReverse = (head, tail) =&gt; &#123;</span><br><span class="line">    let prev = tail.next;</span><br><span class="line">    let p = head;</span><br><span class="line">    while (prev !== tail) &#123;</span><br><span class="line">        const nex = p.next;</span><br><span class="line">        p.next = prev;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    return [tail, head];</span><br><span class="line">&#125;</span><br><span class="line">var reverseKGroup = function(head, k) &#123;</span><br><span class="line">    const hair = new ListNode(0);</span><br><span class="line">    hair.next = head;</span><br><span class="line">    let pre = hair;</span><br><span class="line"></span><br><span class="line">    while (head) &#123;</span><br><span class="line">        let tail = pre;</span><br><span class="line">        // 查看剩余部分长度是否大于等于 k</span><br><span class="line">        for (let i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            if (!tail) &#123;</span><br><span class="line">                return hair.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const nex = tail.next;</span><br><span class="line">        [head, tail] = myReverse(head, tail);</span><br><span class="line">        // 把子链表重新接回原链表</span><br><span class="line">        pre.next = head;</span><br><span class="line">        tail.next = nex;</span><br><span class="line">        pre = tail;</span><br><span class="line">        head = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return hair.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func reverseKGroup(head *ListNode, k int) *ListNode &#123;</span><br><span class="line">    hair := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    pre := hair</span><br><span class="line"></span><br><span class="line">    for head != nil &#123;</span><br><span class="line">        tail := pre</span><br><span class="line">        for i := 0; i &lt; k; i++ &#123;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">            if tail == nil &#123;</span><br><span class="line">                return hair.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nex := tail.Next</span><br><span class="line">        head, tail = myReverse(head, tail)</span><br><span class="line">        pre.Next = head</span><br><span class="line">        tail.Next = nex</span><br><span class="line">        pre = tail</span><br><span class="line">        head = tail.Next</span><br><span class="line">    &#125;</span><br><span class="line">    return hair.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func myReverse(head, tail *ListNode) (*ListNode, *ListNode) &#123;</span><br><span class="line">    prev := tail.Next</span><br><span class="line">    p := head</span><br><span class="line">    for prev != tail &#123;</span><br><span class="line">        nex := p.Next</span><br><span class="line">        p.Next = prev</span><br><span class="line">        prev = p</span><br><span class="line">        p = nex</span><br><span class="line">    &#125;</span><br><span class="line">    return tail, head</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
    <category term="LinkList" scheme="http://yoursite.com/tags/LinkList/"/>
    
  </entry>
  
  <entry>
    <title>92. 反转链表II</title>
    <link href="http://yoursite.com/2022/10/10/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yoursite.com/2022/10/10/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</id>
    <published>2022-10-10T07:15:12.000Z</published>
    <updated>2022-10-10T07:08:47.246Z</updated>
    
    <content type="html"><![CDATA[<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><span id="more"></span><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p>示例1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><p>示例 2：</p><pre><code>输入：head = [5], left = 1, right = 1输出：[5]</code></pre><p>提示：</p><pre><code>链表中节点数目为 n1 &lt;= n &lt;= 500-500 &lt;= Node.val &lt;= 5001 &lt;= left &lt;= right &lt;= n</code></pre><p>进阶： 你可以使用一趟扫描完成反转吗？</p><p>[TOC]</p><h1 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一: 递归"></a>方法一: 递归</h1><p>这种方法实际上是交换节点的值而非反转链表的指针</p><p><strong>直觉</strong></p><p>使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。</p><p><a href="https://pic.leetcode-cn.com/7f6ec0687455cfecce2019fcb560d7066d7e7dfedd46922d3cc96bcbff3c1eb5-image.png">image.png</a></p><p>反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 <em>m</em> 个结点，另一个指向第 <em>n</em> 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。</p><blockquote><p>然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 <strong>模拟</strong> 向后指针。递归中的回溯可以帮助我们模拟一个指针从第<em>n</em>个结点向中心移动的移动过程。</p></blockquote><p><strong>算法</strong></p><ol><li>我们定义一个递归函数用于反转给定链表的一部分。</li><li>将函数记为 <code>recurse</code>。该函数使用三个参数: <code>m</code> 为反转的起点, <code>n</code> 为反转的终点, 以及从第 <em>n</em> 个结点开始，随着递归回溯过程向后移动的指针 <code>right</code>。不清楚的话，可以参考后文的示意图。</li><li>此外，我们还有一个指针 <code>left</code>，它从第 <code>m</code> 个结点开始向前移动。在 <code>Python</code> 中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数 <code>recurse</code> 的一个变量。</li><li>在递归调用中，给定 <code>m</code>，<code>n</code>，和 <code>right</code>, 首先判断 <code>n = 1</code>。 若判断为真, 则结束。</li><li>于是，当 <code>n</code> 的值达到 1 时，我们便<strong>回溯</strong>。这时，<code>right</code> 指针在我们要反转的子链表结尾，<code>left</code> 到达了字列表的开头。于是，我们置换数据，并将 <code>left</code> 指针前移：<code>left = left.next</code>。我们需要此变化在回溯过程中保持。</li><li>自此，每当我们回溯时，<code>right</code> 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。</li><li>当 <code>right == left</code> 或者 <code>right.next == left</code> 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。</li></ol><p>下面是一系列整个算法的示意图，希望能够帮助你理解清楚。</p><p><img src="http://pic.leetcode-cn.com/1adc7164bea5cd650af1545682900c792bd37a82df607aeb4f87a233d3eb69cf-image.png" alt="image.png"></p><p>这是递归过程的第一步。给定所用链表，<code>left</code> 和 <code>right</code> 指针从链表的 <code>head</code> 开始。第一步是以更新过的 <code>m</code> 和 <code>n</code> 进行递归调用，换而言之，它们的值各自减 1。此外，<code>left</code> 和 <code>right</code> 指针向前移动一位。</p><p><a href="https://pic.leetcode-cn.com/162f18666a30ffd98e185da1311f2daa48b087b03d3a9eefeeb9541eafbcd013-image.png">image.png</a></p><p>接下来的两步展示了 <code>left</code> 和 <code>right</code> 指针在链表中的移动。注意到在第二步之后，<code>left</code> 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 <code>right</code> 指针继续移动，直到抵达结点 <code>6</code>。</p><p><a href="https://pic.leetcode-cn.com/4213450e7d9466ddf22f289d5e753df47a94a9a87789312a02de2979ed161718-image.png">image.png</a></p><p>如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 <code>left</code> 和 <code>right</code> 结点的数据。</p><p><a href="https://pic.leetcode-cn.com/36b2ed0c1859c5574a17597070797d8f26b77a9c13a0c3462ea150b1058fbbce-image.png">image.png</a></p><p>如你所见，在第三步（回溯）之后，<code>right</code> 指针 <strong>穿过了</strong> <code>left</code> 指针，此时已经完成了要求部分链表的反转。结果是 <code>[7 → 9 → 8 → 1 → 10 → 2 → 6]</code>。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。</p><details>    <summary>递归Java</summary>    <figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object level variables since we need the changes</span></span><br><span class="line">    <span class="comment">// to persist across recursive calls and Java is pass by value.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stop;</span><br><span class="line">    <span class="keyword">private</span> ListNode left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recurseAndReverse</span><span class="params">(ListNode right, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case. Don&#x27;t proceed any further</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">        right = right.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">        <span class="comment">// from where the reversal is to start.</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recurse with m and n reduced.</span></span><br><span class="line">        <span class="built_in">this</span>.recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case both the pointers cross each other or become equal, we</span></span><br><span class="line">        <span class="comment">// stop i.e. don&#x27;t swap data any further. We are done reversing at this</span></span><br><span class="line">        <span class="comment">// point.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left == right || right.next == <span class="built_in">this</span>.left) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stop = <span class="literal">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Until the boolean stop is false, swap data between the two pointers</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.stop) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.left.val;</span><br><span class="line">            <span class="built_in">this</span>.left.val = right.val;</span><br><span class="line">            right.val = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move left one step to the right.</span></span><br><span class="line">            <span class="comment">// The right pointer moves one step back via backtracking.</span></span><br><span class="line">            <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = head;</span><br><span class="line">        <span class="built_in">this</span>.stop = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.recurseAndReverse(head, m, n);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Python</summary>    <figure class="highlight python"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        left, right = head, head</span><br><span class="line">        stop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recurseAndReverse</span>(<span class="params">right, m, n</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> left, stop</span><br><span class="line"></span><br><span class="line">            <span class="comment"># base case. Don&#x27;t proceed any further</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">            <span class="comment"># from where the reversal is to start.</span></span><br><span class="line">            <span class="keyword">if</span> m &gt; <span class="number">1</span>:</span><br><span class="line">                left = left.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Recurse with m and n reduced.</span></span><br><span class="line">            recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># In case both the pointers cross each other or become equal, we</span></span><br><span class="line">            <span class="comment"># stop i.e. don&#x27;t swap data any further. We are done reversing at this</span></span><br><span class="line">            <span class="comment"># point.</span></span><br><span class="line">            <span class="keyword">if</span> left == right <span class="keyword">or</span> right.<span class="built_in">next</span> == left:</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Until the boolean stop is false, swap data between the two pointers     </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stop:</span><br><span class="line">                left.val, right.val = right.val, left.val</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Move left one step to the right.</span></span><br><span class="line">                <span class="comment"># The right pointer moves one step back via backtracking.</span></span><br><span class="line">                left = left.<span class="built_in">next</span>           </span><br><span class="line"></span><br><span class="line">        recurseAndReverse(right, m, n)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: *O(N)*。对每个结点最多处理两次。递归过程</li><li>回溯</li><li>在回溯过程中，我们只交换了一半的结点，但总复杂度是 *O(N)*。</li><li>空间复杂度: 最坏情况下为 *O(N)*。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。<br/><br/></li></ul><hr><h1 id="方法二-迭代链接反转"><a href="#方法二-迭代链接反转" class="headerlink" title="方法二: 迭代链接反转"></a>方法二: 迭代链接反转</h1><p>我一开始想到的就是通过迭代方法来反转，但是在处理反转后调整成环的情况时翻车了，想了半天，还是参照下面图例中的方法比较直观。</p><p><strong>直觉</strong></p><p>在上个方法中，我们研究了一种反转给定链表部分的算法，该算法不改变给定链表的内在结构，只是修改了对于结点的值。 然而，有时可能无法修改结点的数据值。这时，我们就需要改变结点的链接来完成反转。</p><p>从位置 <code>m</code> 到位置 <code>n</code> 的全部结点，我们需要反转每个结点的 <code>next</code> 指针。下面来看看具体的算法。</p><p><strong>算法</strong></p><p>在看具体算法之前，有必要先弄清楚链接反转的原理以及需要哪些指针。举例而言，有一个三个不同结点组成的链表 <code>A → B → C</code>，需要反转结点中的链接成为 <code>A ← B ← C</code>。</p><p>假设我们有两个指针，一个指向结点 <code>A</code>，一个指向结点 <code>B</code>。 分别记为 <code>prev</code> 和 <code>cur</code>。则可以用这两个指针简单地实现 <code>A 和 B</code> 之间的链接反转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.next = prev</span><br></pre></td></tr></table></figure><p>这样做唯一的问题是，没有办法继续下去，换而言之，这样做之后就无法再访问到结点 <code>C</code>。因此，我们需要引入第三个指针，用于帮助反转过程的进行。因此，我们不采用上面的反转方法，而是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">third = cur.next</span><br><span class="line">cur.next = prev</span><br><span class="line">prev = cur</span><br><span class="line">cur = third</span><br></pre></td></tr></table></figure><p> <strong>迭代</strong> 地进行上述过程，即可完成问题的要求。下面来看看算法的步骤。</p><ol><li>如上所述，我们需要两个指针 <code>prev</code> 和 <code>cur</code>。</li><li><code>prev</code> 指针初始化为 <code>None</code>，<code>cur</code> 指针初始化为链表的 <code>head</code>。</li><li>一步步地向前推进 <code>cur</code> 指针，<code>prev</code> 指针跟随其后。</li><li>如此推进两个指针，直到 <code>cur</code> 指针到达从链表头起的第 <em>m</em> 个结点。这就是我们反转链表的起始位置。</li><li>注意我们要引入两个额外指针，分别称为 <code>tail</code> 和 <code>con</code>。<code>tail</code> 指针指向从链表头起的第<em>m</em>个结点，此结点是反转后链表的尾部，故称为 <code>tail</code>。<code>con</code> 指针指向第 <em>m</em> 个结点的前一个结点，此结点是新链表的头部。下图可以帮助你更好的理解这两个指针。</li></ol><p><a href="https://pic.leetcode-cn.com/bf38eaeb92184fbfb55bd76336c7f746b6f01b3c83bd921268afe84a3c3cf183-image.png">image.png</a></p><ol start="6"><li><code>tail</code> 和 <code>con</code> 指针在算法开始时被初始化，在算法最后被调用，用于完成链表反转。</li><li>如前文所解释的那样，抵达第 <em>m</em> 个结点后，在用到上述两个指针前，先迭代地反转链接。不断迭代，直到完成指向第 <em>n</em> 个结点的链接。此时，<code>prev</code> 指针会指向第 <em>n</em> 个结点。</li><li>我们使用 <code>con</code> 指针来连接 <code>prev</code> 指针，这是因为 <code>prev</code> 指针当前指向的结点(第 <em>n</em> 个结点)会代替第 <em>m</em> 个结点的位置。 类似地，我们利用 <code>tail</code> 指针来连接 <code>prev</code> 指针之后的结点（第 <em>n+1</em> 个结点）。</li></ol><p>为了便于理清每个指针的用法，我们来看一个算法运行的实例。给定一个链表 <code>7 → 9 → 2 → 10 → 1 → 8 → 6</code>，我们需要反转从第 3 个结点到第 6 个结点的子链表。</p><p><a href="https://pic.leetcode-cn.com/08d4eb39be0db6ded442a208399b5778bbab1cf75c26bc5b3d93128b7c224cb4-image.png">image.png</a></p><p>从上图可以看到迭代法的前几步。第一步展示了两个指针的初始化，第三步展示了链表反转过程的初始位置。</p><p><a href="https://pic.leetcode-cn.com/77af1e2ca8bd5f9ccc89802094ce07e2505c6b4483ccd6887f2762a6e67310e1-image.png">image.png</a></p><p>上图详细显示了链接反转的过程以及反转两个结点的链接后如何向前移动。如下图所示，本步骤将执行多次。</p><p><a href="https://pic.leetcode-cn.com/f634c434bcc5092d84b3125a4cd7c723aa3ddd53dcfb9ec3077423cbff1d2f85-image.png">image.png</a></p><p><a href="https://pic.leetcode-cn.com/b11861e6d3a86cdec19152d442dd243aaf0fb6c914787e7cf60990f2ecf0d558-image.png">image.png</a></p><p>如上图所示, 两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 <code>tail</code> 和 <code>con</code> 指针完成链接调整的过程。</p><p><a href="https://pic.leetcode-cn.com/968684e83b4cbc4b4db6f80e3bda03748729af672e702a8d3473b24cd04a7092-image.png">image.png</a></p><details>    <summary>迭代链接反转Java</summary><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty list</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment">// in the list.</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The two pointers that will fix the final connections.</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">con</span> <span class="operator">=</span> prev, tail = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">third</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            third = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = third;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            con.next = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代链接反转Python</summary>    <figure class="highlight python"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Empty list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment"># in the list.</span></span><br><span class="line">        cur, prev = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            m, n = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The two pointers that will fix the final connections.</span></span><br><span class="line">        tail, con = cur, prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            third = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = third</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> con:</span><br><span class="line">            con.<span class="built_in">next</span> = prev</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = prev</span><br><span class="line">        tail.<span class="built_in">next</span> = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: *O(N)*。考虑包含 <em>N</em> 个结点的链表。对每个节点最多会处理</li><li>（第 <em>n</em> 个结点之后的结点不处理）。</li><li>空间复杂度: *O(1)*。我们仅仅在原有链表的基础上调整了一些指针，只使用了 <em>O(1)</em> 的额外存储空间来获得结果。<br /></li></ul><h1 id="方法三：一次遍历「穿针引线」反转链表（头插法）-1"><a href="#方法三：一次遍历「穿针引线」反转链表（头插法）-1" class="headerlink" title="方法三：一次遍历「穿针引线」反转链表（头插法）^1"></a>方法三：一次遍历「穿针引线」反转链表（头插法）<a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">^1</a></h1><p>链接中方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为<br>O(N)，但遍历了链表2 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。</p><p>我们依然以方法一的示例为例进行说明。</p><p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。</p><p>下面我们具体解释如何实现。使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：</p><pre><code>curr：指向待反转区域的第一个节点 left；next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</code></pre><p>第 1 步，我们使用 ①、②、③ 标注「穿针引线」的步骤。</p><p>操作步骤：</p><pre><code>先将 curr 的下一个节点记录为 next；执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；执行操作 ③：把 pre 的下一个节点指向 next。</code></pre><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *reverseBetween(ListNode *head, int left, int right) &#123;</span><br><span class="line">        // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">        ListNode *dummyNode = new ListNode(-1);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseBetween(ListNode head, int left, int right) &#123;</span><br><span class="line">        // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">        ListNode dummyNode = new ListNode(-1);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        ListNode pre = dummyNode;</span><br><span class="line">        for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = pre.next;</span><br><span class="line">        ListNode next;</span><br><span class="line">        for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            next.next = pre.next;</span><br><span class="line">            pre.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseBetween(self, head: ListNode, left: int, right: int) -&gt; ListNode:</span><br><span class="line">        # 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">        dummy_node = ListNode(-1)</span><br><span class="line">        dummy_node.next = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        for _ in range(left - 1):</span><br><span class="line">            pre = pre.next</span><br><span class="line"></span><br><span class="line">        cur = pre.next</span><br><span class="line">        for _ in range(right - left):</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = next.next</span><br><span class="line">            next.next = pre.next</span><br><span class="line">            pre.next = next</span><br><span class="line">        return dummy_node.next</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func reverseBetween(head *ListNode, left, right int) *ListNode &#123;</span><br><span class="line">    // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">    dummyNode := &amp;ListNode&#123;Val: -1&#125;</span><br><span class="line">    dummyNode.Next = head</span><br><span class="line">    pre := dummyNode</span><br><span class="line">    for i := 0; i &lt; left-1; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line">    cur := pre.Next</span><br><span class="line">    for i := 0; i &lt; right-left; i++ &#123;</span><br><span class="line">        next := cur.Next</span><br><span class="line">        cur.Next = next.Next</span><br><span class="line">        next.Next = pre.Next</span><br><span class="line">        pre.Next = next</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;</span><br><span class="line">    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span><br><span class="line">    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummyNode-&gt;val = -1;</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    struct ListNode *pre = dummyNode;</span><br><span class="line">    for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *cur = pre-&gt;next;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>62. 不同路径</title>
    <link href="http://yoursite.com/2022/10/08/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2022/10/08/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2022-10-08T07:12:12.000Z</published>
    <updated>2022-10-08T08:15:08.377Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><span id="more"></span><p>[TOC]</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>示例 1:</p><pre><code>输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</code></pre><p>示例 2:</p><pre><code>输入: m = 7, n = 3输出: 28</code></pre><p>示例 3：</p><pre><code>输入：m = 7, n = 3输出：28</code></pre><p>示例 4：</p><pre><code>输入：m = 3, n = 3输出：6</code></pre><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100</code></pre><p>题目数据保证答案小于等于 2 * 10 ^ 9</p><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路^1"></a>思路<a href="https://leetcode.cn/problems/unique-paths/solution/bu-tong-lu-jing-by-leetcode-solution-hzjf/">^1</a></h1><h2 id="思路一：排列组合"><a href="#思路一：排列组合" class="headerlink" title="思路一：排列组合"></a><strong>思路一：排列组合</strong></h2><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，<code>m=3, n=2</code>，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 <em>C_{m+n-2}^{m-1}</em></p><details>    <summary>Python</summary>    <figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(math.factorial(m+n-<span class="number">2</span>)/math.factorial(m-<span class="number">1</span>)/math.factorial(n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long long ans = 1;</span><br><span class="line">        for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">            ans = ans * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long ans = 1;</span><br><span class="line">        for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">            ans = ans * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func uniquePaths(m, n int) int &#123;</span><br><span class="line">    return int(new(big.Int).Binomial(int64(m+n-2), int64(n-1)).Int64())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    long long ans = 1;</span><br><span class="line">    for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">        ans = ans * x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a><strong>思路二：动态规划</strong></h2><p>我们令 <code>dp[i][j]</code> 是到达 <code>i, j</code> 最多路径</p><p>动态方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>注意，对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，由于都是在边界，所以只能为 <code>1</code></p><p>时间复杂度：<em>O(m</em>n)*</p><p>空间复杂度：<em>O(m * n)</em></p><h2 id="优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1"><a href="#优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1" class="headerlink" title="优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1] "></a>优化：因为我们每次只需要 <code>dp[i-1][j],dp[i][j-1] </code></h2><p>所以我们只要记录这两个数，直接看代码吧！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路二：</p><details>    <summary>Java</summary>   <figure class="highlight java"><figcaption><span>[1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>优化1：空间复杂度 <em>O(2n)</em></p><details>    <summary>Java</summary>   <figure class="highlight java"><figcaption><span>[2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(pre, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-<span class="number">1</span>] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>优化2：空间复杂度 <em>O(n)</em></p><details>    <summary>Java</summary>  <figure class="highlight java"><figcaption><span>[3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Combinatorics" scheme="http://yoursite.com/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>206. 反转链表</title>
    <link href="http://yoursite.com/2022/09/30/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/09/30/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-09-30T07:51:12.000Z</published>
    <updated>2022-09-30T08:03:51.645Z</updated>
    
    <content type="html"><![CDATA[<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2]输出：[2,1]</code></pre><p>示例 3：</p><pre><code>输入：head = []输出：[]</code></pre><p>进阶:</p><pre><code>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><h1 id="方法一：迭代-1"><a href="#方法一：迭代-1" class="headerlink" title="方法一：迭代^1"></a>方法一：迭代<a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/">^1</a></h1><p>假设存在链表 <code>1 → 2 → 3 → Ø</code>，我们想要把它改成 <code>Ø ← 1 ← 2 ← 3</code>。</p><p>在遍历列表时，将当前节点的 <code>next</code> 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><details>    <summary>迭代Java</summary>    <figure class="highlight java"><figcaption><span>[Tww6MiPp-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    let prev = null;</span><br><span class="line">    let curr = head;</span><br><span class="line">    while (curr) &#123;</span><br><span class="line">        const next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode prev = null;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        while (curr != null) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        while (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode* prev = NULL;</span><br><span class="line">    struct ListNode* curr = head;</span><br><span class="line">    while (curr) &#123;</span><br><span class="line">        struct ListNode* next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*O(n)*，假设 <em>n</em> 是列表的长度，时间复杂度是 *O(n)*。</li><li>空间复杂度：*O(1)*。</li></ul><hr><h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><p>递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？</p><p>假设列表为：</p><p>n1→…→nk−1    →n k→n k+1→…→nm→∅</p><p>若从节点 <em>n_{k+1}</em> 到 <em>n_{m}</em> 已经被反转，而我们正处于 *n_{k}*。</p><p>n1→…→nk−1→n k→n k+1←…←nm</p><p>我们希望 <em>n_{k+1}</em> 的下一个节点指向 *n_{k}*。</p><p>所以，<em>n_{k}</em>.next.next &#x3D; *n_{k}*。</p><p>要小心的是 <em>n_{1}</em> 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><details>    <summary>递归</summary>    <figure class="highlight java"><figcaption><span>[ESkYHVXb-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if (head == null || head.next == null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const newHead = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func reverseList(head *ListNode) *ListNode &#123;</span><br><span class="line">    if head == nil || head.Next == nil &#123;</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    newHead := reverseList(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = nil</span><br><span class="line">    return newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    if (head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*O(n)*，假设 <em>n</em> 是列表的长度，那么时间复杂度为 *O(n)*。</li><li>空间复杂度：*O(n)*，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 <em>n</em> 层。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
    <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>24.两两交换链表中的节点</title>
    <link href="http://yoursite.com/2022/09/29/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2022/09/29/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2022-09-29T06:32:12.000Z</published>
    <updated>2022-09-29T09:04:53.109Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：head = [1,2,3,4]输出：[2,1,4,3]</code></pre><p>示例 2：</p><pre><code>输入：head = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：head = [1]输出：[1]</code></pre><p>提示：</p><pre><code>链表中节点的数目在范围 [0, 100] 内0 &lt;= Node.val &lt;= 100</code></pre><p>[TOC]</p><p>此题有递归和迭代两种方法<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/">^1</a>，我在做的时候首先想到的是用迭代的方法。但是在返回哪个结点时出了问题。调试了很久。看官方题解<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/</a><br>也没有弄清楚dummy结点下个结点为什么会准确的指向交换后的链表头而不是跟着交换移动。<br>看了<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/</a><br>这个题解中的图解才算搞清楚了，建议再做的时候还是在不看题解的情况下写一次。</p><p>顺便推荐IDEA中的leetcode-editor插件，这个插件现在已经可以在中文版leetcode上无缝对接使用了。适合在一些场景下做leetcode。</p><p>22年再做第二次的解法</p><details>    <summary>我的解法</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        ListNode dummy = new ListNode();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode slow = null;</span><br><span class="line">        ListNode fast = null;</span><br><span class="line">        if (head != null) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            if (head.next != null) &#123;</span><br><span class="line">                fast = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        while (slow != null &amp;&amp; fast != null) &#123;</span><br><span class="line">            prev.next = fast;</span><br><span class="line">            slow.next = fast.next;</span><br><span class="line">            fast.next = slow;</span><br><span class="line">            if (slow.next == null || slow.next.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法一：递归-2"><a href="#方法一：递归-2" class="headerlink" title="方法一：递归^2"></a>方法一：递归<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/">^2</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>可以通过递归的方式实现两两交换链表中的节点。</p><p>递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。</p><p>如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next &#x3D; swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next &#x3D; head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = head.next;</span><br><span class="line">        head.next = swapPairs(newHead.next);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(newHead-&gt;next);</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var swapPairs = function(head) &#123;</span><br><span class="line">    if (head === null|| head.next === null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const newHead = head.next;</span><br><span class="line">    head.next = swapPairs(newHead.next);</span><br><span class="line">    newHead.next = head;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line">        newHead = head.next</span><br><span class="line">        head.next = self.swapPairs(newHead.next)</span><br><span class="line">        newHead.next = head</span><br><span class="line">        return newHead</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func swapPairs(head *ListNode) *ListNode &#123;</span><br><span class="line">    if head == nil || head.Next == nil &#123;</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    newHead := head.Next</span><br><span class="line">    head.Next = swapPairs(newHead.Next)</span><br><span class="line">    newHead.Next = head</span><br><span class="line">    return newHead</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct ListNode* swapPairs(struct ListNode* head) &#123;</span><br><span class="line">    if (head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* newHead = head-&gt;next;</span><br><span class="line">    head-&gt;next = swapPairs(newHead-&gt;next);</span><br><span class="line">    newHead-&gt;next = head;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</p><p>空间复杂度：<br>O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。</p><h1 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>也可以通过迭代的方式实现两两交换链表中的节点。</p><p>创建哑结点 dummyHead，令 dummyHead.next &#x3D; head。令 temp 表示当前到达的节点，初始时 temp &#x3D; dummyHead。每次需要交换 temp 后面的两个节点。</p><p>如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</p><p>具体而言，交换之前的节点关系是 temp -&gt; node1 -&gt; node2，交换之后的节点关系要变成 temp -&gt; node2 -&gt; node1，因此需要进行如下操作。</p><pre><code>temp.next = node2node1.next = node2.nextnode2.next = node1</code></pre><p>完成上述操作之后，节点关系即变成 temp -&gt; node2 -&gt; node1。再令 temp &#x3D; node1，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p><p>两两交换链表中的节点之后，新的链表的头节点是 dummyHead.next，返回新的链表的头节点即可。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        while (temp.next != null &amp;&amp; temp.next.next != null) &#123;</span><br><span class="line">            ListNode node1 = temp.next;</span><br><span class="line">            ListNode node2 = temp.next.next;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        while (temp-&gt;next != nullptr &amp;&amp; temp-&gt;next-&gt;next != nullptr) &#123;</span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var swapPairs = function(head) &#123;</span><br><span class="line">    const dummyHead = new ListNode(0);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    let temp = dummyHead;</span><br><span class="line">    while (temp.next !== null &amp;&amp; temp.next.next !== null) &#123;</span><br><span class="line">        const node1 = temp.next;</span><br><span class="line">        const node2 = temp.next.next;</span><br><span class="line">        temp.next = node2;</span><br><span class="line">        node1.next = node2.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        temp = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummyHead = ListNode(0)</span><br><span class="line">        dummyHead.next = head</span><br><span class="line">        temp = dummyHead</span><br><span class="line">        while temp.next and temp.next.next:</span><br><span class="line">            node1 = temp.next</span><br><span class="line">            node2 = temp.next.next</span><br><span class="line">            temp.next = node2</span><br><span class="line">            node1.next = node2.next</span><br><span class="line">            node2.next = node1</span><br><span class="line">            temp = node1</span><br><span class="line">        return dummyHead.next</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func swapPairs(head *ListNode) *ListNode &#123;</span><br><span class="line">    dummyHead := &amp;ListNode&#123;0, head&#125;</span><br><span class="line">    temp := dummyHead</span><br><span class="line">    for temp.Next != nil &amp;&amp; temp.Next.Next != nil &#123;</span><br><span class="line">        node1 := temp.Next</span><br><span class="line">        node2 := temp.Next.Next</span><br><span class="line">        temp.Next = node2</span><br><span class="line">        node1.Next = node2.Next</span><br><span class="line">        node2.Next = node1</span><br><span class="line">        temp = node1</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode dummyHead;</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    struct ListNode* temp = &amp;dummyHead;</span><br><span class="line">    while (temp-&gt;next != NULL &amp;&amp; temp-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        struct ListNode* node1 = temp-&gt;next;</span><br><span class="line">        struct ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">        temp-&gt;next = node2;</span><br><span class="line">        node1-&gt;next = node2-&gt;next;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        temp = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</p><p>空间复杂度：<br>O(1)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="LinkList" scheme="http://yoursite.com/tags/LinkList/"/>
    
  </entry>
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="http://yoursite.com/2022/09/28/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2022/09/28/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2022-09-28T07:52:12.000Z</published>
    <updated>2022-09-28T09:57:08.177Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><span id="more"></span><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><pre><code>输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></pre><p>示例2:</p><pre><code>输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False</code></pre><p>注意：</p><pre><code>输入的字符串只包含小写字母两个字符串的长度都在 [1, 10,000] 之间</code></pre><p>[TOC]</p><h1 id="方法一-暴力-超过时间限制"><a href="#方法一-暴力-超过时间限制" class="headerlink" title="方法一 暴力 超过时间限制"></a>方法一 暴力 <a href="https://leetcode.cn/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode-solut-7k7u/">超过时间限制</a></h1><p><strong>算法</strong></p><p>最简单的方法是生成短字符串的所有排列，并检查生成的排列是否是较长字符串的子字符串。</p><p>为了生成所有可能的配对，我们使用函数<code>permute（string_1，string_2，current_index）</code>。此函数创建短字符串 <em>s1</em> 的所有可能排列。</p><p>为此，permute将当前元素 <em>current_index</em> 的索引作为参数之一。然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。完成交换后，它会再次调用置换，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。</p><p>因此，当我们到达数组的末尾时，会生成数组元素的新排序。以下动画描述了生成排列的过程。</p><p> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide1.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide2.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide3.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide4.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide5.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide6.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide7.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide8.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide9.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide10.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide11.PNG">1200</a> </p><details>    <summary>暴力</summary>    <figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        permute(s1, s2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">swap</span><span class="params">(String s, <span class="type">int</span> i0, <span class="type">int</span> i1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i0 == i1)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, i0);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.substring(i0 + <span class="number">1</span>, i1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s.substring(i1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">permute</span><span class="params">(String s1, String s2, <span class="type">int</span> l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.indexOf(s1) &gt;= <span class="number">0</span>)</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt; s1.length(); i++) &#123;</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">                permute(s1, s2, l + <span class="number">1</span>);</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n!)<em>。我们将 <em>s1</em> 的短字符串 <em>s1</em> 的所有排列与 <em>s2</em> 匹配。这里，</em>n</em> 指的是 <em>s1</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n^2)<em>。递归树的深度是 <em>n</em>（</em>n</em> 是指短字符串 <em>s1</em> 的长度）。递归树的每个节点都包含一个 max 的字符串。长度 <em>n</em>。</p></li></ul><hr><h1 id="方法二-排序-超过时间限制"><a href="#方法二-排序-超过时间限制" class="headerlink" title="方法二 排序 [超过时间限制]:"></a>方法二 排序 [超过时间限制]:</h1><p><strong>算法</strong></p><p>这种方法背后的想法是，只有当两个字符串包含相同次数的相同字符时，一个字符串才是另一个字符串的排列。只有<em>sorted(x)&#x3D; sorted(y)<em>时，一个字符串</em>x</em>才​​是其他字符串 <em>y</em> 的排列。</p><p>为了检查这一点，我们可以对两个字符串进行排序并进行比较。我们对短字符串 <em>s1</em> 和 <em>s2</em> 的所有子字符串进行排序，对它们进行排序并将它们与排序的 <em>s1</em> 字符串进行比较。如果两者完全匹配，<em>s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>排序</summary>        <figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(l1log(l1)+(l2-l1)l1log(l1))。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(l_1)*。使用了 <em>t</em> 数组。</p></li></ul><hr><h1 id="方法三-使用哈希表-超过时间限制"><a href="#方法三-使用哈希表-超过时间限制" class="headerlink" title="方法三 使用哈希表 [超过时间限制]"></a>方法三 使用哈希表 [超过时间限制]</h1><p><strong>算法</strong></p><p>如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 <em>s1</em> 长度相同的长字符串 <em>s2</em> 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 <em>s1</em> 的排列可以是 <em>s2</em> 的子字符串。</p><p>为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 <em>s1map</em>来存储短字符串 <em>s1</em> 中所有字符的出现频率。我们考虑 <em>s2</em> 的每个可能的子串，其长度与 <em>s1</em> 的长度相同，也可以找到相应的哈希表，即 <em>s2map</em>。因此，所考虑的子字符串可以被视为一个长度窗口，如 <em>s1</em> 迭代超过 <em>s2</em>。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 <em>s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>使用哈希表</summary>        <figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(l_1+26</em>l_1*(l_2-l_1))<em>。这个哈希表包含最多26个键。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2* 是字符串 <em>l_2</em> 的长度。</li><li>空间复杂度：*O(1)*。表包含最多 26 个键值对。</li></ul><hr><h1 id="方法四-使用数组-通过"><a href="#方法四-使用数组-通过" class="headerlink" title="方法四 使用数组 [通过]"></a>方法四 使用数组 [通过]</h1><p><strong>算法</strong></p><p>我们可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。给定字符串仅包含小写字母（’a’到’z’）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。</p><details>    <summary>使用数组</summary>    <figure class="highlight java"><figcaption><span>[solution-4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] s1map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++)</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] s2map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s1.length(); j++) &#123;</span><br><span class="line">                s2map[s2.charAt(i + j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(<span class="type">int</span>[] s1map, <span class="type">int</span>[] s2map)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p>时间复杂度：<em>O(l_1+26</em>l_1*(l_2-l_1))<em>。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2* 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(1)*。使用 <em>s1map</em> 和 <em>s2map</em>，大小为 26。</p></li></ul><hr><h1 id="方法五-滑动窗口-通过"><a href="#方法五-滑动窗口-通过" class="headerlink" title="方法五 滑动窗口  [通过]:"></a>方法五 滑动窗口  [通过]:</h1><p><strong>算法</strong></p><p>我们可以为 <em>s2</em> 中的第一个窗口创建一次哈希表，而不是为 <em>s2</em> 中考虑的每个窗口重新生成哈希表。然后，稍后当我们滑动窗口时，我们知道我们添加了一个前面的字符并将新的后续字符添加到所考虑的新窗口中。因此，我们可以通过仅更新与这两个字符相关联的索引来更新哈希表。同样，对于每个更新的哈希表，我们将哈希表的所有元素进行比较以获得所需的结果。</p><details>    <summary>使用数组</summary>    <figure class="highlight java"><figcaption><span>[solution5-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] s1map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] s2map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(<span class="type">int</span>[] s1map, <span class="type">int</span>[] s2map)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度分析：<em>O(l_1+26</em>(l_2-l_1))<em>。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2* 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(1)*。常数级空间。</p></li></ul><hr><h1 id="方法六-优化的滑动窗口-通过"><a href="#方法六-优化的滑动窗口-通过" class="headerlink" title="方法六 优化的滑动窗口 [通过]:"></a>方法六 优化的滑动窗口 [通过]:</h1><p><strong>算法</strong></p><p>上一种方法可以优化，如果不是比较每个更新的 <em>s2map</em> 的哈希表的所有元素，而是对应于 <em>s2</em> 考虑的每个窗口，我们会跟踪先前哈希表中已经匹配的元素数量当我们向右移动窗口时，只更新匹配元素的数量。</p><p>为此，我们维护一个 <em>count</em> 变量，该变量存储字符数（26个字母表中的数字），这些字符在 <em>s1</em> 中具有相同的出现频率，当前窗口在 <em>s2</em> 中。当我们滑动窗口时，如果扣除最后一个元素并添加新元素导致任何字符的新频率匹配，我们将 <em>count</em> 递增1.如果不是，我们保持 <em>count</em> 完整。但是，如果添加频率相同的字符（添加和删除之前）相同的字符，现在会导致频率不匹配，这会通过递减相同的 <em>count</em> 变量来考虑。如果在移动窗口后，<em>count</em> 的计算结果为26，则表示所有字符的频率完全匹配。所以，我们立即返回一个True。</p><details>    <summary>使用数组</summary>    <figure class="highlight java"><figcaption><span>[solution6-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] s1map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] s2map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] == s2map[i])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s2.charAt(i + s1.length()) - <span class="string">&#x27;a&#x27;</span>, l = s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">26</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s2map[r]++;</span><br><span class="line">            <span class="keyword">if</span> (s2map[r] == s1map[r])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[r] == s1map[r] + <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">            s2map[l]--;</span><br><span class="line">            <span class="keyword">if</span> (s2map[l] == s1map[l])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[l] == s1map[l] - <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(l_1+(l_2-l_1))<em>。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(1)*。常数级的空间。</p></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
    <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="http://yoursite.com/2022/09/28/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/09/28/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2022-09-28T04:03:12.000Z</published>
    <updated>2022-09-28T03:51:15.233Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><span id="more"></span><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="fc6033f3-e9c6-41d7-b660-328fc288d2e2">3. 无重复字符的最长子串_2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><p>我一开始想到的是一个比较粗暴的方法，遍历字符串中的每一个位置，然后在该位置向两边扩展，直到遇到重复的字符，最后统计长度，但这种方法效率较低</p><details>    <summary>Java暴力解法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            int j = i ;</span><br><span class="line">            int k = i ;</span><br><span class="line">            while (j &gt; 0) &#123;</span><br><span class="line">                if (s.substring(j, k + 1).contains(s.substring(j-1,j))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (k &lt; s.length()-1) &#123;</span><br><span class="line">                if (s.substring(j, k+1).contains(s.substring(k + 1,k+2))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = Math.max(maxlen, k - j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++暴力解法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int lengthOfLongestSubstring(string s)&#123;</span><br><span class="line">        long len=s.size();</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">            int j=i, k=i;</span><br><span class="line">            //向左搜索</span><br><span class="line">            while (j&gt;0) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(j-1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //向右搜索</span><br><span class="line">            while (k&lt;len-1) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(k+1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=max(maxlen, k-j+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>时间复杂度：O(N^2)</p><p>空间复杂度：O(1)</p><h2 id="方法二：滑动窗口-1"><a href="#方法二：滑动窗口-1" class="headerlink" title="方法二：滑动窗口^1"></a>方法二：滑动窗口<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/">^1</a></h2><p><strong>思路和算法</strong></p><p>我们先用一个例子来想一想如何在较优的时间复杂度内通过本题。</p><p>我们不妨以示例一中的字符串 abcabcbb  为例，找出 <strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><ul><li>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</li><li>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb ；</li><li>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb ；</li><li>以 abc(a)bcbb  开始的最长字符串为 abc(abc)bb ；</li><li>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</li><li>以 abcab(c)bb  开始的最长字符串为abcab(cb)b ；</li><li>以 abcabc(b)b  开始的最长字符串为 abcabc(b)b ；</li><li>以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 。</li></ul><p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 <em>k</em> 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 <em>r_k</em>。那么当我们选择第 <em>k+1</em> 个字符作为起始位置时，首先从 <em>k+1</em> 到 <em>r_k</em> 的字符显然是不重复的，并且由于少了原本的第 <em>k</em> 个字符，我们可以尝试继续增大 <em>r_k</em>，直到右侧出现了重复字符为止。</p><p>这样以来，我们就可以使用「滑动窗口」来解决这个问题了：</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 <em>r_k</em>；</p></li><li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p><strong>判断重复字符</strong></p><p>在上面的流程中，我们还需要使用一种数据结构来判断 <strong>是否有重复的字符</strong>，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><p>至此，我们就完美解决了本题。</p><details>    <summary>滑动窗口C++</summary>    <figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Java</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>我的Java解法</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length() &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.charAt(right))) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">                maxlen = Math.max(maxlen, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(s.charAt(right));</span><br><span class="line">                maxlen = Math.max(maxlen, right - left + <span class="number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Python3</summary>    <figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口JavaScript</summary>    <figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="keyword">const</span> occ = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    <span class="keyword">let</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            occ.<span class="title function_">delete</span>(s.<span class="title function_">charAt</span>(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="title function_">has</span>(s.<span class="title function_">charAt</span>(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            occ.<span class="title function_">add</span>(s.<span class="title function_">charAt</span>(rk + <span class="number">1</span>));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*，其中 <em>N</em> 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p></li><li><p>空间复杂度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure><p>，其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Sigma</span><br></pre></td></tr></table></figure><p> 表示字符集（即字符串中可以出现的字符），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p> 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 <em>[0, 128)</em> 内的字符，即 </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|=128</span><br></pre></td></tr></table></figure><p>。我们需要用到哈希集合来存储出现过的字符，而字符最多有 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p>个，因此空间复杂度为 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
    <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>435. Non-overlapping Intervals无重叠区间</title>
    <link href="http://yoursite.com/2022/09/27/435.%20Non-overlapping%20Intervals%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2022/09/27/435.%20Non-overlapping%20Intervals%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</id>
    <published>2022-09-27T06:26:48.000Z</published>
    <updated>2022-09-27T06:10:31.382Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><span id="more"></span><p>[TOC]</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><pre><code>示例 1:输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。示例 2:输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。示例 3:输入: [ [1,2], [2,3] ]输出: 0</code></pre><p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode.cn/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/">^1</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>题目的要求等价于「选出最多数量的区间，使得它们互不重叠」。由于选出的区间互不重叠，因此我们可以将它们按照端点从小到大的顺序进行排序，并且无论我们按照左端点还是右端点进行排序，得到的结果都是唯一的。</p><p>这样一来，我们可以先将所有的 n 个区间按照左端点（或者右端点）从小到大进行排序，随后使用动态规划的方法求出区间数量的最大值。设排完序后这 n 个区间的左右端点分别为 l0,l1,…,ln-1 以及r0, r1,…,rn-1, 那么我们令 fi 表示「以区间i 为最后一个区间，可以选出的区间数量的最大值」，状态转移方程即为：</p><p>即我们枚举倒数第二个区间的编号 j，满足 j&lt;i，并且第 j 个区间必须要与第<br>i 个区间不重叠。由于我们已经按照左端点进行升序排序了，因此只要第<br>j 个区间的右端点 rj 没有越过第 i 个区间的左端点 li，即 rj&lt;&#x3D;li，那么第 j 个区间就与第 i 个区间不重叠。我们在所有满足要求的 j 中，选择 fj<br>  最大的那一个进行状态转移，如果找不到满足要求的区间，那么状态转移方程中 max 这一项就为 0，fi 就为 1。最终的答案即为所有 fi中的最大值。</p><p>由于方法一的时间复杂度较高，因此在下面的 Python 代码中，我们尽量使用列表推导优化常数，使得其可以在时间限制内通过所有测试数据。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * struct Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() : start(0), end(0) &#123;&#125;</span><br><span class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">/*</span><br><span class="line">    这道题给了我们一堆区间，让我们求需要至少移除多少个区间才能使剩下的区间没有重叠，</span><br><span class="line">    那么我们首先要给区间排序，根据每个区间的start来做升序排序，</span><br><span class="line">    然后我们开始要查找重叠区间，判断方法是看如果前一个区间的end大于后一个区间的start，那么一定是重复区间，</span><br><span class="line">    此时我们结果res自增1，我们需要删除一个，</span><br><span class="line">    那么此时我们究竟该删哪一个呢，为了保证我们总体去掉的区间数最小，我们去掉那个end值较大的区间，</span><br><span class="line">    而在代码中，我们并没有真正的删掉某一个区间，而是用一个变量last指向上一个需要比较的区间，</span><br><span class="line">    我们将last指向end值较小的那个区间；如果两个区间没有重叠，那么此时last指向当前区间，继续进行下一次遍历，参见代码如下：</span><br><span class="line">*/</span><br><span class="line">       int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">           if (intervals.empty()) &#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) &#123;</span><br><span class="line">               return u[0] &lt; v[0];</span><br><span class="line">           &#125;);</span><br><span class="line">   </span><br><span class="line">           int n = intervals.size();</span><br><span class="line">           vector&lt;int&gt; f(n, 1);</span><br><span class="line">           for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">               for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                   if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                       f[i] = max(f[i], f[j] + 1);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return n - *max_element(f.begin(), f.end());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">        if (intervals.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] interval1, int[] interval2) &#123;</span><br><span class="line">                return interval1[0] - interval2[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int n = intervals.length;</span><br><span class="line">        int[] f = new int[n];</span><br><span class="line">        Arrays.fill(f, 1);</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                    f[i] = Math.max(f[i], f[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - Arrays.stream(f).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:</span><br><span class="line">        if not intervals:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        intervals.sort()</span><br><span class="line">        n = len(intervals)</span><br><span class="line">        f = [1]</span><br><span class="line"></span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            f.append(max((f[j] for j in range(i) if intervals[j][1] &lt;= intervals[i][0]), default=0) + 1)</span><br><span class="line"></span><br><span class="line">        return n - max(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func eraseOverlapIntervals(intervals [][]int) int &#123;</span><br><span class="line">    n := len(intervals)</span><br><span class="line">    if n == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(intervals, func(i, j int) bool &#123; return intervals[i][0] &lt; intervals[j][0] &#125;)</span><br><span class="line">    dp := make([]int, n)</span><br><span class="line">    for i := range dp &#123;</span><br><span class="line">        dp[i] = 1</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 1; i &lt; n; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; i; j++ &#123;</span><br><span class="line">            if intervals[j][1] &lt;= intervals[i][0] &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j]+1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - max(dp...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a ...int) int &#123;</span><br><span class="line">    res := a[0]</span><br><span class="line">    for _, v := range a[1:] &#123;</span><br><span class="line">        if v &gt; res &#123;</span><br><span class="line">            res = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int cmp(int** a, int** b) &#123;</span><br><span class="line">    return (*a)[0] - (*b)[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) &#123;</span><br><span class="line">    if (intervalsSize == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(intervals, intervalsSize, sizeof(int*), cmp);</span><br><span class="line">    int f[intervalsSize];</span><br><span class="line">    for (int i = 0; i &lt; intervalsSize; i++) &#123;</span><br><span class="line">        f[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxn = 1;</span><br><span class="line">    for (int i = 1; i &lt; intervalsSize; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">            if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                f[i] = fmax(f[i], f[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn = fmax(maxn, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return intervalsSize - maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var eraseOverlapIntervals = function(intervals) &#123;</span><br><span class="line">    if (!intervals.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intervals.sort((a, b) =&gt; a[0] - b[0]);</span><br><span class="line">    const n = intervals.length;</span><br><span class="line">    const f = new Array(n).fill(1);</span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                f[i] = Math.max(f[i], f[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - Math.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^2)，其中 n 是区间的数量。我们需要 O(nlogn) 的时间对所有的区间按照左端点进行升序排序，并且需要 O(n^2) 的时间进行动态规划。由于前者在渐进意义下小于后者，因此总时间复杂度为<br>O(n^2)。<br>注意到方法一本质上是一个「最长上升子序列」问题，因此我们可以将时间复杂度优化至 O(nlogn)，具体可以参考「300. 最长递增子序列的官方题解」<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">^2</a>。<br>空间复杂度：O(n)，即为存储所有状态 fi 需要的空间。</p><h1 id="方法二：贪心"><a href="#方法二：贪心" class="headerlink" title="方法二：贪心"></a>方法二：贪心</h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>我们不妨想一想应该选择哪一个区间作为首个区间。</p><p>假设在某一种最优的选择方法中，[lk,rk] 是首个（即最左侧的）区间，那么它的左侧没有其它区间，右侧有若干个不重叠的区间。设想一下，如果此时存在一个区间 [lj,rj]，使得 rj&lt;rk，即区间 j 的右端点在区间 k 的左侧，那么我们将区间 k 替换为区间 j，其与剩余右侧被选择的区间仍然是不重叠的。而当我们将区间 k 替换为区间 j 后，就得到了另一种最优的选择方法。</p><p>我们可以不断地寻找右端点在首个区间右端点左侧的新区间，将首个区间替换成该区间。那么当我们无法替换时，首个区间就是所有可以选择的区间中右端点最小的那个区间。因此我们将所有区间按照右端点从小到大进行排序，那么排完序之后的首个区间，就是我们选择的首个区间。</p><p>如果有多个区间的右端点都同样最小怎么办？由于我们选择的是首个区间，因此在左侧不会有其它的区间，那么左端点在何处是不重要的，我们只要任意选择一个右端点最小的区间即可。</p><p>当确定了首个区间之后，所有与首个区间不重合的区间就组成了一个规模更小的子问题。由于我们已经在初始时将所有区间按照右端点排好序了，因此对于这个子问题，我们无需再次进行排序，只要找出其中与首个区间不重合并且右端点最小的区间即可。用相同的方法，我们可以依次确定后续的所有区间。</p><p>在实际的代码编写中，我们对按照右端点排好序的区间进行遍历，并且实时维护上一个选择区间的右端点 right。如果当前遍历到的区间 [li,ri] 与上一个区间不重合，即<br>li≥right，那么我们就可以贪心地选择这个区间，并将 right 更新为ri。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) &#123;</span><br><span class="line">            return u[1] &lt; v[1];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int n = intervals.size();</span><br><span class="line">        int right = intervals[0][1];</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                right = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">        if (intervals.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] interval1, int[] interval2) &#123;</span><br><span class="line">                return interval1[1] - interval2[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int n = intervals.length;</span><br><span class="line">        int right = intervals[0][1];</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                right = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:</span><br><span class="line">        if not intervals:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        intervals.sort(key=lambda x: x[1])</span><br><span class="line">        n = len(intervals)</span><br><span class="line">        right = intervals[0][1]</span><br><span class="line">        ans = 1</span><br><span class="line"></span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            if intervals[i][0] &gt;= right:</span><br><span class="line">                ans += 1</span><br><span class="line">                right = intervals[i][1]</span><br><span class="line">        </span><br><span class="line">        return n - ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func eraseOverlapIntervals(intervals [][]int) int &#123;</span><br><span class="line">    n := len(intervals)</span><br><span class="line">    if n == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(intervals, func(i, j int) bool &#123; return intervals[i][1] &lt; intervals[j][1] &#125;)</span><br><span class="line">    ans, right := 1, intervals[0][1]</span><br><span class="line">    for _, p := range intervals[1:] &#123;</span><br><span class="line">        if p[0] &gt;= right &#123;</span><br><span class="line">            ans++</span><br><span class="line">            right = p[1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int cmp(int** a, int** b) &#123;</span><br><span class="line">    return (*a)[1] - (*b)[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) &#123;</span><br><span class="line">    if (intervalsSize == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(intervals, intervalsSize, sizeof(int*), cmp);</span><br><span class="line"></span><br><span class="line">    int right = intervals[0][1];</span><br><span class="line">    int ans = 1;</span><br><span class="line">    for (int i = 1; i &lt; intervalsSize; ++i) &#123;</span><br><span class="line">        if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            right = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervalsSize - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var eraseOverlapIntervals = function(intervals) &#123;</span><br><span class="line">    if (!intervals.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intervals.sort((a, b) =&gt; a[1] - b[1]);</span><br><span class="line"></span><br><span class="line">    const n = intervals.length;</span><br><span class="line">    let right = intervals[0][1];</span><br><span class="line">    let ans = 1;</span><br><span class="line">    for (let i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            right = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(nlogn)，其中 n 是区间的数量。我们需要 O(nlogn) 的时间对所有的区间按照右端点进行升序排序，并且需要 O(n) 的时间进行遍历。由于前者在渐进意义下大于后者，因此总时间复杂度为 O(nlogn)。</p><p>空间复杂度：<br>O(logn)，即为排序需要使用的栈空间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
    <category term="Sorting" scheme="http://yoursite.com/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>199.二叉树的右视图Binary Tree Right Side View</title>
    <link href="http://yoursite.com/2022/09/26/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEBinary%20Tree%20Right%20Side%20View/"/>
    <id>http://yoursite.com/2022/09/26/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEBinary%20Tree%20Right%20Side%20View/</id>
    <published>2022-09-26T11:14:32.000Z</published>
    <updated>2022-09-26T02:56:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><span id="more"></span><p>[TOC]</p><p>示例1:</p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><p>示例 2:</p><pre><code>输入: [1,null,3]输出: [1,3]</code></pre><p>示例 3:</p><pre><code>输入: []输出: []</code></pre><p>提示:</p><pre><code>二叉树的节点个数的范围是 [0,100]-100 &lt;= Node.val &lt;= 100 </code></pre><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>使用队列层次遍历二叉树，存储每层最右边的结点</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>执行广度优先搜索，左结点排在右结点之前，这样，我们对每一层都从左到右访问。因此，只保留每个深度最后访问的结点，我们就可以在遍历完整棵树后得到每个深度最右的结点。除了将栈改成队列，并去除了 rightmost_value_at_depth 之前的检查外，算法没有别的改动。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        if(root) q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode *cur=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(i==len-1)res.push_back(cur-&gt;val);</span><br><span class="line">                if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; depthQueue = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        depthQueue.add(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.remove();</span><br><span class="line">            int depth = depthQueue.remove();</span><br><span class="line"></span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line"></span><br><span class="line">                nodeQueue.add(node.left);</span><br><span class="line">                nodeQueue.add(node.right);</span><br><span class="line">                depthQueue.add(depth + 1);</span><br><span class="line">                depthQueue.add(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>我的Java写法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            Deque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">            deque.offer(root);</span><br><span class="line">            while (!deque.isEmpty()) &#123;</span><br><span class="line">                int n = deque.size();</span><br><span class="line">                for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                    TreeNode temp = deque.poll();</span><br><span class="line">                    if (temp.left != null) &#123;</span><br><span class="line">                        deque.offer(temp.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (temp.right != null) &#123;</span><br><span class="line">                        deque.offer(temp.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (i == n - 1) &#123;</span><br><span class="line">                        list.add(temp.val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rightSideView(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值</span><br><span class="line">        max_depth = -1</span><br><span class="line"></span><br><span class="line">        queue = deque([(root, 0)])</span><br><span class="line">        while queue:</span><br><span class="line">            node, depth = queue.popleft()</span><br><span class="line"></span><br><span class="line">            if node is not None:</span><br><span class="line">                # 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth)</span><br><span class="line"></span><br><span class="line">                # 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmost_value_at_depth[depth] = node.val</span><br><span class="line"></span><br><span class="line">                queue.append((node.left, depth + 1))</span><br><span class="line">                queue.append((node.right, depth + 1))</span><br><span class="line"></span><br><span class="line">        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度 :<br>O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。<br>空间复杂度 :<br>O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为O(n)。</p><p>注释</p><p>deque 数据类型来自于collections 模块，支持从头和尾部的常数时间 append&#x2F;pop 操作。若使用 Python 的 list，通过 list.pop(0) 去除头部会消耗 O(n) 的时间。</p><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。</p><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>这样一来，我们可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组</p><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rightSideView(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值</span><br><span class="line">        max_depth = -1</span><br><span class="line"></span><br><span class="line">        stack = [(root, 0)]</span><br><span class="line">        while stack:</span><br><span class="line">            node, depth = stack.pop()</span><br><span class="line"></span><br><span class="line">            if node is not None:</span><br><span class="line">                # 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth)</span><br><span class="line"></span><br><span class="line">                # 如果不存在对应深度的节点我们才插入</span><br><span class="line">                rightmost_value_at_depth.setdefault(depth, node.val)</span><br><span class="line"></span><br><span class="line">                stack.append((node.left, depth + 1))</span><br><span class="line">                stack.append((node.right, depth + 1))</span><br><span class="line"></span><br><span class="line">        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; nodeStack = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; depthStack = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            int depth = depthStack.pop();</span><br><span class="line"></span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 如果不存在对应深度的节点我们才插入</span><br><span class="line">                if (!rightmostValueAtDepth.containsKey(depth)) &#123;</span><br><span class="line">                    rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        stack&lt;int&gt; depthStack;</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeStack.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeStack.top();nodeStack.pop();</span><br><span class="line">            int depth = depthStack.top();depthStack.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 如果不存在对应深度的节点我们才插入</span><br><span class="line">                if (rightmostValueAtDepth.find(depth) == rightmostValueAtDepth.end()) &#123;</span><br><span class="line">                    rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node -&gt; left);</span><br><span class="line">                nodeStack.push(node -&gt; right);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度 : </p><p>O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。</p><p>空间复杂度 : </p><p>O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>637. 二叉树的层平均值</title>
    <link href="http://yoursite.com/2022/09/26/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <id>http://yoursite.com/2022/09/26/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</id>
    <published>2022-09-26T07:24:32.000Z</published>
    <updated>2022-09-26T07:32:55.175Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10^-5 以内的答案可以被接受。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</code></pre><p>示例 2:</p><pre><code>输入：root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000]</code></pre><p>提示：</p><pre><code>树中节点数量在 [1, 104] 范围内-231 &lt;= Node.val &lt;= 231 - 1</code></pre><p>深度&#x2F;广度优先搜索<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/solution/er-cha-shu-de-ceng-ping-jun-zhi-by-leetcode-soluti/">^1</a>,同102，103，199和515几题比较接近</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10^-5 以内的答案可以被接受。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>515. 在每个树行中找最大值</title>
    <link href="http://yoursite.com/2022/09/26/515.%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2022/09/26/515.%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2022-09-26T07:14:32.000Z</published>
    <updated>2022-09-26T07:25:57.537Z</updated>
    
    <content type="html"><![CDATA[<p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><span id="more"></span><p>[TOC]</p><p>示例1：</p><pre><code>输入: root = [1,3,2,5,3,null,9]输出: [1,3,9]</code></pre><p>示例2：</p><pre><code>输入: root = [1,2,3]输出: [1,3]</code></pre><p>提示：</p><pre><code>二叉树的节点个数的范围是 [0,104]-231 &lt;= Node.val &lt;= 231 - 1</code></pre><h1 id="方法一：深度优先搜索-1"><a href="#方法一：深度优先搜索-1" class="headerlink" title="方法一：深度优先搜索^1"></a>方法一：深度优先搜索<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/solution/zai-mei-ge-shu-xing-zhong-zhao-zui-da-zh-6xbs/">^1</a></h1><p>思路与算法</p><p>我们用树的「先序遍历」来进行「深度优先搜索」处理，并用 curHeight 来标记遍历到的当前节点的高度。当遍历到 curHeight 高度的节点就判断是否更新该层节点的最大值。</p><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestValues(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">        ans = []</span><br><span class="line">        def dfs(node: TreeNode, curHeight: int) -&gt; None:</span><br><span class="line">            if node is None:</span><br><span class="line">                return</span><br><span class="line">            if curHeight == len(ans):</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            else:</span><br><span class="line">                ans[curHeight] = max(ans[curHeight], node.val)</span><br><span class="line">            dfs(node.left, curHeight + 1)</span><br><span class="line">            dfs(node.right, curHeight + 1)</span><br><span class="line">        dfs(root, 0)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; res, TreeNode* root, int curHeight) &#123;</span><br><span class="line">        if (curHeight == res.size()) &#123;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res[curHeight] = max(res[curHeight], root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;left) &#123;</span><br><span class="line">            dfs(res, root-&gt;left, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right) &#123;</span><br><span class="line">            dfs(res, root-&gt;right, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        dfs(res, root, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(res, root, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(List&lt;Integer&gt; res, TreeNode root, int curHeight) &#123;</span><br><span class="line">        if (curHeight == res.size()) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.set(curHeight, Math.max(res.get(curHeight), root.val));</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.left != null) &#123;</span><br><span class="line">            dfs(res, root.left, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.right != null) &#123;</span><br><span class="line">            dfs(res, root.right, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func largestValues(root *TreeNode) (ans []int) &#123;</span><br><span class="line">    var dfs func(*TreeNode, int)</span><br><span class="line">    dfs = func(node *TreeNode, curHeight int) &#123;</span><br><span class="line">        if node == nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if curHeight == len(ans) &#123;</span><br><span class="line">            ans = append(ans, node.Val)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans[curHeight] = max(ans[curHeight], node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.Left, curHeight+1)</span><br><span class="line">        dfs(node.Right, curHeight+1)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, 0)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if b &gt; a &#123;</span><br><span class="line">        return b</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度：</p><p>O(n)，其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p><p>空间复杂度：</p><p>O(height)。其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p><h1 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h1><p>思路与算法</p><p>我们也可以用「广度优先搜索」的方法来解决这道题目。「广度优先搜索」中的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于「广度优先搜索」的每次只从队列里拿出一个节点，我们把当前队列中的全部节点拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是下一层的所有节点，即我们是一层一层地进行拓展，然后每一层我们用 maxVal 来标记该层节点的最大值。当该层全部节点都处理完后，<br>maxVal 就是该层全部节点中的最大值。</p><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestValues(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        ans = []</span><br><span class="line">        q = [root]</span><br><span class="line">        while q:</span><br><span class="line">            maxVal = -inf</span><br><span class="line">            tmp = q</span><br><span class="line">            q = []</span><br><span class="line">            for node in tmp:</span><br><span class="line">                maxVal = max(maxVal, node.val)</span><br><span class="line">                if node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">            ans.append(maxVal)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int len = q.size();</span><br><span class="line">            int maxVal = INT_MIN;</span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                len--;</span><br><span class="line">                auto t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                maxVal = max(maxVal, t-&gt;val);</span><br><span class="line">                if (t-&gt;left) &#123;</span><br><span class="line">                    q.push(t-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (t-&gt;right) &#123;</span><br><span class="line">                    q.push(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(maxVal);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int len = queue.size();</span><br><span class="line">            int maxVal = Integer.MIN_VALUE;</span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                len--;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                maxVal = Math.max(maxVal, t.val);</span><br><span class="line">                if (t.left != null) &#123;</span><br><span class="line">                    queue.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (t.right != null) &#123;</span><br><span class="line">                    queue.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(maxVal);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func largestValues(root *TreeNode) (ans []int) &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    for len(q) &gt; 0 &#123;</span><br><span class="line">        maxVal := math.MinInt32</span><br><span class="line">        tmp := q</span><br><span class="line">        q = nil</span><br><span class="line">        for _, node := range tmp &#123;</span><br><span class="line">            maxVal = max(maxVal, node.Val)</span><br><span class="line">            if node.Left != nil &#123;</span><br><span class="line">                q = append(q, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            if node.Right != nil &#123;</span><br><span class="line">                q = append(q, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, maxVal)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if b &gt; a &#123;</span><br><span class="line">        return b</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度： O(n)，其中 n 为二叉树节点个数，每一个节点仅会进出队列一次。<br>空间复杂度： O(n)，存储二叉树节点的空间开销。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>103. 二叉树的锯齿形层序遍历</title>
    <link href="http://yoursite.com/2022/09/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/09/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-09-23T07:39:12.000Z</published>
    <updated>2022-09-23T07:39:56.144Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]]</code></pre><p>示例 2：</p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>[TOC]</p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：广度优先遍历"><a href="#方法一：广度优先遍历" class="headerlink" title="方法一：广度优先遍历"></a>方法一：广度优先遍历</h2><p>此题是「102. 二叉树的层序遍历」的变种，最后输出的要求有所变化，要求我们按层数的奇偶来决定每一层的输出顺序。规定二叉树的根节点为第<br>0<br>0 层，如果当前层数是偶数，从左至右输出当前层的节点值，否则，从右至左输出当前层的节点值。</p><p>我们依然可以沿用第 102 题的思想，修改广度优先搜索，对树进行逐层遍历，用队列维护当前层的所有元素，当队列不为空的时候，求得当前队列的长度 size，每次从队列中取出 size 个元素进行拓展，然后进行下一次迭代。</p><p>为了满足题目要求的返回值为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用「双端队列」的数据结构来维护当前层节点值输出的顺序。</p><p>双端队列是一个可以在队列任意一端插入元素的队列。在广度优先搜索遍历当前层节点拓展下一层节点的时候我们仍然从左往右按顺序拓展，但是对当前层节点的存储我们维护一个变量 isOrderLeft 记录是从左至右还是从右至左的：</p><p>如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。<br>如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。<br>当遍历结束的时候我们就得到了答案数组。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        bool isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            deque&lt;int&gt; levelList;</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                auto node = nodeQueue.front();</span><br><span class="line">                nodeQueue.pop();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.push_back(node-&gt;val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.push_front(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;left) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(vector&lt;int&gt;&#123;levelList.begin(), levelList.end()&#125;);</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        boolean isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; levelList = new LinkedList&lt;Integer&gt;();</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode curNode = nodeQueue.poll();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.offerLast(curNode.val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.offerFirst(curNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.left != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.right != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(new LinkedList&lt;Integer&gt;(levelList));</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var zigzagLevelOrder = function(root) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ans = [];</span><br><span class="line">    const nodeQueue = [root];</span><br><span class="line"></span><br><span class="line">    let isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">    while (nodeQueue.length) &#123;</span><br><span class="line">        let levelList = [];</span><br><span class="line">        const size = nodeQueue.length;</span><br><span class="line">        for (let i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">            const node = nodeQueue.shift();</span><br><span class="line">            if (isOrderLeft) &#123;</span><br><span class="line">                levelList.push(node.val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                levelList.unshift(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left !== null) &#123;</span><br><span class="line">                nodeQueue.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right !== null) &#123;</span><br><span class="line">                nodeQueue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">        ans.push(levelList);</span><br><span class="line">        isOrderLeft = !isOrderLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func zigzagLevelOrder(root *TreeNode) (ans [][]int) &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    for level := 0; len(queue) &gt; 0; level++ &#123;</span><br><span class="line">        vals := []int&#123;&#125;</span><br><span class="line">        q := queue</span><br><span class="line">        queue = nil</span><br><span class="line">        for _, node := range q &#123;</span><br><span class="line">            vals = append(vals, node.Val)</span><br><span class="line">            if node.Left != nil &#123;</span><br><span class="line">                queue = append(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            if node.Right != nil &#123;</span><br><span class="line">                queue = append(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 本质上和层序遍历一样，我们只需要把奇数层的元素翻转即可</span><br><span class="line">        if level%2 == 1 &#123;</span><br><span class="line">            for i, n := 0, len(vals); i &lt; n/2; i++ &#123;</span><br><span class="line">                vals[i], vals[n-1-i] = vals[n-1-i], vals[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, vals)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#define N 2000</span><br><span class="line"></span><br><span class="line">int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int** ans = malloc(sizeof(int*) * N);</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * N);</span><br><span class="line">    struct TreeNode* nodeQueue[N];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    nodeQueue[right++] = root;</span><br><span class="line">    bool isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int levelList[N * 2];</span><br><span class="line">        int front = N, rear = N;</span><br><span class="line">        int size = right - left;</span><br><span class="line">        for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">            struct TreeNode* node = nodeQueue[left++];</span><br><span class="line">            if (isOrderLeft) &#123;</span><br><span class="line">                levelList[rear++] = node-&gt;val;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                levelList[--front] = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;left) &#123;</span><br><span class="line">                nodeQueue[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right) &#123;</span><br><span class="line">                nodeQueue[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * (rear - front));</span><br><span class="line">        for (int i = 0; i &lt; rear - front; i++) &#123;</span><br><span class="line">            tmp[i] = levelList[i + front];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[*returnSize] = tmp;</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = rear - front;</span><br><span class="line">        (*returnSize)++;</span><br><span class="line">        isOrderLeft = !isOrderLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(N)，其中 N 为二叉树的节点数。每个节点会且仅会被遍历一次。<br>空间复杂度：<br>O(N)。我们需要维护存储节点的队列和存储节点值的双端队列，空间复杂度为 O(N)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>1162. 地图分析</title>
    <link href="http://yoursite.com/2022/09/22/1162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2022/09/22/1162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</id>
    <published>2022-09-22T06:00:12.000Z</published>
    <updated>2022-09-22T09:21:31.231Z</updated>
    
    <content type="html"><![CDATA[<p>你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。</p><p>请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。</p><span id="more"></span><p>[TOC]</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>示例 1：</p><pre><code>输入：grid = [[1,0,1],[0,0,0],[1,0,1]]输出：2解释： 海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。</code></pre><p>示例 2：</p><pre><code>输入：grid = [[1,0,0],[0,0,0],[0,0,0]]输出：4解释： 海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。</code></pre><p>提示：</p><pre><code>n == grid.lengthn == grid[i].length1 &lt;= n &lt;= 100grid[i][j] 不是 0 就是 1</code></pre><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>「离陆地区域最远」要求海洋区域距离它最近的陆地区域的曼哈顿距离是最大的。所以我们需要找一个海洋区域，满足它到陆地的最小距离是最大的。</p><h1 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑最朴素的方法，即求出每一个海洋区域（grid[i][j] &#x3D;&#x3D; 0 的区域）的「最近陆地区域」，然后记录下它们的距离，然后在这些距离里面取一个最大值。<br>对于一个给定的区域 (x,y) ，求它的「最近陆地区域」，可以使用广度优先搜索思想。我们把每个区域的坐标作以及这个区域与 (x,y) 的曼哈顿距离为搜索状态，即 Coordinate 结构体的 x、y 和 step 属性。findNearestLand 方法实现了广度优先搜索的过程，我们用一个 vis[u][v] 数组记录 (u,v) 区域是否被访问过，在拓展新状态的时候按照如下四个方向：<br>(x−1,y)<br>(x,y+1)<br>(x+1,y)<br>(x,y−1)<br>在这里我们可以把四个方向定义为常量增量数组 dx 和 dy。</p><p>思考：我们需不需要搜索到队列为空才停止 BFS ？ 答案是不需要。当我们搜索到一个新入队的区域它的 grid 值为 1，即这个区域是陆地区域的时候我们就可以停止搜索，因为 BFS 能保证当前的这个区域是最近的陆地区域（BFS 的性质决定了这里求出来的一定是最短路）。</p><p>findNearestLand如果我们找不不到任何一个点是陆地区域则返回 -1。最终我们把 ans 的初始值置为 -1，然后与所有的 BFS 结果取最大。</p><p>代码实现如下。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y, step;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int n, m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    bool vis[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    int findNearestLand(int x, int y) &#123;</span><br><span class="line">        memset(vis, 0, sizeof vis);</span><br><span class="line">        queue &lt;Coordinate&gt; q;</span><br><span class="line">        q.push(&#123;x, y, 0&#125;);</span><br><span class="line">        vis[x][y] = 1;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= m - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!vis[nx][ny]) &#123;</span><br><span class="line">                    q.push(&#123;nx, ny, f.step + 1&#125;);</span><br><span class="line">                    vis[nx][ny] = 1;</span><br><span class="line">                    if (a[nx][ny]) &#123;</span><br><span class="line">                        return f.step + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        this-&gt;m = grid.at(0).size();</span><br><span class="line">        a = grid;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, findNearestLand(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">    static int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    int n;</span><br><span class="line">    int[][] grid;</span><br><span class="line"></span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        this.n = grid.length;</span><br><span class="line">        this.grid = grid;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, findNearestLand(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int findNearestLand(int x, int y) &#123;</span><br><span class="line">        boolean[][] vis = new boolean[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;x, y, 0&#125;);</span><br><span class="line">        vis[x][y] = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!vis[nx][ny]) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;nx, ny, f[2] + 1&#125;);</span><br><span class="line">                    vis[nx][ny] = true;</span><br><span class="line">                    if (grid[nx][ny] == 1) &#123;</span><br><span class="line">                        return f[2] + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>我的另一种解法Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int max = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    max = Math.max(findNearestLand(i, j,grid), max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findNearestLand(int x, int y, int[][] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] vis=new int[n][n];</span><br><span class="line">        int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        int dis = 0;</span><br><span class="line">        Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;x, y&#125;);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            vis[x][y] = 2;</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                int[] index = queue.poll();</span><br><span class="line">                int prevX = index[0];</span><br><span class="line">                int prevY = index[1];</span><br><span class="line">                for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                    int nx = prevX + dirs[j][0];</span><br><span class="line">                    int ny = prevY + dirs[j][1];</span><br><span class="line">                    if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; vis[nx][ny] != 2) &#123;</span><br><span class="line">                        if (grid[nx][ny] == 1) &#123;</span><br><span class="line">                            dis++;</span><br><span class="line">                            return dis;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            vis[nx][ny] = 2;</span><br><span class="line">                            queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dis++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>## 复杂度分析<p>时间复杂度：该算法最多执行 n^2次 BFS，即我们考虑最坏情况所有的区域都是海洋，那么每一个区域都会进行 BFS。对于每一次 BFS，最坏的情况是找不到陆地区域，我们只能遍历完剩下的 n^2−1 个海洋区域，由于 vis 数组确保每个区域只被访问一次，所以单次 BFS 的渐进时间复杂度是 O(n^2)，程序的总的渐进时间复杂度是 O(n^4)。<br>空间复杂度：该算法使用了 vis 数组，渐进空间复杂度为 O(n^2)。</p><h1 id="方法二：多源最短路"><a href="#方法二：多源最短路" class="headerlink" title="方法二：多源最短路"></a>方法二：多源最短路</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实在方法一中我们已经发现我们 BFS 的过程是求最短路的过程，但是这里不是求某一个海洋区域到陆地区域的最短路，而是求所有的海洋区域到陆地区域这个「点集」的最短路。显然这不是一个「单源」最短路问题（SSSP）。在我们学习过的最短路算法中，求解 SSSP 问题的方法有 Dijkstra 算法和 SPFA算法，而求解任意两点之间的最短路一般使用 Floyd 算法。那我们在这里就应该使用 Floyd 算法吗？要考虑这个问题，我们需要分析一下这里使用 Floyd 算法的时间复杂度。我们知道在网格图中求最短路，每个区域（格子）相当于图中的顶点，而每个格子和上下左右四个格子的相邻关系相当于边，我们记顶点的个数为 V，Floyd 算法的时间复杂度为 O(V^3)，而这里 V&#x3D;n^2 ，所以<br>O(V^3)&#x3D;O(n^6)，显然是不现实的。</p><p>考虑 SSSP 是求一个源点到一个点集中所有点的最短路，而这个问题的本质是求某个点集到另一个点集中所有点的最短路，即「多源最短路」，我们只需要对 Dijkstra 算法或者 SPFA 算法稍作修改。这里以 Dijkstra 算法为例，我们知道堆优化的 Dijkstra 算法实际上是 BFS 的一个变形，把 BFS 中的队列变成了优先队列，在拓展新状态的时候加入了松弛操作。Dijkstra 的堆优化版本第一步是源点入队，我们只需要把它改成源点集合中的所有的点入队就可以实现求「多源最短路」。</p><p>思考：为什么？ 因为我们这样做相当于建立了一个超级源点 S，这个点与源点集中的<br>s0, s1,  ⋯s∣V∣<br>都有边，并且权都为 0。这样求源点集到目标点集的最短路就变成了求超级源点 S 到它们的最短路，于是又转化成了 SSSP 问题。</p><p>思考：海洋区域和陆地区域，应该哪一个作为源点集？ 也许你分析出「我们需要找一个海洋区域，满足它到陆地的最小距离是最大」会把海洋区域作为源点集。我们可以考虑后续的实现，我们知道 Dijkstra 中一个 d 数组用来维护当前源点集到其他点的最短路，而对于源点集中的任意一个点 s，d[s_x][s_y] &#x3D; 0，这很好理解，源点到源点的最短路就是 0。如果我们把海洋区域作为源点集、陆地区域作为目标点集，假设 t 是目标点集中的一个点，算法执行结束后 d[t_x][t_y] 就是海洋区域中的点到 t 的最短距离，但是我们却不知道哪些 t 是海洋区域的这些点的「最近陆地区域」，我们也不知道每个 s 距离它的「最近陆地区域」的曼哈顿距离。考虑我们把陆地区域作为源点集、海洋区域作为目标点集，目标点集中的点 t 对应的 d[t_x][t_y] 就是海洋区域 t 对应的距离它的「最近陆地区域」的曼哈顿距离，正是我们需要的，所以应该把陆地区域作为源点集。</p><h3 id="Dijkstra-版"><a href="#Dijkstra-版" class="headerlink" title="Dijkstra 版"></a>Dijkstra 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Status &#123;</span><br><span class="line">        int v, x, y;</span><br><span class="line">        bool operator &lt; (const Status &amp;rhs) const &#123;</span><br><span class="line">            return v &gt; rhs.v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;0, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.top(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (f.v + 1 &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f.v + 1;</span><br><span class="line">                    q.push(&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] status1, int[] status2) &#123;</span><br><span class="line">                return status1[0] - status2[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;0, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[1] + dx[i], ny = f[2] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (f[0] + 1 &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f[0] + 1;</span><br><span class="line">                    queue.offer(new int[]&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="多源-BFS-版"><a href="#多源-BFS-版" class="headerlink" title="多源 BFS 版"></a>多源 BFS 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    queue &lt;Coordinate&gt; q;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) continue;</span><br><span class="line">                if (d[nx][ny] &gt; d[f.x][f.y] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + 1;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f[0]][f[1]] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f[0]][f[1]] + 1;</span><br><span class="line">                    queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="SPFA-版"><a href="#SPFA-版" class="headerlink" title="SPFA 版"></a>SPFA 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    queue &lt;Coordinate&gt; q;</span><br><span class="line">    bool inq[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                    inq[i][j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop(); inq[f.x][f.y] = 0;</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f.x][f.y] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + 1;</span><br><span class="line">                    if (!inq[nx][ny]) &#123;</span><br><span class="line">                        q.push(&#123;nx, ny&#125;);</span><br><span class="line">                        inq[nx][ny] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        boolean[][] inq = new boolean[n][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    inq[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            inq[f[0]][f[1]] = false;</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f[0]][f[1]] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f[0]][f[1]] + 1;</span><br><span class="line">                    if (!inq[nx][ny]) &#123;</span><br><span class="line">                        queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                        inq[nx][ny] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：考虑这里的「多源最短路」的本质还是「单源最短路」，因此就是 Dijkstra 算法堆优化版本的渐进时间复杂度 O(ElogV)，这里 E 为边的个数，约等于<br>4n^2&#x2F;2 ，V 为顶点个数，约等于 n^2 ，所以这里的渐进时间复杂度为<br>O(n^2 logn^2 )&#x3D;O(n^2 logn)；在多源 BFS 当中，由于每个点只能被访问一次，渐进时间复杂度为<br>O(V+E)&#x3D;O(n^2)；SPFA 算法的理论渐进上界是 O(VE)&#x3D;O(n^2)，但是由于这里的边权都为 1，于是它退化成了 BFS，渐进时间复杂度 O(n^2)。<br>空间复杂度：该算法使用了 d 数组，渐进空间复杂度为 O(n^2)</p><h1 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>考虑优化方法二中的「把陆地区域作为源点集、海洋区域作为目标点集，求最短路」的过程。我们知道对于每个海洋区域 (x,y)，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x,y) 为 (x,y) 距离最近的陆地区域的曼哈顿距离，则我们可以推出这样的转移方程：</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>f(x,y)&#x3D;{ 0, (x,y)island<br>        min{f(x−1,y),f(x,y−1)}+1,(x,y)isocean</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>f(x,y)&#x3D;{ 0,(x,y)island<br>        min{f(x+1,y),f(x,y+1)}+1, (x,y)isocean</p><p>我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 INF，做完两个阶段的动态规划后，我们在所有的不为零的 f[i][j] 中比一个最大值即可，如果最终比较出的最大值为 INF，就返回 -1。</p><p>思考：如果用 f(x,y) 记录左上方的 DP 结果，g(x,y) 记录右下方的DP结果可行吗？ 答案是不可行。因为考虑距离点 (x,y) 最近的点可能既不来自左上方，也不来自右下方，比如它来自右上方，这个时候，第二阶段我们就需要用到第一阶段的计算结果。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    </span><br><span class="line">    int f[MAX_N][MAX_N];</span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;&amp; a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (a[i][j] ? 0 : INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i - 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = n - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i + 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i][j + 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans == INF) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] f = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = grid[i][j] == 1 ? 0 : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i - 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = n - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i + 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i][j + 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans == INF) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：从代码不难看出，这个算法的过程就是四个双重 for 循环，渐进时间复杂度为 O(n^2)。<br>空间复杂度：该算法使用了 f 数组，渐进空间复杂度为 O(n^2)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。&lt;/p&gt;
&lt;p&gt;请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://yoursite.com/2022/09/22/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/09/22/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-09-22T03:39:12.000Z</published>
    <updated>2022-09-22T05:55:54.531Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p>示例 2：</p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：[]</code></pre><p>提示：</p><pre><code>树中节点数目在范围 [0, 2000] 内-1000 &lt;= Node.val &lt;= 1000</code></pre><p>[TOC]</p><h1 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路^1"></a>解题思路<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/">^1</a></h1><p>本文将会讲解为什么这道题适合用广度优先搜索（BFS），以及 BFS 适用于什么样的场景。</p><p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p><p>如果我们使用 DFS&#x2F;BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。</p><p>本文包括以下内容：</p><p>DFS 与 BFS 的特点比较<br>BFS 的适用场景<br>如何用 BFS 进行层序遍历<br>如何用 BFS 求解最短路径问题</p><h1 id="DFS-与-BFS"><a href="#DFS-与-BFS" class="headerlink" title="DFS 与 BFS"></a>DFS 与 BFS</h1><p>让我们先看看在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。</p><p>DFS 遍历使用递归：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void bfs(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()</span><br><span class="line">        if (node.left != null) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right != null) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。<p>虽然 DFS 与 BFS 都是将二叉树的所有结点遍历了一遍，但它们遍历结点的顺序不同。</p><p>这个遍历顺序也是 BFS 能够用来解「层序遍历」、「最短路径」问题的根本原因。下面，我们结合几道例题来讲讲 BFS 是如何求解层序遍历和最短路径问题的。</p><p>BFS 的应用一：层序遍历</p><p>BFS 的层序遍历应用就是本题了：</p><p>LeetCode 102. Binary Tree Level Order Traversal 二叉树的层序遍历（Medium）</p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：<br>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。<br>那么，怎么给 BFS 遍历的结果分层呢？我们首先来观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：</p><p>截取 BFS 遍历过程中的某个时刻：</p><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的n 个结点。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 二叉树的层序遍历</span><br><span class="line">void bfs(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            // 变量 i 无实际意义，只是为了循环 n 次</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。<p>最终我们得到的题解代码为：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="BFS-的应用二：最短路径"><a href="#BFS-的应用二：最短路径" class="headerlink" title="BFS 的应用二：最短路径"></a>BFS 的应用二：最短路径</h1><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><h2 id="小贴士："><a href="#小贴士：" class="headerlink" title="小贴士："></a>小贴士：</h2><p>很多同学一看到「最短路径」，就条件反射地想到「Dijkstra 算法」。为什么 BFS 遍历也能找到最短路径呢？</p><p>这是因为，Dijkstra 算法解决的是带权最短路径问题，而我们这里关注的是无权最短路径问题。也可以看成每条边的权重都是 1。这样的最短路径问题，用 BFS 求解就行了。</p><p>在面试中，你可能更希望写 BFS 而不是 Dijkstra。毕竟，敢保证自己能写对 Dijkstra 算法的人不多。</p><p>最短路径问题属于图算法。由于图的表示和描述比较复杂，本文用比较简单的网格结构代替。网格结构是一种特殊的图，它的表示和遍历都比较简单，适合作为练习题。在 LeetCode 中，最短路径问题也以网格结构为主。</p><h1 id="最短路径例题讲解"><a href="#最短路径例题讲解" class="headerlink" title="最短路径例题讲解"></a>最短路径例题讲解</h1><p>LeetCode 1162. As Far from Land as Possible 离开陆地的最远距离（Medium）<a href="https://leetcode.cn/problems/as-far-from-land-as-possible/">^2</a></p><p>你现在手里有一份大小为 n×n 的地图网格 grid，上面的每个单元格都标记为 0 或者 1，其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」。(x0 ,y0 ) 和 (x1,y1)这两个区域之间的距离是 ∣x0−x1∣+∣y0−y1∣ 。</p><p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p><p>这道题就是一个在网格结构中求最短路径的问题。同时，它也是一个「岛屿问题」，即用网格中的 1 和 0 表示陆地和海洋，模拟出若干个岛屿。</p><p>在上一篇文章中，我们介绍了网格结构的基本概念，以及网格结构中的 DFS 遍历。其中一些概念和技巧也可以用在 BFS 遍历中：</p><p>格子 (r, c) 的相邻四个格子为：(r-1, c)、(r+1, c)、(r, c-1) 和 (r, c+1)；<br>使用函数 inArea 判断当前格子的坐标是否在网格范围内；<br>将遍历过的格子标记为 2，避免重复遍历。<br>对于网格结构的性质、网格结构的 DFS 遍历技巧不是很了解的同学，可以复习一下上一篇文章：LeetCode 例题精讲 | 12 岛屿问题：网格结构中的 DFS。</p><p>上一篇文章讲过了网格结构 DFS 遍历，这篇文章正好讲解一下网格结构的 BFS 遍历。要解最短路径问题，我们首先要写出层序遍历的代码，仿照上面的二叉树层序遍历代码，类似地可以写出网格层序遍历：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 网格结构的层序遍历</span><br><span class="line">// 从格子 (i, j) 开始遍历</span><br><span class="line">void bfs(int[][] grid, int i, int j) &#123;</span><br><span class="line">    Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(new int[]&#123;r, c&#125;);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            int[] node = queue.poll();</span><br><span class="line">            int r = node[0];</span><br><span class="line">            int c = node[1];</span><br><span class="line">            if (r-1 &gt;= 0 &amp;&amp; grid[r-1][c] == 0) &#123;</span><br><span class="line">                grid[r-1][c] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r-1, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (r+1 &lt; N &amp;&amp; grid[r+1][c] == 0) &#123;</span><br><span class="line">                grid[r+1][c] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r+1, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (c-1 &gt;= 0 &amp;&amp; grid[r][c-1] == 0) &#123;</span><br><span class="line">                grid[r][c-1] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r, c-1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (c+1 &lt; N &amp;&amp; grid[r][c+1] == 0) &#123;</span><br><span class="line">                grid[r][c+1] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r, c+1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>以上的层序遍历代码有几个注意点：</p><p>队列中的元素类型是 int[] 数组，每个数组的长度为 2，包含格子的行坐标和列坐标。<br>为了避免重复遍历，这里使用到了和 DFS 遍历一样的技巧：把已遍历的格子标记为 2。注意：我们在将格子放入队列之前就将其标记为 2。想一想，这是为什么？<br>在将格子放入队列之前就检查其坐标是否在网格范围内，避免将「不存在」的格子放入队列。<br>这段网格遍历代码还有一些可以优化的地方。由于一个格子有四个相邻的格子，代码中判断了四遍格子坐标的合法性，代码稍微有点啰嗦。我们可以用一个 moves 数组存储相邻格子的四个方向：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">int[][] moves = &#123;</span><br><span class="line">    &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>然后把四个 if 判断变成一个循环：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int[][] move : moves) &#123;</span><br><span class="line">    int r2 = r + move[0];</span><br><span class="line">    int c2 = c + move[1];</span><br><span class="line">    if (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == 0) &#123;</span><br><span class="line">        grid[r2][c2] = 2;</span><br><span class="line">        queue.add(new int[]&#123;r2, c2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>写好了层序遍历的代码，接下来我们看看如何来解决本题中的最短路径问题。</p><p>这道题要找的是距离陆地最远的海洋格子。假设网格中只有一个陆地格子，我们可以从这个陆地格子出发做层序遍历，直到所有格子都遍历完。最终遍历了几层，海洋格子的最远距离就是几。<br>那么有多个陆地格子的时候怎么办呢？一种方法是将每个陆地格子都作为起点做一次层序遍历，但是这样的时间开销太大。</p><p>BFS 完全可以以多个格子同时作为起点。我们可以把所有的陆地格子同时放入初始队列，然后开始层序遍历，这样遍历的效果如下图所示：<br>这种遍历方法实际上叫做「多源 BFS」。多源 BFS 的定义不是今天讨论的重点，你只需要记住多源 BFS 很方便，只需要把多个源点同时放入初始队列即可。</p><p>需要注意的是，虽然上面的图示用 1、2、3、4 表示层序遍历的层数，但是在代码中，我们不需要给每个遍历到的格子标记层数，只需要用一个 distance 变量记录当前的遍历的层数（也就是到陆地格子的距离）即可。</p><p>最终，我们得到的题解代码为：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public int maxDistance(int[][] grid) &#123;</span><br><span class="line">    int N = grid.length;</span><br><span class="line"></span><br><span class="line">    Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    // 将所有的陆地格子加入队列</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                queue.add(new int[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果地图上只有陆地或者海洋，返回 -1</span><br><span class="line">    if (queue.isEmpty() || queue.size() == N * N) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[][] moves = &#123;</span><br><span class="line">        &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int distance = -1; // 记录当前遍历的层数（距离）</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        distance++;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            int[] node = queue.poll();</span><br><span class="line">            int r = node[0];</span><br><span class="line">            int c = node[1];</span><br><span class="line">            for (int[] move : moves) &#123;</span><br><span class="line">                int r2 = r + move[0];</span><br><span class="line">                int c2 = c + move[1];</span><br><span class="line">                if (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == 0) &#123;</span><br><span class="line">                    grid[r2][c2] = 2;</span><br><span class="line">                    queue.add(new int[]&#123;r2, c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断坐标 (r, c) 是否在网格中</span><br><span class="line">boolean inArea(int[][] grid, int r, int c) &#123;</span><br><span class="line">    return 0 &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到，「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。</p><p>BFS 遍历是一类很值得反复体会和练习的题目。一方面，BFS 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 BFS 遍历。</p><p>本文讲解的只是两道非常典型的例题。LeetCode 中还有许多层序遍历和最短路径的题目</p><p>层序遍历的一些变种题目：</p><p>LeetCode 103. Binary Tree Zigzag Level Order Traversal 之字形层序遍历<br>LeetCode 199. Binary Tree Right Side View 找每一层的最右结点<br>LeetCode 515. Find Largest Value in Each Tree Row 计算每一层的最大值<br>LeetCode 637. Average of Levels in Binary Tree 计算每一层的平均值</p><p>对于最短路径问题，还有两道题目也是求网格结构中的最短路径，和我们讲解的距离岛屿的最远距离非常类似：</p><p>LeetCode 542. 01 Matrix<br>LeetCode 994. Rotting Oranges<br>还有一道在真正的图结构中求最短路径的问题：</p><p>LeetCode 310. Minimum Height Trees<br>经过了本文的讲解，相信解决这些题目也不是难事。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="http://yoursite.com/2022/09/21/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2022/09/21/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-09-21T03:15:12.000Z</published>
    <updated>2022-09-25T13:06:27.605Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><span id="more"></span><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：true</code></pre><p>示例 2：</p><pre><code>输入：root = [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：true</code></pre><p>提示：</p><pre><code>树中的节点数在范围 [0, 5000] 内-104 &lt;= Node.val &lt;= 104</code></pre><p>[TOC]</p><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode.cn/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/">^1</a></h1><p>这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。</p><h1 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h1><p>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：</p><p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过<br>1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.max(height(root.left), height(root.right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><pre><code>class Solution &#123;    public boolean isBalanced(TreeNode root) &#123;        if (root == null) &#123;            return true;        &#125; else &#123;            return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);        &#125;    &#125;    public int height(TreeNode root) &#123;        if (root == null) &#123;            return 0;        &#125; else &#123;            return Math.max(height(root.left), height(root.right)) + 1;        &#125;    &#125;&#125;</code></pre></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isBalanced(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        def height(root: TreeNode) -&gt; int:</span><br><span class="line">            if not root:</span><br><span class="line">                return 0</span><br><span class="line">            return max(height(root.left), height(root.right)) + 1</span><br><span class="line"></span><br><span class="line">        if not root:</span><br><span class="line">            return True</span><br><span class="line">        return abs(height(root.left) - height(root.right)) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><pre><code>int height(struct TreeNode* root) &#123;    if (root == NULL) &#123;        return 0;    &#125; else &#123;        return fmax(height(root-&gt;left), height(root-&gt;right)) + 1;    &#125;&#125;bool isBalanced(struct TreeNode* root) &#123;    if (root == NULL) &#123;        return true;    &#125; else &#123;        return fabs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);    &#125;&#125;</code></pre></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func isBalanced(root *TreeNode) bool &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return abs(height(root.Left) - height(root.Right)) &lt;= 1 &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func height(root *TreeNode) int &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    return max(height(root.Left), height(root.Right)) + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func abs(x int) int &#123;</span><br><span class="line">    if x &lt; 0 &#123;</span><br><span class="line">        return -1 * x</span><br><span class="line">    &#125;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。<br>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。<br>对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足<br>O(h)&#x3D;O(logn)，因为 d≤h，所以总时间复杂度为O(nlogn)。对于最坏的情况，二叉树形成链式结构，高度为O(n)，此时总时间复杂度为</p><p>空间复杂度：<br>O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p><h1 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h1><p>方法一由于是自顶向下递归，因此对于同一个节点，函数<br>height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数<br>height 只会被调用一次。</p><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return height(root) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = height(root.left);</span><br><span class="line">        int rightHeight = height(root.right);</span><br><span class="line">        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.max(leftHeight, rightHeight) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><pre><code>class Solution &#123;public:    int height(TreeNode* root) &#123;        if (root == NULL) &#123;            return 0;        &#125;        int leftHeight = height(root-&gt;left);        int rightHeight = height(root-&gt;right);        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) &#123;            return -1;        &#125; else &#123;            return max(leftHeight, rightHeight) + 1;        &#125;    &#125;    bool isBalanced(TreeNode* root) &#123;        return height(root) &gt;= 0;    &#125;&#125;;</code></pre></details><details>    <summary>Python</summary><pre><code>class Solution &#123;public:    int height(TreeNode* root) &#123;        if (root == NULL) &#123;            return 0;        &#125;        int leftHeight = height(root-&gt;left);        int rightHeight = height(root-&gt;right);        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) &#123;            return -1;        &#125; else &#123;            return max(leftHeight, rightHeight) + 1;        &#125;    &#125;    bool isBalanced(TreeNode* root) &#123;        return height(root) &gt;= 0;    &#125;&#125;;</code></pre></details><details>    <summary>C</summary><pre><code>int height(struct TreeNode* root) &#123;    if (root == NULL) &#123;        return 0;    &#125;    int leftHeight = height(root-&gt;left);    int rightHeight = height(root-&gt;right);    if (leftHeight == -1 || rightHeight == -1 || fabs(leftHeight - rightHeight) &gt; 1) &#123;        return -1;    &#125; else &#123;        return fmax(leftHeight, rightHeight) + 1;    &#125;&#125;bool isBalanced(struct TreeNode* root) &#123;    return height(root) &gt;= 0;&#125;</code></pre></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func isBalanced(root *TreeNode) bool &#123;</span><br><span class="line">    return height(root) &gt;= 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func height(root *TreeNode) int &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    leftHeight := height(root.Left)</span><br><span class="line">    rightHeight := height(root.Right)</span><br><span class="line">    if leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1 &#123;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">    return max(leftHeight, rightHeight) + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func abs(x int) int &#123;</span><br><span class="line">    if x &lt; 0 &#123;</span><br><span class="line">        return -1 * x</span><br><span class="line">    &#125;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中<br>n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是<br>O(n)。</p><p>空间复杂度：<br>O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
  </entry>
  
</feed>
