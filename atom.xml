<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-10-10T09:03:02.786Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>25. K 个一组翻转链表</title>
    <link href="http://yoursite.com/2022/10/10/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/10/10/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-10-10T09:12:12.000Z</published>
    <updated>2022-10-10T09:03:02.786Z</updated>
    
    <content type="html"><![CDATA[<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5]</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5]</code></pre><p>提示：</p><pre><code>链表中的节点数目为 n1 &lt;= k &lt;= n &lt;= 50000 &lt;= Node.val &lt;= 1000</code></pre><p>进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？</p><p>从字节跳动的高频题过来的，<a href="https://codetop.cc/home%EF%BC%8C">https://codetop.cc/home，</a> 这道题出了很多次</p><h1 id="方法一：参考92-反转链表-1"><a href="#方法一：参考92-反转链表-1" class="headerlink" title="方法一：参考92.反转链表^1"></a>方法一：参考92.反转链表<a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">^1</a></h1><p>这道题和92.反转链表<a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">^1</a>方法二的思路非常接近，没看官方题解的前提下做出来了。就是遇到几次空指针的错误。</p><p>就是先统计一下链表长度，然后以类似冒泡的方法在每K个节点内部做反转。</p><details>    <summary>我的解法Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode prev = dummyHead;</span><br><span class="line">        ListNode p1 = dummyHead;</span><br><span class="line">        int length = 0;</span><br><span class="line">        while (p1.next != null) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; length / k; i++) &#123;</span><br><span class="line">            ListNode cur = prev.next;</span><br><span class="line">            for (int j = 1; j &lt; k; j++) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = next.next;</span><br><span class="line">                next.next = prev.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="方法二：图解模拟-2"><a href="#方法二：图解模拟-2" class="headerlink" title="方法二：图解模拟^2"></a>方法二：图解模拟<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/">^2</a></h1><p>一图胜千言，根据图片看代码，马上就懂了</p><p>步骤分解:</p><pre><code>链表分区为已翻转部分+待翻转部分+未翻转部分每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可</code></pre><p>时间复杂度为 O(n∗K) 最好的情况为 O(n) 最差的情况未 O(n^2)<br>空间复杂度为 O(1) 除了几个必须的节点指针外，我们并没有占用其他空间</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">    ListNode dummy = new ListNode(0);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    ListNode end = dummy;</span><br><span class="line"></span><br><span class="line">    while (end.next != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;</span><br><span class="line">        if (end == null) break;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        end.next = null;</span><br><span class="line">        pre.next = reverse(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        pre = start;</span><br><span class="line"></span><br><span class="line">        end = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ListNode reverse(ListNode head) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    while (curr != null) &#123;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="方法三：模拟-3"><a href="#方法三：模拟-3" class="headerlink" title="方法三：模拟^3"></a>方法三：模拟<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/">^3</a></h1><p>思路与算法</p><p>本题的目标非常清晰易懂，不涉及复杂的算法，但是实现过程中需要考虑的细节比较多，容易写出冗长的代码。主要考查面试者设计的能力。</p><p>我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。</p><p>接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206. 反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。如下图所示：</p><p>因此，在翻转子链表的时候，我们不仅需要子链表头节点 head，还需要有 head 的上一个节点 pre，以便翻转完后把子链表再接回 pre。</p><p>但是对于第一个子链表，它的头节点 head 前面是没有节点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点，把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个节点，我们就可以避开链表头部的边界条件。这么做还有一个好处，下面我们会看到。</p><p>反复移动指针 head 与 pre，对 head 所指向的子链表进行翻转，直到结尾，我们就得到了答案。下面我们该返回函数值了。</p><p>有的同学可能发现这又是一件麻烦事：链表翻转之后，链表的头节点发生了变化，那么应该返回哪个节点呢？照理来说，前 k 个节点翻转之后，链表的头节点应该是第 k 个节点。那么要在遍历过程中记录第 k 个节点吗？但是如果链表里面没有 k 个节点，答案又还是原来的头节点。我们又多了一大堆循环和判断要写，太崩溃了！</p><p>等等！还记得我们创建了节点 pre 吗？这个节点一开始被连接到了头节点的前面，而无论之后链表有没有翻转，它的 next 指针都会指向正确的头节点。那么我们只要返回它的下一个节点就好了。至此，问题解决。</p><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 翻转一个子链表，并且返回新的头与尾</span><br><span class="line">    def reverse(self, head: ListNode, tail: ListNode):</span><br><span class="line">        prev = tail.next</span><br><span class="line">        p = head</span><br><span class="line">        while prev != tail:</span><br><span class="line">            nex = p.next</span><br><span class="line">            p.next = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        return tail, head</span><br><span class="line"></span><br><span class="line">    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        hair = ListNode(0)</span><br><span class="line">        hair.next = head</span><br><span class="line">        pre = hair</span><br><span class="line"></span><br><span class="line">        while head:</span><br><span class="line">            tail = pre</span><br><span class="line">            # 查看剩余部分长度是否大于等于 k</span><br><span class="line">            for i in range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                if not tail:</span><br><span class="line">                    return hair.next</span><br><span class="line">            nex = tail.next</span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            # 把子链表重新接回原链表</span><br><span class="line">            pre.next = head</span><br><span class="line">            tail.next = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.next</span><br><span class="line">        </span><br><span class="line">        return hair.next</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 翻转一个子链表，并且返回新的头与尾</span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; myReverse(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode* hair = new ListNode(0);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line"></span><br><span class="line">        while (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            // 查看剩余部分长度是否大于等于 k</span><br><span class="line">            for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                if (!tail) &#123;</span><br><span class="line">                    return hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            // 这里是 C++17 的写法，也可以写成</span><br><span class="line">            // pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span><br><span class="line">            // head = result.first;</span><br><span class="line">            // tail = result.second;</span><br><span class="line">            tie(head, tail) = myReverse(head, tail);</span><br><span class="line">            // 把子链表重新接回原链表</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">        ListNode hair = new ListNode(0);</span><br><span class="line">        hair.next = head;</span><br><span class="line">        ListNode pre = hair;</span><br><span class="line"></span><br><span class="line">        while (head != null) &#123;</span><br><span class="line">            ListNode tail = pre;</span><br><span class="line">            // 查看剩余部分长度是否大于等于 k</span><br><span class="line">            for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                if (tail == null) &#123;</span><br><span class="line">                    return hair.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode nex = tail.next;</span><br><span class="line">            ListNode[] reverse = myReverse(head, tail);</span><br><span class="line">            head = reverse[0];</span><br><span class="line">            tail = reverse[1];</span><br><span class="line">            // 把子链表重新接回原链表</span><br><span class="line">            pre.next = head;</span><br><span class="line">            tail.next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return hair.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode[] myReverse(ListNode head, ListNode tail) &#123;</span><br><span class="line">        ListNode prev = tail.next;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        while (prev != tail) &#123;</span><br><span class="line">            ListNode nex = p.next;</span><br><span class="line">            p.next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        return new ListNode[]&#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const myReverse = (head, tail) =&gt; &#123;</span><br><span class="line">    let prev = tail.next;</span><br><span class="line">    let p = head;</span><br><span class="line">    while (prev !== tail) &#123;</span><br><span class="line">        const nex = p.next;</span><br><span class="line">        p.next = prev;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    return [tail, head];</span><br><span class="line">&#125;</span><br><span class="line">var reverseKGroup = function(head, k) &#123;</span><br><span class="line">    const hair = new ListNode(0);</span><br><span class="line">    hair.next = head;</span><br><span class="line">    let pre = hair;</span><br><span class="line"></span><br><span class="line">    while (head) &#123;</span><br><span class="line">        let tail = pre;</span><br><span class="line">        // 查看剩余部分长度是否大于等于 k</span><br><span class="line">        for (let i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            if (!tail) &#123;</span><br><span class="line">                return hair.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const nex = tail.next;</span><br><span class="line">        [head, tail] = myReverse(head, tail);</span><br><span class="line">        // 把子链表重新接回原链表</span><br><span class="line">        pre.next = head;</span><br><span class="line">        tail.next = nex;</span><br><span class="line">        pre = tail;</span><br><span class="line">        head = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return hair.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func reverseKGroup(head *ListNode, k int) *ListNode &#123;</span><br><span class="line">    hair := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    pre := hair</span><br><span class="line"></span><br><span class="line">    for head != nil &#123;</span><br><span class="line">        tail := pre</span><br><span class="line">        for i := 0; i &lt; k; i++ &#123;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">            if tail == nil &#123;</span><br><span class="line">                return hair.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nex := tail.Next</span><br><span class="line">        head, tail = myReverse(head, tail)</span><br><span class="line">        pre.Next = head</span><br><span class="line">        tail.Next = nex</span><br><span class="line">        pre = tail</span><br><span class="line">        head = tail.Next</span><br><span class="line">    &#125;</span><br><span class="line">    return hair.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func myReverse(head, tail *ListNode) (*ListNode, *ListNode) &#123;</span><br><span class="line">    prev := tail.Next</span><br><span class="line">    p := head</span><br><span class="line">    for prev != tail &#123;</span><br><span class="line">        nex := p.Next</span><br><span class="line">        p.Next = prev</span><br><span class="line">        prev = p</span><br><span class="line">        p = nex</span><br><span class="line">    &#125;</span><br><span class="line">    return tail, head</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
    <category term="LinkList" scheme="http://yoursite.com/tags/LinkList/"/>
    
  </entry>
  
  <entry>
    <title>92. 反转链表II</title>
    <link href="http://yoursite.com/2022/10/10/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yoursite.com/2022/10/10/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</id>
    <published>2022-10-10T07:15:12.000Z</published>
    <updated>2022-10-10T07:08:47.246Z</updated>
    
    <content type="html"><![CDATA[<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><span id="more"></span><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p>示例1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><p>示例 2：</p><pre><code>输入：head = [5], left = 1, right = 1输出：[5]</code></pre><p>提示：</p><pre><code>链表中节点数目为 n1 &lt;= n &lt;= 500-500 &lt;= Node.val &lt;= 5001 &lt;= left &lt;= right &lt;= n</code></pre><p>进阶： 你可以使用一趟扫描完成反转吗？</p><p>[TOC]</p><h1 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一: 递归"></a>方法一: 递归</h1><p>这种方法实际上是交换节点的值而非反转链表的指针</p><p><strong>直觉</strong></p><p>使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。</p><p><a href="https://pic.leetcode-cn.com/7f6ec0687455cfecce2019fcb560d7066d7e7dfedd46922d3cc96bcbff3c1eb5-image.png">image.png</a></p><p>反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 <em>m</em> 个结点，另一个指向第 <em>n</em> 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。</p><blockquote><p>然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 <strong>模拟</strong> 向后指针。递归中的回溯可以帮助我们模拟一个指针从第<em>n</em>个结点向中心移动的移动过程。</p></blockquote><p><strong>算法</strong></p><ol><li>我们定义一个递归函数用于反转给定链表的一部分。</li><li>将函数记为 <code>recurse</code>。该函数使用三个参数: <code>m</code> 为反转的起点, <code>n</code> 为反转的终点, 以及从第 <em>n</em> 个结点开始，随着递归回溯过程向后移动的指针 <code>right</code>。不清楚的话，可以参考后文的示意图。</li><li>此外，我们还有一个指针 <code>left</code>，它从第 <code>m</code> 个结点开始向前移动。在 <code>Python</code> 中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数 <code>recurse</code> 的一个变量。</li><li>在递归调用中，给定 <code>m</code>，<code>n</code>，和 <code>right</code>, 首先判断 <code>n = 1</code>。 若判断为真, 则结束。</li><li>于是，当 <code>n</code> 的值达到 1 时，我们便<strong>回溯</strong>。这时，<code>right</code> 指针在我们要反转的子链表结尾，<code>left</code> 到达了字列表的开头。于是，我们置换数据，并将 <code>left</code> 指针前移：<code>left = left.next</code>。我们需要此变化在回溯过程中保持。</li><li>自此，每当我们回溯时，<code>right</code> 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。</li><li>当 <code>right == left</code> 或者 <code>right.next == left</code> 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。</li></ol><p>下面是一系列整个算法的示意图，希望能够帮助你理解清楚。</p><p><img src="http://pic.leetcode-cn.com/1adc7164bea5cd650af1545682900c792bd37a82df607aeb4f87a233d3eb69cf-image.png" alt="image.png"></p><p>这是递归过程的第一步。给定所用链表，<code>left</code> 和 <code>right</code> 指针从链表的 <code>head</code> 开始。第一步是以更新过的 <code>m</code> 和 <code>n</code> 进行递归调用，换而言之，它们的值各自减 1。此外，<code>left</code> 和 <code>right</code> 指针向前移动一位。</p><p><a href="https://pic.leetcode-cn.com/162f18666a30ffd98e185da1311f2daa48b087b03d3a9eefeeb9541eafbcd013-image.png">image.png</a></p><p>接下来的两步展示了 <code>left</code> 和 <code>right</code> 指针在链表中的移动。注意到在第二步之后，<code>left</code> 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 <code>right</code> 指针继续移动，直到抵达结点 <code>6</code>。</p><p><a href="https://pic.leetcode-cn.com/4213450e7d9466ddf22f289d5e753df47a94a9a87789312a02de2979ed161718-image.png">image.png</a></p><p>如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 <code>left</code> 和 <code>right</code> 结点的数据。</p><p><a href="https://pic.leetcode-cn.com/36b2ed0c1859c5574a17597070797d8f26b77a9c13a0c3462ea150b1058fbbce-image.png">image.png</a></p><p>如你所见，在第三步（回溯）之后，<code>right</code> 指针 <strong>穿过了</strong> <code>left</code> 指针，此时已经完成了要求部分链表的反转。结果是 <code>[7 → 9 → 8 → 1 → 10 → 2 → 6]</code>。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。</p><details>    <summary>递归Java</summary>    <figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object level variables since we need the changes</span></span><br><span class="line">    <span class="comment">// to persist across recursive calls and Java is pass by value.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stop;</span><br><span class="line">    <span class="keyword">private</span> ListNode left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recurseAndReverse</span><span class="params">(ListNode right, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case. Don&#x27;t proceed any further</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">        right = right.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">        <span class="comment">// from where the reversal is to start.</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recurse with m and n reduced.</span></span><br><span class="line">        <span class="built_in">this</span>.recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case both the pointers cross each other or become equal, we</span></span><br><span class="line">        <span class="comment">// stop i.e. don&#x27;t swap data any further. We are done reversing at this</span></span><br><span class="line">        <span class="comment">// point.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left == right || right.next == <span class="built_in">this</span>.left) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stop = <span class="literal">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Until the boolean stop is false, swap data between the two pointers</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.stop) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.left.val;</span><br><span class="line">            <span class="built_in">this</span>.left.val = right.val;</span><br><span class="line">            right.val = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move left one step to the right.</span></span><br><span class="line">            <span class="comment">// The right pointer moves one step back via backtracking.</span></span><br><span class="line">            <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = head;</span><br><span class="line">        <span class="built_in">this</span>.stop = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.recurseAndReverse(head, m, n);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Python</summary>    <figure class="highlight python"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        left, right = head, head</span><br><span class="line">        stop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recurseAndReverse</span>(<span class="params">right, m, n</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> left, stop</span><br><span class="line"></span><br><span class="line">            <span class="comment"># base case. Don&#x27;t proceed any further</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">            <span class="comment"># from where the reversal is to start.</span></span><br><span class="line">            <span class="keyword">if</span> m &gt; <span class="number">1</span>:</span><br><span class="line">                left = left.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Recurse with m and n reduced.</span></span><br><span class="line">            recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># In case both the pointers cross each other or become equal, we</span></span><br><span class="line">            <span class="comment"># stop i.e. don&#x27;t swap data any further. We are done reversing at this</span></span><br><span class="line">            <span class="comment"># point.</span></span><br><span class="line">            <span class="keyword">if</span> left == right <span class="keyword">or</span> right.<span class="built_in">next</span> == left:</span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Until the boolean stop is false, swap data between the two pointers     </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stop:</span><br><span class="line">                left.val, right.val = right.val, left.val</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Move left one step to the right.</span></span><br><span class="line">                <span class="comment"># The right pointer moves one step back via backtracking.</span></span><br><span class="line">                left = left.<span class="built_in">next</span>           </span><br><span class="line"></span><br><span class="line">        recurseAndReverse(right, m, n)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: *O(N)*。对每个结点最多处理两次。递归过程</li><li>回溯</li><li>在回溯过程中，我们只交换了一半的结点，但总复杂度是 *O(N)*。</li><li>空间复杂度: 最坏情况下为 *O(N)*。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。<br/><br/></li></ul><hr><h1 id="方法二-迭代链接反转"><a href="#方法二-迭代链接反转" class="headerlink" title="方法二: 迭代链接反转"></a>方法二: 迭代链接反转</h1><p>我一开始想到的就是通过迭代方法来反转，但是在处理反转后调整成环的情况时翻车了，想了半天，还是参照下面图例中的方法比较直观。</p><p><strong>直觉</strong></p><p>在上个方法中，我们研究了一种反转给定链表部分的算法，该算法不改变给定链表的内在结构，只是修改了对于结点的值。 然而，有时可能无法修改结点的数据值。这时，我们就需要改变结点的链接来完成反转。</p><p>从位置 <code>m</code> 到位置 <code>n</code> 的全部结点，我们需要反转每个结点的 <code>next</code> 指针。下面来看看具体的算法。</p><p><strong>算法</strong></p><p>在看具体算法之前，有必要先弄清楚链接反转的原理以及需要哪些指针。举例而言，有一个三个不同结点组成的链表 <code>A → B → C</code>，需要反转结点中的链接成为 <code>A ← B ← C</code>。</p><p>假设我们有两个指针，一个指向结点 <code>A</code>，一个指向结点 <code>B</code>。 分别记为 <code>prev</code> 和 <code>cur</code>。则可以用这两个指针简单地实现 <code>A 和 B</code> 之间的链接反转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.next = prev</span><br></pre></td></tr></table></figure><p>这样做唯一的问题是，没有办法继续下去，换而言之，这样做之后就无法再访问到结点 <code>C</code>。因此，我们需要引入第三个指针，用于帮助反转过程的进行。因此，我们不采用上面的反转方法，而是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">third = cur.next</span><br><span class="line">cur.next = prev</span><br><span class="line">prev = cur</span><br><span class="line">cur = third</span><br></pre></td></tr></table></figure><p> <strong>迭代</strong> 地进行上述过程，即可完成问题的要求。下面来看看算法的步骤。</p><ol><li>如上所述，我们需要两个指针 <code>prev</code> 和 <code>cur</code>。</li><li><code>prev</code> 指针初始化为 <code>None</code>，<code>cur</code> 指针初始化为链表的 <code>head</code>。</li><li>一步步地向前推进 <code>cur</code> 指针，<code>prev</code> 指针跟随其后。</li><li>如此推进两个指针，直到 <code>cur</code> 指针到达从链表头起的第 <em>m</em> 个结点。这就是我们反转链表的起始位置。</li><li>注意我们要引入两个额外指针，分别称为 <code>tail</code> 和 <code>con</code>。<code>tail</code> 指针指向从链表头起的第<em>m</em>个结点，此结点是反转后链表的尾部，故称为 <code>tail</code>。<code>con</code> 指针指向第 <em>m</em> 个结点的前一个结点，此结点是新链表的头部。下图可以帮助你更好的理解这两个指针。</li></ol><p><a href="https://pic.leetcode-cn.com/bf38eaeb92184fbfb55bd76336c7f746b6f01b3c83bd921268afe84a3c3cf183-image.png">image.png</a></p><ol start="6"><li><code>tail</code> 和 <code>con</code> 指针在算法开始时被初始化，在算法最后被调用，用于完成链表反转。</li><li>如前文所解释的那样，抵达第 <em>m</em> 个结点后，在用到上述两个指针前，先迭代地反转链接。不断迭代，直到完成指向第 <em>n</em> 个结点的链接。此时，<code>prev</code> 指针会指向第 <em>n</em> 个结点。</li><li>我们使用 <code>con</code> 指针来连接 <code>prev</code> 指针，这是因为 <code>prev</code> 指针当前指向的结点(第 <em>n</em> 个结点)会代替第 <em>m</em> 个结点的位置。 类似地，我们利用 <code>tail</code> 指针来连接 <code>prev</code> 指针之后的结点（第 <em>n+1</em> 个结点）。</li></ol><p>为了便于理清每个指针的用法，我们来看一个算法运行的实例。给定一个链表 <code>7 → 9 → 2 → 10 → 1 → 8 → 6</code>，我们需要反转从第 3 个结点到第 6 个结点的子链表。</p><p><a href="https://pic.leetcode-cn.com/08d4eb39be0db6ded442a208399b5778bbab1cf75c26bc5b3d93128b7c224cb4-image.png">image.png</a></p><p>从上图可以看到迭代法的前几步。第一步展示了两个指针的初始化，第三步展示了链表反转过程的初始位置。</p><p><a href="https://pic.leetcode-cn.com/77af1e2ca8bd5f9ccc89802094ce07e2505c6b4483ccd6887f2762a6e67310e1-image.png">image.png</a></p><p>上图详细显示了链接反转的过程以及反转两个结点的链接后如何向前移动。如下图所示，本步骤将执行多次。</p><p><a href="https://pic.leetcode-cn.com/f634c434bcc5092d84b3125a4cd7c723aa3ddd53dcfb9ec3077423cbff1d2f85-image.png">image.png</a></p><p><a href="https://pic.leetcode-cn.com/b11861e6d3a86cdec19152d442dd243aaf0fb6c914787e7cf60990f2ecf0d558-image.png">image.png</a></p><p>如上图所示, 两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 <code>tail</code> 和 <code>con</code> 指针完成链接调整的过程。</p><p><a href="https://pic.leetcode-cn.com/968684e83b4cbc4b4db6f80e3bda03748729af672e702a8d3473b24cd04a7092-image.png">image.png</a></p><details>    <summary>迭代链接反转Java</summary><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty list</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment">// in the list.</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The two pointers that will fix the final connections.</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">con</span> <span class="operator">=</span> prev, tail = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">third</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            third = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = third;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            con.next = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代链接反转Python</summary>    <figure class="highlight python"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Empty list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment"># in the list.</span></span><br><span class="line">        cur, prev = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            m, n = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The two pointers that will fix the final connections.</span></span><br><span class="line">        tail, con = cur, prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            third = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = third</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> con:</span><br><span class="line">            con.<span class="built_in">next</span> = prev</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = prev</span><br><span class="line">        tail.<span class="built_in">next</span> = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: *O(N)*。考虑包含 <em>N</em> 个结点的链表。对每个节点最多会处理</li><li>（第 <em>n</em> 个结点之后的结点不处理）。</li><li>空间复杂度: *O(1)*。我们仅仅在原有链表的基础上调整了一些指针，只使用了 <em>O(1)</em> 的额外存储空间来获得结果。<br /></li></ul><h1 id="方法三：一次遍历「穿针引线」反转链表（头插法）-1"><a href="#方法三：一次遍历「穿针引线」反转链表（头插法）-1" class="headerlink" title="方法三：一次遍历「穿针引线」反转链表（头插法）^1"></a>方法三：一次遍历「穿针引线」反转链表（头插法）<a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">^1</a></h1><p>链接中方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为<br>O(N)，但遍历了链表2 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。</p><p>我们依然以方法一的示例为例进行说明。</p><p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。</p><p>下面我们具体解释如何实现。使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：</p><pre><code>curr：指向待反转区域的第一个节点 left；next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</code></pre><p>第 1 步，我们使用 ①、②、③ 标注「穿针引线」的步骤。</p><p>操作步骤：</p><pre><code>先将 curr 的下一个节点记录为 next；执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；执行操作 ③：把 pre 的下一个节点指向 next。</code></pre><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *reverseBetween(ListNode *head, int left, int right) &#123;</span><br><span class="line">        // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">        ListNode *dummyNode = new ListNode(-1);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseBetween(ListNode head, int left, int right) &#123;</span><br><span class="line">        // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">        ListNode dummyNode = new ListNode(-1);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        ListNode pre = dummyNode;</span><br><span class="line">        for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = pre.next;</span><br><span class="line">        ListNode next;</span><br><span class="line">        for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            next.next = pre.next;</span><br><span class="line">            pre.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseBetween(self, head: ListNode, left: int, right: int) -&gt; ListNode:</span><br><span class="line">        # 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">        dummy_node = ListNode(-1)</span><br><span class="line">        dummy_node.next = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        for _ in range(left - 1):</span><br><span class="line">            pre = pre.next</span><br><span class="line"></span><br><span class="line">        cur = pre.next</span><br><span class="line">        for _ in range(right - left):</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = next.next</span><br><span class="line">            next.next = pre.next</span><br><span class="line">            pre.next = next</span><br><span class="line">        return dummy_node.next</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func reverseBetween(head *ListNode, left, right int) *ListNode &#123;</span><br><span class="line">    // 设置 dummyNode 是这一类问题的一般做法</span><br><span class="line">    dummyNode := &amp;ListNode&#123;Val: -1&#125;</span><br><span class="line">    dummyNode.Next = head</span><br><span class="line">    pre := dummyNode</span><br><span class="line">    for i := 0; i &lt; left-1; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line">    cur := pre.Next</span><br><span class="line">    for i := 0; i &lt; right-left; i++ &#123;</span><br><span class="line">        next := cur.Next</span><br><span class="line">        cur.Next = next.Next</span><br><span class="line">        next.Next = pre.Next</span><br><span class="line">        pre.Next = next</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;</span><br><span class="line">    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span><br><span class="line">    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummyNode-&gt;val = -1;</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    struct ListNode *pre = dummyNode;</span><br><span class="line">    for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *cur = pre-&gt;next;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>62. 不同路径</title>
    <link href="http://yoursite.com/2022/10/08/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2022/10/08/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2022-10-08T07:12:12.000Z</published>
    <updated>2022-10-08T08:15:08.377Z</updated>
    
    <content type="html"><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><span id="more"></span><p>[TOC]</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>示例 1:</p><pre><code>输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</code></pre><p>示例 2:</p><pre><code>输入: m = 7, n = 3输出: 28</code></pre><p>示例 3：</p><pre><code>输入：m = 7, n = 3输出：28</code></pre><p>示例 4：</p><pre><code>输入：m = 3, n = 3输出：6</code></pre><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100</code></pre><p>题目数据保证答案小于等于 2 * 10 ^ 9</p><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路^1"></a>思路<a href="https://leetcode.cn/problems/unique-paths/solution/bu-tong-lu-jing-by-leetcode-solution-hzjf/">^1</a></h1><h2 id="思路一：排列组合"><a href="#思路一：排列组合" class="headerlink" title="思路一：排列组合"></a><strong>思路一：排列组合</strong></h2><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，<code>m=3, n=2</code>，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 <em>C_{m+n-2}^{m-1}</em></p><details>    <summary>Python</summary>    <figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(math.factorial(m+n-<span class="number">2</span>)/math.factorial(m-<span class="number">1</span>)/math.factorial(n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long long ans = 1;</span><br><span class="line">        for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">            ans = ans * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long ans = 1;</span><br><span class="line">        for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">            ans = ans * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func uniquePaths(m, n int) int &#123;</span><br><span class="line">    return int(new(big.Int).Binomial(int64(m+n-2), int64(n-1)).Int64())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    long long ans = 1;</span><br><span class="line">    for (int x = n, y = 1; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">        ans = ans * x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a><strong>思路二：动态规划</strong></h2><p>我们令 <code>dp[i][j]</code> 是到达 <code>i, j</code> 最多路径</p><p>动态方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><p>注意，对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，由于都是在边界，所以只能为 <code>1</code></p><p>时间复杂度：<em>O(m</em>n)*</p><p>空间复杂度：<em>O(m * n)</em></p><h2 id="优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1"><a href="#优化：因为我们每次只需要-dp-i-1-j-dp-i-j-1" class="headerlink" title="优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1] "></a>优化：因为我们每次只需要 <code>dp[i-1][j],dp[i][j-1] </code></h2><p>所以我们只要记录这两个数，直接看代码吧！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路二：</p><details>    <summary>Java</summary>   <figure class="highlight java"><figcaption><span>[1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>优化1：空间复杂度 <em>O(2n)</em></p><details>    <summary>Java</summary>   <figure class="highlight java"><figcaption><span>[2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(pre, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-<span class="number">1</span>] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>优化2：空间复杂度 <em>O(n)</em></p><details>    <summary>Java</summary>  <figure class="highlight java"><figcaption><span>[3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？&lt;/p&gt;</summary>
    
    
    
    <category term="2022年10月" scheme="http://yoursite.com/categories/2022%E5%B9%B410%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Combinatorics" scheme="http://yoursite.com/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>206. 反转链表</title>
    <link href="http://yoursite.com/2022/09/30/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/09/30/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-09-30T07:51:12.000Z</published>
    <updated>2022-09-30T08:03:51.645Z</updated>
    
    <content type="html"><![CDATA[<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2]输出：[2,1]</code></pre><p>示例 3：</p><pre><code>输入：head = []输出：[]</code></pre><p>进阶:</p><pre><code>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><h1 id="方法一：迭代-1"><a href="#方法一：迭代-1" class="headerlink" title="方法一：迭代^1"></a>方法一：迭代<a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/">^1</a></h1><p>假设存在链表 <code>1 → 2 → 3 → Ø</code>，我们想要把它改成 <code>Ø ← 1 ← 2 ← 3</code>。</p><p>在遍历列表时，将当前节点的 <code>next</code> 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><details>    <summary>迭代Java</summary>    <figure class="highlight java"><figcaption><span>[Tww6MiPp-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    let prev = null;</span><br><span class="line">    let curr = head;</span><br><span class="line">    while (curr) &#123;</span><br><span class="line">        const next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode prev = null;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        while (curr != null) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        while (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode* prev = NULL;</span><br><span class="line">    struct ListNode* curr = head;</span><br><span class="line">    while (curr) &#123;</span><br><span class="line">        struct ListNode* next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*O(n)*，假设 <em>n</em> 是列表的长度，时间复杂度是 *O(n)*。</li><li>空间复杂度：*O(1)*。</li></ul><hr><h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><p>递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？</p><p>假设列表为：</p><p>n1→…→nk−1    →n k→n k+1→…→nm→∅</p><p>若从节点 <em>n_{k+1}</em> 到 <em>n_{m}</em> 已经被反转，而我们正处于 *n_{k}*。</p><p>n1→…→nk−1→n k→n k+1←…←nm</p><p>我们希望 <em>n_{k+1}</em> 的下一个节点指向 *n_{k}*。</p><p>所以，<em>n_{k}</em>.next.next &#x3D; *n_{k}*。</p><p>要小心的是 <em>n_{1}</em> 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><details>    <summary>递归</summary>    <figure class="highlight java"><figcaption><span>[ESkYHVXb-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if (head == null || head.next == null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const newHead = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func reverseList(head *ListNode) *ListNode &#123;</span><br><span class="line">    if head == nil || head.Next == nil &#123;</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    newHead := reverseList(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = nil</span><br><span class="line">    return newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct ListNode* reverseList(struct ListNode* head) &#123;</span><br><span class="line">    if (head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：*O(n)*，假设 <em>n</em> 是列表的长度，那么时间复杂度为 *O(n)*。</li><li>空间复杂度：*O(n)*，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 <em>n</em> 层。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
    <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>24.两两交换链表中的节点</title>
    <link href="http://yoursite.com/2022/09/29/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2022/09/29/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2022-09-29T06:32:12.000Z</published>
    <updated>2022-09-29T09:04:53.109Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：head = [1,2,3,4]输出：[2,1,4,3]</code></pre><p>示例 2：</p><pre><code>输入：head = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：head = [1]输出：[1]</code></pre><p>提示：</p><pre><code>链表中节点的数目在范围 [0, 100] 内0 &lt;= Node.val &lt;= 100</code></pre><p>[TOC]</p><p>此题有递归和迭代两种方法<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/">^1</a>，我在做的时候首先想到的是用迭代的方法。但是在返回哪个结点时出了问题。调试了很久。看官方题解<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-19/</a><br>也没有弄清楚dummy结点下个结点为什么会准确的指向交换后的链表头而不是跟着交换移动。<br>看了<br><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/bi-jiao-zhi-jie-gao-xiao-de-zuo-fa-han-tu-jie-by-w/</a><br>这个题解中的图解才算搞清楚了，建议再做的时候还是在不看题解的情况下写一次。</p><p>顺便推荐IDEA中的leetcode-editor插件，这个插件现在已经可以在中文版leetcode上无缝对接使用了。适合在一些场景下做leetcode。</p><p>22年再做第二次的解法</p><details>    <summary>我的解法</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        ListNode dummy = new ListNode();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode slow = null;</span><br><span class="line">        ListNode fast = null;</span><br><span class="line">        if (head != null) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            if (head.next != null) &#123;</span><br><span class="line">                fast = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        while (slow != null &amp;&amp; fast != null) &#123;</span><br><span class="line">            prev.next = fast;</span><br><span class="line">            slow.next = fast.next;</span><br><span class="line">            fast.next = slow;</span><br><span class="line">            if (slow.next == null || slow.next.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法一：递归-2"><a href="#方法一：递归-2" class="headerlink" title="方法一：递归^2"></a>方法一：递归<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/">^2</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>可以通过递归的方式实现两两交换链表中的节点。</p><p>递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。</p><p>如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next &#x3D; swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next &#x3D; head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = head.next;</span><br><span class="line">        head.next = swapPairs(newHead.next);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(newHead-&gt;next);</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var swapPairs = function(head) &#123;</span><br><span class="line">    if (head === null|| head.next === null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const newHead = head.next;</span><br><span class="line">    head.next = swapPairs(newHead.next);</span><br><span class="line">    newHead.next = head;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line">        newHead = head.next</span><br><span class="line">        head.next = self.swapPairs(newHead.next)</span><br><span class="line">        newHead.next = head</span><br><span class="line">        return newHead</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func swapPairs(head *ListNode) *ListNode &#123;</span><br><span class="line">    if head == nil || head.Next == nil &#123;</span><br><span class="line">        return head</span><br><span class="line">    &#125;</span><br><span class="line">    newHead := head.Next</span><br><span class="line">    head.Next = swapPairs(newHead.Next)</span><br><span class="line">    newHead.Next = head</span><br><span class="line">    return newHead</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct ListNode* swapPairs(struct ListNode* head) &#123;</span><br><span class="line">    if (head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* newHead = head-&gt;next;</span><br><span class="line">    head-&gt;next = swapPairs(newHead-&gt;next);</span><br><span class="line">    newHead-&gt;next = head;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</p><p>空间复杂度：<br>O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。</p><h1 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>也可以通过迭代的方式实现两两交换链表中的节点。</p><p>创建哑结点 dummyHead，令 dummyHead.next &#x3D; head。令 temp 表示当前到达的节点，初始时 temp &#x3D; dummyHead。每次需要交换 temp 后面的两个节点。</p><p>如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</p><p>具体而言，交换之前的节点关系是 temp -&gt; node1 -&gt; node2，交换之后的节点关系要变成 temp -&gt; node2 -&gt; node1，因此需要进行如下操作。</p><pre><code>temp.next = node2node1.next = node2.nextnode2.next = node1</code></pre><p>完成上述操作之后，节点关系即变成 temp -&gt; node2 -&gt; node1。再令 temp &#x3D; node1，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p><p>两两交换链表中的节点之后，新的链表的头节点是 dummyHead.next，返回新的链表的头节点即可。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        while (temp.next != null &amp;&amp; temp.next.next != null) &#123;</span><br><span class="line">            ListNode node1 = temp.next;</span><br><span class="line">            ListNode node2 = temp.next.next;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        while (temp-&gt;next != nullptr &amp;&amp; temp-&gt;next-&gt;next != nullptr) &#123;</span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var swapPairs = function(head) &#123;</span><br><span class="line">    const dummyHead = new ListNode(0);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    let temp = dummyHead;</span><br><span class="line">    while (temp.next !== null &amp;&amp; temp.next.next !== null) &#123;</span><br><span class="line">        const node1 = temp.next;</span><br><span class="line">        const node2 = temp.next.next;</span><br><span class="line">        temp.next = node2;</span><br><span class="line">        node1.next = node2.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        temp = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummyHead = ListNode(0)</span><br><span class="line">        dummyHead.next = head</span><br><span class="line">        temp = dummyHead</span><br><span class="line">        while temp.next and temp.next.next:</span><br><span class="line">            node1 = temp.next</span><br><span class="line">            node2 = temp.next.next</span><br><span class="line">            temp.next = node2</span><br><span class="line">            node1.next = node2.next</span><br><span class="line">            node2.next = node1</span><br><span class="line">            temp = node1</span><br><span class="line">        return dummyHead.next</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func swapPairs(head *ListNode) *ListNode &#123;</span><br><span class="line">    dummyHead := &amp;ListNode&#123;0, head&#125;</span><br><span class="line">    temp := dummyHead</span><br><span class="line">    for temp.Next != nil &amp;&amp; temp.Next.Next != nil &#123;</span><br><span class="line">        node1 := temp.Next</span><br><span class="line">        node2 := temp.Next.Next</span><br><span class="line">        temp.Next = node2</span><br><span class="line">        node1.Next = node2.Next</span><br><span class="line">        node2.Next = node1</span><br><span class="line">        temp = node1</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode dummyHead;</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    struct ListNode* temp = &amp;dummyHead;</span><br><span class="line">    while (temp-&gt;next != NULL &amp;&amp; temp-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        struct ListNode* node1 = temp-&gt;next;</span><br><span class="line">        struct ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">        temp-&gt;next = node2;</span><br><span class="line">        node1-&gt;next = node2-&gt;next;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        temp = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</p><p>空间复杂度：<br>O(1)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="LinkList" scheme="http://yoursite.com/tags/LinkList/"/>
    
  </entry>
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="http://yoursite.com/2022/09/28/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2022/09/28/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2022-09-28T07:52:12.000Z</published>
    <updated>2022-09-28T09:57:08.177Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><span id="more"></span><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><pre><code>输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></pre><p>示例2:</p><pre><code>输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False</code></pre><p>注意：</p><pre><code>输入的字符串只包含小写字母两个字符串的长度都在 [1, 10,000] 之间</code></pre><p>[TOC]</p><h1 id="方法一-暴力-超过时间限制"><a href="#方法一-暴力-超过时间限制" class="headerlink" title="方法一 暴力 超过时间限制"></a>方法一 暴力 <a href="https://leetcode.cn/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode-solut-7k7u/">超过时间限制</a></h1><p><strong>算法</strong></p><p>最简单的方法是生成短字符串的所有排列，并检查生成的排列是否是较长字符串的子字符串。</p><p>为了生成所有可能的配对，我们使用函数<code>permute（string_1，string_2，current_index）</code>。此函数创建短字符串 <em>s1</em> 的所有可能排列。</p><p>为此，permute将当前元素 <em>current_index</em> 的索引作为参数之一。然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。完成交换后，它会再次调用置换，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。</p><p>因此，当我们到达数组的末尾时，会生成数组元素的新排序。以下动画描述了生成排列的过程。</p><p> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide1.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide2.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide3.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide4.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide5.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide6.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide7.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide8.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide9.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide10.PNG">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide11.PNG">1200</a> </p><details>    <summary>暴力</summary>    <figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        permute(s1, s2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">swap</span><span class="params">(String s, <span class="type">int</span> i0, <span class="type">int</span> i1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i0 == i1)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, i0);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.substring(i0 + <span class="number">1</span>, i1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s.substring(i1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">permute</span><span class="params">(String s1, String s2, <span class="type">int</span> l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.indexOf(s1) &gt;= <span class="number">0</span>)</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt; s1.length(); i++) &#123;</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">                permute(s1, s2, l + <span class="number">1</span>);</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n!)<em>。我们将 <em>s1</em> 的短字符串 <em>s1</em> 的所有排列与 <em>s2</em> 匹配。这里，</em>n</em> 指的是 <em>s1</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n^2)<em>。递归树的深度是 <em>n</em>（</em>n</em> 是指短字符串 <em>s1</em> 的长度）。递归树的每个节点都包含一个 max 的字符串。长度 <em>n</em>。</p></li></ul><hr><h1 id="方法二-排序-超过时间限制"><a href="#方法二-排序-超过时间限制" class="headerlink" title="方法二 排序 [超过时间限制]:"></a>方法二 排序 [超过时间限制]:</h1><p><strong>算法</strong></p><p>这种方法背后的想法是，只有当两个字符串包含相同次数的相同字符时，一个字符串才是另一个字符串的排列。只有<em>sorted(x)&#x3D; sorted(y)<em>时，一个字符串</em>x</em>才​​是其他字符串 <em>y</em> 的排列。</p><p>为了检查这一点，我们可以对两个字符串进行排序并进行比较。我们对短字符串 <em>s1</em> 和 <em>s2</em> 的所有子字符串进行排序，对它们进行排序并将它们与排序的 <em>s1</em> 字符串进行比较。如果两者完全匹配，<em>s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>排序</summary>        <figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(l1log(l1)+(l2-l1)l1log(l1))。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(l_1)*。使用了 <em>t</em> 数组。</p></li></ul><hr><h1 id="方法三-使用哈希表-超过时间限制"><a href="#方法三-使用哈希表-超过时间限制" class="headerlink" title="方法三 使用哈希表 [超过时间限制]"></a>方法三 使用哈希表 [超过时间限制]</h1><p><strong>算法</strong></p><p>如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 <em>s1</em> 长度相同的长字符串 <em>s2</em> 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 <em>s1</em> 的排列可以是 <em>s2</em> 的子字符串。</p><p>为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 <em>s1map</em>来存储短字符串 <em>s1</em> 中所有字符的出现频率。我们考虑 <em>s2</em> 的每个可能的子串，其长度与 <em>s1</em> 的长度相同，也可以找到相应的哈希表，即 <em>s2map</em>。因此，所考虑的子字符串可以被视为一个长度窗口，如 <em>s1</em> 迭代超过 <em>s2</em>。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 <em>s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>使用哈希表</summary>        <figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(l_1+26</em>l_1*(l_2-l_1))<em>。这个哈希表包含最多26个键。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2* 是字符串 <em>l_2</em> 的长度。</li><li>空间复杂度：*O(1)*。表包含最多 26 个键值对。</li></ul><hr><h1 id="方法四-使用数组-通过"><a href="#方法四-使用数组-通过" class="headerlink" title="方法四 使用数组 [通过]"></a>方法四 使用数组 [通过]</h1><p><strong>算法</strong></p><p>我们可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。给定字符串仅包含小写字母（’a’到’z’）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。</p><details>    <summary>使用数组</summary>    <figure class="highlight java"><figcaption><span>[solution-4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] s1map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++)</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] s2map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s1.length(); j++) &#123;</span><br><span class="line">                s2map[s2.charAt(i + j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(<span class="type">int</span>[] s1map, <span class="type">int</span>[] s2map)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p>时间复杂度：<em>O(l_1+26</em>l_1*(l_2-l_1))<em>。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2* 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(1)*。使用 <em>s1map</em> 和 <em>s2map</em>，大小为 26。</p></li></ul><hr><h1 id="方法五-滑动窗口-通过"><a href="#方法五-滑动窗口-通过" class="headerlink" title="方法五 滑动窗口  [通过]:"></a>方法五 滑动窗口  [通过]:</h1><p><strong>算法</strong></p><p>我们可以为 <em>s2</em> 中的第一个窗口创建一次哈希表，而不是为 <em>s2</em> 中考虑的每个窗口重新生成哈希表。然后，稍后当我们滑动窗口时，我们知道我们添加了一个前面的字符并将新的后续字符添加到所考虑的新窗口中。因此，我们可以通过仅更新与这两个字符相关联的索引来更新哈希表。同样，对于每个更新的哈希表，我们将哈希表的所有元素进行比较以获得所需的结果。</p><details>    <summary>使用数组</summary>    <figure class="highlight java"><figcaption><span>[solution5-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] s1map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] s2map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(<span class="type">int</span>[] s1map, <span class="type">int</span>[] s2map)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度分析：<em>O(l_1+26</em>(l_2-l_1))<em>。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2* 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(1)*。常数级空间。</p></li></ul><hr><h1 id="方法六-优化的滑动窗口-通过"><a href="#方法六-优化的滑动窗口-通过" class="headerlink" title="方法六 优化的滑动窗口 [通过]:"></a>方法六 优化的滑动窗口 [通过]:</h1><p><strong>算法</strong></p><p>上一种方法可以优化，如果不是比较每个更新的 <em>s2map</em> 的哈希表的所有元素，而是对应于 <em>s2</em> 考虑的每个窗口，我们会跟踪先前哈希表中已经匹配的元素数量当我们向右移动窗口时，只更新匹配元素的数量。</p><p>为此，我们维护一个 <em>count</em> 变量，该变量存储字符数（26个字母表中的数字），这些字符在 <em>s1</em> 中具有相同的出现频率，当前窗口在 <em>s2</em> 中。当我们滑动窗口时，如果扣除最后一个元素并添加新元素导致任何字符的新频率匹配，我们将 <em>count</em> 递增1.如果不是，我们保持 <em>count</em> 完整。但是，如果添加频率相同的字符（添加和删除之前）相同的字符，现在会导致频率不匹配，这会通过递减相同的 <em>count</em> 变量来考虑。如果在移动窗口后，<em>count</em> 的计算结果为26，则表示所有字符的频率完全匹配。所以，我们立即返回一个True。</p><details>    <summary>使用数组</summary>    <figure class="highlight java"><figcaption><span>[solution6-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] s1map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] s2map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] == s2map[i])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s2.charAt(i + s1.length()) - <span class="string">&#x27;a&#x27;</span>, l = s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">26</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s2map[r]++;</span><br><span class="line">            <span class="keyword">if</span> (s2map[r] == s1map[r])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[r] == s1map[r] + <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">            s2map[l]--;</span><br><span class="line">            <span class="keyword">if</span> (s2map[l] == s1map[l])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[l] == s1map[l] - <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(l_1+(l_2-l_1))<em>。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，</em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：*O(1)*。常数级的空间。</p></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
    <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="http://yoursite.com/2022/09/28/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/09/28/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2022-09-28T04:03:12.000Z</published>
    <updated>2022-09-28T03:51:15.233Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><span id="more"></span><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="fc6033f3-e9c6-41d7-b660-328fc288d2e2">3. 无重复字符的最长子串_2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><p>我一开始想到的是一个比较粗暴的方法，遍历字符串中的每一个位置，然后在该位置向两边扩展，直到遇到重复的字符，最后统计长度，但这种方法效率较低</p><details>    <summary>Java暴力解法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            int j = i ;</span><br><span class="line">            int k = i ;</span><br><span class="line">            while (j &gt; 0) &#123;</span><br><span class="line">                if (s.substring(j, k + 1).contains(s.substring(j-1,j))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (k &lt; s.length()-1) &#123;</span><br><span class="line">                if (s.substring(j, k+1).contains(s.substring(k + 1,k+2))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = Math.max(maxlen, k - j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++暴力解法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int lengthOfLongestSubstring(string s)&#123;</span><br><span class="line">        long len=s.size();</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">            int j=i, k=i;</span><br><span class="line">            //向左搜索</span><br><span class="line">            while (j&gt;0) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(j-1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //向右搜索</span><br><span class="line">            while (k&lt;len-1) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(k+1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=max(maxlen, k-j+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>时间复杂度：O(N^2)</p><p>空间复杂度：O(1)</p><h2 id="方法二：滑动窗口-1"><a href="#方法二：滑动窗口-1" class="headerlink" title="方法二：滑动窗口^1"></a>方法二：滑动窗口<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/">^1</a></h2><p><strong>思路和算法</strong></p><p>我们先用一个例子来想一想如何在较优的时间复杂度内通过本题。</p><p>我们不妨以示例一中的字符串 abcabcbb  为例，找出 <strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><ul><li>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</li><li>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb ；</li><li>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb ；</li><li>以 abc(a)bcbb  开始的最长字符串为 abc(abc)bb ；</li><li>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</li><li>以 abcab(c)bb  开始的最长字符串为abcab(cb)b ；</li><li>以 abcabc(b)b  开始的最长字符串为 abcabc(b)b ；</li><li>以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 。</li></ul><p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 <em>k</em> 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 <em>r_k</em>。那么当我们选择第 <em>k+1</em> 个字符作为起始位置时，首先从 <em>k+1</em> 到 <em>r_k</em> 的字符显然是不重复的，并且由于少了原本的第 <em>k</em> 个字符，我们可以尝试继续增大 <em>r_k</em>，直到右侧出现了重复字符为止。</p><p>这样以来，我们就可以使用「滑动窗口」来解决这个问题了：</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 <em>r_k</em>；</p></li><li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p><strong>判断重复字符</strong></p><p>在上面的流程中，我们还需要使用一种数据结构来判断 <strong>是否有重复的字符</strong>，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><p>至此，我们就完美解决了本题。</p><details>    <summary>滑动窗口C++</summary>    <figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Java</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>我的Java解法</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length() &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.charAt(right))) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">                maxlen = Math.max(maxlen, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(s.charAt(right));</span><br><span class="line">                maxlen = Math.max(maxlen, right - left + <span class="number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Python3</summary>    <figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口JavaScript</summary>    <figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="keyword">const</span> occ = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    <span class="keyword">let</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            occ.<span class="title function_">delete</span>(s.<span class="title function_">charAt</span>(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="title function_">has</span>(s.<span class="title function_">charAt</span>(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            occ.<span class="title function_">add</span>(s.<span class="title function_">charAt</span>(rk + <span class="number">1</span>));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*，其中 <em>N</em> 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p></li><li><p>空间复杂度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure><p>，其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Sigma</span><br></pre></td></tr></table></figure><p> 表示字符集（即字符串中可以出现的字符），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p> 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 <em>[0, 128)</em> 内的字符，即 </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|=128</span><br></pre></td></tr></table></figure><p>。我们需要用到哈希集合来存储出现过的字符，而字符最多有 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p>个，因此空间复杂度为 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
    <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>435. Non-overlapping Intervals无重叠区间</title>
    <link href="http://yoursite.com/2022/09/27/435.%20Non-overlapping%20Intervals%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2022/09/27/435.%20Non-overlapping%20Intervals%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</id>
    <published>2022-09-27T06:26:48.000Z</published>
    <updated>2022-09-27T06:10:31.382Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><span id="more"></span><p>[TOC]</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><pre><code>示例 1:输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。示例 2:输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。示例 3:输入: [ [1,2], [2,3] ]输出: 0</code></pre><p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode.cn/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/">^1</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>题目的要求等价于「选出最多数量的区间，使得它们互不重叠」。由于选出的区间互不重叠，因此我们可以将它们按照端点从小到大的顺序进行排序，并且无论我们按照左端点还是右端点进行排序，得到的结果都是唯一的。</p><p>这样一来，我们可以先将所有的 n 个区间按照左端点（或者右端点）从小到大进行排序，随后使用动态规划的方法求出区间数量的最大值。设排完序后这 n 个区间的左右端点分别为 l0,l1,…,ln-1 以及r0, r1,…,rn-1, 那么我们令 fi 表示「以区间i 为最后一个区间，可以选出的区间数量的最大值」，状态转移方程即为：</p><p>即我们枚举倒数第二个区间的编号 j，满足 j&lt;i，并且第 j 个区间必须要与第<br>i 个区间不重叠。由于我们已经按照左端点进行升序排序了，因此只要第<br>j 个区间的右端点 rj 没有越过第 i 个区间的左端点 li，即 rj&lt;&#x3D;li，那么第 j 个区间就与第 i 个区间不重叠。我们在所有满足要求的 j 中，选择 fj<br>  最大的那一个进行状态转移，如果找不到满足要求的区间，那么状态转移方程中 max 这一项就为 0，fi 就为 1。最终的答案即为所有 fi中的最大值。</p><p>由于方法一的时间复杂度较高，因此在下面的 Python 代码中，我们尽量使用列表推导优化常数，使得其可以在时间限制内通过所有测试数据。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * struct Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() : start(0), end(0) &#123;&#125;</span><br><span class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">/*</span><br><span class="line">    这道题给了我们一堆区间，让我们求需要至少移除多少个区间才能使剩下的区间没有重叠，</span><br><span class="line">    那么我们首先要给区间排序，根据每个区间的start来做升序排序，</span><br><span class="line">    然后我们开始要查找重叠区间，判断方法是看如果前一个区间的end大于后一个区间的start，那么一定是重复区间，</span><br><span class="line">    此时我们结果res自增1，我们需要删除一个，</span><br><span class="line">    那么此时我们究竟该删哪一个呢，为了保证我们总体去掉的区间数最小，我们去掉那个end值较大的区间，</span><br><span class="line">    而在代码中，我们并没有真正的删掉某一个区间，而是用一个变量last指向上一个需要比较的区间，</span><br><span class="line">    我们将last指向end值较小的那个区间；如果两个区间没有重叠，那么此时last指向当前区间，继续进行下一次遍历，参见代码如下：</span><br><span class="line">*/</span><br><span class="line">       int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">           if (intervals.empty()) &#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) &#123;</span><br><span class="line">               return u[0] &lt; v[0];</span><br><span class="line">           &#125;);</span><br><span class="line">   </span><br><span class="line">           int n = intervals.size();</span><br><span class="line">           vector&lt;int&gt; f(n, 1);</span><br><span class="line">           for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">               for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                   if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                       f[i] = max(f[i], f[j] + 1);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return n - *max_element(f.begin(), f.end());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">        if (intervals.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] interval1, int[] interval2) &#123;</span><br><span class="line">                return interval1[0] - interval2[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int n = intervals.length;</span><br><span class="line">        int[] f = new int[n];</span><br><span class="line">        Arrays.fill(f, 1);</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                    f[i] = Math.max(f[i], f[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - Arrays.stream(f).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:</span><br><span class="line">        if not intervals:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        intervals.sort()</span><br><span class="line">        n = len(intervals)</span><br><span class="line">        f = [1]</span><br><span class="line"></span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            f.append(max((f[j] for j in range(i) if intervals[j][1] &lt;= intervals[i][0]), default=0) + 1)</span><br><span class="line"></span><br><span class="line">        return n - max(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func eraseOverlapIntervals(intervals [][]int) int &#123;</span><br><span class="line">    n := len(intervals)</span><br><span class="line">    if n == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(intervals, func(i, j int) bool &#123; return intervals[i][0] &lt; intervals[j][0] &#125;)</span><br><span class="line">    dp := make([]int, n)</span><br><span class="line">    for i := range dp &#123;</span><br><span class="line">        dp[i] = 1</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 1; i &lt; n; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; i; j++ &#123;</span><br><span class="line">            if intervals[j][1] &lt;= intervals[i][0] &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j]+1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - max(dp...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a ...int) int &#123;</span><br><span class="line">    res := a[0]</span><br><span class="line">    for _, v := range a[1:] &#123;</span><br><span class="line">        if v &gt; res &#123;</span><br><span class="line">            res = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int cmp(int** a, int** b) &#123;</span><br><span class="line">    return (*a)[0] - (*b)[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) &#123;</span><br><span class="line">    if (intervalsSize == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(intervals, intervalsSize, sizeof(int*), cmp);</span><br><span class="line">    int f[intervalsSize];</span><br><span class="line">    for (int i = 0; i &lt; intervalsSize; i++) &#123;</span><br><span class="line">        f[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxn = 1;</span><br><span class="line">    for (int i = 1; i &lt; intervalsSize; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">            if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                f[i] = fmax(f[i], f[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn = fmax(maxn, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return intervalsSize - maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var eraseOverlapIntervals = function(intervals) &#123;</span><br><span class="line">    if (!intervals.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intervals.sort((a, b) =&gt; a[0] - b[0]);</span><br><span class="line">    const n = intervals.length;</span><br><span class="line">    const f = new Array(n).fill(1);</span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (intervals[j][1] &lt;= intervals[i][0]) &#123;</span><br><span class="line">                f[i] = Math.max(f[i], f[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - Math.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^2)，其中 n 是区间的数量。我们需要 O(nlogn) 的时间对所有的区间按照左端点进行升序排序，并且需要 O(n^2) 的时间进行动态规划。由于前者在渐进意义下小于后者，因此总时间复杂度为<br>O(n^2)。<br>注意到方法一本质上是一个「最长上升子序列」问题，因此我们可以将时间复杂度优化至 O(nlogn)，具体可以参考「300. 最长递增子序列的官方题解」<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">^2</a>。<br>空间复杂度：O(n)，即为存储所有状态 fi 需要的空间。</p><h1 id="方法二：贪心"><a href="#方法二：贪心" class="headerlink" title="方法二：贪心"></a>方法二：贪心</h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>我们不妨想一想应该选择哪一个区间作为首个区间。</p><p>假设在某一种最优的选择方法中，[lk,rk] 是首个（即最左侧的）区间，那么它的左侧没有其它区间，右侧有若干个不重叠的区间。设想一下，如果此时存在一个区间 [lj,rj]，使得 rj&lt;rk，即区间 j 的右端点在区间 k 的左侧，那么我们将区间 k 替换为区间 j，其与剩余右侧被选择的区间仍然是不重叠的。而当我们将区间 k 替换为区间 j 后，就得到了另一种最优的选择方法。</p><p>我们可以不断地寻找右端点在首个区间右端点左侧的新区间，将首个区间替换成该区间。那么当我们无法替换时，首个区间就是所有可以选择的区间中右端点最小的那个区间。因此我们将所有区间按照右端点从小到大进行排序，那么排完序之后的首个区间，就是我们选择的首个区间。</p><p>如果有多个区间的右端点都同样最小怎么办？由于我们选择的是首个区间，因此在左侧不会有其它的区间，那么左端点在何处是不重要的，我们只要任意选择一个右端点最小的区间即可。</p><p>当确定了首个区间之后，所有与首个区间不重合的区间就组成了一个规模更小的子问题。由于我们已经在初始时将所有区间按照右端点排好序了，因此对于这个子问题，我们无需再次进行排序，只要找出其中与首个区间不重合并且右端点最小的区间即可。用相同的方法，我们可以依次确定后续的所有区间。</p><p>在实际的代码编写中，我们对按照右端点排好序的区间进行遍历，并且实时维护上一个选择区间的右端点 right。如果当前遍历到的区间 [li,ri] 与上一个区间不重合，即<br>li≥right，那么我们就可以贪心地选择这个区间，并将 right 更新为ri。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) &#123;</span><br><span class="line">            return u[1] &lt; v[1];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int n = intervals.size();</span><br><span class="line">        int right = intervals[0][1];</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                right = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">        if (intervals.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] interval1, int[] interval2) &#123;</span><br><span class="line">                return interval1[1] - interval2[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        int n = intervals.length;</span><br><span class="line">        int right = intervals[0][1];</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                right = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:</span><br><span class="line">        if not intervals:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        intervals.sort(key=lambda x: x[1])</span><br><span class="line">        n = len(intervals)</span><br><span class="line">        right = intervals[0][1]</span><br><span class="line">        ans = 1</span><br><span class="line"></span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            if intervals[i][0] &gt;= right:</span><br><span class="line">                ans += 1</span><br><span class="line">                right = intervals[i][1]</span><br><span class="line">        </span><br><span class="line">        return n - ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func eraseOverlapIntervals(intervals [][]int) int &#123;</span><br><span class="line">    n := len(intervals)</span><br><span class="line">    if n == 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(intervals, func(i, j int) bool &#123; return intervals[i][1] &lt; intervals[j][1] &#125;)</span><br><span class="line">    ans, right := 1, intervals[0][1]</span><br><span class="line">    for _, p := range intervals[1:] &#123;</span><br><span class="line">        if p[0] &gt;= right &#123;</span><br><span class="line">            ans++</span><br><span class="line">            right = p[1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int cmp(int** a, int** b) &#123;</span><br><span class="line">    return (*a)[1] - (*b)[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) &#123;</span><br><span class="line">    if (intervalsSize == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(intervals, intervalsSize, sizeof(int*), cmp);</span><br><span class="line"></span><br><span class="line">    int right = intervals[0][1];</span><br><span class="line">    int ans = 1;</span><br><span class="line">    for (int i = 1; i &lt; intervalsSize; ++i) &#123;</span><br><span class="line">        if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            right = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervalsSize - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var eraseOverlapIntervals = function(intervals) &#123;</span><br><span class="line">    if (!intervals.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intervals.sort((a, b) =&gt; a[1] - b[1]);</span><br><span class="line"></span><br><span class="line">    const n = intervals.length;</span><br><span class="line">    let right = intervals[0][1];</span><br><span class="line">    let ans = 1;</span><br><span class="line">    for (let i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (intervals[i][0] &gt;= right) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            right = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n - ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(nlogn)，其中 n 是区间的数量。我们需要 O(nlogn) 的时间对所有的区间按照右端点进行升序排序，并且需要 O(n) 的时间进行遍历。由于前者在渐进意义下大于后者，因此总时间复杂度为 O(nlogn)。</p><p>空间复杂度：<br>O(logn)，即为排序需要使用的栈空间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
    <category term="Sorting" scheme="http://yoursite.com/tags/Sorting/"/>
    
  </entry>
  
  <entry>
    <title>199.二叉树的右视图Binary Tree Right Side View</title>
    <link href="http://yoursite.com/2022/09/26/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEBinary%20Tree%20Right%20Side%20View/"/>
    <id>http://yoursite.com/2022/09/26/199.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BEBinary%20Tree%20Right%20Side%20View/</id>
    <published>2022-09-26T11:14:32.000Z</published>
    <updated>2022-09-26T02:56:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><span id="more"></span><p>[TOC]</p><p>示例1:</p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><p>示例 2:</p><pre><code>输入: [1,null,3]输出: [1,3]</code></pre><p>示例 3:</p><pre><code>输入: []输出: []</code></pre><p>提示:</p><pre><code>二叉树的节点个数的范围是 [0,100]-100 &lt;= Node.val &lt;= 100 </code></pre><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>使用队列层次遍历二叉树，存储每层最右边的结点</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>执行广度优先搜索，左结点排在右结点之前，这样，我们对每一层都从左到右访问。因此，只保留每个深度最后访问的结点，我们就可以在遍历完整棵树后得到每个深度最右的结点。除了将栈改成队列，并去除了 rightmost_value_at_depth 之前的检查外，算法没有别的改动。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        if(root) q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int len=q.size();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode *cur=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(i==len-1)res.push_back(cur-&gt;val);</span><br><span class="line">                if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; depthQueue = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        depthQueue.add(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.remove();</span><br><span class="line">            int depth = depthQueue.remove();</span><br><span class="line"></span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line"></span><br><span class="line">                nodeQueue.add(node.left);</span><br><span class="line">                nodeQueue.add(node.right);</span><br><span class="line">                depthQueue.add(depth + 1);</span><br><span class="line">                depthQueue.add(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>我的Java写法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            Deque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">            deque.offer(root);</span><br><span class="line">            while (!deque.isEmpty()) &#123;</span><br><span class="line">                int n = deque.size();</span><br><span class="line">                for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                    TreeNode temp = deque.poll();</span><br><span class="line">                    if (temp.left != null) &#123;</span><br><span class="line">                        deque.offer(temp.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (temp.right != null) &#123;</span><br><span class="line">                        deque.offer(temp.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (i == n - 1) &#123;</span><br><span class="line">                        list.add(temp.val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rightSideView(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值</span><br><span class="line">        max_depth = -1</span><br><span class="line"></span><br><span class="line">        queue = deque([(root, 0)])</span><br><span class="line">        while queue:</span><br><span class="line">            node, depth = queue.popleft()</span><br><span class="line"></span><br><span class="line">            if node is not None:</span><br><span class="line">                # 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth)</span><br><span class="line"></span><br><span class="line">                # 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmost_value_at_depth[depth] = node.val</span><br><span class="line"></span><br><span class="line">                queue.append((node.left, depth + 1))</span><br><span class="line">                queue.append((node.right, depth + 1))</span><br><span class="line"></span><br><span class="line">        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度 :<br>O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。<br>空间复杂度 :<br>O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为O(n)。</p><p>注释</p><p>deque 数据类型来自于collections 模块，支持从头和尾部的常数时间 append&#x2F;pop 操作。若使用 Python 的 list，通过 list.pop(0) 去除头部会消耗 O(n) 的时间。</p><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。</p><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>这样一来，我们可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组</p><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rightSideView(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值</span><br><span class="line">        max_depth = -1</span><br><span class="line"></span><br><span class="line">        stack = [(root, 0)]</span><br><span class="line">        while stack:</span><br><span class="line">            node, depth = stack.pop()</span><br><span class="line"></span><br><span class="line">            if node is not None:</span><br><span class="line">                # 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth)</span><br><span class="line"></span><br><span class="line">                # 如果不存在对应深度的节点我们才插入</span><br><span class="line">                rightmost_value_at_depth.setdefault(depth, node.val)</span><br><span class="line"></span><br><span class="line">                stack.append((node.left, depth + 1))</span><br><span class="line">                stack.append((node.right, depth + 1))</span><br><span class="line"></span><br><span class="line">        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; nodeStack = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; depthStack = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            int depth = depthStack.pop();</span><br><span class="line"></span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 如果不存在对应深度的节点我们才插入</span><br><span class="line">                if (!rightmostValueAtDepth.containsKey(depth)) &#123;</span><br><span class="line">                    rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; rightView = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        stack&lt;int&gt; depthStack;</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeStack.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeStack.top();nodeStack.pop();</span><br><span class="line">            int depth = depthStack.top();depthStack.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 如果不存在对应深度的节点我们才插入</span><br><span class="line">                if (rightmostValueAtDepth.find(depth) == rightmostValueAtDepth.end()) &#123;</span><br><span class="line">                    rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node -&gt; left);</span><br><span class="line">                nodeStack.push(node -&gt; right);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">                depthStack.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度 : </p><p>O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。</p><p>空间复杂度 : </p><p>O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>637. 二叉树的层平均值</title>
    <link href="http://yoursite.com/2022/09/26/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <id>http://yoursite.com/2022/09/26/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</id>
    <published>2022-09-26T07:24:32.000Z</published>
    <updated>2022-09-26T07:32:55.175Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10^-5 以内的答案可以被接受。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</code></pre><p>示例 2:</p><pre><code>输入：root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000]</code></pre><p>提示：</p><pre><code>树中节点数量在 [1, 104] 范围内-231 &lt;= Node.val &lt;= 231 - 1</code></pre><p>深度&#x2F;广度优先搜索<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/solution/er-cha-shu-de-ceng-ping-jun-zhi-by-leetcode-soluti/">^1</a>,同102，103，199和515几题比较接近</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10^-5 以内的答案可以被接受。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>515. 在每个树行中找最大值</title>
    <link href="http://yoursite.com/2022/09/26/515.%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2022/09/26/515.%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2022-09-26T07:14:32.000Z</published>
    <updated>2022-09-26T07:25:57.537Z</updated>
    
    <content type="html"><![CDATA[<p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><span id="more"></span><p>[TOC]</p><p>示例1：</p><pre><code>输入: root = [1,3,2,5,3,null,9]输出: [1,3,9]</code></pre><p>示例2：</p><pre><code>输入: root = [1,2,3]输出: [1,3]</code></pre><p>提示：</p><pre><code>二叉树的节点个数的范围是 [0,104]-231 &lt;= Node.val &lt;= 231 - 1</code></pre><h1 id="方法一：深度优先搜索-1"><a href="#方法一：深度优先搜索-1" class="headerlink" title="方法一：深度优先搜索^1"></a>方法一：深度优先搜索<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/solution/zai-mei-ge-shu-xing-zhong-zhao-zui-da-zh-6xbs/">^1</a></h1><p>思路与算法</p><p>我们用树的「先序遍历」来进行「深度优先搜索」处理，并用 curHeight 来标记遍历到的当前节点的高度。当遍历到 curHeight 高度的节点就判断是否更新该层节点的最大值。</p><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestValues(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">        ans = []</span><br><span class="line">        def dfs(node: TreeNode, curHeight: int) -&gt; None:</span><br><span class="line">            if node is None:</span><br><span class="line">                return</span><br><span class="line">            if curHeight == len(ans):</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            else:</span><br><span class="line">                ans[curHeight] = max(ans[curHeight], node.val)</span><br><span class="line">            dfs(node.left, curHeight + 1)</span><br><span class="line">            dfs(node.right, curHeight + 1)</span><br><span class="line">        dfs(root, 0)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; res, TreeNode* root, int curHeight) &#123;</span><br><span class="line">        if (curHeight == res.size()) &#123;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res[curHeight] = max(res[curHeight], root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;left) &#123;</span><br><span class="line">            dfs(res, root-&gt;left, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right) &#123;</span><br><span class="line">            dfs(res, root-&gt;right, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        dfs(res, root, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(res, root, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(List&lt;Integer&gt; res, TreeNode root, int curHeight) &#123;</span><br><span class="line">        if (curHeight == res.size()) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.set(curHeight, Math.max(res.get(curHeight), root.val));</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.left != null) &#123;</span><br><span class="line">            dfs(res, root.left, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.right != null) &#123;</span><br><span class="line">            dfs(res, root.right, curHeight + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func largestValues(root *TreeNode) (ans []int) &#123;</span><br><span class="line">    var dfs func(*TreeNode, int)</span><br><span class="line">    dfs = func(node *TreeNode, curHeight int) &#123;</span><br><span class="line">        if node == nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if curHeight == len(ans) &#123;</span><br><span class="line">            ans = append(ans, node.Val)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ans[curHeight] = max(ans[curHeight], node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.Left, curHeight+1)</span><br><span class="line">        dfs(node.Right, curHeight+1)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, 0)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if b &gt; a &#123;</span><br><span class="line">        return b</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度：</p><p>O(n)，其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p><p>空间复杂度：</p><p>O(height)。其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p><h1 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h1><p>思路与算法</p><p>我们也可以用「广度优先搜索」的方法来解决这道题目。「广度优先搜索」中的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于「广度优先搜索」的每次只从队列里拿出一个节点，我们把当前队列中的全部节点拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是下一层的所有节点，即我们是一层一层地进行拓展，然后每一层我们用 maxVal 来标记该层节点的最大值。当该层全部节点都处理完后，<br>maxVal 就是该层全部节点中的最大值。</p><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestValues(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        ans = []</span><br><span class="line">        q = [root]</span><br><span class="line">        while q:</span><br><span class="line">            maxVal = -inf</span><br><span class="line">            tmp = q</span><br><span class="line">            q = []</span><br><span class="line">            for node in tmp:</span><br><span class="line">                maxVal = max(maxVal, node.val)</span><br><span class="line">                if node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">            ans.append(maxVal)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int len = q.size();</span><br><span class="line">            int maxVal = INT_MIN;</span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                len--;</span><br><span class="line">                auto t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                maxVal = max(maxVal, t-&gt;val);</span><br><span class="line">                if (t-&gt;left) &#123;</span><br><span class="line">                    q.push(t-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (t-&gt;right) &#123;</span><br><span class="line">                    q.push(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(maxVal);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int len = queue.size();</span><br><span class="line">            int maxVal = Integer.MIN_VALUE;</span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                len--;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                maxVal = Math.max(maxVal, t.val);</span><br><span class="line">                if (t.left != null) &#123;</span><br><span class="line">                    queue.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (t.right != null) &#123;</span><br><span class="line">                    queue.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(maxVal);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func largestValues(root *TreeNode) (ans []int) &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    for len(q) &gt; 0 &#123;</span><br><span class="line">        maxVal := math.MinInt32</span><br><span class="line">        tmp := q</span><br><span class="line">        q = nil</span><br><span class="line">        for _, node := range tmp &#123;</span><br><span class="line">            maxVal = max(maxVal, node.Val)</span><br><span class="line">            if node.Left != nil &#123;</span><br><span class="line">                q = append(q, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            if node.Right != nil &#123;</span><br><span class="line">                q = append(q, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, maxVal)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if b &gt; a &#123;</span><br><span class="line">        return b</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度： O(n)，其中 n 为二叉树节点个数，每一个节点仅会进出队列一次。<br>空间复杂度： O(n)，存储二叉树节点的空间开销。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>103. 二叉树的锯齿形层序遍历</title>
    <link href="http://yoursite.com/2022/09/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/09/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-09-23T07:39:12.000Z</published>
    <updated>2022-09-23T07:39:56.144Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]]</code></pre><p>示例 2：</p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>[TOC]</p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：广度优先遍历"><a href="#方法一：广度优先遍历" class="headerlink" title="方法一：广度优先遍历"></a>方法一：广度优先遍历</h2><p>此题是「102. 二叉树的层序遍历」的变种，最后输出的要求有所变化，要求我们按层数的奇偶来决定每一层的输出顺序。规定二叉树的根节点为第<br>0<br>0 层，如果当前层数是偶数，从左至右输出当前层的节点值，否则，从右至左输出当前层的节点值。</p><p>我们依然可以沿用第 102 题的思想，修改广度优先搜索，对树进行逐层遍历，用队列维护当前层的所有元素，当队列不为空的时候，求得当前队列的长度 size，每次从队列中取出 size 个元素进行拓展，然后进行下一次迭代。</p><p>为了满足题目要求的返回值为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用「双端队列」的数据结构来维护当前层节点值输出的顺序。</p><p>双端队列是一个可以在队列任意一端插入元素的队列。在广度优先搜索遍历当前层节点拓展下一层节点的时候我们仍然从左往右按顺序拓展，但是对当前层节点的存储我们维护一个变量 isOrderLeft 记录是从左至右还是从右至左的：</p><p>如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。<br>如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。<br>当遍历结束的时候我们就得到了答案数组。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        bool isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            deque&lt;int&gt; levelList;</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                auto node = nodeQueue.front();</span><br><span class="line">                nodeQueue.pop();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.push_back(node-&gt;val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.push_front(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;left) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(vector&lt;int&gt;&#123;levelList.begin(), levelList.end()&#125;);</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        boolean isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; levelList = new LinkedList&lt;Integer&gt;();</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode curNode = nodeQueue.poll();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.offerLast(curNode.val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.offerFirst(curNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.left != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.right != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(new LinkedList&lt;Integer&gt;(levelList));</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var zigzagLevelOrder = function(root) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ans = [];</span><br><span class="line">    const nodeQueue = [root];</span><br><span class="line"></span><br><span class="line">    let isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">    while (nodeQueue.length) &#123;</span><br><span class="line">        let levelList = [];</span><br><span class="line">        const size = nodeQueue.length;</span><br><span class="line">        for (let i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">            const node = nodeQueue.shift();</span><br><span class="line">            if (isOrderLeft) &#123;</span><br><span class="line">                levelList.push(node.val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                levelList.unshift(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left !== null) &#123;</span><br><span class="line">                nodeQueue.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right !== null) &#123;</span><br><span class="line">                nodeQueue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">        ans.push(levelList);</span><br><span class="line">        isOrderLeft = !isOrderLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func zigzagLevelOrder(root *TreeNode) (ans [][]int) &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    for level := 0; len(queue) &gt; 0; level++ &#123;</span><br><span class="line">        vals := []int&#123;&#125;</span><br><span class="line">        q := queue</span><br><span class="line">        queue = nil</span><br><span class="line">        for _, node := range q &#123;</span><br><span class="line">            vals = append(vals, node.Val)</span><br><span class="line">            if node.Left != nil &#123;</span><br><span class="line">                queue = append(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            if node.Right != nil &#123;</span><br><span class="line">                queue = append(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 本质上和层序遍历一样，我们只需要把奇数层的元素翻转即可</span><br><span class="line">        if level%2 == 1 &#123;</span><br><span class="line">            for i, n := 0, len(vals); i &lt; n/2; i++ &#123;</span><br><span class="line">                vals[i], vals[n-1-i] = vals[n-1-i], vals[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, vals)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#define N 2000</span><br><span class="line"></span><br><span class="line">int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int** ans = malloc(sizeof(int*) * N);</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * N);</span><br><span class="line">    struct TreeNode* nodeQueue[N];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    nodeQueue[right++] = root;</span><br><span class="line">    bool isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int levelList[N * 2];</span><br><span class="line">        int front = N, rear = N;</span><br><span class="line">        int size = right - left;</span><br><span class="line">        for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">            struct TreeNode* node = nodeQueue[left++];</span><br><span class="line">            if (isOrderLeft) &#123;</span><br><span class="line">                levelList[rear++] = node-&gt;val;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                levelList[--front] = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;left) &#123;</span><br><span class="line">                nodeQueue[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right) &#123;</span><br><span class="line">                nodeQueue[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * (rear - front));</span><br><span class="line">        for (int i = 0; i &lt; rear - front; i++) &#123;</span><br><span class="line">            tmp[i] = levelList[i + front];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[*returnSize] = tmp;</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = rear - front;</span><br><span class="line">        (*returnSize)++;</span><br><span class="line">        isOrderLeft = !isOrderLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(N)，其中 N 为二叉树的节点数。每个节点会且仅会被遍历一次。<br>空间复杂度：<br>O(N)。我们需要维护存储节点的队列和存储节点值的双端队列，空间复杂度为 O(N)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>1162. 地图分析</title>
    <link href="http://yoursite.com/2022/09/22/1162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2022/09/22/1162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</id>
    <published>2022-09-22T06:00:12.000Z</published>
    <updated>2022-09-22T09:21:31.231Z</updated>
    
    <content type="html"><![CDATA[<p>你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。</p><p>请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。</p><span id="more"></span><p>[TOC]</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>示例 1：</p><pre><code>输入：grid = [[1,0,1],[0,0,0],[1,0,1]]输出：2解释： 海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。</code></pre><p>示例 2：</p><pre><code>输入：grid = [[1,0,0],[0,0,0],[0,0,0]]输出：4解释： 海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。</code></pre><p>提示：</p><pre><code>n == grid.lengthn == grid[i].length1 &lt;= n &lt;= 100grid[i][j] 不是 0 就是 1</code></pre><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>「离陆地区域最远」要求海洋区域距离它最近的陆地区域的曼哈顿距离是最大的。所以我们需要找一个海洋区域，满足它到陆地的最小距离是最大的。</p><h1 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑最朴素的方法，即求出每一个海洋区域（grid[i][j] &#x3D;&#x3D; 0 的区域）的「最近陆地区域」，然后记录下它们的距离，然后在这些距离里面取一个最大值。<br>对于一个给定的区域 (x,y) ，求它的「最近陆地区域」，可以使用广度优先搜索思想。我们把每个区域的坐标作以及这个区域与 (x,y) 的曼哈顿距离为搜索状态，即 Coordinate 结构体的 x、y 和 step 属性。findNearestLand 方法实现了广度优先搜索的过程，我们用一个 vis[u][v] 数组记录 (u,v) 区域是否被访问过，在拓展新状态的时候按照如下四个方向：<br>(x−1,y)<br>(x,y+1)<br>(x+1,y)<br>(x,y−1)<br>在这里我们可以把四个方向定义为常量增量数组 dx 和 dy。</p><p>思考：我们需不需要搜索到队列为空才停止 BFS ？ 答案是不需要。当我们搜索到一个新入队的区域它的 grid 值为 1，即这个区域是陆地区域的时候我们就可以停止搜索，因为 BFS 能保证当前的这个区域是最近的陆地区域（BFS 的性质决定了这里求出来的一定是最短路）。</p><p>findNearestLand如果我们找不不到任何一个点是陆地区域则返回 -1。最终我们把 ans 的初始值置为 -1，然后与所有的 BFS 结果取最大。</p><p>代码实现如下。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y, step;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int n, m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    bool vis[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    int findNearestLand(int x, int y) &#123;</span><br><span class="line">        memset(vis, 0, sizeof vis);</span><br><span class="line">        queue &lt;Coordinate&gt; q;</span><br><span class="line">        q.push(&#123;x, y, 0&#125;);</span><br><span class="line">        vis[x][y] = 1;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= m - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!vis[nx][ny]) &#123;</span><br><span class="line">                    q.push(&#123;nx, ny, f.step + 1&#125;);</span><br><span class="line">                    vis[nx][ny] = 1;</span><br><span class="line">                    if (a[nx][ny]) &#123;</span><br><span class="line">                        return f.step + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        this-&gt;m = grid.at(0).size();</span><br><span class="line">        a = grid;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, findNearestLand(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">    static int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    int n;</span><br><span class="line">    int[][] grid;</span><br><span class="line"></span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        this.n = grid.length;</span><br><span class="line">        this.grid = grid;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, findNearestLand(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int findNearestLand(int x, int y) &#123;</span><br><span class="line">        boolean[][] vis = new boolean[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;x, y, 0&#125;);</span><br><span class="line">        vis[x][y] = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!vis[nx][ny]) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;nx, ny, f[2] + 1&#125;);</span><br><span class="line">                    vis[nx][ny] = true;</span><br><span class="line">                    if (grid[nx][ny] == 1) &#123;</span><br><span class="line">                        return f[2] + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>我的另一种解法Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int max = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    max = Math.max(findNearestLand(i, j,grid), max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findNearestLand(int x, int y, int[][] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] vis=new int[n][n];</span><br><span class="line">        int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        int dis = 0;</span><br><span class="line">        Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;x, y&#125;);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            vis[x][y] = 2;</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                int[] index = queue.poll();</span><br><span class="line">                int prevX = index[0];</span><br><span class="line">                int prevY = index[1];</span><br><span class="line">                for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                    int nx = prevX + dirs[j][0];</span><br><span class="line">                    int ny = prevY + dirs[j][1];</span><br><span class="line">                    if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; vis[nx][ny] != 2) &#123;</span><br><span class="line">                        if (grid[nx][ny] == 1) &#123;</span><br><span class="line">                            dis++;</span><br><span class="line">                            return dis;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            vis[nx][ny] = 2;</span><br><span class="line">                            queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dis++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>## 复杂度分析<p>时间复杂度：该算法最多执行 n^2次 BFS，即我们考虑最坏情况所有的区域都是海洋，那么每一个区域都会进行 BFS。对于每一次 BFS，最坏的情况是找不到陆地区域，我们只能遍历完剩下的 n^2−1 个海洋区域，由于 vis 数组确保每个区域只被访问一次，所以单次 BFS 的渐进时间复杂度是 O(n^2)，程序的总的渐进时间复杂度是 O(n^4)。<br>空间复杂度：该算法使用了 vis 数组，渐进空间复杂度为 O(n^2)。</p><h1 id="方法二：多源最短路"><a href="#方法二：多源最短路" class="headerlink" title="方法二：多源最短路"></a>方法二：多源最短路</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实在方法一中我们已经发现我们 BFS 的过程是求最短路的过程，但是这里不是求某一个海洋区域到陆地区域的最短路，而是求所有的海洋区域到陆地区域这个「点集」的最短路。显然这不是一个「单源」最短路问题（SSSP）。在我们学习过的最短路算法中，求解 SSSP 问题的方法有 Dijkstra 算法和 SPFA算法，而求解任意两点之间的最短路一般使用 Floyd 算法。那我们在这里就应该使用 Floyd 算法吗？要考虑这个问题，我们需要分析一下这里使用 Floyd 算法的时间复杂度。我们知道在网格图中求最短路，每个区域（格子）相当于图中的顶点，而每个格子和上下左右四个格子的相邻关系相当于边，我们记顶点的个数为 V，Floyd 算法的时间复杂度为 O(V^3)，而这里 V&#x3D;n^2 ，所以<br>O(V^3)&#x3D;O(n^6)，显然是不现实的。</p><p>考虑 SSSP 是求一个源点到一个点集中所有点的最短路，而这个问题的本质是求某个点集到另一个点集中所有点的最短路，即「多源最短路」，我们只需要对 Dijkstra 算法或者 SPFA 算法稍作修改。这里以 Dijkstra 算法为例，我们知道堆优化的 Dijkstra 算法实际上是 BFS 的一个变形，把 BFS 中的队列变成了优先队列，在拓展新状态的时候加入了松弛操作。Dijkstra 的堆优化版本第一步是源点入队，我们只需要把它改成源点集合中的所有的点入队就可以实现求「多源最短路」。</p><p>思考：为什么？ 因为我们这样做相当于建立了一个超级源点 S，这个点与源点集中的<br>s0, s1,  ⋯s∣V∣<br>都有边，并且权都为 0。这样求源点集到目标点集的最短路就变成了求超级源点 S 到它们的最短路，于是又转化成了 SSSP 问题。</p><p>思考：海洋区域和陆地区域，应该哪一个作为源点集？ 也许你分析出「我们需要找一个海洋区域，满足它到陆地的最小距离是最大」会把海洋区域作为源点集。我们可以考虑后续的实现，我们知道 Dijkstra 中一个 d 数组用来维护当前源点集到其他点的最短路，而对于源点集中的任意一个点 s，d[s_x][s_y] &#x3D; 0，这很好理解，源点到源点的最短路就是 0。如果我们把海洋区域作为源点集、陆地区域作为目标点集，假设 t 是目标点集中的一个点，算法执行结束后 d[t_x][t_y] 就是海洋区域中的点到 t 的最短距离，但是我们却不知道哪些 t 是海洋区域的这些点的「最近陆地区域」，我们也不知道每个 s 距离它的「最近陆地区域」的曼哈顿距离。考虑我们把陆地区域作为源点集、海洋区域作为目标点集，目标点集中的点 t 对应的 d[t_x][t_y] 就是海洋区域 t 对应的距离它的「最近陆地区域」的曼哈顿距离，正是我们需要的，所以应该把陆地区域作为源点集。</p><h3 id="Dijkstra-版"><a href="#Dijkstra-版" class="headerlink" title="Dijkstra 版"></a>Dijkstra 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Status &#123;</span><br><span class="line">        int v, x, y;</span><br><span class="line">        bool operator &lt; (const Status &amp;rhs) const &#123;</span><br><span class="line">            return v &gt; rhs.v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;0, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.top(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (f.v + 1 &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f.v + 1;</span><br><span class="line">                    q.push(&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] status1, int[] status2) &#123;</span><br><span class="line">                return status1[0] - status2[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;0, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[1] + dx[i], ny = f[2] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (f[0] + 1 &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f[0] + 1;</span><br><span class="line">                    queue.offer(new int[]&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="多源-BFS-版"><a href="#多源-BFS-版" class="headerlink" title="多源 BFS 版"></a>多源 BFS 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    queue &lt;Coordinate&gt; q;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) continue;</span><br><span class="line">                if (d[nx][ny] &gt; d[f.x][f.y] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + 1;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f[0]][f[1]] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f[0]][f[1]] + 1;</span><br><span class="line">                    queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="SPFA-版"><a href="#SPFA-版" class="headerlink" title="SPFA 版"></a>SPFA 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    queue &lt;Coordinate&gt; q;</span><br><span class="line">    bool inq[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                    inq[i][j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop(); inq[f.x][f.y] = 0;</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f.x][f.y] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + 1;</span><br><span class="line">                    if (!inq[nx][ny]) &#123;</span><br><span class="line">                        q.push(&#123;nx, ny&#125;);</span><br><span class="line">                        inq[nx][ny] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        boolean[][] inq = new boolean[n][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    inq[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            inq[f[0]][f[1]] = false;</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f[0]][f[1]] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f[0]][f[1]] + 1;</span><br><span class="line">                    if (!inq[nx][ny]) &#123;</span><br><span class="line">                        queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                        inq[nx][ny] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：考虑这里的「多源最短路」的本质还是「单源最短路」，因此就是 Dijkstra 算法堆优化版本的渐进时间复杂度 O(ElogV)，这里 E 为边的个数，约等于<br>4n^2&#x2F;2 ，V 为顶点个数，约等于 n^2 ，所以这里的渐进时间复杂度为<br>O(n^2 logn^2 )&#x3D;O(n^2 logn)；在多源 BFS 当中，由于每个点只能被访问一次，渐进时间复杂度为<br>O(V+E)&#x3D;O(n^2)；SPFA 算法的理论渐进上界是 O(VE)&#x3D;O(n^2)，但是由于这里的边权都为 1，于是它退化成了 BFS，渐进时间复杂度 O(n^2)。<br>空间复杂度：该算法使用了 d 数组，渐进空间复杂度为 O(n^2)</p><h1 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>考虑优化方法二中的「把陆地区域作为源点集、海洋区域作为目标点集，求最短路」的过程。我们知道对于每个海洋区域 (x,y)，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x,y) 为 (x,y) 距离最近的陆地区域的曼哈顿距离，则我们可以推出这样的转移方程：</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>f(x,y)&#x3D;{ 0, (x,y)island<br>        min{f(x−1,y),f(x,y−1)}+1,(x,y)isocean</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>f(x,y)&#x3D;{ 0,(x,y)island<br>        min{f(x+1,y),f(x,y+1)}+1, (x,y)isocean</p><p>我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 INF，做完两个阶段的动态规划后，我们在所有的不为零的 f[i][j] 中比一个最大值即可，如果最终比较出的最大值为 INF，就返回 -1。</p><p>思考：如果用 f(x,y) 记录左上方的 DP 结果，g(x,y) 记录右下方的DP结果可行吗？ 答案是不可行。因为考虑距离点 (x,y) 最近的点可能既不来自左上方，也不来自右下方，比如它来自右上方，这个时候，第二阶段我们就需要用到第一阶段的计算结果。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    </span><br><span class="line">    int f[MAX_N][MAX_N];</span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;&amp; a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (a[i][j] ? 0 : INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i - 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = n - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i + 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i][j + 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans == INF) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] f = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = grid[i][j] == 1 ? 0 : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i - 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = n - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i + 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i][j + 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans == INF) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：从代码不难看出，这个算法的过程就是四个双重 for 循环，渐进时间复杂度为 O(n^2)。<br>空间复杂度：该算法使用了 f 数组，渐进空间复杂度为 O(n^2)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。&lt;/p&gt;
&lt;p&gt;请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://yoursite.com/2022/09/22/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/09/22/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-09-22T03:39:12.000Z</published>
    <updated>2022-09-22T05:55:54.531Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p>示例 2：</p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：[]</code></pre><p>提示：</p><pre><code>树中节点数目在范围 [0, 2000] 内-1000 &lt;= Node.val &lt;= 1000</code></pre><p>[TOC]</p><h1 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路^1"></a>解题思路<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/">^1</a></h1><p>本文将会讲解为什么这道题适合用广度优先搜索（BFS），以及 BFS 适用于什么样的场景。</p><p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p><p>如果我们使用 DFS&#x2F;BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。</p><p>本文包括以下内容：</p><p>DFS 与 BFS 的特点比较<br>BFS 的适用场景<br>如何用 BFS 进行层序遍历<br>如何用 BFS 求解最短路径问题</p><h1 id="DFS-与-BFS"><a href="#DFS-与-BFS" class="headerlink" title="DFS 与 BFS"></a>DFS 与 BFS</h1><p>让我们先看看在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。</p><p>DFS 遍历使用递归：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void bfs(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()</span><br><span class="line">        if (node.left != null) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right != null) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。<p>虽然 DFS 与 BFS 都是将二叉树的所有结点遍历了一遍，但它们遍历结点的顺序不同。</p><p>这个遍历顺序也是 BFS 能够用来解「层序遍历」、「最短路径」问题的根本原因。下面，我们结合几道例题来讲讲 BFS 是如何求解层序遍历和最短路径问题的。</p><p>BFS 的应用一：层序遍历</p><p>BFS 的层序遍历应用就是本题了：</p><p>LeetCode 102. Binary Tree Level Order Traversal 二叉树的层序遍历（Medium）</p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：<br>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。<br>那么，怎么给 BFS 遍历的结果分层呢？我们首先来观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：</p><p>截取 BFS 遍历过程中的某个时刻：</p><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的n 个结点。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 二叉树的层序遍历</span><br><span class="line">void bfs(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            // 变量 i 无实际意义，只是为了循环 n 次</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。<p>最终我们得到的题解代码为：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="BFS-的应用二：最短路径"><a href="#BFS-的应用二：最短路径" class="headerlink" title="BFS 的应用二：最短路径"></a>BFS 的应用二：最短路径</h1><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><h2 id="小贴士："><a href="#小贴士：" class="headerlink" title="小贴士："></a>小贴士：</h2><p>很多同学一看到「最短路径」，就条件反射地想到「Dijkstra 算法」。为什么 BFS 遍历也能找到最短路径呢？</p><p>这是因为，Dijkstra 算法解决的是带权最短路径问题，而我们这里关注的是无权最短路径问题。也可以看成每条边的权重都是 1。这样的最短路径问题，用 BFS 求解就行了。</p><p>在面试中，你可能更希望写 BFS 而不是 Dijkstra。毕竟，敢保证自己能写对 Dijkstra 算法的人不多。</p><p>最短路径问题属于图算法。由于图的表示和描述比较复杂，本文用比较简单的网格结构代替。网格结构是一种特殊的图，它的表示和遍历都比较简单，适合作为练习题。在 LeetCode 中，最短路径问题也以网格结构为主。</p><h1 id="最短路径例题讲解"><a href="#最短路径例题讲解" class="headerlink" title="最短路径例题讲解"></a>最短路径例题讲解</h1><p>LeetCode 1162. As Far from Land as Possible 离开陆地的最远距离（Medium）<a href="https://leetcode.cn/problems/as-far-from-land-as-possible/">^2</a></p><p>你现在手里有一份大小为 n×n 的地图网格 grid，上面的每个单元格都标记为 0 或者 1，其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」。(x0 ,y0 ) 和 (x1,y1)这两个区域之间的距离是 ∣x0−x1∣+∣y0−y1∣ 。</p><p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p><p>这道题就是一个在网格结构中求最短路径的问题。同时，它也是一个「岛屿问题」，即用网格中的 1 和 0 表示陆地和海洋，模拟出若干个岛屿。</p><p>在上一篇文章中，我们介绍了网格结构的基本概念，以及网格结构中的 DFS 遍历。其中一些概念和技巧也可以用在 BFS 遍历中：</p><p>格子 (r, c) 的相邻四个格子为：(r-1, c)、(r+1, c)、(r, c-1) 和 (r, c+1)；<br>使用函数 inArea 判断当前格子的坐标是否在网格范围内；<br>将遍历过的格子标记为 2，避免重复遍历。<br>对于网格结构的性质、网格结构的 DFS 遍历技巧不是很了解的同学，可以复习一下上一篇文章：LeetCode 例题精讲 | 12 岛屿问题：网格结构中的 DFS。</p><p>上一篇文章讲过了网格结构 DFS 遍历，这篇文章正好讲解一下网格结构的 BFS 遍历。要解最短路径问题，我们首先要写出层序遍历的代码，仿照上面的二叉树层序遍历代码，类似地可以写出网格层序遍历：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 网格结构的层序遍历</span><br><span class="line">// 从格子 (i, j) 开始遍历</span><br><span class="line">void bfs(int[][] grid, int i, int j) &#123;</span><br><span class="line">    Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(new int[]&#123;r, c&#125;);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            int[] node = queue.poll();</span><br><span class="line">            int r = node[0];</span><br><span class="line">            int c = node[1];</span><br><span class="line">            if (r-1 &gt;= 0 &amp;&amp; grid[r-1][c] == 0) &#123;</span><br><span class="line">                grid[r-1][c] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r-1, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (r+1 &lt; N &amp;&amp; grid[r+1][c] == 0) &#123;</span><br><span class="line">                grid[r+1][c] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r+1, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (c-1 &gt;= 0 &amp;&amp; grid[r][c-1] == 0) &#123;</span><br><span class="line">                grid[r][c-1] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r, c-1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (c+1 &lt; N &amp;&amp; grid[r][c+1] == 0) &#123;</span><br><span class="line">                grid[r][c+1] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r, c+1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>以上的层序遍历代码有几个注意点：</p><p>队列中的元素类型是 int[] 数组，每个数组的长度为 2，包含格子的行坐标和列坐标。<br>为了避免重复遍历，这里使用到了和 DFS 遍历一样的技巧：把已遍历的格子标记为 2。注意：我们在将格子放入队列之前就将其标记为 2。想一想，这是为什么？<br>在将格子放入队列之前就检查其坐标是否在网格范围内，避免将「不存在」的格子放入队列。<br>这段网格遍历代码还有一些可以优化的地方。由于一个格子有四个相邻的格子，代码中判断了四遍格子坐标的合法性，代码稍微有点啰嗦。我们可以用一个 moves 数组存储相邻格子的四个方向：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">int[][] moves = &#123;</span><br><span class="line">    &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>然后把四个 if 判断变成一个循环：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int[][] move : moves) &#123;</span><br><span class="line">    int r2 = r + move[0];</span><br><span class="line">    int c2 = c + move[1];</span><br><span class="line">    if (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == 0) &#123;</span><br><span class="line">        grid[r2][c2] = 2;</span><br><span class="line">        queue.add(new int[]&#123;r2, c2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>写好了层序遍历的代码，接下来我们看看如何来解决本题中的最短路径问题。</p><p>这道题要找的是距离陆地最远的海洋格子。假设网格中只有一个陆地格子，我们可以从这个陆地格子出发做层序遍历，直到所有格子都遍历完。最终遍历了几层，海洋格子的最远距离就是几。<br>那么有多个陆地格子的时候怎么办呢？一种方法是将每个陆地格子都作为起点做一次层序遍历，但是这样的时间开销太大。</p><p>BFS 完全可以以多个格子同时作为起点。我们可以把所有的陆地格子同时放入初始队列，然后开始层序遍历，这样遍历的效果如下图所示：<br>这种遍历方法实际上叫做「多源 BFS」。多源 BFS 的定义不是今天讨论的重点，你只需要记住多源 BFS 很方便，只需要把多个源点同时放入初始队列即可。</p><p>需要注意的是，虽然上面的图示用 1、2、3、4 表示层序遍历的层数，但是在代码中，我们不需要给每个遍历到的格子标记层数，只需要用一个 distance 变量记录当前的遍历的层数（也就是到陆地格子的距离）即可。</p><p>最终，我们得到的题解代码为：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public int maxDistance(int[][] grid) &#123;</span><br><span class="line">    int N = grid.length;</span><br><span class="line"></span><br><span class="line">    Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    // 将所有的陆地格子加入队列</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                queue.add(new int[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果地图上只有陆地或者海洋，返回 -1</span><br><span class="line">    if (queue.isEmpty() || queue.size() == N * N) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[][] moves = &#123;</span><br><span class="line">        &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int distance = -1; // 记录当前遍历的层数（距离）</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        distance++;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            int[] node = queue.poll();</span><br><span class="line">            int r = node[0];</span><br><span class="line">            int c = node[1];</span><br><span class="line">            for (int[] move : moves) &#123;</span><br><span class="line">                int r2 = r + move[0];</span><br><span class="line">                int c2 = c + move[1];</span><br><span class="line">                if (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == 0) &#123;</span><br><span class="line">                    grid[r2][c2] = 2;</span><br><span class="line">                    queue.add(new int[]&#123;r2, c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断坐标 (r, c) 是否在网格中</span><br><span class="line">boolean inArea(int[][] grid, int r, int c) &#123;</span><br><span class="line">    return 0 &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到，「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。</p><p>BFS 遍历是一类很值得反复体会和练习的题目。一方面，BFS 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 BFS 遍历。</p><p>本文讲解的只是两道非常典型的例题。LeetCode 中还有许多层序遍历和最短路径的题目</p><p>层序遍历的一些变种题目：</p><p>LeetCode 103. Binary Tree Zigzag Level Order Traversal 之字形层序遍历<br>LeetCode 199. Binary Tree Right Side View 找每一层的最右结点<br>LeetCode 515. Find Largest Value in Each Tree Row 计算每一层的最大值<br>LeetCode 637. Average of Levels in Binary Tree 计算每一层的平均值</p><p>对于最短路径问题，还有两道题目也是求网格结构中的最短路径，和我们讲解的距离岛屿的最远距离非常类似：</p><p>LeetCode 542. 01 Matrix<br>LeetCode 994. Rotting Oranges<br>还有一道在真正的图结构中求最短路径的问题：</p><p>LeetCode 310. Minimum Height Trees<br>经过了本文的讲解，相信解决这些题目也不是难事。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="http://yoursite.com/2022/09/21/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2022/09/21/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-09-21T03:15:12.000Z</published>
    <updated>2022-09-25T13:06:27.605Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><span id="more"></span><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：true</code></pre><p>示例 2：</p><pre><code>输入：root = [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：true</code></pre><p>提示：</p><pre><code>树中的节点数在范围 [0, 5000] 内-104 &lt;= Node.val &lt;= 104</code></pre><p>[TOC]</p><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode.cn/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/">^1</a></h1><p>这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。</p><h1 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h1><p>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：</p><p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过<br>1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.max(height(root.left), height(root.right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><pre><code>class Solution &#123;    public boolean isBalanced(TreeNode root) &#123;        if (root == null) &#123;            return true;        &#125; else &#123;            return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);        &#125;    &#125;    public int height(TreeNode root) &#123;        if (root == null) &#123;            return 0;        &#125; else &#123;            return Math.max(height(root.left), height(root.right)) + 1;        &#125;    &#125;&#125;</code></pre></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isBalanced(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        def height(root: TreeNode) -&gt; int:</span><br><span class="line">            if not root:</span><br><span class="line">                return 0</span><br><span class="line">            return max(height(root.left), height(root.right)) + 1</span><br><span class="line"></span><br><span class="line">        if not root:</span><br><span class="line">            return True</span><br><span class="line">        return abs(height(root.left) - height(root.right)) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><pre><code>int height(struct TreeNode* root) &#123;    if (root == NULL) &#123;        return 0;    &#125; else &#123;        return fmax(height(root-&gt;left), height(root-&gt;right)) + 1;    &#125;&#125;bool isBalanced(struct TreeNode* root) &#123;    if (root == NULL) &#123;        return true;    &#125; else &#123;        return fabs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);    &#125;&#125;</code></pre></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func isBalanced(root *TreeNode) bool &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return abs(height(root.Left) - height(root.Right)) &lt;= 1 &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func height(root *TreeNode) int &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    return max(height(root.Left), height(root.Right)) + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func abs(x int) int &#123;</span><br><span class="line">    if x &lt; 0 &#123;</span><br><span class="line">        return -1 * x</span><br><span class="line">    &#125;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。<br>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。<br>对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足<br>O(h)&#x3D;O(logn)，因为 d≤h，所以总时间复杂度为O(nlogn)。对于最坏的情况，二叉树形成链式结构，高度为O(n)，此时总时间复杂度为</p><p>空间复杂度：<br>O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p><h1 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h1><p>方法一由于是自顶向下递归，因此对于同一个节点，函数<br>height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数<br>height 只会被调用一次。</p><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return height(root) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = height(root.left);</span><br><span class="line">        int rightHeight = height(root.right);</span><br><span class="line">        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.max(leftHeight, rightHeight) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><pre><code>class Solution &#123;public:    int height(TreeNode* root) &#123;        if (root == NULL) &#123;            return 0;        &#125;        int leftHeight = height(root-&gt;left);        int rightHeight = height(root-&gt;right);        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) &#123;            return -1;        &#125; else &#123;            return max(leftHeight, rightHeight) + 1;        &#125;    &#125;    bool isBalanced(TreeNode* root) &#123;        return height(root) &gt;= 0;    &#125;&#125;;</code></pre></details><details>    <summary>Python</summary><pre><code>class Solution &#123;public:    int height(TreeNode* root) &#123;        if (root == NULL) &#123;            return 0;        &#125;        int leftHeight = height(root-&gt;left);        int rightHeight = height(root-&gt;right);        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) &#123;            return -1;        &#125; else &#123;            return max(leftHeight, rightHeight) + 1;        &#125;    &#125;    bool isBalanced(TreeNode* root) &#123;        return height(root) &gt;= 0;    &#125;&#125;;</code></pre></details><details>    <summary>C</summary><pre><code>int height(struct TreeNode* root) &#123;    if (root == NULL) &#123;        return 0;    &#125;    int leftHeight = height(root-&gt;left);    int rightHeight = height(root-&gt;right);    if (leftHeight == -1 || rightHeight == -1 || fabs(leftHeight - rightHeight) &gt; 1) &#123;        return -1;    &#125; else &#123;        return fmax(leftHeight, rightHeight) + 1;    &#125;&#125;bool isBalanced(struct TreeNode* root) &#123;    return height(root) &gt;= 0;&#125;</code></pre></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func isBalanced(root *TreeNode) bool &#123;</span><br><span class="line">    return height(root) &gt;= 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func height(root *TreeNode) int &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    leftHeight := height(root.Left)</span><br><span class="line">    rightHeight := height(root.Right)</span><br><span class="line">    if leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1 &#123;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">    return max(leftHeight, rightHeight) + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func abs(x int) int &#123;</span><br><span class="line">    if x &lt; 0 &#123;</span><br><span class="line">        return -1 * x</span><br><span class="line">    &#125;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中<br>n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是<br>O(n)。</p><p>空间复杂度：<br>O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口专题练习</title>
    <link href="http://yoursite.com/2022/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2022/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0/</id>
    <published>2022-09-21T03:15:12.000Z</published>
    <updated>2022-09-25T13:07:45.350Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口专题及模板</p><span id="more"></span><p>[TOC]</p><p>从 3. 无重复字符的最长子串 开始滑动窗口专题：</p><p>这道题主要用到思路是：滑动窗口 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/">^1</a></p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：O(n)</p><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        if not s:return 0</span><br><span class="line">        left = 0</span><br><span class="line">        lookup = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = 0</span><br><span class="line">        cur_len = 0</span><br><span class="line">        for i in range(n):</span><br><span class="line">            cur_len += 1</span><br><span class="line">            while s[i] in lookup:</span><br><span class="line">                lookup.remove(s[left])</span><br><span class="line">                left += 1</span><br><span class="line">                cur_len -= 1</span><br><span class="line">            if cur_len &gt; max_len:max_len = cur_len</span><br><span class="line">            lookup.add(s[i])</span><br><span class="line">        return max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if (s.length()==0) return 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        int max = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        if(s.size() == 0) return 0;</span><br><span class="line">        unordered_set&lt;char&gt; lookup;</span><br><span class="line">        int maxStr = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            while (lookup.find(s[i]) != lookup.end())&#123;</span><br><span class="line">                lookup.erase(s[left]);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxStr = max(maxStr,i-left+1);</span><br><span class="line">            lookup.insert(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        return maxStr;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>滑动窗口题目:</p><ol start="3"><li><p>无重复字符的最长子串</p></li><li><p>串联所有单词的子串</p></li><li><p>最小覆盖子串 <a href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></p></li><li><p>至多包含两个不同字符的最长子串</p></li><li><p>长度最小的子数组</p></li><li><p>滑动窗口最大值</p></li><li><p>字符串的排列</p></li><li><p>最小区间</p></li><li><p>最小窗口子序列</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;滑动窗口专题及模板&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>239. 滑动窗口最大值</title>
    <link href="http://yoursite.com/2022/09/21/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2022/09/21/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2022-09-20T17:12:12.000Z</published>
    <updated>2022-09-21T09:24:44.884Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><span id="more"></span><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p>示例:</p><pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] </code></pre><p>解释: </p><pre><code>  滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7 </code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^41 &lt;= k &lt;= nums.length</code></pre><p>[TOC]</p><h1 id="我的解法："><a href="#我的解法：" class="headerlink" title="我的解法："></a>我的解法：</h1><p>我首先想到的是用一个max保存窗口中的最大值，每次滑动窗口时都更新一下max并放到结果数组中，但是遇到问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试用例:[1,-1]</span><br><span class="line">1</span><br><span class="line">测试结果:[1,1]</span><br><span class="line">期望结果:[1,-1]</span><br></pre></td></tr></table></figure><p>是因为没有考虑到滑动到新窗口时如果原来的最大值恰好是原窗口的首个这种情况，需要把原来的最大值去掉，然后找到剩余元素的最大值，再去更新新窗口中的最大值。</p><details>    <summary>我的解法Java版</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int[] res = new int[nums.length - k + 1];</span><br><span class="line">        int max = findMax(nums, 0, k - 1);</span><br><span class="line">        res[0]=max;</span><br><span class="line">        int index = 1;</span><br><span class="line">        for (int i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (max == nums[i - k]) &#123;</span><br><span class="line">                max = findMax(nums, i - k + 1, i - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            res[index++] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int findMax(int[] nums, int begin, int end) &#123;</span><br><span class="line">        int max=Integer.MIN_VALUE;</span><br><span class="line">        for (int i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>哈哈哈通过了，这道Hard的题目只改了一次就过了，前所未有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info</span><br><span class="line">解答成功:</span><br><span class="line">执行耗时:4 ms,击败了92.27% 的Java用户</span><br><span class="line">内存消耗:51.1 MB,击败了6.67% 的Java用户</span><br></pre></td></tr></table></figure><p>但2022年时再用此方法就超时了。两年没做再做犯的错误还是一模一样。</p><h1 id="方法一：暴力法-1"><a href="#方法一：暴力法-1" class="headerlink" title="方法一：暴力法^1"></a>方法一：暴力法<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/">^1</a></h1><p><strong>直觉</strong></p><p>最简单直接的方法是遍历每个滑动窗口，找到每个窗口的最大值。一共有  <code>N - k + 1</code> 个滑动窗口，每个有 <code>k</code> 个元素，于是算法的时间复杂度为 *O(N k)*，表现较差。</p><p><strong>实现</strong></p><details>    <summary>暴力解法Python版</summary><figure class="highlight python"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="string">&#x27;List[int]&#x27;</span>, k: <span class="string">&#x27;int&#x27;</span></span>) -&gt; <span class="string">&#x27;List[int]&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(nums[i:i + k]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力解法Java版</summary>    <figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> [] output = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; i + k; j++) </span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">            output[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N k)*。其中 <code>N</code> 为数组中元素个数。</p></li><li><p>空间复杂度：*O(N - k + 1)*，用于输出数组。</p><br /><br /></li></ul><hr><h1 id="方法二：双向队列"><a href="#方法二：双向队列" class="headerlink" title="方法二：双向队列"></a>方法二：双向队列</h1><p><strong>直觉</strong></p><p>如何优化时间复杂度呢？首先想到的是使用<strong>堆</strong>，因为在最大堆中 <code>heap[0]</code> 永远是最大的元素。在大小为 <code>k</code> 的堆中插入一个元素消耗log(k) 时间，因此算法的时间复杂度为 O(Nlog(k))。</p><blockquote><p>能否得到只要 <em>O(N)</em> 的算法？</p></blockquote><p>我们可以使用<strong>双向队列</strong>，该数据结构可以从两端以常数时间压入&#x2F;弹出元素。</p><p>存储双向队列的索引比存储元素更方便，因为两者都能在数组解析中使用。</p><p><strong>算法</strong></p><p>算法非常直截了当：</p><ul><li><p>处理前 <code>k</code> 个元素，初始化双向队列。</p></li><li><p>遍历整个数组。在每一步 :</p><p>  清理双向队列 :</p><pre><code>  - 只保留当前滑动窗口中有的元素的索引。  - 移除比当前元素小的所有元素，它们不可能是最大的。</code></pre></li></ul><ul><li>将当前元素添加到双向队列中。</li><li>将 <code>deque[0]</code> 添加到输出中。</li><li>返回输出数组。</li></ul><p><strong>实现</strong></p><details>    <summary>双向队列Python实现</summary><figure class="highlight python"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="string">&#x27;List[int]&#x27;</span>, k: <span class="string">&#x27;int&#x27;</span></span>) -&gt; <span class="string">&#x27;List[int]&#x27;</span>:</span><br><span class="line">        <span class="comment"># base cases</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">clean_deque</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># remove indexes of elements not from sliding window</span></span><br><span class="line">            <span class="keyword">if</span> deq <span class="keyword">and</span> deq[<span class="number">0</span>] == i - k:</span><br><span class="line">                deq.popleft()</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># remove from deq indexes of all elements </span></span><br><span class="line">            <span class="comment"># which are smaller than current element nums[i]</span></span><br><span class="line">            <span class="keyword">while</span> deq <span class="keyword">and</span> nums[i] &gt; nums[deq[-<span class="number">1</span>]]:</span><br><span class="line">                deq.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># init deque and output</span></span><br><span class="line">        deq = deque()</span><br><span class="line">        max_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            clean_deque(i)</span><br><span class="line">            deq.append(i)</span><br><span class="line">            <span class="comment"># compute max in nums[:k]</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[max_idx]:</span><br><span class="line">                max_idx = i</span><br><span class="line">        output = [nums[max_idx]]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build output</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            clean_deque(i)          </span><br><span class="line">            deq.append(i)</span><br><span class="line">            output.append(nums[deq[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></details><details>    <summary>双向队列Java实现</summary>    <figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  ArrayDeque&lt;Integer&gt; deq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">  <span class="type">int</span> [] nums;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean_deque</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// remove indexes of elements not from sliding window</span></span><br><span class="line">    <span class="keyword">if</span> (!deq.isEmpty() &amp;&amp; deq.getFirst() == i - k)</span><br><span class="line">      deq.removeFirst();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove from deq indexes of all elements </span></span><br><span class="line">    <span class="comment">// which are smaller than current element nums[i]</span></span><br><span class="line">    <span class="keyword">while</span> (!deq.isEmpty() &amp;&amp; nums[i] &gt; nums[deq.getLast()])   </span><br><span class="line">    deq.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init deque and output</span></span><br><span class="line">    <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max_idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      clean_deque(i, k);</span><br><span class="line">      deq.addLast(i);</span><br><span class="line">      <span class="comment">// compute max in nums[:k]</span></span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[max_idx]) max_idx = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> [] output = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    output[<span class="number">0</span>] = nums[max_idx];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> k; i &lt; n; i++) &#123;</span><br><span class="line">      clean_deque(i, k);</span><br><span class="line">      deq.addLast(i);</span><br><span class="line">      output[i - k + <span class="number">1</span>] = nums[deq.getFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。</p></li><li><p>空间复杂度：*O(N)*，输出数组使用了 <em>O(N - k + 1)</em> 空间，双向队列使用了 *O(k)*。</p><br /><br /></li></ul><hr><h1 id="方法三-动态规划"><a href="#方法三-动态规划" class="headerlink" title="方法三: 动态规划"></a>方法三: 动态规划</h1><p><strong>直觉</strong></p><p>这是另一个 <em>{O}(N)</em> 的算法。本算法的优点是不需要使用 <code>数组 / 列表</code> 之外的任何数据结构。</p><p>算法的思想是将输入数组分割成有 <code>k</code> 个元素的块。<br>若 <code>n % k != 0</code>，则最后一块的元素个数可能更少。</p><p> <a href="https://pic.leetcode-cn.com/95c5c42bcedb9c417b96925e5204e5bdad34456e29bd1b61a41138abd80e4b0b-image.png">image.png</a></p><p>开头元素为 <code>i</code> ，结尾元素为 <code>j</code> 的当前滑动窗口可能在一个块内，也可能在两个块中。</p><p> <a href="https://pic.leetcode-cn.com/27af2b52e80803bcb7a8285dbd27cfa9292a6cf6dd0a6454454d6d3357da15c6-image.png">image.png</a></p><p>情况 <code>1</code> 比较简单。 建立数组 <code>left</code>， 其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向 <code>左-&gt;右</code>。</p><p> <a href="https://pic.leetcode-cn.com/79cbfbefc4c891c337f6b5de8c29f9d3ab39883c92c084a46163f2fa4f0f1d37-image.png">image.png</a></p><p>为了处理更复杂的情况 <code>2</code>，我们需要数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向 <code>右-&gt;左</code>。<code>right</code> 数组和 <code>left</code> 除了方向不同以外基本一致。</p><p> <a href="https://pic.leetcode-cn.com/b404188e760dd82a2bd4ebf4f6fe2e8b3c229bb506ed2f3cc8a01675744c351b-image.png">image.png</a></p><p>两数组一起可以提供两个块内元素的全部信息。考虑从下标 <code>i</code> 到下标 <code>j</code>的滑动窗口。 根据定义，<code>right[i]</code> 是<strong>左侧块内的最大元素</strong>， <code>left[j]</code> 是<strong>右侧块内的最大元素</strong>。因此滑动窗口中的最大元素为 <code>max(right[i], left[j])</code>。</p><p> <a href="https://pic.leetcode-cn.com/3074f1eb068151ebdebbf1b605234815c64d0bf7812d33c8eb5ba044ab625300-image.png">image.png</a></p><p>说实话我一开始看到这个方法有点儿迷糊，但重点理解<code>right[i]</code> 是<strong>左侧块内的最大元素</strong>， <code>left[j]</code> 是<strong>右侧块内的最大元素</strong>，配合下面的图解就能轻松理解了。</p><p><strong>算法</strong></p><p>算法十分直截了当：</p><ul><li><p>从左到右遍历数组，建立数组 <code>left</code>。</p></li><li><p>从右到左遍历数组，建立数组 <code>right</code>。</p></li><li><p>建立输出数组 <code>max(right[i], left[i + k - 1])</code>，其中 <code>i</code> 取值范围为 <code>(0, n - k + 1)</code>。</p></li></ul><p><strong>实现</strong></p><p>  <a href="https://pic.leetcode-cn.com/e793d5c8ede0be91804b291f1565ab90c980371879d6ec683d0a05c1b4f7e984-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/4a699746334bfd5548a8a2a920e5bcd2b2922f6c39ca0bf2a52bc741a8b9c10d-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/f20d788625572649bd3def127aafdd287eb9d958fdb7e8323183980a4721f7aa-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/df789ba3e0741df8493eaedbbb5cc483a5805e7f4fc65a5a16436749a29bd08b-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/f060cabc30a2f902c9be177070a68df07e9a1586aff921c4243dbc376c276738-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/263dd3579de8f15c38164db0e7c506d9269c657c34f50dff0512469867a26f78-image.png">image.png</a> </p><details>    <summary>动态规划Python</summary><figure class="highlight python"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="string">&#x27;List[int]&#x27;</span>, k: <span class="string">&#x27;int&#x27;</span></span>) -&gt; <span class="string">&#x27;List[int]&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        left = [<span class="number">0</span>] * n</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        right = [<span class="number">0</span>] * n</span><br><span class="line">        right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># from left to right</span></span><br><span class="line">            <span class="keyword">if</span> i % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block start</span></span><br><span class="line">                left[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left[i] = <span class="built_in">max</span>(left[i - <span class="number">1</span>], nums[i])</span><br><span class="line">            <span class="comment"># from right to left</span></span><br><span class="line">            j = n - i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block end</span></span><br><span class="line">                right[j] = nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right[j] = <span class="built_in">max</span>(right[j + <span class="number">1</span>], nums[j])</span><br><span class="line">        </span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k + <span class="number">1</span>):</span><br><span class="line">            output.append(<span class="built_in">max</span>(left[i + k - <span class="number">1</span>], right[i]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary>    <figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> [] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> [] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// from left to right</span></span><br><span class="line">      <span class="keyword">if</span> (i % k == <span class="number">0</span>) left[i] = nums[i];  <span class="comment">// block_start</span></span><br><span class="line">      <span class="keyword">else</span> left[i] = Math.max(left[i - <span class="number">1</span>], nums[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// from right to left</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ((j + <span class="number">1</span>) % k == <span class="number">0</span>) right[j] = nums[j];  <span class="comment">// block_end</span></span><br><span class="line">      <span class="keyword">else</span> right[j] = Math.max(right[j + <span class="number">1</span>], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> [] output = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++)</span><br><span class="line">      output[i] = Math.max(left[i + k - <span class="number">1</span>], right[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：*O(N)*，我们对长度为 <code>N</code> 的数组处理了 <code>3</code>次。 </p></li><li><p>空间复杂度：*O(N)*，用于存储长度为 <code>N</code> 的 <code>left</code> 和 <code>right</code> 数组，以及长度为 <code>N - k + 1</code>的输出数组。</p></li></ul><h1 id="方法四：-优先队列-2"><a href="#方法四：-优先队列-2" class="headerlink" title="方法四： 优先队列^2"></a>方法四： 优先队列<a href="https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/">^2</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p><p>对于本题而言，初始时，我们将数组 nums 的前 k 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 nums 中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。</p><p>我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组<br>(num,index)，表示元素 num 在数组中的下标为 index。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        PriorityQueue&lt;int[]&gt; pq=new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">                return o1[0] != o2[0] ? o2[0]-o1[0] : o2[1]-o1[1];// 大根堆o1[1]-o2[1]也可以</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            pq.offer(new int[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ans = new int[n - k + 1];</span><br><span class="line">        ans[0]=pq.peek()[0];</span><br><span class="line">        for (int i = k; i &lt; n; i++) &#123;</span><br><span class="line">            pq.offer(new int[]&#123;nums[i], i&#125;);</span><br><span class="line">            while (pq.peek()[1] &lt;= i - k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i - k + 1] = pq.peek()[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans = &#123;q.top().first&#125;;</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">            while (q.top().second &lt;= i - k) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        # 注意 Python 默认的优先队列是小根堆</span><br><span class="line">        q = [(-nums[i], i) for i in range(k)]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line"></span><br><span class="line">        ans = [-q[0][0]]</span><br><span class="line">        for i in range(k, n):</span><br><span class="line">            heapq.heappush(q, (-nums[i], i))</span><br><span class="line">            while q[0][1] &lt;= i - k:</span><br><span class="line">                heapq.heappop(q)</span><br><span class="line">            ans.append(-q[0][0])</span><br><span class="line">        </span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">type hp struct&#123; sort.IntSlice &#125;</span><br><span class="line">func (h hp) Less(i, j int) bool  &#123; return a[h.IntSlice[i]] &gt; a[h.IntSlice[j]] &#125;</span><br><span class="line">func (h *hp) Push(v interface&#123;&#125;) &#123; h.IntSlice = append(h.IntSlice, v.(int)) &#125;</span><br><span class="line">func (h *hp) Pop() interface&#123;&#125;   &#123; a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v &#125;</span><br><span class="line"></span><br><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    a = nums</span><br><span class="line">    q := &amp;hp&#123;make([]int, k)&#125;</span><br><span class="line">    for i := 0; i &lt; k; i++ &#123;</span><br><span class="line">        q.IntSlice[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(q)</span><br><span class="line"></span><br><span class="line">    n := len(nums)</span><br><span class="line">    ans := make([]int, 1, n-k+1)</span><br><span class="line">    ans[0] = nums[q.IntSlice[0]]</span><br><span class="line">    for i := k; i &lt; n; i++ &#123;</span><br><span class="line">        heap.Push(q, i)</span><br><span class="line">        for q.IntSlice[0] &lt;= i-k &#123;</span><br><span class="line">            heap.Pop(q)</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, nums[q.IntSlice[0]])</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">void swap(int** a, int** b) &#123;</span><br><span class="line">    int* tmp = *a;</span><br><span class="line">    *a = *b, *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(int* a, int* b) &#123;</span><br><span class="line">    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Heap &#123;</span><br><span class="line">    int** heap;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void init(struct Heap* obj, int capacity) &#123;</span><br><span class="line">    obj-&gt;size = 0;</span><br><span class="line">    obj-&gt;heap = NULL;</span><br><span class="line">    obj-&gt;capacity = capacity;</span><br><span class="line">    obj-&gt;heap = malloc(sizeof(int*) * (obj-&gt;capacity + 1));</span><br><span class="line">    for (int i = 1; i &lt;= obj-&gt;capacity; i++) &#123;</span><br><span class="line">        obj-&gt;heap[i] = malloc(sizeof(int) * 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setFree(struct Heap* obj) &#123;</span><br><span class="line">    for (int i = 1; i &lt;= obj-&gt;capacity; i++) &#123;</span><br><span class="line">        free(obj-&gt;heap[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(obj-&gt;heap);</span><br><span class="line">    free(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(struct Heap* obj, int num0, int num1) &#123;</span><br><span class="line">    int sub1 = ++(obj-&gt;size), sub2 = sub1 &gt;&gt; 1;</span><br><span class="line">    (obj-&gt;heap[sub1])[0] = num0, (obj-&gt;heap[sub1])[1] = num1;</span><br><span class="line">    while (sub2 &gt; 0 &amp;&amp; cmp(obj-&gt;heap[sub2], obj-&gt;heap[sub1]) &lt; 0) &#123;</span><br><span class="line">        swap(&amp;(obj-&gt;heap[sub1]), &amp;(obj-&gt;heap[sub2]));</span><br><span class="line">        sub1 = sub2, sub2 = sub1 &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pop(struct Heap* obj) &#123;</span><br><span class="line">    int sub = 1;</span><br><span class="line">    swap(&amp;(obj-&gt;heap[sub]), &amp;(obj-&gt;heap[(obj-&gt;size)--]));</span><br><span class="line">    while (sub &lt;= obj-&gt;size) &#123;</span><br><span class="line">        int sub1 = sub &lt;&lt; 1, sub2 = sub &lt;&lt; 1 | 1;</span><br><span class="line">        int maxSub = sub;</span><br><span class="line">        if (sub1 &lt;= obj-&gt;size &amp;&amp; cmp(obj-&gt;heap[maxSub], obj-&gt;heap[sub1]) &lt; 0) &#123;</span><br><span class="line">            maxSub = sub1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sub2 &lt;= obj-&gt;size &amp;&amp; cmp(obj-&gt;heap[maxSub], obj-&gt;heap[sub2]) &lt; 0) &#123;</span><br><span class="line">            maxSub = sub2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sub == maxSub) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;(obj-&gt;heap[sub]), &amp;(obj-&gt;heap[maxSub]));</span><br><span class="line">        sub = maxSub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* top(struct Heap* obj) &#123;</span><br><span class="line">    return obj-&gt;heap[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) &#123;</span><br><span class="line">    struct Heap* q = malloc(sizeof(struct Heap));</span><br><span class="line">    init(q, numsSize);</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        push(q, nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    int* ans = malloc(sizeof(int) * (numsSize - k + 1));</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    ans[(*returnSize)++] = top(q)[0];</span><br><span class="line"></span><br><span class="line">    for (int i = k; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        push(q, nums[i], i);</span><br><span class="line">        while (top(q)[1] &lt;= i - k) &#123;</span><br><span class="line">            pop(q);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = top(q)[0];</span><br><span class="line">    &#125;</span><br><span class="line">    setFree(q);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。在最坏情况下，数组<br>nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为O(logn)，因此总时间复杂度为O(nlogn)。</p><p>空间复杂度：<br>O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的<br>O(n) 空间，只计算额外的空间使用。</p><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>思路与算法</p><p>我们可以顺着方法一的思路继续进行优化。</p><p>由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 i 和 j，其中<br>i 在 j 的左侧（i&lt;j），并且 i 对应的元素不大于 j 对应的元素（nums[i]≤nums[j]），那么会发生什么呢？<br>当滑动窗口向右移动时，只要<br>i 还在窗口中，那么 j 一定也还在窗口中，这是 i 在 j 的左侧所保证的。因此，由于<br>nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将<br>nums[i] 永久地移除。</p><p>因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 nums 中对应的值是严格单调递减的。因为如果队列中有两个相邻的下标，它们对应的值相等或者递增，那么令前者为 i，后者为 j，就对应了上面所说的情况，即 nums[i] 会被移除，这就产生了矛盾。</p><p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p><p>由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。</p><p>为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        deque&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; ans = &#123;nums[q.front()]&#125;;</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            while (q.front() &lt;= i - k) &#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] ans = new int[n - k + 1];</span><br><span class="line">        ans[0] = nums[deque.peekFirst()];</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            while (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i - k + 1] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        for i in range(k):</span><br><span class="line">            while q and nums[i] &gt;= nums[q[-1]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line"></span><br><span class="line">        ans = [nums[q[0]]]</span><br><span class="line">        for i in range(k, n):</span><br><span class="line">            while q and nums[i] &gt;= nums[q[-1]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            while q[0] &lt;= i - k:</span><br><span class="line">                q.popleft()</span><br><span class="line">            ans.append(nums[q[0]])</span><br><span class="line">        </span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    q := []int&#123;&#125;</span><br><span class="line">    push := func(i int) &#123;</span><br><span class="line">        for len(q) &gt; 0 &amp;&amp; nums[i] &gt;= nums[q[len(q)-1]] &#123;</span><br><span class="line">            q = q[:len(q)-1]</span><br><span class="line">        &#125;</span><br><span class="line">        q = append(q, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; k; i++ &#123;</span><br><span class="line">        push(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := len(nums)</span><br><span class="line">    ans := make([]int, 1, n-k+1)</span><br><span class="line">    ans[0] = nums[q[0]]</span><br><span class="line">    for i := k; i &lt; n; i++ &#123;</span><br><span class="line">        push(i)</span><br><span class="line">        for q[0] &lt;= i-k &#123;</span><br><span class="line">            q = q[1:]</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, nums[q[0]])</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) &#123;</span><br><span class="line">    int q[numsSize];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; nums[i] &gt;= nums[q[right - 1]]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        q[right++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    int* ans = malloc(sizeof(int) * (numsSize - k + 1));</span><br><span class="line">    ans[(*returnSize)++] = nums[q[left]];</span><br><span class="line">    for (int i = k; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; nums[i] &gt;= nums[q[right - 1]]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        q[right++] = i;</span><br><span class="line">        while (q[left] &lt;= i - k) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = nums[q[left]];</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    const q = [];</span><br><span class="line">    for (let i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        while (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - 1]]) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ans = [nums[q[0]]];</span><br><span class="line">    for (let i = k; i &lt; n; i++) &#123;</span><br><span class="line">        while (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - 1]]) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(i);</span><br><span class="line">        while (q[0] &lt;= i - k) &#123;</span><br><span class="line">            q.shift();</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(nums[q[0]]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="方法六：分块-预处理"><a href="#方法六：分块-预处理" class="headerlink" title="方法六：分块 + 预处理"></a>方法六：分块 + 预处理</h1><p>思路与算法</p><p>除了基于「随着窗口的移动实时维护最大值」的方法一以及方法二之外，我们还可以考虑其他有趣的做法。</p><p>我们可以将数组 nums 从左到右按照 k 个一组进行分组，最后一组中元素的数量可能会不足 k 个。如果我们希望求出 nums[i] 到 nums[i+k−1] 的最大值，就会有两种情况：<br>如果 i 是 k 的倍数，那么 nums[i] 到 nums[i+k−1] 恰好是一个分组。我们只要预处理出每个分组中的最大值，即可得到答案；<br>如果 i 不是 k 的倍数，那么 nums[i] 到 nums[i+k−1] 会跨越两个分组，占有第一个分组的后缀以及第二个分组的前缀。假设<br>j 是 k 的倍数，并且满足 i&lt;j≤i+k−1，那么 nums[i] 到 nums[j−1] 就是第一个分组的后缀，<br>nums[j] 到 nums[i+k−1]就是第二个分组的前缀。如果我们能够预处理出每个分组中的前缀最大值以及后缀最大值，同样可以在 O(1) 的时间得到答案。<br>因此我们用 prefixMax[i] 表示下标 i 对应的分组中，以<br>i 结尾的前缀最大值；suffixMax[i] 表示下标 i 对应的分组中，以 i 开始的后缀最大值。它们分别满足如下的递推式</p><pre><code>prefixMax[i]=&#123;         nums[i],i 是 k 的倍数        max&#123;prefixMax[i−1],nums[i]&#125;,i 不是 k 的倍数suffixMax[i]=&#123;     nums[i],i+1 是 k 的倍数    max&#123;suffixMax[i+1],nums[i]&#125;,i+1 不是 k 的倍数</code></pre><p>需要注意在递推 suffixMax[i] 时需要考虑到边界条件<br>suffixMax[n−1]&#x3D;nums[n−1]，而在递推 prefixMax[i] 时的边界条件<br>prefixMax[0]&#x3D;nums[0] 恰好包含在递推式的第一种情况中，因此无需特殊考虑。</p><p>在预处理完成之后，对于 nums[i] 到 nums[i+k−1] 的所有元素，如果 i 不是<br>k 的倍数，那么窗口中的最大值为 suffixMax[i] 与 prefixMax[i+k−1] 中的较大值；如果<br>i 是 k 的倍数，那么此时窗口恰好对应一整个分组，suffixMax[i] 和<br>prefixMax[i+k−1] 都等于分组中的最大值，因此无论窗口属于哪一种情况，</p><p>max{suffixMax[i],prefixMax[i+k−1]}</p><p>即为答案。</p><p>这种方法与稀疏表（Sparse Table）非常类似。感兴趣的读者可以自行查阅资料进行学习</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; prefixMax(n), suffixMax(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (i % k == 0) &#123;</span><br><span class="line">                prefixMax[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                prefixMax[i] = max(prefixMax[i - 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (i == n - 1 || (i + 1) % k == 0) &#123;</span><br><span class="line">                suffixMax[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                suffixMax[i] = max(suffixMax[i + 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for (int i = 0; i &lt;= n - k; ++i) &#123;</span><br><span class="line">            ans.push_back(max(suffixMax[i], prefixMax[i + k - 1]));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] prefixMax = new int[n];</span><br><span class="line">        int[] suffixMax = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (i % k == 0) &#123;</span><br><span class="line">                prefixMax[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (i == n - 1 || (i + 1) % k == 0) &#123;</span><br><span class="line">                suffixMax[i] = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] ans = new int[n - k + 1];</span><br><span class="line">        for (int i = 0; i &lt;= n - k; ++i) &#123;</span><br><span class="line">            ans[i] = Math.max(suffixMax[i], prefixMax[i + k - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        prefixMax, suffixMax = [0] * n, [0] * n</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if i % k == 0:</span><br><span class="line">                prefixMax[i] = nums[i]</span><br><span class="line">            else:</span><br><span class="line">                prefixMax[i] = max(prefixMax[i - 1], nums[i])</span><br><span class="line">        for i in range(n - 1, -1, -1):</span><br><span class="line">            if i == n - 1 or (i + 1) % k == 0:</span><br><span class="line">                suffixMax[i] = nums[i]</span><br><span class="line">            else:</span><br><span class="line">                suffixMax[i] = max(suffixMax[i + 1], nums[i])</span><br><span class="line"></span><br><span class="line">        ans = [max(suffixMax[i], prefixMax[i + k - 1]) for i in range(n - k + 1)]</span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    prefixMax := make([]int, n)</span><br><span class="line">    suffixMax := make([]int, n)</span><br><span class="line">    for i, v := range nums &#123;</span><br><span class="line">        if i%k == 0 &#123;</span><br><span class="line">            prefixMax[i] = v</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prefixMax[i] = max(prefixMax[i-1], v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">        if i == n-1 || (i+1)%k == 0 &#123;</span><br><span class="line">            suffixMax[i] = nums[i]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            suffixMax[i] = max(suffixMax[i+1], nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := make([]int, n-k+1)</span><br><span class="line">    for i := range ans &#123;</span><br><span class="line">        ans[i] = max(suffixMax[i], prefixMax[i+k-1])</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if a &gt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) &#123;</span><br><span class="line">    int prefixMax[numsSize], suffixMax[numsSize];</span><br><span class="line">    for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        if (i % k == 0) &#123;</span><br><span class="line">            prefixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prefixMax[i] = fmax(prefixMax[i - 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = numsSize - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        if (i == numsSize - 1 || (i + 1) % k == 0) &#123;</span><br><span class="line">            suffixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            suffixMax[i] = fmax(suffixMax[i + 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    int* ans = malloc(sizeof(int) * (numsSize - k + 1));</span><br><span class="line">    for (int i = 0; i &lt;= numsSize - k; ++i) &#123;</span><br><span class="line">        ans[(*returnSize)++] = fmax(suffixMax[i], prefixMax[i + k - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    const prefixMax = new Array(n).fill(0);</span><br><span class="line">    const suffixMax = new Array(n).fill(0);</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (i % k === 0) &#123;</span><br><span class="line">            prefixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        if (i === n || (i + 1) % k === 0) &#123;</span><br><span class="line">            suffixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const ans = [];</span><br><span class="line">    for (let i = 0; i &lt; n - k + 1; i++) &#123;</span><br><span class="line">        ans.push(Math.max(suffixMax[i], prefixMax[i + k - 1]));</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度：<br>O(n)，其中 n 是数组 nums 的长度。我们需要 O(n) 的时间预处理出数组prefixMax，suffixMax 以及计算答案。</p><p>空间复杂度：<br>O(n)，即为存储prefixMax 和 suffixMax 需要的空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
    <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>256. 粉刷房子</title>
    <link href="http://yoursite.com/2022/09/20/256.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <id>http://yoursite.com/2022/09/20/256.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</id>
    <published>2022-09-20T07:15:12.000Z</published>
    <updated>2022-09-25T13:09:14.310Z</updated>
    
    <content type="html"><![CDATA[<p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其与相邻的两个房子颜色不能相同。</p><span id="more"></span><p>[TOC]</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p><p>注意：<br>所有花费均为正整数。</p><p>示例：<br>输入: [[17,2,17],[16,16,5],[14,3,19]]<br>输出: 10<br>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>最少花费: 2 + 5 + 3 &#x3D; 10。</p><p>参考<a href="https://codetop.cc/home">^1</a>是字节跳动商业变现是最近的高频题</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>初始态</p><pre><code>red[0] = costs[0][0]blue[0] = costs[0][0]green[0] = costs[0][0]</code></pre><p>过程</p><pre><code>red[i] = Min(blue[i-1], green[i-1]) + costs[i][0]blue[i] = Min(red[i-1], green[i-1]) + costs[i][1]green[i] = Min(red[i-1], blue[i-1]) + costs[i][2]</code></pre><p>结果：</p><pre><code>result = Min(red[n-1], blue[n-1], green[n-1])</code></pre><p>时间复杂度为O(n).</p><p>dp[i][c] 表示刷完 i 房子后，i 房子是 c 颜色时，花费最小多少</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;</span><br><span class="line">    int n = costs.size(), house, color;</span><br><span class="line">        if(n==0) return 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(3,INT_MAX));</span><br><span class="line">    dp[0] = costs[0];</span><br><span class="line">    for(house = 1; house &lt; n; house++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(color = 0; color &lt; 3; ++color)</span><br><span class="line">    &#123;</span><br><span class="line">    dp[house][color] = min(dp[house][color], costs[house][color]+min(dp[house-1][(color+1)%3], dp[house-1][(color+2)%3]));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其与相邻的两个房子颜色不能相同。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>卡特兰数(Catalan number)</title>
    <link href="http://yoursite.com/2022/09/19/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0(Catalan%20number)/"/>
    <id>http://yoursite.com/2022/09/19/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0(Catalan%20number)/</id>
    <published>2022-09-19T09:05:12.000Z</published>
    <updated>2022-09-25T13:06:34.422Z</updated>
    
    <content type="html"><![CDATA[<p>卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。<br>以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。</p><span id="more"></span><p>[TOC]</p><h1 id="卡特兰数（Catalan-number）-1"><a href="#卡特兰数（Catalan-number）-1" class="headerlink" title="卡特兰数（Catalan number） ^1"></a>卡特兰数（Catalan number） <a href="https://leetcode.cn/circle/article/lWYCzv/">^1</a></h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。<br>以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。</p><p>卡塔兰数的通项公式为</p><p>Cn&#x3D; C(2n, n)&#x2F;(n+1) &#x3D; (2n)!&#x2F;(n+1)!n!</p><p>令其为h(n)的话，满足<br>h(n)&#x3D;h(0)*h(n-1) + h(1)*h(n-2) + … + h(n-1)h(0)  (n&gt;&#x3D;2)</p><p>数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862，…</p><p>本文将会选取几个经典的卡特兰问题，难度先易后难，带领读者逐个击破解决，最后给出相关的解题模板。</p><h2 id="二、经典问题"><a href="#二、经典问题" class="headerlink" title="二、经典问题"></a>二、经典问题</h2><h3 id="2-1-进出栈序列"><a href="#2-1-进出栈序列" class="headerlink" title="2.1 进出栈序列"></a>2.1 进出栈序列</h3><p>这是一道最经典的入门级卡特兰数题目，如果能把这题看懂，相信后面的题目也能迎刃而解。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>n 个元素进栈序列为：1，2，3，4，…，n，则有多少种出栈序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们将进栈表示为 +1，出栈表示为 -1，则 1 3 2 的出栈序列可以表示为：+1 -1 +1 +1 -1 -1。</p><p>根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的所有前缀和必然大于等于 0，并且 +1 的数量等于 -1 的数量。</p><p>接下来让我们观察一下 n &#x3D; 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。</p><p>如果将第一个前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。</p><p>因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，<strong>对于 n  元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。</strong></p><p>如何证明这两种序列是一一对应的？</p><p>假设非法序列为 A，对应的序列为 B。每个 A 只有一个”第一个前缀和小于 0 的前缀”，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到”第一个前缀和大于 0 的前缀”，显然 B 也只能产生一个 A。</p><p>每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为C(2n, n+1)​ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 C(2n,n+1)</p><p>出栈序列的总数量共有C(2n,n) ​ ，因此，合法的出栈序列的数量为 C(2n,n)-C(2n,n+1) &#x3D; C(2n,n)&#x2F;(n+1)</p><p>此时我们就得到了卡特兰数的通项C(2n,n)&#x2F;(n+1) ，至于具体如何计算结果将会在后面进行介绍。</p><h3 id="2-2-括号序列"><a href="#2-2-括号序列" class="headerlink" title="2.2 括号序列"></a>2.2 括号序列</h3><p><strong>题目描述</strong></p><p>n 对括号，则有多少种 “括号匹配” 的括号序列</p><p><strong>思路</strong></p><p>左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，共有C(2n,n)&#x2F;(n+1) 种序列。</p><h3 id="2-3-二叉树"><a href="#2-3-二叉树" class="headerlink" title="2.3 二叉树"></a>2.3 二叉树</h3><p>题目描述</p><p>n + 1 个叶子节点能够构成多少种形状不同的（国际）满二叉树</p><p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是(2^k) -1 ，则它就是满二叉树。(一棵满二叉树的每一个结点要么是叶子结点，要么它有两个子结点，但是反过来不成立，因为完全二叉树也满足这个要求，但不是满二叉树)</p><p>国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.</p><p>大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>（国际）满二叉树定义：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>思路</p><p>使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。</p><p>由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。n + 1 个叶子结点会有 2n 次扩展，构成​<br>种形状不同的满二叉树。</p><h3 id="2-4-电影购票"><a href="#2-4-电影购票" class="headerlink" title="2.4 电影购票"></a>2.4 电影购票</h3><p>题目描述</p><p>电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。</p><p>则有多少种排队方式，可以让每个人都买到电影票。</p><p>思路</p><p>持有 50 coin 的人每次购票时不需要找零，并且可以帮助后面持有 100 coin 的人找零；而对于持有 100 coin 的人每次购票时需要找零，但 100 coin 对后面的找零没有任何作用。</p><p>因此，相当于每个持有 100 coin 的人都需要和一个持有 50 coin 的人进行匹配。我们将持有 50 coin 的标记为 +1，持有 100 coin 的标记为 -1，此时又回到了进出栈问题。</p><p>不同的是，m 并一定等于 n，且排队序列是一种排列，需要考虑先后顺序，例如各自持有 50 coin 的甲和乙的前后关系会造成两种不同的排队序列。所以，将会有(C(m+n, m)-C(m+n,m+1)) * m! * n!</p><p>第二项为什么是C(m+n,m+1)​ ，其实很简单，我们每次把第一个前缀小于0 的前缀取反后，会造成 +1 多了一个而 -1 少了一个。这里 +1 有 m 个，-1 有 n 个，取反后 +1 变成 m + 1 个，-1 变成 n - 1 个，总和不变。</p><h2 id="三、解题模板"><a href="#三、解题模板" class="headerlink" title="三、解题模板"></a>三、解题模板</h2><p>最后我们需要来计算一下卡特兰数的通项Cn &#x3D; C(2n,n)&#x2F;(n+1)</p><p>卡特兰数满足以下递推式：</p><p>C1 &#x3D; 1, Cn &#x3D; Cn-1(4*n-2)&#x2F;(n+1) ​ （证明从略）</p><p>因此，我们可以通过递推来得到第 n 个卡特兰数。</p><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="comment">// 打印前 n 个卡特兰数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;1:&quot;</span> + ans.toString());</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">four</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">4</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">one</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">two</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(i);</span><br><span class="line">ans = ans.multiply(four.multiply(bi).subtract(two)).divide(bi.add(one));</span><br><span class="line">System.out.println(i + <span class="string">&quot;:&quot;</span> + ans.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line"></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">ans = ans \* (<span class="number">4</span> \* i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>需要注意的是，由于卡特兰数增长速度较快，当 n 等于 17 时，卡特兰数将会超过 int 最大值，造成溢出（Python 除外）。对于 Java 语言来说，可以使用 BigInteger 来计算大整数。</p><p>那如果 +1 的数量不等于 -1 的数量呢，如前面提到的电影购票问题。此时<br>，不是卡特兰数的通项，也就不能够继续使用原有的递推性质。</p><p>那就推导新的公式，一般而言，为了降低难度，题目会要求我们计算排列数量An&#x3D;Cn * m! * n!&#x3D;(m+n)!*(m+1-n)&#x2F;(m+1)</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题。因此，只要我们能够学会进出栈问题的解法，无论问题再怎么变化，本质还是不变的。</p><p>卡特兰数问题中都会存在一种匹配关系，如进出栈匹配，括号匹配等，一旦计数问题中存在这种关系，那我们就需要去考虑这是否是卡特兰数问题。此外，我们还可以记住序列前四项：1, 1, 2, 5，这些将有利于我们联想到卡特兰数。1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,…</p><p>目前，LeetCode 已经出现一道卡特兰数问题 1259. 不相交的握手 <a href="https://leetcode-cn.com/problems/handshakes-that-dont-cross">^2</a>，这也是这篇文章编写的原因之一。同时，近年某巴巴，某讯的笔试题中也有出现过这类题目，无非将背景换成买烧饼，借书排队等，相信这些都难不倒读者。</p><h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><p>最后留一道比较有意思的卡特兰数问题，欢迎读者留言，提出自己的看法。</p><p>8 个高矮不同的人需要排成两队，每队 4 个人。其中，每排都是从低到高排列，且第二排的第 i 个人比第一排中第 i 个人高，则有多少种排队方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。&lt;br&gt;以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>1259. 不相交的握手</title>
    <link href="http://yoursite.com/2022/09/15/1259.%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E6%8F%A1%E6%89%8B/"/>
    <id>http://yoursite.com/2022/09/15/1259.%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E6%8F%A1%E6%89%8B/</id>
    <published>2022-09-15T03:15:12.000Z</published>
    <updated>2022-09-25T13:08:37.807Z</updated>
    
    <content type="html"><![CDATA[<p>偶数 个人站成一个圆，总人数为 n 。每个人与除自己外的一个人握手，所以总共会有 n &#x2F; 2 次握手。</p><p>将握手的人之间连线，请你返回连线不会相交的握手方案数。</p><span id="more"></span><p>[TOC]</p><p>由于结果可能会很大，请你返回答案 模 10^9+7 后的结果<a href="https://leetcode-cn.com/problems/handshakes-that-dont-cross">^2</a></p><p>示例 1：</p><pre><code>输入：num_people = 2输出：1    </code></pre><p>示例 2：</p><pre><code>输入：num_people = 4输出：2 解释：总共有两种方案，第一种方案是 [(1,2),(3,4)] ，第二种方案是 [(2,3),(4,1)] 。</code></pre><p>示例 3：</p><pre><code>输入：num_people = 6输出：5</code></pre><p>示例 4：</p><pre><code>输入：num_people = 8输出：14</code></pre><p>提示：<br>2 &lt;&#x3D; num_people &lt;&#x3D; 1000<br>num_people % 2 &#x3D;&#x3D; 0</p><p>本题是一道字节跳动的面试题</p><h1 id="递归-3"><a href="#递归-3" class="headerlink" title="递归^3"></a>递归<a href="https://blog.csdn.net/qq_32424059/article/details/103105435">^3</a></h1><p>当第一个人和第 i 个人握手了之后，剩下的人被分割成了两个部分：</p><ol><li><p>i - 2， 即前 i 个人去掉 第一个人和 第 i 个人。</p></li><li><p>num_people - i， 总人数去掉前 i 个人。</p></li></ol><p>现在这两部分是和原问题种类相同，但规模更小的问题，因此可以采用递归求解。</p><p>递归的问题在于，重复计算非常多，因此效率很低，当输入等于24的时候就会超时。</p><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, num_people</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num_people: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num_people:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num_people + <span class="number">1</span>):</span><br><span class="line">            res += self.numberOfWays(i - <span class="number">2</span>) * self.numberOfWays(num_people - i)</span><br><span class="line">        <span class="keyword">return</span> res % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>观察一下前四项可以发现， 1， 2， 5， 14，</p><p>这就是熟悉的卡特兰数，直接套公式：Cn&#x3D; C(2n, n)&#x2F;(n+1) &#x3D; (2n)!&#x2F;(n+1)!n!</p><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> factorial <span class="keyword">as</span> fac</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, num_people</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num_people: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">catalan</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">return</span> fac(<span class="number">2</span>*n) // (fac(n+<span class="number">1</span>) * fac(n))</span><br><span class="line">        <span class="keyword">return</span> catalan(num_people // <span class="number">2</span>) % ( <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>时间复杂度： O((2n)!)，不过因为factorial是用c实现的，所以飞快</p><p>空间复杂度：O（1）</p><h1 id="动态规划解法1"><a href="#动态规划解法1" class="headerlink" title="动态规划解法1"></a>动态规划解法1</h1><p>用dp[i] 代表输入为 i 时的解，</p><p>根据之前的分析， dp[i] &#x3D; sum(dp[j - 2] * dp[i - j] for j in range(2, i + 1, 2))</p><p>时间复杂度：O(N ^ 2)</p><p>空间复杂度：O(N)</p><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, num_people</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num_people: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_people + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_people + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, i + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                dp[i] += (dp[j - <span class="number">2</span>] * dp[i - j]) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[num_people] % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="动态规划2-4"><a href="#动态规划2-4" class="headerlink" title="动态规划2^4"></a><a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&spm=1001.2101.3001.7020">动态规划2</a><a href="https://blog.csdn.net/yu_duan_hun/article/details/125948450">^4</a></h1><ol><li>假设有 x 个人，我们从中任选了一个人 a,这个 a和一个人握手，要保证后续有解，则分割出的两部分必须都为偶数</li><li>a 握手以后，还剩下，x-2个人没握手，x 握手以后，把剩余人员通过握手的连线分割为两部分，假设其中一个部分为 y 个人，则剩余部分为 x-2-y 个人</li><li>这个 y 人握手问题，就化解为了 x 人握手的子问题，枚举 所有可行的 y 和 x-2-y 握手可能性，两者互不干涉，可相乘处理</li></ol><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>由于都是偶数，我们只关心有多少对握手，可将空间范围缩减为 n&#x2F;2</li><li>一边分割为 y 人，一边分割为 x-2-y 人，与反过来的结果是相同的，那么对于两边数目不同的情况，可以乘以2，从而减少一半循环次数，特别注意的是，当 y&#x3D;x-2-y时，只有一种可能性，</li></ol><details>    <summary></summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfWays</span><span class="params">(<span class="type">int</span> numPeople)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> numPeople/<span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[half+<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>) (<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= half; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i-j-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                    dp[i]+=dp[j]*dp[i-j-<span class="number">1</span>]*<span class="number">2</span>;</span><br><span class="line">                    dp[i] = dp[i]%MOD;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]+=dp[i/<span class="number">2</span>]*dp[i-i/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">                    dp[i] = dp[i]%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) dp[half];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="卡特兰数（Catalan-number）-1"><a href="#卡特兰数（Catalan-number）-1" class="headerlink" title="卡特兰数（Catalan number） ^1"></a>卡特兰数（Catalan number） <a href="https://leetcode.cn/circle/article/lWYCzv/">^1</a></h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。<br>以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。</p><p>卡塔兰数的通项公式为</p><p>Cn&#x3D; C(2n, n)&#x2F;(n+1) &#x3D; (2n)!&#x2F;(n+1)!n!</p><p>令其为h(n)的话，满足<br>h(n)&#x3D;h(0)*h(n-1) + h(1)*h(n-2) + … + h(n-1)h(0)  (n&gt;&#x3D;2)</p><p>数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862，…</p><p>本文将会选取几个经典的卡特兰问题，难度先易后难，带领读者逐个击破解决，最后给出相关的解题模板。</p><h2 id="二、经典问题"><a href="#二、经典问题" class="headerlink" title="二、经典问题"></a>二、经典问题</h2><h3 id="2-1-进出栈序列"><a href="#2-1-进出栈序列" class="headerlink" title="2.1 进出栈序列"></a>2.1 进出栈序列</h3><p>这是一道最经典的入门级卡特兰数题目，如果能把这题看懂，相信后面的题目也能迎刃而解。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>n 个元素进栈序列为：1，2，3，4，…，n，则有多少种出栈序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们将进栈表示为 +1，出栈表示为 -1，则 1 3 2 的出栈序列可以表示为：+1 -1 +1 +1 -1 -1。</p><p>根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的所有前缀和必然大于等于 0，并且 +1 的数量等于 -1 的数量。</p><p>接下来让我们观察一下 n &#x3D; 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。</p><p>如果将第一个前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。</p><p>因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，<strong>对于 n  元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。</strong></p><p>如何证明这两种序列是一一对应的？</p><p>假设非法序列为 A，对应的序列为 B。每个 A 只有一个”第一个前缀和小于 0 的前缀”，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到”第一个前缀和大于 0 的前缀”，显然 B 也只能产生一个 A。</p><p>每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为C(2n, n+1)​ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 C(2n,n+1)</p><p>出栈序列的总数量共有C(2n,n) ​ ，因此，合法的出栈序列的数量为 C(2n,n)-C(2n,n+1) &#x3D; C(2n,n)&#x2F;(n+1)</p><p>此时我们就得到了卡特兰数的通项C(2n,n)&#x2F;(n+1) ，至于具体如何计算结果将会在后面进行介绍。</p><h3 id="2-2-括号序列"><a href="#2-2-括号序列" class="headerlink" title="2.2 括号序列"></a>2.2 括号序列</h3><p><strong>题目描述</strong></p><p>n 对括号，则有多少种 “括号匹配” 的括号序列</p><p><strong>思路</strong></p><p>左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，共有C(2n,n)&#x2F;(n+1) 种序列。</p><h3 id="2-3-二叉树"><a href="#2-3-二叉树" class="headerlink" title="2.3 二叉树"></a>2.3 二叉树</h3><p>题目描述</p><p>n + 1 个叶子节点能够构成多少种形状不同的（国际）满二叉树</p><p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是(2^k) -1 ，则它就是满二叉树。(一棵满二叉树的每一个结点要么是叶子结点，要么它有两个子结点，但是反过来不成立，因为完全二叉树也满足这个要求，但不是满二叉树)</p><p>国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.</p><p>大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>（国际）满二叉树定义：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>思路</p><p>使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。</p><p>由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。n + 1 个叶子结点会有 2n 次扩展，构成​<br>种形状不同的满二叉树。</p><h3 id="2-4-电影购票"><a href="#2-4-电影购票" class="headerlink" title="2.4 电影购票"></a>2.4 电影购票</h3><p>题目描述</p><p>电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。</p><p>则有多少种排队方式，可以让每个人都买到电影票。</p><p>思路</p><p>持有 50 coin 的人每次购票时不需要找零，并且可以帮助后面持有 100 coin 的人找零；而对于持有 100 coin 的人每次购票时需要找零，但 100 coin 对后面的找零没有任何作用。</p><p>因此，相当于每个持有 100 coin 的人都需要和一个持有 50 coin 的人进行匹配。我们将持有 50 coin 的标记为 +1，持有 100 coin 的标记为 -1，此时又回到了进出栈问题。</p><p>不同的是，m 并一定等于 n，且排队序列是一种排列，需要考虑先后顺序，例如各自持有 50 coin 的甲和乙的前后关系会造成两种不同的排队序列。所以，将会有(C(m+n, m)-C(m+n,m+1)) * m! * n!</p><p>第二项为什么是C(m+n,m+1)​ ，其实很简单，我们每次把第一个前缀小于0 的前缀取反后，会造成 +1 多了一个而 -1 少了一个。这里 +1 有 m 个，-1 有 n 个，取反后 +1 变成 m + 1 个，-1 变成 n - 1 个，总和不变。</p><h2 id="三、解题模板"><a href="#三、解题模板" class="headerlink" title="三、解题模板"></a>三、解题模板</h2><p>最后我们需要来计算一下卡特兰数的通项Cn &#x3D; C(2n,n)&#x2F;(n+1)</p><p>卡特兰数满足以下递推式：</p><p>C1 &#x3D; 1, Cn &#x3D; Cn-1(4*n-2)&#x2F;(n+1) ​ （证明从略）</p><p>因此，我们可以通过递推来得到第 n 个卡特兰数。</p><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="comment">// 打印前 n 个卡特兰数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;1:&quot;</span> + ans.toString());</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">four</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">4</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">one</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">two</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(i);</span><br><span class="line">ans = ans.multiply(four.multiply(bi).subtract(two)).divide(bi.add(one));</span><br><span class="line">System.out.println(i + <span class="string">&quot;:&quot;</span> + ans.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line"></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">ans = ans \* (<span class="number">4</span> \* i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>需要注意的是，由于卡特兰数增长速度较快，当 n 等于 17 时，卡特兰数将会超过 int 最大值，造成溢出（Python 除外）。对于 Java 语言来说，可以使用 BigInteger 来计算大整数。</p><p>那如果 +1 的数量不等于 -1 的数量呢，如前面提到的电影购票问题。此时<br>，不是卡特兰数的通项，也就不能够继续使用原有的递推性质。</p><p>那就推导新的公式，一般而言，为了降低难度，题目会要求我们计算排列数量An&#x3D;Cn * m! * n!&#x3D;(m+n)!*(m+1-n)&#x2F;(m+1)</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题。因此，只要我们能够学会进出栈问题的解法，无论问题再怎么变化，本质还是不变的。</p><p>卡特兰数问题中都会存在一种匹配关系，如进出栈匹配，括号匹配等，一旦计数问题中存在这种关系，那我们就需要去考虑这是否是卡特兰数问题。此外，我们还可以记住序列前四项：1, 1, 2, 5，这些将有利于我们联想到卡特兰数。1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,…</p><p>目前，LeetCode 已经出现一道卡特兰数问题 1259. 不相交的握手，这也是这篇文章编写的原因之一。同时，近年某巴巴，某讯的笔试题中也有出现过这类题目，无非将背景换成买烧饼，借书排队等，相信这些都难不倒读者。</p><h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><p>最后留一道比较有意思的卡特兰数问题，欢迎读者留言，提出自己的看法。</p><p>8 个高矮不同的人需要排成两队，每队 4 个人。其中，每排都是从低到高排列，且第二排的第 i 个人比第一排中第 i 个人高，则有多少种排队方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;偶数 个人站成一个圆，总人数为 n 。每个人与除自己外的一个人握手，所以总共会有 n &amp;#x2F; 2 次握手。&lt;/p&gt;
&lt;p&gt;将握手的人之间连线，请你返回连线不会相交的握手方案数。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
</feed>
