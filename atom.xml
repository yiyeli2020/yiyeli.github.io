<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-15T08:32:57.800Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>904. 水果成篮</title>
    <link href="http://yoursite.com/2021/11/15/904.%20%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"/>
    <id>http://yoursite.com/2021/11/15/904. 水果成篮/</id>
    <published>2021-11-15T03:12:12.000Z</published>
    <updated>2021-11-15T08:32:57.800Z</updated>
    
    <content type="html"><![CDATA[<p>能收集的水果树的最大总量是多少</p><a id="more"></a><p>[TOC]</p><p>在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>你可以从你选择的任何树开始，然后重复执行以下步骤：</p><p>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。<br>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。<br>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p><p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p><p>用这个程序你能收集的水果树的最大总量是多少？</p><p>示例 1：</p><pre><code>输入：[1,2,1]输出：3解释：我们可以收集 [1,2,1]。</code></pre><p>示例 2：</p><pre><code>输入：[0,1,2,2]输出：3解释：我们可以收集 [1,2,2]如果我们从第一棵树开始，我们将只能收集到 [0, 1]。</code></pre><p>示例 3：</p><pre><code>输入：[1,2,3,2,2]输出：4解释：我们可以收集 [2,3,2,2]如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</code></pre><p>示例 4：</p><pre><code>输入：[3,3,3,1,2,1,1,2,3,3,4]输出：5解释：我们可以收集 [1,2,1,1,2]如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。</code></pre><p>提示：</p><pre><code>1 &lt;= tree.length &lt;= 400000 &lt;= tree[i] &lt; tree.length</code></pre><h1 id="方法-1：按块扫描"><a href="#方法-1：按块扫描" class="headerlink" title="方法 1：按块扫描"></a>方法 1：按块扫描</h1><p><strong>想法</strong></p><p>问题等价于，找到最长的子序列，最多含有两种“类型”（<code>tree[i]</code> 的值）。</p><p>不单独考虑每个元素，转而考虑相同类型的相连块。</p><p>比如说，<code>tree = [1, 1, 1, 1, 2, 2, 3, 3, 3]</code> 可以看成是 <code>blocks = [(1, weight = 4), (2, weight = 2), (3, weight = 3)]</code>。</p><p>现在可以使用暴力，从左往右扫描。我们会有类似于 <code>blocks = [1, _2_, 1, 2, 1, 2, _1_, 3, ...]</code> 以及对应权重。</p><p>处理的核心思想是，当我们考虑 <code>3</code> 的时候，我们不需要从第二个元素 <code>2</code> （也就是标记成 <code>_2_</code> 的数字）开始考虑，我们可以从 <code>3</code> 之前的第一个元素开始考虑（<code>_1_</code>）。这是因为如果我们从前两个或更多元素开始，这个序列一定包含类型 <code>1</code> 和 <code>2</code>，所以序列一定会在 <code>3</code> 处停止，这就比已经考虑的序列更短了。</p><p>从每个开始点（块的最左端点）开始考虑，这个结果一定是对的。</p><p><strong>算法</strong></p><p>Python 和 Java 的实现方法，符号和策略有所不同，可以查看代码内的注释。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// We'll make a list of indexes for which a block starts.</span></span><br><span class="line">        List&lt;Integer&gt; blockLefts = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the left boundary of each block</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.length; ++i)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || tree[i-<span class="number">1</span>] != tree[i])</span><br><span class="line">                blockLefts.add(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add tree.length as a sentinel for convenience</span></span><br><span class="line">        blockLefts.add(tree.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//跳转标识，里层循环 continue直接跳出外层循环，继续执行外层循环</span></span><br><span class="line">        search: <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// We'll start our scan at block[i].</span></span><br><span class="line">            <span class="comment">// types : the different values of tree[i] seen</span></span><br><span class="line">            <span class="comment">// weight : the total number of trees represented</span></span><br><span class="line">            <span class="comment">//          by blocks under consideration</span></span><br><span class="line">            Set&lt;Integer&gt; types = <span class="keyword">new</span> HashSet();</span><br><span class="line">            <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For each block from the i-th and going forward,</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; blockLefts.size() - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">// Add each block to consideration</span></span><br><span class="line">                types.add(tree[blockLefts.get(j)]);</span><br><span class="line">                weight += blockLefts.get(j+<span class="number">1</span>) - blockLefts.get(j);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we have 3+ types, this is an illegal subarray</span></span><br><span class="line">                <span class="keyword">if</span> (types.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span> search;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If it is a legal subarray, record the answer</span></span><br><span class="line">                ans = Math.max(ans, weight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        blocks = [(k, len(list(v)))</span><br><span class="line">                  <span class="keyword">for</span> k, v <span class="keyword">in</span> itertools.groupby(tree)]</span><br><span class="line"></span><br><span class="line">        ans = i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(blocks):</span><br><span class="line">            <span class="comment"># We'll start our scan at block[i].</span></span><br><span class="line">            <span class="comment"># types : the different values of tree[i] seen</span></span><br><span class="line">            <span class="comment"># weight : the total number of trees represented</span></span><br><span class="line">            <span class="comment">#          by blocks under consideration</span></span><br><span class="line">            types, weight = set(), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># For each block from i and going forward,</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i, len(blocks)):</span><br><span class="line">                <span class="comment"># Add each block to consideration</span></span><br><span class="line">                types.add(blocks[j][<span class="number">0</span>])</span><br><span class="line">                weight += blocks[j][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If we have 3 types, this is not a legal subarray</span></span><br><span class="line">                <span class="keyword">if</span> len(types) &gt;= <span class="number">3</span>:</span><br><span class="line">                    i = j<span class="number">-1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                ans = max(ans, weight)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If we go to the last block, then stop</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 是 <code>tree</code> 的长度。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><h1 id="方法-2：滑动窗口"><a href="#方法-2：滑动窗口" class="headerlink" title="方法 2：滑动窗口"></a>方法 2：滑动窗口</h1><p><strong>想法</strong></p><p>在<em>方法 1</em>中，我们希望找到最长的包含两种不同“类型”的子序列，我们称这样的子序列为<em>合法的</em>。</p><p>假设我们考虑所有以下标 <code>j</code> 为结尾的合法子序列，那么一定有一个最小的开始下标 <code>i</code>：称之为 <code>opt(j) = i</code>。</p><p>我们会发现这个 <code>opt(j)</code> 是一个单调递增的函数，这是因为所有合法子序列的子序列一定也是合法的。</p><p><strong>算法</strong></p><p>模拟一个滑动窗口，维护变量 <code>i</code> 是最小的下标满足 <code>[i, j]</code> 是合法的子序列。</p><p>维护 <code>count</code> 是序列中各种类型的个数，这使得我们可以很快知道子序列中是否含有 3 中类型。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        Counter count = <span class="keyword">new</span> Counter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tree.length; ++j) &#123;</span><br><span class="line">            count.add(tree[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                count.add(tree[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.get(tree[i]) == <span class="number">0</span>)</span><br><span class="line">                    count.remove(tree[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="keyword">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>我的滑动窗口写法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] fruits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找最多只含两种元素的最长连续子数组长度</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(fruits[i], map.getOrDefault(fruits[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(fruits[left], map.getOrDefault(fruits[left], <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.getOrDefault(fruits[left], <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxlen = Math.max(maxlen, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        ans = i = <span class="number">0</span></span><br><span class="line">        count = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> j, x <span class="keyword">in</span> enumerate(tree):</span><br><span class="line">            count[x] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> len(count) &gt;= <span class="number">3</span>:</span><br><span class="line">                count[tree[i]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count[tree[i]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> count[tree[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            ans = max(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 是 <code>tree</code> 的长度。</li><li>空间复杂度：<em>O(N)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能收集的水果树的最大总量是多少&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>795. 区间子数组个数</title>
    <link href="http://yoursite.com/2021/11/12/795.%20%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2021/11/12/795. 区间子数组个数/</id>
    <published>2021-11-12T12:12:12.000Z</published>
    <updated>2021-11-14T01:16:35.388Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个元素都是正整数的数组A，正整数 L以及R(L&lt;= R)。</p><a id="more"></a><p>[TOC]</p><p>求连续、非空且其中最大元素满足大于等于L 小于等于R的子数组个数。</p><p>例如 :</p><pre><code>输入: A = [2, 1, 4, 3]L = 2R = 3输出: 3解释: 满足条件的子数组: [2], [2, 1], [3].注意:L, R  和 A[i] 都是整数，范围在 [0, 10^9]。数组 A 的长度范围在[1, 50000]。</code></pre><h1 id="方法一：计数"><a href="#方法一：计数" class="headerlink" title="方法一：计数"></a>方法一：计数</h1><p><strong>思想</strong></p><p>根据以下步骤推导出解决方案：</p><p>其实我们只关心数组中的元素是否小于 <code>L</code>，大于 <code>R</code>，或者位于 <code>[L, R]</code> 之间。假设一个元素小于 <code>L</code> 标记为 <code>0</code>，位于 <code>[L, R]</code> 之间标记为 <code>1</code>，大于 <code>R</code> 标记为 <code>2</code>。</p><p>我们希望找出不包含 <code>2</code> 且至少包含一个 <code>1</code> 的子数组数量。因此可以看作是所有的 <code>2</code> 将数组拆分为仅包含 <code>0</code> 或 <code>1</code> 的子数组。例如在数组 <code>[0, 0, 1, 2, 2, 1, 0, 2, 0]</code>，<code>2</code> 将数组拆分为 <code>[0, 0, 1]</code>、<code>[1, 0]</code> 和 <code>[0]</code> 三个子数组。 </p><p>接下来，需要计算每个只包含 <code>0</code> 或 <code>1</code> 的数组中，至少包含一个 <code>1</code> 的子数组数量。那么问题可以转换为先找出所有的子数组，再从中减去只包含 <code>0</code> 的子数组。</p><p>例如，<code>[0, 0, 1]</code> 有 6 个子数组，其中 3 个子数组只包含 <code>0</code>，3 个子数组至少包含一个 <code>1</code>；<code>[1, 0]</code> 有 3 个子数组，其中 1 个子数组只包含 <code>0</code>，2 个子数组至少包含一个 <code>1</code>；<code>[0]</code> 只有 1 个子数组，且这个子数组只包含 <code>0</code>。因此数组 <code>A = [0, 0, 1, 2, 2, 1, 0, 2, 0]</code> 中不包含 <code>2</code>，且至少包含一个 <code>1</code> 的子数组的数量是 <code>3 + 2 + 0 = 5</code>。</p><p><strong>算法</strong></p><p>假设 <code>count(B)</code> 用于计算所有元素都小于等于 <code>B</code> 的子数组数量。根据上面分析，本题答案为 <code>count(R) - count(L-1)</code>。</p><p>那么如何计算 <code>count(B)</code>？使用 <code>cur</code> 记录在 <code>B</code> 的左边，小于等于 <code>B</code> 的连续元素数量。当找到一个这样的元素时，在此位置上结束的有效子数组的数量为 <code>cur + 1</code>。当遇到一个元素大于 <code>B</code> 时，则在此位置结束的有效子数组的数量为 0。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count(A, R) - count(A, L-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) &#123;</span><br><span class="line">            cur = x &lt;= bound ? cur + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ans += cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(self, A, L, R)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(bound)</span>:</span></span><br><span class="line">            ans = cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> A :</span><br><span class="line">                cur = cur + <span class="number">1</span> <span class="keyword">if</span> x &lt;= bound <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                ans += cur</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count(R) - count(L - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)</em>，其中 <code>N</code> 是 <code>A</code> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个元素都是正整数的数组A，正整数 L以及R(L&amp;lt;= R)。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>467. 环绕字符串中唯一的子字符串</title>
    <link href="http://yoursite.com/2021/11/10/467.%20%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/10/467. 环绕字符串中唯一的子字符串/</id>
    <published>2021-11-10T08:12:12.000Z</published>
    <updated>2021-11-12T10:05:45.222Z</updated>
    
    <content type="html"><![CDATA[<p>你需要输出字符串s 中 p 的不同的非空子串的数目。</p><a id="more"></a><p>[TOC]</p><p>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以s看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p><p>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串s 中 p 的不同的非空子串的数目。</p><p>注意: p仅由小写的英文字母组成，p 的大小可能超过 10000。</p><p>示例 1:</p><pre><code>输入: &quot;a&quot;输出: 1解释: 字符串 S 中只有一个&quot;a&quot;子字符。</code></pre><p>示例 2:</p><pre><code>输入: &quot;cac&quot;输出: 2解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.</code></pre><p>示例 3:</p><pre><code>输入: &quot;zab&quot;输出: 6解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.</code></pre><h1 id="方法一：统计所有以每个字符结尾的最长连续子串的长度"><a href="#方法一：统计所有以每个字符结尾的最长连续子串的长度" class="headerlink" title="方法一：统计所有以每个字符结尾的最长连续子串的长度"></a>方法一：统计所有以每个字符结尾的最长连续子串的长度</h1><p>题意，假设有一个 a-z 无限循环的字符串 s，计算它和字符串 p 中有多少个相等的非空子串。题目中唯一的意思是，假设 <code>p=aa</code>，字符串 p 中有两个 <code>a</code>，相等的子串记作一个，即 <code>a</code>。</p><p>当 <code>p=cac</code> 时，有 <code>a 和 c</code>，因为 <code>ac、ca、cac</code> 不是 s 的子串。当 <code>p=bcabc</code> 时，有 <code>a、b、ab、c、bc、abc</code>。</p><ul><li>连续子串<code>a</code> 中以字符<code>a</code> 结尾的连续子串有<code>a</code>。</li><li>连续子串<code>b</code> 中以字符<code>b</code> 结尾的连续子串有<code>b</code>；而连续子串<code>ab</code> 以字符<code>b</code> 结尾的连续子串有<code>b、ab</code>。</li><li>连续子串<code>c</code> 中以字符<code>c</code> 结尾的连续子串有<code>c</code>，连续子串<code>bc</code> 中以字符<code>c</code> 结尾的连续子串有<code>c、bc</code>；连续子串<code>abc</code> 中以字符<code>c</code> 结尾的连续子串有<code>c、bc、abc</code>。</li><li>不难发现以该字符结尾的连续子串的长度，就等于以该字符结尾的相等子串的个数。</li></ul><p>所以我们只需求出p中以每个字符结尾的最长连续子串的长度即可。统计所有以每个字符结尾的最长连续子串的长度，就是唯一相等子串的个数。注意：因为 s 是一个循环字符串，所以 <code>za</code> 也是连续子串。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findSubstringInWraproundString(String p) &#123;</span><br><span class="line">        // 记录 p 中以每个字符结尾的最长连续子串的长度</span><br><span class="line">        int[] dp = new int[26];</span><br><span class="line">        char[] array = p.toCharArray();</span><br><span class="line">        // 记录当前连续子串的长度</span><br><span class="line">        int count = 0;</span><br><span class="line">        // 遍历 p 中的所有字符</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            // 判断字符是否连续</span><br><span class="line">            if (i &gt; 0 &amp;&amp; (array[i] - array[i - 1] - 1) % 26 == 0) &#123;</span><br><span class="line">                // 连续则自加</span><br><span class="line">                count++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不连续则刷新</span><br><span class="line">                count = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 只存储最长的连续长度</span><br><span class="line">            dp[array[i] - &apos;a&apos;] = Math.max(dp[array[i] - &apos;a&apos;], count);</span><br><span class="line">        &#125;</span><br><span class="line">        int result = 0;</span><br><span class="line">        // 统计所有以每个字符结尾的最长连续子串的长度，就是唯一相等子串的个数</span><br><span class="line">        for (int i : dp) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>代码优化</strong></p><p>上面的代码中，对于每一个字符都进行了一次判断、赋值。我们可以先计算出当前最长的连续子串，然后再计算其中所有连续子串的长度。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findSubstringInWraproundString(String p) &#123;</span><br><span class="line">        // // 记录 p 中以每个字符结尾的最长连续子串的长度</span><br><span class="line">        int[] dp = new int[26];</span><br><span class="line">        char[] array = p.toCharArray();</span><br><span class="line">        // 连续子串的开始下标</span><br><span class="line">        int start = 0;</span><br><span class="line">        while (start &lt; array.length) &#123;</span><br><span class="line">            // 连续子串的结束下标</span><br><span class="line">            int end = start + 1;</span><br><span class="line">            // 结束下标向后移动，寻找当前最长的连续子串</span><br><span class="line">            while (end &lt; array.length &amp;&amp; (array[end] - array[end-1] - 1) % 26 == 0) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 计算连续子串的长度</span><br><span class="line">            int length = end - start;</span><br><span class="line">            // 遍历连续子串的所有字符</span><br><span class="line">            for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">                // 计算当前字符在数组的下标</span><br><span class="line">                int index = array[i] - &apos;a&apos;;</span><br><span class="line">                // 计算当前连续子串的长度</span><br><span class="line">                int l = length - (i - start);</span><br><span class="line">                dp[index] = Math.max(dp[index], l);</span><br><span class="line">            &#125;</span><br><span class="line">            start = end;</span><br><span class="line">        &#125;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int i : dp) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul><li><a href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/" target="_blank" rel="noopener">467. 环绕字符串中唯一的子字符串</a>(中等)</li><li><a href="https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/" target="_blank" rel="noopener">795. 区间子数组个数</a>(中等)</li><li><a href="https://leetcode-cn.com/problems/fruit-into-baskets/" target="_blank" rel="noopener">904. 水果成篮</a>(中等)</li><li><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. K 个不同整数的子数组</a>（困难）</li><li><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">1109. 航班预订统计</a>(中等)</li></ul><p>前四道题都是滑动窗口的子类型，我们知道滑动窗口适合在题目要求连续的情况下使用， 而<a href="https://oi-wiki.org/basic/prefix-sum/" target="_blank" rel="noopener">前缀和</a>也是如此。二者在连续问题中，对于<strong>优化时间复杂度</strong>有着很重要的意义。 因此如果一道题你可以用暴力解决出来，而且题目恰好有连续的限制， 那么滑动窗口和前缀和等技巧就应该被想到。</p><p>除了这几道题， 还有很多题目都是类似的套路， 大家可以在学习过程中进行体会。今天我们就来一起学习一下。</p><h2 id="前情摘要"><a href="#前情摘要" class="headerlink" title="前情摘要"></a>前情摘要</h2><p>我们从一个简单的问题入手，识别一下这种题的基本形式和套路，为之后的四道题打基础。当你了解了这个套路之后， 之后做这种题就可以直接套。</p><p>需要注意的是这四道题的前置知识都是 <code>滑动窗口</code>， 不熟悉的同学可以先看下之前写的 <a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md" target="_blank" rel="noopener">滑动窗口专题（思路 + 模板）</a></p><h3 id="母题-0"><a href="#母题-0" class="headerlink" title="母题 0"></a>母题 0</h3><p>有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。</p><p>这道题可以使用前缀和来解决。 前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。</p><p>对 [1,2,3,4,5,6] 来说，其前缀和可以是 pre=[1,3,6,10,15,21]。我们可以使用公式 pre[𝑖]=pre[𝑖−1]+nums[𝑖]得到每一位前缀和的值，从而通过前缀和进行相应的计算和解题。其实前缀和的概念很简单，但困难的是如何在题目中使用前缀和以及如何使用前缀和的关系来进行解题。</p><h3 id="母题-1"><a href="#母题-1" class="headerlink" title="母题 1"></a>母题 1</h3><p>如果让你求一个数组的连续子数组总个数，你会如何求？其中连续指的是数组的索引连续。 比如 [1,3,4]，其连续子数组有：<code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，你需要返回 6。</p><p>一种思路是总的连续子数组个数等于：<strong>以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数</strong>，这无疑是完备的。</p><p>同时<strong>利用母题 0 的前缀和思路， 边遍历边求和。</strong></p><p>参考代码(JS)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSubArray</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (_ <span class="keyword">in</span> nums) &#123;</span><br><span class="line">    pre += <span class="number">1</span>;</span><br><span class="line">    ans += pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em>，其中 N 为数组长度。</li><li>空间复杂度：<em>O(1)</em></li></ul><p>而由于以索引为 i 结尾的子数组个数就是 i + 1，因此这道题可以直接用等差数列求和公式 <code>(1 + n) * n / 2</code>，其中 n 数组长度。</p><h3 id="母题-2"><a href="#母题-2" class="headerlink" title="母题 2"></a>母题 2</h3><p>我继续修改下题目， 如果让你求一个数组相邻差为 1 连续子数组的总个数呢？其实就是<strong>索引差 1 的同时，值也差 1。</strong></p><p>和上面思路类似，无非就是增加差值的判断。</p><p>参考代码(JS)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSubArray</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] - nums[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">      pre += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans += pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em>，其中 N 为数组长度。</li><li>空间复杂度：<em>O(1)</em></li></ul><p>如果我值差只要大于 1 就行呢？其实改下符号就行了，这不就是求上升子序列个数么？这里不再继续赘述， 大家可以自己试试。</p><h3 id="母题-3"><a href="#母题-3" class="headerlink" title="母题 3"></a>母题 3</h3><p>我们继续扩展。</p><p>如果我让你求出不大于 k 的子数组的个数呢？不大于 k 指的是子数组的全部元素都不大于 k。 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，不大于 3 的子数组有 <code>[1], [3], [1,3]</code> ，那么 [1,3,4] 不大于 3 的子数组个数就是 3。 实现函数 atMostK(k, nums)。</p><p>参考代码（JS）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSubArray</span>(<span class="params">k, nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= k) &#123;</span><br><span class="line">      pre += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans += pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em>，其中 N 为数组长度。</li><li>空间复杂度：<em>O(1)</em></li></ul><h3 id="母题-4"><a href="#母题-4" class="headerlink" title="母题 4"></a>母题 4</h3><p>如果我让你求出子数组最大值刚好是 k 的子数组的个数呢？ 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，子数组最大值刚好是 3 的子数组有 <code>[3], [1,3]</code> ，那么 [1,3,4] 子数组最大值刚好是 3 的子数组个数就是 2。实现函数 exactK(k, nums)。</p><p>实际上是 exactK 可以直接利用 atMostK，即 atMostK(k) - atMostK(k - 1)，原因见下方母题 5 部分。</p><h3 id="母题-5"><a href="#母题-5" class="headerlink" title="母题 5"></a>母题 5</h3><p>如果我让你求出子数组最大值刚好是 介于 k1 和 k2 的子数组的个数呢？实现函数 betweenK(k1, k2, nums)。</p><p>实际上是 betweenK 可以直接利用 atMostK，即 atMostK(k1, nums) - atMostK(k2 - 1, nums)，其中 k1 &gt; k2。前提是值是离散的， 比如上面我出的题都是整数。 因此我可以直接 减 1，因为 <strong>1 是两个整数最小的间隔</strong>。</p><p>如上，<code>小于等于 10 的区域</code>减去 <code>小于 5 的区域</code>就是 <code>大于等于 5 且小于等于 10 的区域</code>。</p><p>注意我说的是小于 5， 不是小于等于 5。 由于整数是离散的，最小间隔是 1。因此小于 5 在这里就等价于 小于等于 4。这就是 betweenK(k1, k2, nums) = atMostK(k1) - atMostK(k2 - 1) 的原因。</p><p>因此不难看出 exactK 其实就是 betweenK 的特殊形式。 当 k1 == k2 的时候， betweenK 等价于 exactK。</p><p>因此 atMostK 就是灵魂方法，一定要掌握，不明白建议多看几遍。</p><p>有了上面的铺垫， 我们来看下第一道题。</p><h2 id="467-环绕字符串中唯一的子字符串（中等）"><a href="#467-环绕字符串中唯一的子字符串（中等）" class="headerlink" title="467. 环绕字符串中唯一的子字符串（中等）"></a>467. 环绕字符串中唯一的子字符串（中等）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><details>    <summary>题目描述</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;. </span><br><span class="line"></span><br><span class="line">现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 </span><br><span class="line"></span><br><span class="line">注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 S 中只有一个&quot;a&quot;子字符。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.</span><br></pre></td></tr></table></figure></details><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目是让我们找 p 在 s 中出现的非空子串数目，而 s 是固定的一个无限循环字符串。由于 p 的数据范围是 10^5 ，因此暴力找出所有子串就需要 10^10 次操作了，应该会超时。而且题目很多信息都没用到，肯定不对。</p><p>仔细看下题目发现，这不就是母题 2 的变种么？话不多说， 直接上代码，看看有多像。</p><blockquote><p>为了减少判断， 我这里用了一个黑科技， p 前面加了个 <code>^</code>。</p></blockquote><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstringInWraproundString</span><span class="params">(self, p: str)</span> -&gt; int:</span></span><br><span class="line">        p = <span class="string">'^'</span> + p</span><br><span class="line">        w = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)):</span><br><span class="line">            <span class="keyword">if</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">1</span> <span class="keyword">or</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">-25</span>:</span><br><span class="line">                w += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                w = <span class="number">1</span></span><br><span class="line">            ans += w</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p>如上代码是有问题。 比如 <code>cac</code>会被计算为 3，实际上应该是 2。根本原因在于 c 被错误地计算了两次。因此一个简单的思路就是用 set 记录一下访问过的子字符串即可。比如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c,</span><br><span class="line">    abc,</span><br><span class="line">    ab,</span><br><span class="line">    abcd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而由于 set 中的元素一定是连续的，因此上面的数据也可以用 hashmap 存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c: 3</span><br><span class="line">    d: 4</span><br><span class="line">    b: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>含义是：</p><ul><li>以 b 结尾的子串最大长度为 1，也就是 b。</li><li>以 c 结尾的子串最大长度为 3，也就是 abc。</li><li>以 d 结尾的子串最大长度为 4，也就是 abcd。</li></ul><p>至于 c ，是没有必要存的。我们可以通过母题 2 的方式算出来。</p><p>具体算法：</p><ul><li>定义一个 len_mapper。key 是 字母， value 是 长度。 含义是以 key 结尾的最长连续子串的长度。</li></ul><blockquote><p>关键字是：最长</p></blockquote><ul><li>用一个变量 w 记录连续子串的长度，遍历过程根据 w 的值更新 len_mapper</li><li>返回 len_mapper 中所有 value 的和。</li></ul><p>比如: abc，此时的 len_mapper 为:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如：abcab，此时的 len_mapper 依旧。</p><p>再比如: abcazabc，此时的 len_mapper：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c: <span class="number">4</span></span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">    z: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就得到了去重的目的。这种算法是不重不漏的，因为最长的连续子串一定是包含了比它短的连续子串，这个思想和 <a href="https://github.com/azl397985856/leetcode/issues/266" target="_blank" rel="noopener">1297. 子串的最大出现次数</a> 剪枝的方法有异曲同工之妙。</p><h3 id="代码（Python）"><a href="#代码（Python）" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstringInWraproundString</span><span class="params">(self, p: str)</span> -&gt; int:</span></span><br><span class="line">        p = <span class="string">'^'</span> + p</span><br><span class="line">        len_mapper = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)</span><br><span class="line">        w = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)):</span><br><span class="line">            <span class="keyword">if</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">1</span> <span class="keyword">or</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">-25</span>:</span><br><span class="line">                w += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                w = <span class="number">1</span></span><br><span class="line">            len_mapper[p[i]] = max(len_mapper[p[i]], w)</span><br><span class="line">        <span class="keyword">return</span> sum(len_mapper.values())</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 为字符串 p 的长度。</li><li>空间复杂度：由于最多存储 26 个字母， 因此空间实际上是常数，故空间复杂度为 <em>O(1)</em>。</li></ul><h2 id="795-区间子数组个数（中等）"><a href="#795-区间子数组个数（中等）" class="headerlink" title="795. 区间子数组个数（中等）"></a>795. 区间子数组个数（中等）</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给定一个元素都是正整数的数组 A ，正整数 L  以及  R (L &lt;= R)。</span><br><span class="line"></span><br><span class="line">求连续、非空且其中最大元素满足大于等于 L  小于等于 R 的子数组个数。</span><br><span class="line"></span><br><span class="line">例如 :</span><br><span class="line">输入:</span><br><span class="line">A = [2, 1, 4, 3]</span><br><span class="line">L = 2</span><br><span class="line">R = 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 满足条件的子数组: [2], [2, 1], [3].</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">L, R  和  A[i] 都是整数，范围在  [0, 10^9]。</span><br><span class="line">数组  A  的长度范围在[1, 50000]。</span><br></pre></td></tr></table></figure><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>由母题 5，我们知道 <strong>betweenK 可以直接利用 atMostK，即 atMostK(k1) - atMostK(k2 - 1)，其中 k1 &gt; k2</strong>。</p><p>由母题 2，我们知道如何求满足一定条件（这里是元素都小于等于 R）子数组的个数。</p><p>这两个结合一下， 就可以解决。</p><h3 id="代码（Python）-1"><a href="#代码（Python）-1" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><blockquote><p>代码是不是很像</p></blockquote><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(self, A: List[int], L: int, R: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">notGreater</span><span class="params">(R)</span>:</span></span><br><span class="line">            ans = cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> a &lt;= R: cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: cnt = <span class="number">0</span></span><br><span class="line">                ans += cnt</span><br><span class="line">            <span class="keyword">return</span>  ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> notGreater(R) - notGreater(L - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(1)</em>。</li></ul><h2 id="904-水果成篮（中等）"><a href="#904-水果成篮（中等）" class="headerlink" title="904. 水果成篮（中等）"></a>904. 水果成篮（中等）</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">在一排树中，第 i 棵树产生 tree[i] 型的水果。</span><br><span class="line">你可以从你选择的任何树开始，然后重复执行以下步骤：</span><br><span class="line"></span><br><span class="line">把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</span><br><span class="line">移动到当前树右侧的下一棵树。如果右边没有树，就停下来。</span><br><span class="line">请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</span><br><span class="line"></span><br><span class="line">你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</span><br><span class="line"></span><br><span class="line">用这个程序你能收集的水果树的最大总量是多少？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以收集 [1,2,1]。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以收集 [1,2,2]</span><br><span class="line">如果我们从第一棵树开始，我们将只能收集到 [0, 1]。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：我们可以收集 [2,3,2,2]</span><br><span class="line">如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：[3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：我们可以收集 [1,2,1,1,2]</span><br><span class="line">如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= tree.length &lt;= 40000</span><br><span class="line">0 &lt;= tree[i] &lt; tree.length</span><br></pre></td></tr></table></figure><h3 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目花里胡哨的。我们来抽象一下，就是给你一个数组， 让你<strong>选定一个子数组， 这个子数组最多只有两种数字</strong>，这个选定的子数组最大可以是多少。</p><p>这不就和母题 3 一样么？只不过 k 变成了固定值 2。另外由于题目要求整个窗口最多两种数字，我们用哈希表存一下不就好了吗？</p><blockquote><p>set 是不行了的。 因此我们不但需要知道几个数字在窗口， 我们还要知道每个数字出现的次数，这样才可以使用滑动窗口优化时间复杂度。</p></blockquote><h3 id="代码（Python）-2"><a href="#代码（Python）-2" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">atMostK</span><span class="params">(k, nums)</span>:</span></span><br><span class="line">            i = ans = <span class="number">0</span></span><br><span class="line">            win = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> win[nums[j]] == <span class="number">0</span>: k -= <span class="number">1</span></span><br><span class="line">                win[nums[j]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                    win[nums[i]] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> win[nums[i]] == <span class="number">0</span>: k += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                ans = max(ans, j - i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> atMostK(<span class="number">2</span>, tree)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(k)</em>。</li></ul><h2 id="992-K-个不同整数的子数组（困难）"><a href="#992-K-个不同整数的子数组（困难）" class="headerlink" title="992. K 个不同整数的子数组（困难）"></a>992. K 个不同整数的子数组（困难）</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。</span><br><span class="line"></span><br><span class="line">（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）</span><br><span class="line"></span><br><span class="line">返回 A 中好子数组的数目。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A = [1,2,1,2,3], K = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A = [1,2,1,3,4], K = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= A.length &lt;= 20000</span><br><span class="line">1 &lt;= A[i] &lt;= A.length</span><br><span class="line">1 &lt;= K &lt;= A.length</span><br></pre></td></tr></table></figure><h3 id="前置知识-3"><a href="#前置知识-3" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>由母题 5，知：exactK = atMostK(k) - atMostK(k - 1)， 因此答案便呼之欲出了。其他部分和上面的题目 <code>904. 水果成篮</code> 一样。</p><blockquote><p>实际上和所有的滑动窗口题目都差不多。</p></blockquote><h3 id="代码（Python）-3"><a href="#代码（Python）-3" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.atMostK(A, K) - self.atMostK(A, K - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">atMostK</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        counter = collections.Counter()</span><br><span class="line">        res = i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> counter[A[j]] == <span class="number">0</span>:</span><br><span class="line">                K -= <span class="number">1</span></span><br><span class="line">            counter[A[j]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> K &lt; <span class="number">0</span>:</span><br><span class="line">                counter[A[i]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> counter[A[i]] == <span class="number">0</span>:</span><br><span class="line">                    K += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res += j - i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(k)</em>。</li></ul><h2 id="1109-航班预订统计（中等）"><a href="#1109-航班预订统计（中等）" class="headerlink" title="1109. 航班预订统计（中等）"></a>1109. 航班预订统计（中等）</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里有  n  个航班，它们分别从 1 到 n 进行编号。</span><br><span class="line"></span><br><span class="line">我们这儿有一份航班预订表，表中第  i  条预订记录  bookings[i] = [i, j, k]  意味着我们在从  i  到  j  的每个航班上预订了 k 个座位。</span><br><span class="line"></span><br><span class="line">请你返回一个长度为 n 的数组  answer，按航班编号顺序返回每个航班上预订的座位数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= bookings.length &lt;= 20000</span><br><span class="line">1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000</span><br><span class="line">1 &lt;= bookings[i][2] &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="前置知识-4"><a href="#前置知识-4" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>前缀和</li></ul><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这道题的题目描述不是很清楚。我简单分析一下题目：</p><p>[i, j, k] 其实代表的是 第 i 站上来了 k 个人， 一直到 第 j 站都在飞机上，到第 j + 1 就不在飞机上了。所以第 i 站到第 j 站的<strong>每一站</strong>都会因此多 k 个人。</p><p>理解了题目只会不难写出下面的代码。</p><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">corpFlightBookings</span><span class="params">(self, bookings: List[List[int]], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        counter = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j, k <span class="keyword">in</span> bookings:</span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                counter[i - <span class="number">1</span>] += k</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure></details><p>如上的代码复杂度太高，无法通过全部的测试用例。</p><p><strong>注意到里层的 while 循环是连续的数组全部加上一个数字，不难想到可以利用母题 0 的前缀和思路优化。</strong></p><p>一种思路就是在 i 的位置 + k， 然后利用前缀和的技巧给 i 到 n 的元素都加上 k。但是题目需要加的是一个区间， j + 1 及其之后的元素会被多加一个 k。一个简单的技巧就是给 j + 1 的元素减去 k，这样正负就可以抵消。</p><h3 id="代码（Python）-4"><a href="#代码（Python）-4" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">corpFlightBookings</span><span class="params">(self, bookings: List[List[int]], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        counter = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j, k <span class="keyword">in</span> bookings:</span><br><span class="line">            counter[i - <span class="number">1</span>] += k</span><br><span class="line">            <span class="keyword">if</span> j &lt; n: counter[j] -= k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            counter[i] += counter[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> counter[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这几道题都是滑动窗口和前缀和的思路。力扣类似的题目还真不少，大家只有多留心，就会发现这个套路。</p><p>前缀和的技巧以及滑动窗口的技巧都比较固定，且有模板可套。 难点就在于我怎么才能想到可以用这个技巧呢？</p><p>我这里总结了两点：</p><ol><li>找关键字。比如题目中有连续，就应该条件反射想到滑动窗口和前缀和。比如题目求最大最小就想到动态规划和贪心等等。想到之后，就可以和题目信息对比快速排除错误的算法，找到可行解。这个思考的时间会随着你的题感增加而降低。</li><li>先写出暴力解，然后找暴力解的瓶颈， 根据瓶颈就很容易知道应该用什么数据结构和算法去优化。</li></ol><p>最后推荐几道类似的题目， 供大家练习，一定要自己写出来才行哦。</p><ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></li><li><a href="https://lucifer.ren/blog/2019/12/11/leetcode-1186/" target="_blank" rel="noopener">1186.删除一次得到子数组最大和</a></li><li><a href="https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/" target="_blank" rel="noopener">1310. 子数组异或查询</a></li><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你需要输出字符串s 中 p 的不同的非空子串的数目。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>992. K 个不同整数的子数组</title>
    <link href="http://yoursite.com/2021/11/07/992.%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2021/11/07/992. K 个不同整数的子数组/</id>
    <published>2021-11-07T04:12:12.000Z</published>
    <updated>2021-11-08T06:37:41.364Z</updated>
    
    <content type="html"><![CDATA[<p>返回A中好子数组的数目。</p><a id="more"></a><p>[TOC]</p><p>给定一个正整数数组 A，如果 A的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定不同的子数组为好子数组。</p><p>（例如，[1,2,3,1,2] 中有3个不同的整数：1，2，以及3。）</p><p>返回A中好子数组的数目。</p><p>示例 1：</p><pre><code>输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</code></pre><p>示例 2：</p><pre><code>输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</code></pre><p>提示：</p><pre><code>1 &lt;= A.length &lt;= 200001 &lt;= A[i] &lt;= A.length1 &lt;= K &lt;= A.length</code></pre><h1 id="📺-视频讲解"><a href="#📺-视频讲解" class="headerlink" title="📺 视频讲解"></a>📺 视频讲解</h1><p><a href="21472c3c-27ea-4ecf-9093-862f9b2f8e8b">992. K 个不同整数的子数组.mp4</a></p><h1 id="最初直觉使用双指针算法遇到的问题"><a href="#最初直觉使用双指针算法遇到的问题" class="headerlink" title="最初直觉使用双指针算法遇到的问题"></a>最初直觉使用双指针算法遇到的问题</h1><p>对于一个固定的左边界来说，满足「恰好存在 <code>K</code> 个不同整数的子区间」的右边界 <strong>不唯一</strong>，且形成区间。</p><p>示例 1：左边界固定的时候，恰好存在 <em>2</em> 个不同整数的子区间为 <em>[1,2],[1,2,1],[1,2,1,2]</em> ，总数为 <em>3</em>。其值为下标 <em>3 - 1 + 1*，即区间 *[1..3]</em> 的长度。</p><p><a href="https://pic.leetcode-cn.com/1612775858-VWbhYR-image.png" target="_blank" rel="noopener">image.png</a></p><p>须要找到左边界固定的情况下，满足「恰好存在 <code>K</code> 个不同整数的子区间」最小右边界和最大右边界。对比以前我们做过的，使用双指针解决的问题的问法基本都会出现「最小」、「最大」这样的字眼。</p><ul><li><a href="/problems/minimum-window-substring/">76. 最小覆盖子串</a>；</li><li><a href="/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>；</li><li><a href="/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a>；</li><li><a href="/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a>。</li></ul><h1 id="把原问题转换成为容易求解的问题"><a href="#把原问题转换成为容易求解的问题" class="headerlink" title="把原问题转换成为容易求解的问题"></a>把原问题转换成为容易求解的问题</h1><blockquote><p>友情提示：这里把 「恰好」 转换成为 「最多」须要一点求解「双指针（滑动窗口）」问题的经验。建立在熟练掌握这一类问题求解思路的基础上。</p></blockquote><p>把「<strong>恰好</strong>」改成「<strong>最多</strong>」就可以使用双指针一前一后交替向右的方法完成，这是因为 <strong>对于每一个确定的左边界，最多包含 <em>K</em> 种不同整数的右边界是唯一确定的</strong>，并且在左边界向右移动的过程中，右边界或者在原来的地方，或者在原来地方的右边。</p><p>而「最多存在 <em>K</em> 个不同整数的子区间的个数」与「恰好存在 <code>K</code> 个不同整数的子区间的个数」的差恰好等于「最多存在 <em>K - 1</em> 个不同整数的子区间的个数」。</p><p><a href="https://pic.leetcode-cn.com/1612776085-sZFGqE-image.png" target="_blank" rel="noopener">image.png</a></p><p>因为原问题就转换成为求解「最多存在 <em>K</em> 个不同整数的子区间的个数」与 「最多存在 <em>K - 1</em> 个不同整数的子区间的个数」，它们其实是一个问题。</p><h1 id="方法：双指针（滑动窗口）"><a href="#方法：双指针（滑动窗口）" class="headerlink" title="方法：双指针（滑动窗口）"></a>方法：双指针（滑动窗口）</h1><p>实现函数 <code>atMostWithKDistinct(A, K)</code> ，表示「最多存在 <em>K</em> 个不同整数的子区间的个数」。于是 <code>atMostWithKDistinct(A, K) - atMostWithKDistinct(A, K - 1)</code> 即为所求。</p><p><strong>参考代码</strong>：</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最多包含 K 个不同整数的子区间的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">atMostKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [left, right) 里不同整数的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [left, right) 包含不同整数的个数小于等于 K</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[A[right]] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            freq[A[right]]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count &gt; K) &#123;</span><br><span class="line">                freq[A[left]]--;</span><br><span class="line">                <span class="keyword">if</span> (freq[A[left]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [left, right) 区间的长度就是对结果的贡献</span></span><br><span class="line">            res += right - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>说明</strong>： <code>res += right - left;</code> 这行代码的意思：</p><p>用具体的例子理解：最多包含 3 种不同整数的子区间  <code>[1, 3, 2, 3]</code> （双指针算法是在左边界固定的前提下，让右边界走到最右边），当前可以确定 <code>1</code> 开始的满足最多包含 3 种不同整数的子区间有 <code>[1]</code>、<code>[1, 3]</code>、<code>[1, 3, 2]</code>、<code>[1, 3, 2, 3]</code>。</p><p><strong>所有的</strong> 左边界固定前提下，根据右边界最右的下标，计算出来的子区间的个数就是整个函数要返回的值。用右边界固定的前提下，左边界最左边的下标去计算也是完全可以的。</p><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N)*，这里 *N</em> 是输入数组的长度；</li><li>空间复杂度：<em>O(N)</em>，使用了常数个变量、频数数组的长度为 <em>N + 1</em>。</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用双指针（滑动窗口、两个变量一前一后交替向后移动）解决的问题通常都和这个问题要问的结果有关。以我们在题解中给出的 5 道经典问题为例：</p><ul><li><a href="/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>：没有重复的子串，一定只会问「最长」，因为最短的没有重复字符的子串是只有一个字符的子串； </li><li><a href="/problems/minimum-window-substring/">76. 最小覆盖子串</a>：求一个字符串的子串覆盖另一个字符串的长度一定是问「最小」，而不会问「最大」，因为最大一定是整个字符串；</li><li><a href="/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>：所有元素都是正整数，且子区间里所有元素的和大于等于定值 <code>s</code> 的子区间一定是问长度「最小」，而不会问「最多」，因为最多也一定是整个数组的长度；</li><li><a href="/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a>：最多包含两个不同字符一定是问「最长」才有意义，因为长度更长的子串可能会包含更多的字符；</li><li><a href="/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a>：替换的次数 <code>k</code> 是定值，替换以后字符全部相等的子串也一定只会问「最长」。</li></ul><hr><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>提示</strong>：在做这些问题的时候，<strong>一定要思考清楚为什么可以采用双指针（滑动窗口）算法解决如上的问题</strong>，为什么 <strong>左、右指针向右移动的时候可以不回头</strong>。如果不太熟悉这一类问题思路的朋友，一定要想清楚算法为什么有效，比知道这些问题可以用双指针（滑动窗口）算法解决重要得多。</p><p>思路一般是这样：固定左边界的前提下，如果较短的区间性质是什么样的，较长的区间的性质其实我们也可以推测出来。在右边界固定的前提下，我们须要将左边界右移，如此反复。这样的算法只遍历了数组两次，不用枚举所有可能的区间，把 <em>O(N^2)</em> 的时间复杂度降到了 <em>O(N)</em>。</p><ul><li><a href="/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a>；</li><li><a href="/problems/fruit-into-baskets/">904. 水果成篮</a> ；</li><li><a href="/problems/number-of-subarrays-with-bounded-maximum/">795. 区间子数组个数</a>；</li><li><a href="/problems/number-of-substrings-containing-all-three-characters/">1358. 包含所有三种字符的子字符串数目</a>；</li><li><a href="/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a>；</li><li><a href="/problems/longest-substring-with-at-most-k-distinct-characters/">340. 至多包含 K 个不同字符的最长子串</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回A中好子数组的数目。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Counting" scheme="http://yoursite.com/tags/Counting/"/>
    
  </entry>
  
  <entry>
    <title>340. 至多包含 K 个不同字符的最长子串</title>
    <link href="http://yoursite.com/2021/11/07/340.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/07/340. 至多包含 K 个不同字符的最长子串/</id>
    <published>2021-11-07T03:12:12.000Z</published>
    <updated>2021-11-07T04:15:35.403Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串s，找出至多包含k个不同字符的最长子串 T。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: s = &quot;eceba&quot;, k = 2输出: 3解释: 则 T 为 &quot;ece&quot;，所以长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: s = &quot;aa&quot;, k = 1输出: 2解释: 则 T 为 &quot;aa&quot;，所以长度为 2。</code></pre><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstringTwoDistinct(String s,int k) &#123;</span><br><span class="line">       int i = 0, j = 0, n = s.length(), maxlen = 0;</span><br><span class="line">       Map&lt;Character,Integer&gt; map = new HashMap();</span><br><span class="line">       while (j &lt; n) &#123;</span><br><span class="line">           if (map.size() &lt;= k &amp;&amp; j &lt; n) &#123;</span><br><span class="line">               map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           while (map.size() &gt; k) &#123;</span><br><span class="line">               map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) - 1);</span><br><span class="line">               if (map.getOrDefault(s.charAt(i), 0) &lt;= 0) &#123;</span><br><span class="line">                   map.remove(s.charAt(i));</span><br><span class="line">               &#125;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           maxlen = Math.max(maxlen, j - i);</span><br><span class="line">       &#125;</span><br><span class="line">       return maxlen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstringTwoDistinct(string s,int k) &#123;</span><br><span class="line">    int i = 0, j = 0, maxlen = 0;</span><br><span class="line">    unordered_map&lt;char, int&gt; m;</span><br><span class="line">    while(j &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">    if(m.size() &lt;= k)</span><br><span class="line">                ++m[s[j++]];</span><br><span class="line">            while(m.size()&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                if(--m[s[i]] == 0)</span><br><span class="line">                    m.erase(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">    maxlen = max(maxlen, j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串s，找出至多包含k个不同字符的最长子串 T。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>159. 至多包含两个不同字符的最长子串</title>
    <link href="http://yoursite.com/2021/11/07/159.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/07/159. 至多包含两个不同字符的最长子串/</id>
    <published>2021-11-07T01:03:12.000Z</published>
    <updated>2021-11-07T03:49:25.926Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串s，找出至多包含两个不同字符的最长子串 t ，并返回该子串的长度。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;eceba&quot;输出: 3解释: t 是 &quot;ece&quot;，长度为3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;ccaabbb&quot;输出: 5解释: t 是 &quot;aabbb&quot;，长度为5。</code></pre><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstringTwoDistinct(String s) &#123;</span><br><span class="line">       int k = 2, i = 0, j = 0, n = s.length(), maxlen = 0;</span><br><span class="line">       Map&lt;Character,Integer&gt; map = new HashMap();</span><br><span class="line">       while (j &lt; n) &#123;</span><br><span class="line">           if (map.size() &lt;= k &amp;&amp; j &lt; n) &#123;</span><br><span class="line">               map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           while (map.size() &gt; k) &#123;</span><br><span class="line">               map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) - 1);</span><br><span class="line">               if (map.getOrDefault(s.charAt(i), 0) &lt;= 0) &#123;</span><br><span class="line">                   map.remove(s.charAt(i));</span><br><span class="line">               &#125;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           maxlen = Math.max(maxlen, j - i);</span><br><span class="line">       &#125;</span><br><span class="line">       return maxlen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstringTwoDistinct(string s) &#123;</span><br><span class="line">    int k = 2, i = 0, j = 0, maxlen = 0;</span><br><span class="line">    unordered_map&lt;char, int&gt; m;</span><br><span class="line">    while(j &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">    if(m.size() &lt;= k)</span><br><span class="line">                ++m[s[j++]];</span><br><span class="line">            while(m.size()&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                if(--m[s[i]] == 0)</span><br><span class="line">                    m.erase(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">    maxlen = max(maxlen, j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串s，找出至多包含两个不同字符的最长子串 t ，并返回该子串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="http://yoursite.com/2021/11/05/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/05/3. 无重复字符的最长子串/</id>
    <published>2021-11-05T04:03:12.000Z</published>
    <updated>2021-11-06T13:34:01.945Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="fc6033f3-e9c6-41d7-b660-328fc288d2e2">3. 无重复字符的最长子串_2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><p>我一开始想到的是一个比较粗暴的方法，遍历字符串中的每一个位置，然后在该位置向两边扩展，直到遇到重复的字符，最后统计长度，但这种方法效率较低</p><details>    <summary>Java暴力解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            int j = i ;</span><br><span class="line">            int k = i ;</span><br><span class="line">            while (j &gt; 0) &#123;</span><br><span class="line">                if (s.substring(j, k + 1).contains(s.substring(j-1,j))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (k &lt; s.length()-1) &#123;</span><br><span class="line">                if (s.substring(j, k+1).contains(s.substring(k + 1,k+2))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = Math.max(maxlen, k - j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++暴力解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int lengthOfLongestSubstring(string s)&#123;</span><br><span class="line">        long len=s.size();</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">            int j=i, k=i;</span><br><span class="line">            //向左搜索</span><br><span class="line">            while (j&gt;0) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(j-1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //向右搜索</span><br><span class="line">            while (k&lt;len-1) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(k+1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=max(maxlen, k-j+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>时间复杂度：O(N^2)</p><p>空间复杂度：O(1)</p><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><p><strong>思路和算法</strong></p><p>我们先用一个例子来想一想如何在较优的时间复杂度内通过本题。</p><p>我们不妨以示例一中的字符串 abcabcbb  为例，找出 <strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><ul><li>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</li><li>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb ；</li><li>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb ；</li><li>以 abc(a)bcbb  开始的最长字符串为 abc(abc)bb ；</li><li>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</li><li>以 abcab(c)bb  开始的最长字符串为abcab(cb)b ；</li><li>以 abcabc(b)b  开始的最长字符串为 abcabc(b)b ；</li><li>以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 。</li></ul><p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 <em>k</em> 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 <em>r_k*。那么当我们选择第 *k+1</em> 个字符作为起始位置时，首先从 <em>k+1</em> 到 <em>r_k</em> 的字符显然是不重复的，并且由于少了原本的第 <em>k</em> 个字符，我们可以尝试继续增大 <em>r_k</em>，直到右侧出现了重复字符为止。</p><p>这样以来，我们就可以使用「滑动窗口」来解决这个问题了：</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 <em>r_k</em>；</p></li><li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p><strong>判断重复字符</strong></p><p>在上面的流程中，我们还需要使用一种数据结构来判断 <strong>是否有重复的字符</strong>，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><p>至此，我们就完美解决了本题。</p><details>    <summary>滑动窗口C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.erase(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.insert(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="keyword">const</span> occ = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    <span class="keyword">let</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            occ.delete(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.has(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p></li><li><p>空间复杂度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure></li></ul><p>，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Sigma</span><br></pre></td></tr></table></figure><p> 表示字符集（即字符串中可以出现的字符），</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p> 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 <em>[0, 128)</em> 内的字符，即<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|=128</span><br><span class="line">``` </span><br><span class="line">。我们需要用到哈希集合来存储出现过的字符，而字符最多有 </span><br><span class="line">```math</span><br><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure></p><p>个，因此空间复杂度为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>991. 坏了的计算器</title>
    <link href="http://yoursite.com/2021/11/03/991.%20%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://yoursite.com/2021/11/03/991. 坏了的计算器/</id>
    <published>2021-11-03T03:12:12.000Z</published>
    <updated>2021-11-03T03:45:01.565Z</updated>
    
    <content type="html"><![CDATA[<p>返回显示数字 Y 所需的最小操作数。</p><a id="more"></a><p>[TOC]</p><p>在显示着数字的坏计算器上，我们可以执行以下两种操作：</p><p>双倍（Double）：将显示屏上的数字乘 2；<br>递减（Decrement）：将显示屏上的数字减 1 。<br>最初，计算器显示数字 X。</p><p>返回显示数字 Y 所需的最小操作数。</p><p>示例 1：</p><pre><code>输入：X = 2, Y = 3输出：2解释：先进行双倍运算，然后再进行递减运算 {2 -&gt; 4 -&gt; 3}.</code></pre><p>示例 2：</p><pre><code>输入：X = 5, Y = 8输出：2解释：先递减，再双倍 {5 -&gt; 4 -&gt; 8}.</code></pre><p>示例 3：</p><pre><code>输入：X = 3, Y = 10输出：3解释：先双倍，然后递减，再双倍 {3 -&gt; 6 -&gt; 5 -&gt; 10}.</code></pre><p>示例 4：</p><pre><code>输入：X = 1024, Y = 1输出：1023解释：执行递减运算 1023 次</code></pre><p>提示：</p><pre><code>1 &lt;= X &lt;= 10^91 &lt;= Y &lt;= 10^9</code></pre><h1 id="方法一：逆向思维"><a href="#方法一：逆向思维" class="headerlink" title="方法一：逆向思维"></a>方法一：逆向思维</h1><p><strong>思路</strong></p><p>除了对 <code>X</code> 执行乘 2 或 减 1 操作之外，我们也可以对 <code>Y</code> 执行<code>除 2</code>（当 <code>Y</code> 是偶数时）或者<code>加 1</code>操作。</p><p>为什么这道题采用逆向思维更优？</p><p>正向思维：在X&lt;Y时要实现操作数最小，要将X逼近Y的1/2值或1/4值或1/8值或…再进行*2操作，难点在于要判断要逼近的是1/2值还是1/4值还是其他值，逻辑复杂 </p><p>逆向思维：在Y&gt;X时Y只管/2，到了Y&lt;X时在+1逼近 说白了就是，正向思维采用的是先小跨度的-1操作，再大跨度的*2操作；逆向思维采用的是先大跨度的/2操作，再小跨度的-1操作</p><p>然而事实上往往是先大后小的解决问题思维在实现起来会比较简单</p><p>下面的解释我没有太理解，但重点是要分奇数和偶数。奇数不能直接除2，可以先加1</p><p>这样做的动机是我们可以总是贪心地执行除 2 操作：</p><ul><li><p>当 <code>Y</code> 是偶数，如果先执行 2 次加法操作，再执行 1 次除法操作，我们可以通过先执行 1 次除法操作，再执行 1 次加法操作以使用更少的操作次数得到相同的结果 [<code>(Y+2) / 2</code> vs <code>Y/2 + 1</code>]。</p></li><li><p>当 <code>Y</code> 是奇数，如果先执行 3 次加法操作，再执行 1 次除法操作，我们可以将其替代为顺次执行加法、除法、加法操作以使用更少的操作次数得到相同的结果 [<code>(Y+3) / 2</code> vs <code>(Y+1) / 2 + 1</code>]。</p></li></ul><p><strong>算法</strong></p><p>当 <code>Y</code> 大于 <code>X</code> 时，如果它是奇数，我们执行加法操作，否则执行除法操作。之后，我们需要执行 <code>X - Y</code> 次加法操作以得到 <code>X</code>。</p><figure class="highlight java"><figcaption><span>[uRsowHNz-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> startValue, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (startValue &lt; target) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            target = ((target &amp; <span class="number">1</span>) == <span class="number">1</span>) ? target + <span class="number">1</span> : target / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + startValue - target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[uRsowHNz-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brokenCalc</span><span class="params">(self, X, Y)</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Y &gt; X:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> Y%<span class="number">2</span>: Y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: Y /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans + X-Y</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：  O(logY)</p></li><li><p>空间复杂度：  <em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回显示数字 Y 所需的最小操作数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>224. 基本计算器</title>
    <link href="http://yoursite.com/2021/11/02/224.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://yoursite.com/2021/11/02/224. 基本计算器/</id>
    <published>2021-11-02T09:12:12.000Z</published>
    <updated>2021-11-03T03:11:38.688Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串表达式s，请你实现一个基本计算器来计算并返回它的值。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：s = &quot;1 + 1&quot;输出：2</code></pre><p>示例 2：</p><pre><code>输入：s = &quot; 2-1 + 2 &quot;输出：3</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 3 * 105s 由数字、&apos;+&apos;、&apos;-&apos;、&apos;(&apos;、&apos;)&apos;、和 &apos; &apos; 组成s 表示一个有效的表达式</code></pre><h1 id="方法一：括号展开-栈"><a href="#方法一：括号展开-栈" class="headerlink" title="方法一：括号展开 + 栈"></a>方法一：括号展开 + 栈</h1><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。<a href="https://leetcode-cn.com/problems/basic-calculator/solution/ji-ben-ji-suan-qi-by-leetcode-solution-jvir/" target="_blank" rel="noopener">^1</a></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ops;</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; ops = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ops = [<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">' '</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">'+'</span>) &#123;</span><br><span class="line">            sign = ops[ops.length - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = -ops[ops.length - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">'('</span>) &#123;</span><br><span class="line">            ops.push(sign);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">')'</span>) &#123;</span><br><span class="line">            ops.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; !(<span class="built_in">isNaN</span>(<span class="built_in">Number</span>(s[i]))) &amp;&amp; s[i] !== <span class="string">' '</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i].charCodeAt() - <span class="string">'0'</span>.charCodeAt();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += sign * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ops := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">    sign := <span class="number">1</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; &#123;</span><br><span class="line">        <span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            sign = ops[<span class="built_in">len</span>(ops)<span class="number">-1</span>]</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            sign = -ops[<span class="built_in">len</span>(ops)<span class="number">-1</span>]</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">            ops = <span class="built_in">append</span>(ops, sign)</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            ops = ops[:<span class="built_in">len</span>(ops)<span class="number">-1</span>]</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            num := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ; i &lt; n &amp;&amp; <span class="string">'0'</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">'9'</span>; i++ &#123;</span><br><span class="line">                num = num*<span class="number">10</span> + <span class="keyword">int</span>(s[i]-<span class="string">'0'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            ans += sign * num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> ops[n], top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    ops[top++] = sign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            sign = ops[top - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = -ops[top - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            ops[top++] = sign;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            top--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += sign * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ops = [<span class="number">1</span>]</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'+'</span>:</span><br><span class="line">                sign = ops[<span class="number">-1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'-'</span>:</span><br><span class="line">                sign = -ops[<span class="number">-1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                ops.append(sign)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                ops.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">                    num = num * <span class="number">10</span> + ord(s[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                ret += num * sign</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为字符串 <em>s</em> 的长度。需要遍历字符串 <em>s</em> 一次，计算表达式的值。</p></li><li><p>空间复杂度：<em>O(n)*，其中 *n</em> 为字符串 <em>s</em> 的长度。空间复杂度主要取决于栈的空间，栈中的元素数量不超过 <em>n</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串表达式s，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>772. 基本计算器III</title>
    <link href="http://yoursite.com/2021/11/02/772.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8III/"/>
    <id>http://yoursite.com/2021/11/02/772. 基本计算器III/</id>
    <published>2021-11-02T09:12:12.000Z</published>
    <updated>2021-11-06T13:32:42.408Z</updated>
    
    <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.</p><a id="more"></a><p>[TOC]</p><p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p><p>The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid. All intermediate results will be in the range of [-2147483648, 2147483647].</p><p>Some examples:</p><pre><code>&quot;1 + 1&quot; = 2&quot; 6-4 / 2 &quot; = 4&quot;2*(5+5*2)/3+(6/2+8)&quot; = 21&quot;(2+6* 3+5- (3*14/7+2)*5)+3&quot;=-12</code></pre><p>Note: Do not use the eval built-in library function.</p><h1 id="方法一：中缀转后缀（逆波兰）表达式"><a href="#方法一：中缀转后缀（逆波兰）表达式" class="headerlink" title="方法一：中缀转后缀（逆波兰）表达式"></a>方法一：中缀转后缀（逆波兰）表达式</h1><p>唯一需要注意的地方就是计算的中间结果范围可能出现超出 int 类型的情况。因此，在进行逆波兰计算的时候，使用 long 来计算。</p><p>逆波兰计算器的原理是使用逆波兰表达式来计算出表达式的值，我们人类能够熟练使用的是中缀表达式，比如2×(9+6/3-5)+4就是一个中缀表达式，但是看到上面的简单计算器就知道处理起来很麻烦。于是有一种逆波兰计算器，计算是在逆波兰表达式（也叫做后缀表达式）的基础上。</p><p>逆波兰计算器的计算过程为：从左到右扫描后缀表达式，遇到数字就入栈，遇到操作符就从栈弹出两个数字，然后计算得到的值继续入栈，继续扫描表达式，直到扫描完毕得到结果。</p><p>把中缀表达式转成后缀表达式？</p><p>转换规则</p><pre><code>　　1）我们使用一个stack栈结构存储操作符，用一个List结构存储后缀表达式结果　　2）首先读取到数字，直接存入list中　　3）当读取到左括号&quot;(&quot;时，直接压栈，当读取到运算符时，分两种情况讨论　　　　a.当运算符栈为空或者栈顶操作符的优先级小于当前运算符优先级时(如+和-的优先级低于 * 和 /)，直接入栈　　　　b.当运算符不为空时且栈顶操作符的优先级大于或等于当前运算符优先级时，循环执行出栈操作并加入list中，直到遇到优先级小于当前运算符的元素为止。循环执行完后再将当前运算符压栈。另外需要注意的是，只有遇到右括号时，左括号才出栈　　4) 当遇到右括号&quot;)&quot;时，循环执行出栈操作并加入到list中，直到遇到左括号为止。并将左括号弹出，但不加入list中　　5) 表达式的值读取完后，将操作符栈中的所有元素弹出并加入到list中　　执行完上面步骤后，list中存储的顺序即为我们转换后的后缀表达式的结果</code></pre><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String expression = s.replaceAll(<span class="string">" "</span>, <span class="string">""</span>); <span class="comment">//去空格</span></span><br><span class="line">        List&lt;String&gt; infix = expressionToList(expression); <span class="comment">//表达式转中缀</span></span><br><span class="line">        List&lt;String&gt; suffix = parseToSuffixExpression(infix); <span class="comment">//中缀转后缀</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 存储中间结果</span></span><br><span class="line">        <span class="comment">// 逆波兰计算器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suffix.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOper(suffix.get(i))) &#123;</span><br><span class="line">                String b = stack.pop();</span><br><span class="line">                String a = stack.pop();</span><br><span class="line">                String result = cal(a, suffix.get(i), b);</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(suffix.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * num1 和 num2 进行 oper 计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">cal</span><span class="params">(String num1, String oper, String num2)</span> </span>&#123;</span><br><span class="line">        Long result = <span class="number">0L</span>;</span><br><span class="line">        Long a = Long.parseLong(num1);</span><br><span class="line">        Long b = Long.parseLong(num2);</span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                result = a + b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                result = a - b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                result = a * b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                result = a / b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中缀转后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  List&lt;String&gt; <span class="title">parseToSuffixExpression</span><span class="params">(List&lt;String&gt; expressionList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈用于保存操作符</span></span><br><span class="line">        Stack&lt;String&gt; opStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个list用于保存后缀表达式</span></span><br><span class="line">        List&lt;String&gt; suffixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String item : expressionList)&#123;</span><br><span class="line">            <span class="comment">//得到数或操作符</span></span><br><span class="line">            <span class="keyword">if</span>(isOper(item))&#123;</span><br><span class="line">                <span class="comment">//是操作符 判断操作符栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(opStack.isEmpty() || <span class="string">"("</span>.equals(opStack.peek()) || priority(item) &gt; priority(opStack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//为空或者栈顶元素为左括号或者当前操作符大于栈顶操作符直接压栈</span></span><br><span class="line">                    opStack.push(item);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则将栈中元素出栈如队，直到遇到大于当前操作符或者遇到左括号时</span></span><br><span class="line">                    <span class="keyword">while</span> (!opStack.isEmpty() &amp;&amp; !<span class="string">"("</span>.equals(opStack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(priority(item) &lt;= priority(opStack.peek()))&#123;</span><br><span class="line">                            suffixList.add(opStack.pop());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前操作符压栈</span></span><br><span class="line">                    opStack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isNumber(item))&#123;</span><br><span class="line">                <span class="comment">//是数字则直接入队</span></span><br><span class="line">                suffixList.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"("</span>.equals(item))&#123;</span><br><span class="line">                <span class="comment">//是左括号，压栈</span></span><br><span class="line">                opStack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">")"</span>.equals(item))&#123;</span><br><span class="line">                <span class="comment">//是右括号 ，将栈中元素弹出入队，直到遇到左括号，左括号出栈，但不入队</span></span><br><span class="line">                <span class="keyword">while</span> (!opStack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"("</span>.equals(opStack.peek()))&#123;</span><br><span class="line">                        opStack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        suffixList.add(opStack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"有非法字符！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环完毕，如果操作符栈中元素不为空，将栈中元素出栈入队</span></span><br><span class="line">        <span class="keyword">while</span> (!opStack.isEmpty())&#123;</span><br><span class="line">            suffixList.add(opStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suffixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"+"</span>.equals(string) || <span class="string">"-"</span>.equals(string) || <span class="string">"*"</span>.equals(string)</span><br><span class="line">                || <span class="string">"/"</span>.equals(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//匹配数字（非负数，整数和小数）和 负数</span></span><br><span class="line">        <span class="keyword">return</span> num.matches(<span class="string">"\\d+"</span>) || (num.charAt(<span class="number">0</span>)==<span class="string">'-'</span> &amp;&amp; num.substring(<span class="number">1</span>,num.length()).matches(<span class="string">"\\d+"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串转为中缀 List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">expressionToList</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = expression.length();</span><br><span class="line">        String num = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = expression.charAt(i);</span><br><span class="line">            <span class="comment">//直接用Character.isDigit判断会忽略负数和小数的情况</span></span><br><span class="line">            <span class="keyword">if</span> (isNumber(c+<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != len - <span class="number">1</span> &amp;&amp; Character.isDigit(expression.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                    num += c;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    num += c;</span><br><span class="line">                    list.add(num);</span><br><span class="line">                    num = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//处理负数情况</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span> &amp;&amp; (i == <span class="number">0</span> || !Character.isDigit(expression.charAt(i - <span class="number">1</span>)))) &#123;</span><br><span class="line">                    num += c;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(c + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回操作符的优先级，+- 为 0，* / 为 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"+"</span>.equals(oper) || <span class="string">"-"</span>.equals(oper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"*"</span>.equals(oper) || <span class="string">"/"</span>.equals(oper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>227.基本计算器 II</title>
    <link href="http://yoursite.com/2021/11/02/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/"/>
    <id>http://yoursite.com/2021/11/02/227. 基本计算器 II/</id>
    <published>2021-11-02T03:12:12.000Z</published>
    <updated>2021-11-02T10:04:31.752Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p><p>字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;3+2*2&quot;输出: 7</code></pre><p>示例 2:</p><pre><code>输入: &quot; 3/2 &quot;输出: 1</code></pre><p>示例 3:</p><pre><code>输入: &quot; 3+5 / 2 &quot;输出: 5</code></pre><p>说明：</p><p>你可以假设所给定的表达式都是有效的。<br>请不要使用内置的库函数 eval。</p><h1 id="解法一：单栈的经典应用"><a href="#解法一：单栈的经典应用" class="headerlink" title="解法一：单栈的经典应用"></a>解法一：单栈的经典应用</h1><p>此算法的思路很简单，先把乘除法的值计算出来，最终将所有的运算简化成只有加法。</p><ol><li>先跳过空格</li><li>出现了数字则记录整个数字是多少，然后根据之前的运算符决定下一步：</li></ol><ul><li>如果是加号’+’，说明前面的运算独立于以后的运算，可以将结果暂时放入栈；</li><li>如果是减号’-‘，可以看成<code>-1 * tempNum</code>，然后将<code>-tempNum</code>入栈；</li><li>如果是乘号’*’或者除号’/‘，由于前面的运算独立于此，可以先计算<code>lastNum</code>和<code>tempNum</code>积，然后结果入栈。</li></ul><ol start="3"><li>最后将栈中的所有元素相加就是答案。</li></ol><p>注意的点，在写代码的时候注意到pop要和push成对使用，之前混用了offer和poll，但对其实际用法并没有详细了解。结果导致出现了意料之外的结果。</p><details>    <summary>栈的经典应用</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        char lastOp = &apos;+&apos;;</span><br><span class="line">        char[] arr = s.toCharArray();</span><br><span class="line">        for(int i = 0; i &lt; arr.length; i ++)&#123;</span><br><span class="line">            if(arr[i] == &apos; &apos;) continue;</span><br><span class="line"></span><br><span class="line">            if(Character.isDigit(arr[i]))&#123;</span><br><span class="line">                int tempNum = arr[i] - &apos;0&apos;;</span><br><span class="line">                while(++i &lt; arr.length &amp;&amp; Character.isDigit(arr[i]))&#123;</span><br><span class="line">                    tempNum = tempNum * 10 + (arr[i] - &apos;0&apos;);</span><br><span class="line">                &#125; i--;</span><br><span class="line"></span><br><span class="line">                if(lastOp == &apos;+&apos;) numStack.push(tempNum);</span><br><span class="line">                else if(lastOp == &apos;-&apos;) numStack.push(-tempNum);</span><br><span class="line">                else numStack.push(res(lastOp, numStack.pop(), tempNum));</span><br><span class="line">            &#125; else lastOp = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int num : numStack) ans += num;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int res(char op, int a, int b)&#123;</span><br><span class="line">        if(op == &apos;*&apos;) return a * b;</span><br><span class="line">        else if(op == &apos;/&apos;) return a / b;</span><br><span class="line">        else if(op == &apos;+&apos;) return a + b; //其实加减运算可以忽略</span><br><span class="line">        else return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <h1 id="解法二：双栈算法"><a href="#解法二：双栈算法" class="headerlink" title="解法二：双栈算法"></a>解法二：双栈算法</h1><p>这个算法有个专门的名称Shunting-yard algorithm</p><p>栈oprands存储表达式中的整数。<br>栈opors存储表达式中的运算符。</p><p>从左向右遍历字符串，</p><p>当s[i] 为空格时，过滤掉空格；</p><p>当s[i] 为数字数，提取连续的整数。存入oprands。</p><p>当s[i] 为运算符时，如果s[i]的优先级比opors栈顶运算符高，那么s[i]入opors栈。</p><p>如果不是，那么弹出opors栈顶运算符，和oprands栈顶的两个整数，计算，结果存入oprands栈。</p><p>最终的解在oprands中。</p><details>    <summary>双栈算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    static Stack&lt;Integer&gt; num = new Stack&lt;Integer&gt;();</span><br><span class="line">    static Stack&lt;Character&gt; op = new Stack&lt;Character&gt;();</span><br><span class="line">    static HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">    static void eval()</span><br><span class="line">    &#123;</span><br><span class="line">        int b = num.pop();</span><br><span class="line">        int a = num.pop();</span><br><span class="line">        char c = op.pop();</span><br><span class="line">        int r = 0;</span><br><span class="line">        if(c == &apos;+&apos;) r = a + b;</span><br><span class="line">        else if(c == &apos;-&apos;) r = a - b;</span><br><span class="line">        else if(c == &apos;*&apos;) r = a * b;</span><br><span class="line">        else r = a / b;</span><br><span class="line">        num.add(r); </span><br><span class="line">    &#125;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        s = &apos;0&apos; + s; // 对开头是负数的处理 </span><br><span class="line">        map.put(&apos;+&apos;, 1);   //定义运算符的优先级</span><br><span class="line">        map.put(&apos;-&apos;, 1);</span><br><span class="line">        map.put(&apos;*&apos;, 2);</span><br><span class="line">        map.put(&apos;/&apos;, 2);</span><br><span class="line">        for(int i = 0; i &lt; s.length();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            char c = s.charAt(i);</span><br><span class="line">            if(c == &apos; &apos;) continue;  //跳过空格</span><br><span class="line">            if(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)  //c是数字,读取一个连续的数字</span><br><span class="line">            &#123;</span><br><span class="line">                int x = 0, j = i;</span><br><span class="line">                while(j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= &apos;0&apos; &amp;&amp; s.charAt(j) &lt;= &apos;9&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = x * 10 + s.charAt(j) - &apos;0&apos;;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">                i = j - 1;</span><br><span class="line">                num.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">            else  //c是操作符 </span><br><span class="line">            &#123;     //op栈非空并且栈顶操作符优先级大于等于当前操作符c的优先级，进行eval()计算</span><br><span class="line">                while(!op.isEmpty() &amp;&amp; map.get(op.peek()) &gt;= map.get(c)) eval();</span><br><span class="line">                op.add(c); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!op.isEmpty()) eval();</span><br><span class="line">        return num.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <h1 id="解法三：不用栈"><a href="#解法三：不用栈" class="headerlink" title="解法三：不用栈"></a>解法三：不用栈</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int calculate(String s) &#123;</span><br><span class="line">        int res = 0, tmp = 0, curNum = 0, n = s.length();</span><br><span class="line">        //res存结果，tmp存当前高优先级运算结果，curNum存当前字母段所代表的数值</span><br><span class="line">        char op = &apos;+&apos;;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char c = s.charAt(i);</span><br><span class="line">            if (Character.isDigit(c)) &#123;</span><br><span class="line">                curNum = curNum * 10 + c - &apos;0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (c == &apos;+&apos; || c == &apos;-&apos; || c == &apos;*&apos; || c == &apos;/&apos; || i == n - 1) &#123;</span><br><span class="line">                switch (op) &#123;</span><br><span class="line">                    case &apos;+&apos;:tmp+=curNum;break;</span><br><span class="line">                    case &apos;-&apos;:tmp-=curNum;break;</span><br><span class="line">                    case &apos;*&apos;:tmp*=curNum;break;</span><br><span class="line">                    case &apos;/&apos;:tmp/=curNum;break;</span><br><span class="line">                &#125;</span><br><span class="line">                //单独判断连乘、连除结束 或 达到最后一个字符，例如：3 + 2 * 2</span><br><span class="line">                //如果没有下面这个if则会出错</span><br><span class="line">                if (c == &apos;+&apos; || c == &apos;-&apos; || i == n - 1) &#123;</span><br><span class="line">                    res += tmp;</span><br><span class="line">                    tmp = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                op = c;//更新操作符</span><br><span class="line">                curNum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式的值。&lt;/p&gt;
&lt;p&gt;字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>560. 和为 K 的子数组</title>
    <link href="http://yoursite.com/2021/10/31/560.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/31/560. 和为 K 的子数组/</id>
    <published>2021-10-31T08:12:12.000Z</published>
    <updated>2021-10-31T13:55:37.873Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [1,1,1], k = 2输出：2</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,3], k = 3输出：2</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2 * 104-1000 &lt;= nums[i] &lt;= 1000-107 &lt;= k &lt;= 107</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><p>一开始想用713题中的滑动窗口双指针来做，但发现由于数组中有可能有负数，这种方法不适用。</p><h2 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h2><p><strong>思路和算法</strong><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p>考虑以 <em>i</em> 结尾和为 <em>k</em> 的连续子数组个数，我们需要统计符合条件的下标 <em>j</em> 的个数，其中0&lt;=j&lt;=i 且 <em>[j..i]</em> 这个子数组的和恰好为 <em>k</em> 。</p><p>我们可以枚举 <em>[0..i]</em> 里所有的下标 <em>j</em> 来判断是否符合条件，可能有读者会认为假定我们确定了子数组的开头和结尾，还需要 <em>O(n)</em> 的时间复杂度遍历子数组来求和，那样复杂度就将达到 <em>O(n^3)</em> 从而无法通过所有测试用例。但是如果我们知道 <em>[j,i]</em> 子数组的和，就能 <em>O(1)</em> 推出 <em>[j-1,i]</em> 的和，因此这部分的遍历求和是不需要的，我们在枚举下标 <em>j</em> 的时候已经能 <em>O(1)</em> 求出 <em>[j,i]</em> 的子数组之和。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; nums.length; ++start) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> end = start; end &gt;= <span class="number">0</span>; --end) &#123;</span><br><span class="line">                sum += nums[end];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; nums.size(); ++start) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> end = start; end &gt;= <span class="number">0</span>; --end) &#123;</span><br><span class="line">                sum += nums[end];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subarraySum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> start = <span class="number">0</span>; start &lt; nums.length; ++start) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> end = start; end &gt;= <span class="number">0</span>; --end) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraySum</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> start := <span class="number">0</span>; start &lt; <span class="built_in">len</span>(nums); start++ &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end := start; end &gt;= <span class="number">0</span>; end-- &#123;</span><br><span class="line">            sum += nums[end]</span><br><span class="line">            <span class="keyword">if</span> sum == k &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 为数组的长度。枚举子数组开头和结尾需要 <em>O(n^2)</em> 的时间，其中求和需要 <em>O(1)</em> 的时间复杂度，因此总时间复杂度为 <em>O(n^2)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。只需要常数空间存放若干变量。</p></li></ul><h2 id="方法二：前缀和-哈希表优化"><a href="#方法二：前缀和-哈希表优化" class="headerlink" title="方法二：前缀和 + 哈希表优化"></a>方法二：前缀和 + 哈希表优化</h2><p><strong>思路和算法</strong></p><p>我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个 <em>i</em>，我们需要枚举所有的 <em>j</em> 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。 </p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt; Integer, Integer &gt; mp = <span class="keyword">new</span> HashMap &lt; &gt; ();</span><br><span class="line">        mp.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (mp.containsKey(pre - k)) &#123;</span><br><span class="line">                count += mp.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            mp.put(pre, mp.getOrDefault(pre, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="keyword">if</span> (mp.find(pre - k) != mp.end()) &#123;</span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subarraySum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> mp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    mp.set(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        pre += x;</span><br><span class="line">        <span class="keyword">if</span> (mp.has(pre - k)) &#123;</span><br><span class="line">            count += mp.get(pre - k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mp.has(pre)) &#123;</span><br><span class="line">            mp.set(pre, mp.get(pre) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp.set(pre, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraySum</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count, pre := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        pre += nums[i]</span><br><span class="line">        <span class="keyword">if</span> _, ok := m[pre - k]; ok &#123;</span><br><span class="line">            count += m[pre - k]</span><br><span class="line">        &#125;</span><br><span class="line">        m[pre] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为数组的长度。我们遍历数组的时间复杂度为 <em>O(n)</em>，中间利用哈希表查询删除的复杂度均为 <em>O(1)</em>，因此总时间复杂度为 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(n)*，其中 *n</em> 为数组的长度。哈希表在最坏情况下可能有 <em>n</em> 个不同的键值，因此需要 <em>O(n)</em> 的空间复杂度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Prefix Sum" scheme="http://yoursite.com/tags/Prefix-Sum/"/>
    
  </entry>
  
  <entry>
    <title>MySQL面试高频20问</title>
    <link href="http://yoursite.com/2021/10/31/MySQL%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%9120%E9%97%AE/"/>
    <id>http://yoursite.com/2021/10/31/MySQL面试高频20问/</id>
    <published>2021-10-31T06:12:12.000Z</published>
    <updated>2021-10-31T08:20:36.687Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL面试高频20问</p><a id="more"></a><p>[TOC]</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>20道MySQL面试题<a href="http://coderleixiaoshuai.gitee.io/java-eight-part/#/" target="_blank" rel="noopener">^1</a>   </p><h2 id="说说MySQL-的基础架构图"><a href="#说说MySQL-的基础架构图" class="headerlink" title="说说MySQL 的基础架构图"></a>说说MySQL 的基础架构图</h2><p><a href="https://blog.csdn.net/GrayGo/article/details/118885029#:~:text=Mysql%20%E7%9A%84%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84,MySql%20%E5%9C%A8%E6%9E%B6%E6%9E%84%E4%B8%8A%E6%80%BB%E4%BD%93%E4%B8%8A%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AFserver%E5%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B1%82%E3%80%82%201.server%E5%B1%82%E7%BB%93%E6%9E%84%20Server%E5%B1%82%E5%8C%85%E6%8B%AC%E8%BF%9E%E6%8E%A5%E5%99%A8%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%99%A8%EF%BC%8C%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%8C%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%99%A8%E3%80%82" target="_blank" rel="noopener">https://blog.csdn.net/GrayGo/article/details/118885029#:~:text=Mysql%20%E7%9A%84%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84,MySql%20%E5%9C%A8%E6%9E%B6%E6%9E%84%E4%B8%8A%E6%80%BB%E4%BD%93%E4%B8%8A%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AFserver%E5%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B1%82%E3%80%82%201.server%E5%B1%82%E7%BB%93%E6%9E%84%20Server%E5%B1%82%E5%8C%85%E6%8B%AC%E8%BF%9E%E6%8E%A5%E5%99%A8%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%99%A8%EF%BC%8C%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%8C%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%99%A8%E3%80%82</a></p><p>Mysql逻辑架构图主要分三层： （1）第一层负责连接处理，授权认证，安全等等 （2）第二层负责编译并优化SQL<br>（3）第三层是存储引擎<br><a href="https://zhuanlan.zhihu.com/p/391596282" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/391596282</a></p><h2 id="一条SQL查询语句在MySQL中如何执行的？"><a href="#一条SQL查询语句在MySQL中如何执行的？" class="headerlink" title="一条SQL查询语句在MySQL中如何执行的？"></a>一条SQL查询语句在MySQL中如何执行的？</h2><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限会先查询缓存(MySQL8.0 版本以前)。</p><p>如果没有缓存，分析器进行词法分析，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。</p><p>最后优化器确定执行方案进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。</p><h2 id="日常工作中你是怎么优化SQL的？"><a href="#日常工作中你是怎么优化SQL的？" class="headerlink" title="日常工作中你是怎么优化SQL的？"></a>日常工作中你是怎么优化SQL的？</h2><p>1 优化表结构</p><p>（1）尽量使用数字型字段</p><p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。 这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>（2）尽可能的使用 varchar 代替 char</p><p>变长字段存储空间小，可以节省存储空间。</p><p>（3）当索引列大量重复数据时，可以把索引删除掉</p><p>比如有一列是性别，几乎只有男、女、未知，这样的索引是无效的。</p><p>2 优化查询</p><ul><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符</li><li>应尽量避免在 where 子句中使用 or 来连接条件</li><li>任何查询也不要出现select *</li><li>避免在 where 子句中对字段进行 null 值判断</li></ul><p>3 索引优化</p><p>对作为查询条件和 order by的字段建立索引<br>避免建立过多的索引，多使用组合索引</p><p>索引优化的一些要点：<br> 使用索引时，有一些技巧：</p><pre><code>1.索引不会包含有NULL的列   只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。2.使用短索引   对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。3.索引列排序   mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。4.like语句操作  一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。5.不要在列上进行运算6.不使用NOT IN 、&lt;&gt;、！=操作，但&lt;,&lt;=，=，&gt;,&gt;=,BETWEEN,IN是可以用到索引的7.索引要建立在经常进行select操作的字段上。   这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。8.索引要建立在值比较唯一的字段上。9.对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。10.在where和join中出现的列需要建立索引。11.where的查询条件里有不等号(where column != …),mysql将无法使用索引。12.如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。13.在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。索引的创建原则索引并非越多越好，一个表中如果有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为在表中的数据更改的同时，索引也会进行调整和更新避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。搜索的索引列，不一定是所要选择的列。换句话说，最适合索引的列是出现在WHERE子句中的列，或连接子句中指定的列，而不是出现在SELECT关键字后的选择列表中的列。使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。利用最左前缀。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</code></pre><h2 id="怎么看执行计划（explain），如何理解其中各个字段的含义？"><a href="#怎么看执行计划（explain），如何理解其中各个字段的含义？" class="headerlink" title="怎么看执行计划（explain），如何理解其中各个字段的含义？"></a>怎么看执行计划（explain），如何理解其中各个字段的含义？</h2><p>在 select 语句之前增加explain关键字，会返回执行计划的信息。</p><h2 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><p>分析语句，是否加载了不必要的字段/数据<br>分析 SQL 执行句，是否命中索引等<br>如果 SQL 很复杂，优化 SQL 结构<br>如果表数据量太大，考虑分表</p><p><a href="https://www.cnblogs.com/zsql/p/13854191.html" target="_blank" rel="noopener">https://www.cnblogs.com/zsql/p/13854191.html</a></p><h2 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h2><p>Primary Key（聚集索引）：InnoDB存储引擎的表会存在主键（唯一非null），如果建表的时候没有指定主键，则会使用第一非空的唯一索引作为聚集索引，否则InnoDB会自动帮你创建一个不可见的、长度为6字节的row_id用来作为聚集索引。</p><p>可以按以下四个维度回答：</p><p>（1）一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。</p><p>（2）聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p><p><strong>此处有异议：聚集索引的存储并不是物理上连续的，而是逻辑上连续的</strong></p><p>a. InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p><p>由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描。</p><p>聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</p><p>b. 有些博客可能会告诉我们：聚集索引按照顺序物理地址存储数据。其实不然，聚集索引的存储并不是物理上的连续，因为这样的维护成本会很高，而是逻辑上的连续！其中有两点：<br>1）所有的叶子结点都是通过双向链表连接的<br>2）每一个叶子结点中的行记录也是通过双向链表连接的</p><p>（3）索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p><p>（4）聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</p><h3 id="聚集索引-VS-非聚集索引"><a href="#聚集索引-VS-非聚集索引" class="headerlink" title="聚集索引 VS 非聚集索引"></a>聚集索引 VS 非聚集索引</h3><p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p><p>这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：</p><p>①聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</p><p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p><p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</p><p>②非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p><p>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p><p><a href="https://www.cnblogs.com/cangqinglang/p/15042752.html" target="_blank" rel="noopener">https://www.cnblogs.com/cangqinglang/p/15042752.html</a></p><h2 id="为什么要用-B-树，为什么不用普通二叉树？"><a href="#为什么要用-B-树，为什么不用普通二叉树？" class="headerlink" title="为什么要用 B+ 树，为什么不用普通二叉树？"></a>为什么要用 B+ 树，为什么不用普通二叉树？</h2><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是普通二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是 B+ 树呢？</p><p>（1）为什么不是普通二叉树？</p><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><p>（2）为什么不是平衡二叉树呢？</p><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><p>（3）为什么不是 B 树而是 B+ 树呢？</p><p>B+ 树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</p><p>B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p><h2 id="Hash-索引和B-树索引区别是什么？你在设计索引是怎么抉择的？"><a href="#Hash-索引和B-树索引区别是什么？你在设计索引是怎么抉择的？" class="headerlink" title="Hash 索引和B+树索引区别是什么？你在设计索引是怎么抉择的？"></a>Hash 索引和B+树索引区别是什么？你在设计索引是怎么抉择的？</h2><p>B+ 树可以进行范围查询，Hash 索引不能。<br>B+ 树支持联合索引的最左侧原则，Hash 索引不支持。<br>B+ 树支持 order by 排序，Hash 索引不支持。<br>Hash 索引在等值查询上比 B+ 树效率更高。<br>B+ 树使用 like 进行模糊查询的时候，like 后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</p><h2 id="什么是最左前缀原则？什么是最左匹配原则？"><a href="#什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则？"></a>什么是最左前缀原则？什么是最左匹配原则？</h2><p>最左前缀原则，就是最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边。</p><p>当我们创建一个组合索引的时候，如 (a1,a2,a3)，相当于创建了（a1）、(a1,a2)和(a1,a2,a3)三个索引，这就是最左匹配原则。</p><p><a href="https://zhuanlan.zhihu.com/p/142852474" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/142852474</a></p><h2 id="索引不适合哪些场景"><a href="#索引不适合哪些场景" class="headerlink" title="索引不适合哪些场景?"></a>索引不适合哪些场景?</h2><p>数据量少的不适合加索引<br>更新比较频繁的也不适合加索引 = 区分度低的字段不适合加索引（如性别）</p><h2 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h2><p>(1) 优点：</p><p>唯一索引可以保证数据库表中每一行的数据的唯一性<br>索引可以加快数据查询速度，减少查询时间</p><p>(2)缺点：</p><p>创建索引和维护索引要耗费时间<br>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间<br>以表中的数据进行增、删、改的时候，索引也要动态的维护。</p><h2 id="MySQL-遇到过死锁问题吗，你是如何解决的？"><a href="#MySQL-遇到过死锁问题吗，你是如何解决的？" class="headerlink" title="MySQL 遇到过死锁问题吗，你是如何解决的？"></a>MySQL 遇到过死锁问题吗，你是如何解决的？</h2><p>（1）查看死锁日志 show engine innodb status; （2）找出死锁Sql<br>（3）分析sql加锁情况<br>（4）模拟死锁案发<br>（5）分析死锁日志<br>（6）分析死锁结果</p><h2 id="说说数据库的乐观锁和悲观锁是什么以及它们的区别"><a href="#说说数据库的乐观锁和悲观锁是什么以及它们的区别" class="headerlink" title="说说数据库的乐观锁和悲观锁是什么以及它们的区别"></a>说说数据库的乐观锁和悲观锁是什么以及它们的区别</h2><p>（1）悲观锁：</p><p>悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。</p><p>（2）乐观锁：</p><p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。</p><p>实现方式：乐观锁一般会使用版本号机制或CAS(Compare And Set)算法实现。</p><h2 id="MVCC-熟悉吗，知道它的底层原理"><a href="#MVCC-熟悉吗，知道它的底层原理" class="headerlink" title="MVCC 熟悉吗，知道它的底层原理"></a>MVCC 熟悉吗，知道它的底层原理</h2><p>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术。</p><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</p><p>MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用读已提交（READ COMMITTD）、可重复读（REPEATABLE READ）这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，数据的可重复读其实就是ReadView的重复使用。</p><p><a href="https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ</a></p><h2 id="MySQL事务四大特性以及实现原理"><a href="#MySQL事务四大特性以及实现原理" class="headerlink" title="MySQL事务四大特性以及实现原理"></a>MySQL事务四大特性以及实现原理</h2><p>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br>一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。<br>隔离性： 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。<br>持久性： 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</p><h2 id="事务的隔离级别有哪些？MySQL的默认隔离级别是什么"><a href="#事务的隔离级别有哪些？MySQL的默认隔离级别是什么" class="headerlink" title="事务的隔离级别有哪些？MySQL的默认隔离级别是什么"></a>事务的隔离级别有哪些？MySQL的默认隔离级别是什么</h2><p>读未提交（Read Uncommitted）<br>读已提交（Read Committed）<br>可重复读（Repeatable Read）<br>串行化（Serializable）</p><p>Mysql默认的事务隔离级别是可重复读(Repeatable Read)</p><p><a href="https://developer.aliyun.com/article/743691" target="_blank" rel="noopener">https://developer.aliyun.com/article/743691</a><br><a href="https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ</a></p><h3 id="可重复读为什么会出现幻读"><a href="#可重复读为什么会出现幻读" class="headerlink" title="可重复读为什么会出现幻读"></a>可重复读为什么会出现幻读</h3><p>在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p><p><a href="https://juejin.cn/post/6985751855426977800" target="_blank" rel="noopener">https://juejin.cn/post/6985751855426977800</a></p><p>mysql是解决了快照读的幻读问题，没解决当前读的幻读问题，但不管它有没有解决幻读问题，它都是不能替代串行化隔离级别的。</p><h2 id="什么是幻读，脏读，不可重复读呢？"><a href="#什么是幻读，脏读，不可重复读呢？" class="headerlink" title="什么是幻读，脏读，不可重复读呢？"></a>什么是幻读，脏读，不可重复读呢？</h2><p>事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据，这就是脏读。</p><p>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。</p><p>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</p><h3 id="“不可重复读”和“幻读”的区别"><a href="#“不可重复读”和“幻读”的区别" class="headerlink" title="“不可重复读”和“幻读”的区别"></a>“不可重复读”和“幻读”的区别</h3><p>“不可重复读”关注的重点在于记录的更新操作，对同样的记录，再次读取后发现返回的数据值不一样了；“幻读”关注的重点在于记录新增或者删除操作（数据条数发生了变化），同样的条件第一次和第二次查询出来的记录数不一样。</p><h2 id="MySQL数据库cpu飙升的话，要怎么处理呢？"><a href="#MySQL数据库cpu飙升的话，要怎么处理呢？" class="headerlink" title="MySQL数据库cpu飙升的话，要怎么处理呢？"></a>MySQL数据库cpu飙升的话，要怎么处理呢？</h2><p>排查过程：</p><p>（1）使用top 命令观察，确定是mysql导致还是其他原因。<br>（2）如果是mysql导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。<br>（3）找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</p><p>处理：</p><p>（1）kill 掉这些线程(同时观察 cpu 使用率是否下降)，<br>（2）进行相应的调整(比如说加索引、改 sql、改内存参数)<br>（3）重新跑这些 SQL。</p><p>其他情况：</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session会话 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p><h2 id="MYSQL的主从延迟，你怎么解决？"><a href="#MYSQL的主从延迟，你怎么解决？" class="headerlink" title="MYSQL的主从延迟，你怎么解决？"></a>MYSQL的主从延迟，你怎么解决？</h2><p>主从复制分了五个步骤进行：</p><p>步骤一：主库的更新事件(update、insert、delete)被写到binlog<br>步骤二：从库发起连接，连接到主库。<br>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。<br>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log<br>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db<br>主从同步延迟的原因</p><p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p><p>主从同步延迟的解决办法</p><p>主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置等。<br>选择更好的硬件设备作为slave。<br>把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。<br>增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。</p><h2 id="如果让你做分库与分表的设计，简单说说你会怎么做？"><a href="#如果让你做分库与分表的设计，简单说说你会怎么做？" class="headerlink" title="如果让你做分库与分表的设计，简单说说你会怎么做？"></a>如果让你做分库与分表的设计，简单说说你会怎么做？</h2><p>分库分表方案:</p><p>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。<br>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。<br>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。<br>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。<br>常用的分库分表中间件：</p><p>sharding-jdbc<br>Mycat<br>分库分表可能遇到的问题</p><p>事务问题：需要用分布式事务啦<br>跨节点Join的问题：解决这一问题可以分两次查询实现<br>跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。<br>数据迁移，容量规划，扩容等问题<br>ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID<br>跨分片的排序分页问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL面试高频20问&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>713. 乘积小于K的子数组</title>
    <link href="http://yoursite.com/2021/10/28/713.%20%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/28/713. 乘积小于K的子数组/</id>
    <published>2021-10-28T08:12:12.000Z</published>
    <updated>2021-10-31T01:31:35.684Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个正整数数组 nums和整数 k 。</p><p>请找出该数组内乘积小于 k 的连续的子数组的个数。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: nums = [10,5,2,6], k = 100输出: 8解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,2,3], k = 0输出: 0</code></pre><p>提示: </p><p>1 &lt;= nums.length &lt;= 3 * 104<br>1 &lt;= nums[i] &lt;= 1000<br>0 &lt;= k &lt;= 106</p><h1 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h1><p><strong>分析</strong><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/solution/cheng-ji-xiao-yu-kde-zi-shu-zu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><p>题解一中 ans += lo - i - 1</p><p>其实是ans+=(lo-2) - i + 1，为了方便运算prefix[0]默认为0后移了1，另外二分法得到的值lo相比最大的位置又后移了1</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        k = math.log(k)</span><br><span class="line"></span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            prefix.append(prefix[<span class="number">-1</span>] + math.log(x))</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(prefix):</span><br><span class="line">            j = bisect.bisect(prefix, x + k - <span class="number">1e-9</span>, i+<span class="number">1</span>)</span><br><span class="line">            ans += j - i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> logk = Math.log(k);</span><br><span class="line">        <span class="keyword">double</span>[] prefix = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prefix[i+<span class="number">1</span>] = prefix[i] + Math.log(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = prefix.length;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//可以不-1e-9</span></span><br><span class="line">                <span class="keyword">if</span> (prefix[mi] &lt; prefix[i] + logk - <span class="number">1e-9</span>) lo = mi + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += lo - i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        prod = <span class="number">1</span></span><br><span class="line">        ans = left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            prod *= val</span><br><span class="line">            <span class="keyword">while</span> prod &gt;= k:</span><br><span class="line">                prod /= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            ans += right - left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prod = <span class="number">1</span>, ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            prod *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (prod &gt;= k) prod /= nums[left++];</span><br><span class="line">            ans += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个正整数数组 nums和整数 k 。&lt;/p&gt;
&lt;p&gt;请找出该数组内乘积小于 k 的连续的子数组的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>209. 长度最小的子数组</title>
    <link href="http://yoursite.com/2021/10/28/209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/28/209. 长度最小的子数组/</id>
    <published>2021-10-28T03:12:12.000Z</published>
    <updated>2021-10-28T08:11:31.454Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre><p>示例 2：</p><pre><code>输入：target = 4, nums = [1,4,4]输出：1</code></pre><p>示例 3：</p><pre><code>输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><p>提示：</p><p>1 &lt;= target &lt;= 109<br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 105</p><p>进阶：</p><p>如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。</p><h1 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h1><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/" target="_blank" rel="noopener">^1</a>注意：使用 <code>Python</code> 语言实现方法一会超出时间限制。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = Math.min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>cpp</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.Length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) </span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = Math.Min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == <span class="keyword">int</span>.MaxValue ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">            sum += nums[j]</span><br><span class="line">            <span class="keyword">if</span> sum &gt;= s &#123;</span><br><span class="line">                ans = min(ans, j - i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ans == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                total += nums[j]</span><br><span class="line">                <span class="keyword">if</span> total &gt;= s:</span><br><span class="line">                    ans = min(ans, j - i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; numsSize; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = fmin(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是数组的长度。需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：前缀和-二分查找"><a href="#方法二：前缀和-二分查找" class="headerlink" title="方法二：前缀和 + 二分查找"></a>方法二：前缀和 + 二分查找</h1><p>题解二分查找中java的binarySearch方法返回有两种：</p><p>一种是刚好找到目标值，返回目标值的下标。</p><p>一种是找不到目标值，则会返回比目标值大的元素的下标，下标带有负数，且从1开始数起。</p><p>例如一个数组有3个元素，但是查找的元素值比那三个元素都大，则会返回-4</p><p>注意题目要找的是大于等于target的连续子数组和。</p><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[lowerbound-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">LowerBound</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">-1</span>, originL = l, originR = r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) </span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (a[l] &gt;= target) ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>下面是这道题的代码。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">        <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">        <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> bound = Arrays.binarySearch(sums, target);</span><br><span class="line">            <span class="comment">//找不到目标值，则会返回比目标值大的元素的下标，下标带有负数，且从1开始数起</span></span><br><span class="line">            <span class="keyword">if</span> (bound &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bound = -bound - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bound &lt;= n) &#123;</span><br><span class="line">                ans = Math.min(ans, bound - (i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(n + <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">        <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">        <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> bound = lower_bound(sums.begin(), sums.end(), target);</span><br><span class="line">            <span class="keyword">if</span> (bound != sums.end()) &#123;</span><br><span class="line">                ans = min(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((bound - sums.begin()) - (i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">LowerBound</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">-1</span>, originL = l, originR = r;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) </span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (a[l] &gt;= target) ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.Length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">        <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">        <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> bound = LowerBound(sums, i, n, target);</span><br><span class="line">            <span class="keyword">if</span> (bound != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = Math.Min(ans, bound - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == <span class="keyword">int</span>.MaxValue ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    sums := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">    <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">    <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">    <span class="comment">// 以此类推</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        target := s + sums[i<span class="number">-1</span>]</span><br><span class="line">        bound := sort.SearchInts(sums, target)</span><br><span class="line">        <span class="keyword">if</span> bound &lt; <span class="number">0</span> &#123;</span><br><span class="line">            bound = -bound - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bound &lt;= n &#123;</span><br><span class="line">            ans = min(ans, bound - (i - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ans == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        sums = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sums.append(sums[<span class="number">-1</span>] + nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            target = s + sums[i - <span class="number">1</span>]</span><br><span class="line">            bound = bisect.bisect_left(sums, target)</span><br><span class="line">            <span class="keyword">if</span> bound != len(sums):</span><br><span class="line">                ans = min(ans, bound - (i - <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[r] &lt; q) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= q) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> *sums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numsSize + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 为了方便计算，令 size = n + 1</span></span><br><span class="line">    <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">    <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">    <span class="comment">// 以此类推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> bound = lower_bound(sums, <span class="number">1</span>, numsSize, target);</span><br><span class="line">        <span class="keyword">if</span> (bound != <span class="number">-1</span>) &#123;</span><br><span class="line">            ans = fmin(ans, bound - (i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法三：滑动窗口"><a href="#方法三：滑动窗口" class="headerlink" title="方法三：滑动窗口"></a>方法三：滑动窗口</h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol3-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSubArrayLen</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">int</span>[] nums</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.Length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">int</span>.MaxValue;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) </span><br><span class="line">            &#123;</span><br><span class="line">                ans = Math.Min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == <span class="keyword">int</span>.MaxValue ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end &lt; n &#123;</span><br><span class="line">        sum += nums[end]</span><br><span class="line">        <span class="keyword">for</span> sum &gt;= s &#123;</span><br><span class="line">            ans = min(ans, end - start + <span class="number">1</span>)</span><br><span class="line">            sum -= nums[start]</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        end++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ans == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; n:</span><br><span class="line">            total += nums[end]</span><br><span class="line">            <span class="keyword">while</span> total &gt;= s:</span><br><span class="line">                ans = min(ans, end - start + <span class="number">1</span>)</span><br><span class="line">                total -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; numsSize) &#123;</span><br><span class="line">        sum += nums[end];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            ans = fmin(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[start];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个含有 n 个正整数的数组和一个正整数 target 。&lt;/p&gt;
&lt;p&gt;找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Prefix Sum" scheme="http://yoursite.com/tags/Prefix-Sum/"/>
    
  </entry>
  
  <entry>
    <title>318. 最大单词长度乘积</title>
    <link href="http://yoursite.com/2021/10/27/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2021/10/27/318. 最大单词长度乘积/</id>
    <published>2021-10-27T09:12:12.000Z</published>
    <updated>2021-10-27T10:28:55.078Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]输出: 16 解释: 这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。</code></pre><p>示例 2:</p><pre><code>输入: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]输出: 4 解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</code></pre><p>示例 3:</p><pre><code>输入: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]输出: 0 解释: 不存在这样的两个单词。</code></pre><p>提示：</p><p>2 &lt;= words.length &lt;= 1000<br>1 &lt;= words[i].length &lt;= 1000<br>words[i] 仅包含小写字母</p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>从简单方法开始慢慢深入。<a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/solution/zui-da-dan-ci-chang-du-cheng-ji-by-leetcode/" target="_blank" rel="noopener">^1</a></p><blockquote><p>将每个单词与其他所有单词一一比较。如果两个单词没有公共字母，则更新 <code>maxProd</code>。</p></blockquote><p>先不考虑实现方法 <code>noCommonLetters</code>，该解法的代码如下：</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[snippet1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">no_common_letters</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">            <span class="comment"># TODO</span></span><br><span class="line">            </span><br><span class="line">        n = len(words)</span><br><span class="line">        max_prod = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> no_common_letters(words[i], words[j]):</span><br><span class="line">                    max_prod = max(max_prod, len(words[i]) * len(words[j]))</span><br><span class="line">        <span class="keyword">return</span> max_prod</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[snippet1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noCommonLetters</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = words.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxProd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="keyword">if</span> (noCommonLetters(words[i], words[j]))</span><br><span class="line">          maxProd = Math.max(maxProd, words[i].length() * words[j].length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxProd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p>方法一：最小化方法 <em>f(L_1, L_2)</em> 的复杂度。</p></li><li><p>方法二：最小化单词的比较次数。不需要O(N^2) 次比较，在所有具有相同字符集的单词中只保留最长的一个单词。例：（<em>ab</em>，<em>aaaaabaabaaabb</em>，<em>bbabbabba</em>）中只保留最长的一个单词（<em>aaaaabaabaaabb</em>）。</p></li></ul><h1 id="方法一：优化的方法-noCommonLetters：位操作-预计算"><a href="#方法一：优化的方法-noCommonLetters：位操作-预计算" class="headerlink" title="方法一：优化的方法 noCommonLetters：位操作+预计算"></a>方法一：优化的方法 noCommonLetters：位操作+预计算</h1><p>首先最小化单词比较 <em>f(L_1, L_2)</em> 的复杂度。</p><p>逐个检查第一个单词的每个字母是否出现在第二个单词中，这种方法不是最优的。</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[snippet2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_common_letters</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s1:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[snippet2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noCommonLetters</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s1.toCharArray())</span><br><span class="line">    <span class="keyword">if</span> (s2.indexOf(ch) != -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </details><p>更好的方法是使用位操作。</p><p>单词仅包含小写字母，可以使用 26 个字母的位掩码对单词的每个字母处理，判断是否存在某个字母。如果单词中存在字母 <code>a</code>，则将位掩码的第一位设为 <code>1</code>，否则设为 <code>0</code>。如果单词中存在字母 <code>b</code>，则将位掩码的第二位设为 <code>1</code>，否则设为 <code>0</code>。依次类推，一直判断到字母 <code>z</code>。</p><blockquote><p>如何设置掩码的第 n 位？使用标准的位操作：<code>n_th_bit = 1 &lt;&lt; n</code>。</p></blockquote><blockquote><p>如何计算一个单词的位掩码？遍历单词的每个字母，计算该字母在掩码中的位置 <code>n = (int)ch - (int)&#39;a&#39;</code>，然后创建一个第 n 位为 1 的掩码 <code>n_th_bit = 1 &lt;&lt; n</code>，通过或操作将该码合并到位掩码中 <code>bitmask |= n_th_bit</code>。</p></blockquote><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[snippet3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_common_letters</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">    bit_number = <span class="keyword">lambda</span> ch : ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    bitmask1 = bitmask2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s1:</span><br><span class="line">        bitmask1 |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s2:</span><br><span class="line">        bitmask2 |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">    <span class="keyword">return</span> bitmask1 &amp; bitmask2 == <span class="number">0</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[snippet3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitNumber</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)ch - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noCommonLetters</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> bitmask1 = <span class="number">0</span>, bitmask2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s1.toCharArray())</span><br><span class="line">    bitmask1 |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s2.toCharArray())</span><br><span class="line">    bitmask2 |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (bitmask1 &amp; bitmask2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>前面方法中，每个单词需要计算 N 次位掩码。实际上，每个单词的位掩码可以预先计算并存储起来，之后每次直接拿来比较。</p><p>因为 Java 的优化，操作数组比 HashMap 更快，所以使用两个整数数组存储位掩码和字符串长度。</p><p><strong>算法</strong></p><ul><li><p>预计算所有单词的位掩码，并把它们存储在数组 <code>masks</code> 中。使用数组 <code>lens</code> 存储所有单词的长度。</p></li><li><p>逐一两两比较单词。如果两个单词不存在公共字母，则更新最大单词长度乘积 <code>maxProd</code>。使用数组 <code>masks</code> 可以在常数时间内判断两个单词是否包含公共字母：<code>(masks[i] &amp; masks[j]) == 0</code>。</p></li><li><p>返回 <code>maxProd</code>。</p></li></ul><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        n = len(words)</span><br><span class="line">        masks = [<span class="number">0</span>] * n</span><br><span class="line">        lens = [<span class="number">0</span>] * n</span><br><span class="line">        bit_number = <span class="keyword">lambda</span> ch : ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            bitmask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> words[i]:</span><br><span class="line">                <span class="comment"># add bit number bit_number in bitmask</span></span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">            masks[i] = bitmask</span><br><span class="line">            lens[i] = len(words[i])</span><br><span class="line">            </span><br><span class="line">        max_val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> masks[i] &amp; masks[j] == <span class="number">0</span>:</span><br><span class="line">                    max_val = max(max_val, lens[i] * lens[j])</span><br><span class="line">        <span class="keyword">return</span> max_val</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitNumber</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)ch - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = words.length;</span><br><span class="line">    <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] lens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitmask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      bitmask = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> ch : words[i].toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// add bit number bit_number in bitmask</span></span><br><span class="line">        bitmask |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line">      &#125;</span><br><span class="line">      masks[i] = bitmask;</span><br><span class="line">      lens[i] = words[i].length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="keyword">if</span> ((masks[i] &amp; masks[j]) == <span class="number">0</span>)</span><br><span class="line">          maxVal = Math.max(maxVal, lens[i] * lens[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：优化比较次数：位操作-预计算-HashMap"><a href="#方法二：优化比较次数：位操作-预计算-HashMap" class="headerlink" title="方法二：优化比较次数：位操作+预计算+HashMap"></a>方法二：优化比较次数：位操作+预计算+HashMap</h1><p>方法一优化了比较过程，方法二优化比较次数。完成所有的两两比较需要 O(N^2)  。一些单词具有相同的字符集，则只保留这些单词中最长的一个单词即可。例如：单词集合（<em>ab<em>，</em>aaaaabaabaaabb<em>，</em>bbabbabba*）只保留单词 *aaaaabaabaaabb</em> 即可。使用 HashMap 代替方法一中的两个长度为 <em>N</em> 的数组，存储结构为：位掩码 -&gt; 该掩码对应的最大长度字符串。</p><p>这种方法单词比较次数可能会减少，从而提高 Python 解法的效率。由于 Java 中 HashMap 的性能问题，这种方法不会改善 Java 解法的效率。</p><p><strong>算法</strong></p><ul><li><p>预计算所有单词的位掩码，并将它们存储在 HashMap 中：位掩码 -&gt; 该掩码对应的最大长度字符串。例如：单词 “aaaaaaa” 和 “a” 具有相同的掩码。 </p></li><li><p>逐一两两比较 HashMap 中的单词。如果两个单词没有公共字母，更新最大单词长度乘积 <code>maxProd</code>。使用位掩码可以在常数时间内判断两个单词是否包含公共字母：<code>(x &amp; y) == 0</code>。</p></li><li><p>返回 <code>maxProd</code>。</p></li></ul><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        hashmap = defaultdict(int)</span><br><span class="line">        bit_number = <span class="keyword">lambda</span> ch : ord(ch) - ord(<span class="string">'a'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            bitmask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                <span class="comment"># add bit number bit_number in bitmask</span></span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; bit_number(ch)</span><br><span class="line">            <span class="comment"># there could be different words with the same bitmask</span></span><br><span class="line">            <span class="comment"># ex. ab and aabb</span></span><br><span class="line">            hashmap[bitmask] = max(hashmap[bitmask], len(word))</span><br><span class="line">        </span><br><span class="line">        max_prod = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">if</span> x &amp; y == <span class="number">0</span>:</span><br><span class="line">                    max_prod = max(max_prod, hashmap[x] * hashmap[y])</span><br><span class="line">        <span class="keyword">return</span> max_prod</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitNumber</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)ch - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hashmap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitmask = <span class="number">0</span>, bitNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      bitmask = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// add bit number bitNumber in bitmask</span></span><br><span class="line">        bitmask |= <span class="number">1</span> &lt;&lt; bitNumber(ch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// there could be different words with the same bitmask</span></span><br><span class="line">      <span class="comment">// ex. ab and aabb</span></span><br><span class="line">      hashmap.put(bitmask, Math.max(hashmap.getOrDefault(bitmask, <span class="number">0</span>), word.length()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxProd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : hashmap.keySet())</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> y : hashmap.keySet())</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; y) == <span class="number">0</span>) maxProd = Math.max(maxProd, hashmap.get(x) * hashmap.get(y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxProd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>1531. 压缩字符串 II</title>
    <link href="http://yoursite.com/2021/10/25/1531.%20%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/"/>
    <id>http://yoursite.com/2021/10/25/1531. 压缩字符串 II/</id>
    <published>2021-10-25T06:12:12.000Z</published>
    <updated>2021-10-26T02:08:45.928Z</updated>
    
    <content type="html"><![CDATA[<p>请你返回删除最多k个字符后，s行程长度编码的最小长度 。</p><a id="more"></a><p>[TOC]</p><p>行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 “aabccc” ，将 “aa” 替换为 “a2” ，”ccc” 替换为` “c3” 。因此压缩后的字符串变为 “a2bc3” 。</p><p>注意，本问题中，压缩时没有在单个字符后附加计数 ‘1’ 。</p><p>给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。</p><p>请你返回删除最多 k 个字符后，s 行程长度编码的最小长度 。</p><p>示例 1：</p><pre><code>输入：s = &quot;aaabcccd&quot;, k = 2输出：4解释：在不删除任何内容的情况下，压缩后的字符串是 &quot;a3bc3d&quot; ，长度为 6 。最优的方案是删除 &apos;b&apos; 和 &apos;d&apos;，这样一来，压缩后的字符串为 &quot;a3c3&quot; ，长度是 4 。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;aabbaa&quot;, k = 2输出：2解释：如果删去两个 &apos;b&apos; 字符，那么压缩后的字符串是长度为 2 的 &quot;a4&quot; 。</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;aaaaaaaaaaa&quot;, k = 0输出：3解释：由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 &quot;a11&quot; ，长度为 3 。</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 1000 &lt;= k &lt;= s.lengths 仅包含小写英文字母</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题难度较大，题解中包含较多变量以及公式，希望读者认真阅读。</p><p>为了叙述方便，我们称给定的字符串 <em>s</em> 为「原串」，压缩后的字符串 <em>t</em> 为「压缩串」。我们的目标是从 <em>s</em> 中删除至多 <em>k</em> 个字符，使得其对应的 <em>t</em> 的长度最小。</p><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/string-compression-ii/solution/ya-suo-zi-fu-chuan-ii-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> calc = [](<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>, INT_MAX &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="comment">// 情况1:删除第i个字符</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况2：保留第i个字符</span></span><br><span class="line">                <span class="keyword">int</span> same = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//向前遍历与第i个字符相同的字符则考虑保留</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i0 = i; i0 &gt;= <span class="number">1</span> &amp;&amp; diff &lt;= j; --i0) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i0 - <span class="number">1</span>] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++same;</span><br><span class="line">                        f[i][j] = min(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ++diff;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//防止后面f[i0 - 1][j - diff] + calc(same)溢出,最大为Integer.MAX_VALUE - 3</span></span><br><span class="line">            Arrays.fill(f[i], Integer.MAX_VALUE - <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">//???</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> same = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i0 = i; i0 &gt;= <span class="number">1</span> &amp;&amp; diff &lt;= j; i0--) &#123;</span><br><span class="line">                    <span class="comment">//为了方便对边界条件进行处理，这里的 i和 j 都从 1 开始编号，但在字符串中仍然从0开始</span></span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(i0 - <span class="number">1</span>) == s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                        ++same;</span><br><span class="line">                        f[i][j] = Math.min(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        diff++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        calc = <span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">else</span> (<span class="number">2</span> <span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">else</span> (<span class="number">3</span> <span class="keyword">if</span> x &lt; <span class="number">100</span> <span class="keyword">else</span> <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [[<span class="number">10</span>**<span class="number">9</span>] * (k + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(min(k, i) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                same = diff = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i0 <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> s[i0 - <span class="number">1</span>] == s[i - <span class="number">1</span>]:</span><br><span class="line">                        same += <span class="number">1</span></span><br><span class="line">                        f[i][j] = min(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        diff += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> diff &gt; j:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> f[n][k]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> f[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> same = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i0 = i; i0 &gt;= <span class="number">1</span> &amp;&amp; diff &lt;= j; --i0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i0 - <span class="number">1</span>] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++same;</span><br><span class="line">                    f[i][j] = fmin(f[i][j], f[i0 - <span class="number">1</span>][j - diff] + calc(same));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++diff;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(|s|^2k)，其中 <em>|s|</em> 是原串 <em>s</em> 的长度。动态规划中状态的数目为 O(|s|k)，每一个状态需要 O(|s|) 的时间进行转移，相乘即可得到总时间复杂度。</p></li><li><p>空间复杂度：O(|s|k)，即为动态规划中状态的数目。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你返回删除最多k个字符后，s行程长度编码的最小长度 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>443. 压缩字符串</title>
    <link href="http://yoursite.com/2021/10/25/443.%20%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/10/25/443. 压缩字符串/</id>
    <published>2021-10-25T06:12:12.000Z</published>
    <updated>2021-10-25T09:08:02.616Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符数组 chars ，请使用下述算法压缩</p><a id="more"></a><p>[TOC]</p><p>从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：</p><p>如果这一组长度为 1 ，则将字符追加到 s 中。<br>否则，需要向 s 追加字符，后跟这一组的长度。<br>压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。</p><p>请在 修改完输入数组后 ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><p>示例 1：</p><pre><code>输入：chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]输出：返回 6 ，输入数组的前 6 个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]解释：&quot;aa&quot; 被 &quot;a2&quot; 替代。&quot;bb&quot; 被 &quot;b2&quot; 替代。&quot;ccc&quot; 被 &quot;c3&quot; 替代。</code></pre><p>示例 2：</p><pre><code>输入：chars = [&quot;a&quot;]输出：返回 1 ，输入数组的前 1 个字符应该是：[&quot;a&quot;]解释：没有任何字符串被替代。</code></pre><p>示例 3：</p><pre><code>输入：chars = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]输出：返回 4 ，输入数组的前 4 个字符应该是：[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]。解释：由于字符 &quot;a&quot; 不重复，所以不会被压缩。&quot;bbbbbbbbbbbb&quot; 被 “b12” 替代。注意每个数字在数组中都有它自己的位置。</code></pre><p>提示：</p><pre><code>1 &lt;= chars.length &lt;= 2000chars[i] 可以是小写英文字母、大写英文字母、数字或符号</code></pre><h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><p><strong>思路和算法</strong></p><p>为了实现原地压缩，我们可以使用双指针分别标志我们在字符串中读和写的位置。每次当读指针read 移动到某一段连续相同子串的最右侧，我们就在写指针 write 处依次写入该子串对应的字符和子串长度即可。</p><p>在实际代码中，当读指针位于字符串的末尾，或读指针指向的字符不同于下一个字符时，我们就认为读指针位于某一段连续相同子串的最右侧。该子串对应的字符即为读指针指向的字符串。我们使用变量记录该子串的最左侧的位置，这样子串长度即为read-left+1 。</p><p>特别地，为了达到 <em>O(1)</em> 空间复杂度，我们需要自行实现将数字转化为字符串写入到原字符串的功能。这里我们采用短除法将子串长度倒序写入原字符串中，然后再将其反转即可。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.size();</span><br><span class="line">        <span class="keyword">int</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; n; read++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read == n - <span class="number">1</span> || chars[read] != chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                <span class="keyword">int</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> anchor = write;</span><br><span class="line">                    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        chars[write++] = num % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                        num /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    reverse(&amp;chars[anchor], &amp;chars[write]);</span><br><span class="line">                &#125;</span><br><span class="line">                left = read + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> write;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="keyword">int</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; n; read++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read == n - <span class="number">1</span> || chars[read] != chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//为了记录新连续字符串字符内容，覆盖原有记录</span></span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                <span class="keyword">int</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//数字的起点位置</span></span><br><span class="line">                    <span class="keyword">int</span> anchor = write;</span><br><span class="line">                    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//数字从右到左写入字符数组中</span></span><br><span class="line">                        chars[write++] = (<span class="keyword">char</span>) (num % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">                        num /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将数字倒转过来</span></span><br><span class="line">                    reverse(chars, anchor, write - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left = read + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Compress(char[] chars) &#123;</span><br><span class="line">        int n = chars.Length;</span><br><span class="line">        int write = 0, left = 0;</span><br><span class="line">        for (int read = 0; read &lt; n; read++) &#123;</span><br><span class="line">            if (read == n - 1 || chars[read] != chars[read + 1]) &#123;</span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                int num = read - left + 1;</span><br><span class="line">                if (num &gt; 1) &#123;</span><br><span class="line">                    int anchor = write;</span><br><span class="line">                    while (num &gt; 0) &#123;</span><br><span class="line">                        chars[write++] = (char) (num % 10 + &apos;0&apos;);</span><br><span class="line">                        num /= 10;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Reverse(chars, anchor, write - 1);</span><br><span class="line">                &#125;</span><br><span class="line">                left = read + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Reverse(char[] chars, int left, int right) &#123;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            char temp = chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = *a;</span><br><span class="line">    *a = *b, *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">        swap(a++, --b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span> *chars, <span class="keyword">int</span> charsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> read = <span class="number">0</span>; read &lt; charsSize; read++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (read == charsSize - <span class="number">1</span> || chars[read] != chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">            chars[write++] = chars[read];</span><br><span class="line">            <span class="keyword">int</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> anchor = write;</span><br><span class="line">                <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    chars[write++] = num % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                    num /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(&amp;chars[anchor], &amp;chars[write]);</span><br><span class="line">            &#125;</span><br><span class="line">            left = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(self, chars: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(left: int, right: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                chars[left], chars[right] = chars[right], chars[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        n = len(chars)</span><br><span class="line">        write = left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> read <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> read == n - <span class="number">1</span> <span class="keyword">or</span> chars[read] != chars[read + <span class="number">1</span>]:</span><br><span class="line">                chars[write] = chars[read]</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">                num = read - left + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                    anchor = write</span><br><span class="line">                    <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                        chars[write] = str(num % <span class="number">10</span>)</span><br><span class="line">                        write += <span class="number">1</span></span><br><span class="line">                        num //= <span class="number">10</span></span><br><span class="line">                    reverse(anchor, write - <span class="number">1</span>)</span><br><span class="line">                left = read + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> write</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compress</span><span class="params">(chars []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    write, left := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> read, ch := <span class="keyword">range</span> chars &#123;</span><br><span class="line">        <span class="keyword">if</span> read == <span class="built_in">len</span>(chars)<span class="number">-1</span> || ch != chars[read+<span class="number">1</span>] &#123;</span><br><span class="line">            chars[write] = ch</span><br><span class="line">            write++</span><br><span class="line">            num := read - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span> &#123;</span><br><span class="line">                anchor := write</span><br><span class="line">                <span class="keyword">for</span> ; num &gt; <span class="number">0</span>; num /= <span class="number">10</span> &#123;</span><br><span class="line">                    chars[write] = <span class="string">'0'</span> + <span class="keyword">byte</span>(num%<span class="number">10</span>)</span><br><span class="line">                    write++</span><br><span class="line">                &#125;</span><br><span class="line">                s := chars[anchor:write]</span><br><span class="line">                <span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(s); i &lt; n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">                    s[i], s[n<span class="number">-1</span>-i] = s[n<span class="number">-1</span>-i], s[i]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left = read + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> write</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compress = <span class="function"><span class="keyword">function</span>(<span class="params">chars</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = chars.length;</span><br><span class="line">    <span class="keyword">let</span> write = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> read = <span class="number">0</span>; read &lt; n; read++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (read === n - <span class="number">1</span> || chars[read] !== chars[read + <span class="number">1</span>]) &#123;</span><br><span class="line">            chars[write++] = chars[read];</span><br><span class="line">            <span class="keyword">let</span> num = read - left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> anchor = write;</span><br><span class="line">                <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    chars[write++] = <span class="string">''</span> + num % <span class="number">10</span>;</span><br><span class="line">                    num = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(chars, anchor, write - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            left = read + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> write;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function">(<span class="params">chars, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = chars[left];</span><br><span class="line">        chars[left] = chars[right];</span><br><span class="line">        chars[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为字符串长度，我们只需要遍历该字符串一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。我们只需要常数的空间保存若干变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符数组 chars ，请使用下述算法压缩&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>338. 比特位计数</title>
    <link href="http://yoursite.com/2021/10/24/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2021/10/24/338. 比特位计数/</id>
    <published>2021-10-24T13:12:12.000Z</published>
    <updated>2021-10-24T14:03:05.727Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><p>输入：n = 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p><p>输入：n = 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101</p><p>提示：</p><p>0 &lt;= n &lt;= 105</p><p>进阶：</p><p>很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？</p><p>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这道题需要计算从 <em>0</em> 到 <em>n</em> 的每个整数的二进制表示中的 <em>1</em> 的数目。</p><p>部分编程语言有相应的内置函数用于计算给定的整数的二进制表示中的 <em>1</em> 的数目，下列各种方法均为不使用内置函数的解法。</p><p>为了表述简洁，下文用「一比特数」表示二进制表示中的 <em>1</em> 的数目。</p><p>参考<a href="https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/" target="_blank" rel="noopener">^1</a></p><h1 id="方法一：BrianKernighan-算法"><a href="#方法一：BrianKernighan-算法" class="headerlink" title="方法一：BrianKernighan  算法"></a>方法一：BrianKernighan  算法</h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = countOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = countOnes(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countOnes = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">        ones++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onesCount</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(ones <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; x &gt; <span class="number">0</span>; x &amp;= x - <span class="number">1</span> &#123;</span><br><span class="line">        ones++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bits &#123;</span><br><span class="line">        bits[i] = onesCount(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">countOnes</span><span class="params">(x: int)</span> -&gt; int:</span></span><br><span class="line">            ones = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">                x &amp;= (x - <span class="number">1</span>)</span><br><span class="line">                ones += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ones</span><br><span class="line">        </span><br><span class="line">        bits = [countOnes(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = countOnes(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">        ones++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = countOnes(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度O(nlogn) 。需要对从 <em>0</em> 到 <em>n</em> 的每个整数使用计算「一比特数」，对于每个整数计算「一比特数」的时间都不会超过O(logn)。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="方法二：动态规划——最高有效位"><a href="#方法二：动态规划——最高有效位" class="headerlink" title="方法二：动态规划——最高有效位"></a>方法二：动态规划——最高有效位</h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> highBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            highBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    highBit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i&amp;(i<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            highBit = i</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i-highBit] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        bits = [<span class="number">0</span>]</span><br><span class="line">        highBit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &amp; (i - <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                highBit = i</span><br><span class="line">            bits.append(bits[i - highBit] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    bits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            highBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*。对于每个整数，只需要 *O(1)</em> 的时间计算「一比特数」。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="方法三：动态规划——最低有效位"><a href="#方法三：动态规划——最低有效位" class="headerlink" title="方法三：动态规划——最低有效位"></a>方法三：动态规划——最低有效位</h1><p>方法二需要实时维护最高有效位，当遍历到的数是 <em>2</em> 的整数次幂时，需要更新最高有效位。如果再换一个思路，可以使用「最低有效位」计算「一比特数」。</p><p>对于正整数 <em>x</em>，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        bits[i] = bits[i&gt;&gt;<span class="number">1</span>] + i&amp;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        bits = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            bits.append(bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    bits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*。对于每个整数，只需要 *O(1)</em> 的时间计算「一比特数」。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="方法四：动态规划——最低设置位"><a href="#方法四：动态规划——最低设置位" class="headerlink" title="方法四：动态规划——最低设置位"></a>方法四：动态规划——最低设置位</h1><p>定义正整数 <em>x</em> 的「最低设置位」为 <em>x</em> 的二进制表示中的最低的 <em>1</em> 所在位。例如，<em>10</em> 的二进制表示是 <em>1010_{(2)}</em>，其最低设置位为 <em>2</em>，对应的二进制表示是 <em>10_{(2)}</em>。</p><p>遍历从 <em>1</em> 到 <em>n</em> 的每个正整数 <em>i</em>，计算 <img src="./p__textit%7Bbits%7D_.png" alt="\textit{bits} ">  的值。最终得到的数组 <img src="./p__textit%7Bbits%7D_.png" alt="\textit{bits} ">  即为答案。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol4-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bits = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol4-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        bits[i] = bits[i&amp;(i<span class="number">-1</span>)] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol4-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        bits = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            bits.append(bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bits</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bits(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol4-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bits = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    *returnSize = n + <span class="number">1</span>;</span><br><span class="line">    bits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*。对于每个整数，只需要 *O(1)</em> 的时间计算「一比特数」。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了返回的数组以外，空间复杂度为常数。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题虽然看起来简单，但做的时候还是有几个值得注意的点</p><h2 id="判断一个正整数是不是-2-的整数次幂-i-amp-i-1-0"><a href="#判断一个正整数是不是-2-的整数次幂-i-amp-i-1-0" class="headerlink" title="判断一个正整数是不是 2 的整数次幂(i &amp; (i - 1)) == 0"></a>判断一个正整数是不是 2 的整数次幂(i &amp; (i - 1)) == 0</h2><h2 id="与-amp-符号的运算优先级，注意加括号-bits-i-bits-i-gt-gt-1-i-amp-1"><a href="#与-amp-符号的运算优先级，注意加括号-bits-i-bits-i-gt-gt-1-i-amp-1" class="headerlink" title="与&amp;符号的运算优先级，注意加括号 bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);"></a>与&amp;符号的运算优先级，注意加括号 bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数 n ，对于 0 &amp;lt;= i &amp;lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>262. 行程和用户</title>
    <link href="http://yoursite.com/2021/10/21/262.%20%E8%A1%8C%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7/"/>
    <id>http://yoursite.com/2021/10/21/262. 行程和用户/</id>
    <published>2021-10-21T11:12:12.000Z</published>
    <updated>2021-10-21T12:16:04.136Z</updated>
    
    <content type="html"><![CDATA[<p>写一段 SQL 语句查出 “2013-10-01” 至 “2013-10-03” 期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 Ban<br>ned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。 </p><a id="more"></a><p>[TOC]</p><p>表：Trips</p><pre><code>+-------------+----------+| Column Name | Type     |+-------------+----------+| Id          | int      || Client_Id   | int      || Driver_Id   | int      || City_Id     | int      || Status      | enum     || Request_at  | date     |     +-------------+----------+</code></pre><p>Id 是这张表的主键。<br>这张表中存所有出租车的行程信息。每段行程有唯一 Id ，其中 Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。<br>Status 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_<br>client’) 。</p><p> 表：Users </p><pre><code>+-------------+----------+| Column Name | Type     |+-------------+----------+| Users_Id    | int      || Banned      | enum     || Role        | enum     |+-------------+----------+</code></pre><p>Users_Id 是这张表的主键。<br>这张表中存所有用户，每个用户都有一个唯一的 Users_Id ，Role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’,<br> ‘partner’) 。<br>Banned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。</p><p> 写一段 SQL 语句查出 “2013-10-01” 至 “2013-10-03” 期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 Ban<br>ned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。 </p><p> 取消率 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)。 </p><p> 返回结果表中的数据可以按任意顺序组织。其中取消率 Cancellation Rate 需要四舍五入保留 两位小数 。 </p><p> 查询结果格式如下例所示： </p><p>Trips 表：</p><pre><code>+----+-----------+-----------+---------+---------------------+------------+| Id | Client_Id | Driver_Id | City_Id | Status              | Request_at |+----+-----------+-----------+---------+---------------------+------------+| 1  | 1         | 10        | 1       | completed           | 2013-10-01 || 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 || 3  | 3         | 12        | 6       | completed           | 2013-10-01 || 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 || 5  | 1         | 10        | 1       | completed           | 2013-10-02 || 6  | 2         | 11        | 6       | completed           | 2013-10-02 || 7  | 3         | 12        | 6       | completed           | 2013-10-02 || 8  | 2         | 12        | 12      | completed           | 2013-10-03 || 9  | 3         | 10        | 12      | completed           | 2013-10-03 || 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |+----+-----------+-----------+---------+---------------------+------------+</code></pre><p>Users 表：</p><pre><code>+----------+--------+--------+| Users_Id | Banned | Role   |+----------+--------+--------+| 1        | No     | client || 2        | Yes    | client || 3        | No     | client || 4        | No     | client || 10       | No     | driver || 11       | No     | driver || 12       | No     | driver || 13       | No     | driver |+----------+--------+--------+</code></pre><p>Result 表：</p><pre><code>+------------+-------------------+| Day        | Cancellation Rate |+------------+-------------------+| 2013-10-01 | 0.33              || 2013-10-02 | 0.00              || 2013-10-03 | 0.50              |+------------+-------------------+</code></pre><p>2013-10-01：</p><ul><li>共有 4 条请求，其中 2 条取消。</li><li>然而，Id=2 的请求是由禁止用户（User_Id=2）发出的，所以计算时应当忽略它。</li><li>因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。</li><li>取消率为 (1 / 3) = 0.33<br>2013-10-02：</li><li>共有 3 条请求，其中 0 条取消。</li><li>然而，Id=6 的请求是由禁止用户发出的，所以计算时应当忽略它。</li><li>因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。</li><li>取消率为 (0 / 2) = 0.00<br>2013-10-03：</li><li>共有 3 条请求，其中 1 条取消。</li><li>然而，Id=8 的请求是由禁止用户发出的，所以计算时应当忽略它。</li><li>因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。</li><li>取消率为 (1 / 2) = 0.50</li></ul><p>统计每天非禁止用户的取消率，需要知道非禁止用户有哪些，总行程数，取消的行程数。</p><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>首先确定被禁止用户的行程记录，再剔除这些行程记录。</p><p>行程表中，字段 client_id 和 driver_id，都与用户表中的 users_id 关联。因此只要 client_id 和 driver_id 中有一个被禁止了，此条行程记录要被剔除。</p><p>先说一种错误的找出没被禁止用户行程记录的方法。此方法很有迷惑性。</p><p>思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (client_id = users_id 或 driver_id = users_id) 且 users_id没有被禁止</span><br><span class="line">&#123;</span><br><span class="line">    此条记录没被禁止。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Trips AS T JOIN Users AS U </span><br><span class="line">ON (T.client_id = U.users_id  OR T.driver_id = U.users_id )  AND U.banned =&apos;No&apos;</span><br></pre></td></tr></table></figure><p>乍一看，思路是对。其实是错误的。因为，我们不知觉得肯定了一个假设—— client_id 与 driver_id 是相同的。只有当两者相同时，才能用此条件排除被禁止用户的行程记录。</p><p>错误的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+------+-----------+-----------+---------+---------------------+------------+----------+--------+--------+</span><br><span class="line">| Id   | Client_Id | Driver_Id | City_Id | STATUS              | Request_at | Users_Id | Banned | Role   |</span><br><span class="line">+------+-----------+-----------+---------+---------------------+------------+----------+--------+--------+</span><br><span class="line">|    1 |         1 |        10 |       1 | completed           | 2013-10-01 |        1 | No     | client |</span><br><span class="line">|    1 |         1 |        10 |       1 | completed           | 2013-10-01 |       10 | No     | driver |</span><br><span class="line">|    2 |         2 |        11 |       1 | cancelled_by_driver | 2013-10-01 |       11 | No     | driver |</span><br><span class="line">|    3 |         3 |        12 |       6 | completed           | 2013-10-01 |        3 | No     | client |</span><br><span class="line">|    3 |         3 |        12 |       6 | completed           | 2013-10-01 |       12 | No     | driver |</span><br><span class="line">|    4 |         4 |        13 |       6 | cancelled_by_client | 2013-10-01 |        4 | No     | client |</span><br><span class="line">|    4 |         4 |        13 |       6 | cancelled_by_client | 2013-10-01 |       13 | No     | driver |</span><br><span class="line">|    5 |         1 |        10 |       1 | completed           | 2013-10-02 |        1 | No     | client |</span><br><span class="line">|    5 |         1 |        10 |       1 | completed           | 2013-10-02 |       10 | No     | driver |</span><br><span class="line">|    6 |         2 |        11 |       6 | completed           | 2013-10-02 |       11 | No     | driver |</span><br><span class="line">|    7 |         3 |        12 |       6 | completed           | 2013-10-02 |        3 | No     | client |</span><br><span class="line">|    7 |         3 |        12 |       6 | completed           | 2013-10-02 |       12 | No     | driver |</span><br><span class="line">|    8 |         2 |        12 |      12 | completed           | 2013-10-03 |       12 | No     | driver |</span><br><span class="line">|    9 |         3 |        10 |      12 | completed           | 2013-10-03 |        3 | No     | client |</span><br><span class="line">|    9 |         3 |        10 |      12 | completed           | 2013-10-03 |       10 | No     | driver |</span><br><span class="line">|   10 |         4 |        13 |      12 | cancelled_by_driver | 2013-10-03 |        4 | No     | client |</span><br><span class="line">|   10 |         4 |        13 |      12 | cancelled_by_driver | 2013-10-03 |       13 | No     | driver |</span><br><span class="line">+------+-----------+-----------+---------+---------------------+------------+----------+--------+--------+</span><br></pre></td></tr></table></figure><p>结果中，被禁止的 users_id = 2，其行程记录没被剔除掉。</p><p>明显， client_id 与 driver_id 不一定相同 。</p><p>正确的做法是对 client_id 和 driver_id 各自关联的 users_id，同时检测是否被禁止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (client_id = users_id_1 且 users_id_1没被禁止 并且 client_id = users_id_2 且 users_id_2没被禁止)&#123;</span><br><span class="line">    此条记录没被禁止。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Trips AS T</span><br><span class="line">JOIN Users AS U1 ON (T.client_id = U1.users_id AND U1.banned =&apos;No&apos;)</span><br><span class="line">JOIN Users AS U2 ON (T.driver_id = U2.users_id AND U2.banned =&apos;No&apos;)</span><br></pre></td></tr></table></figure><p>在此基础上，按日期分组，统计每组的 总行程数，取消的行程数 。</p><p>每组的总行程数：COUNT(T.STATUS)。</p><p>每组的取消的行程数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>取消率 = 每组的取消的行程数 / 每组的总行程数</p><p>完整逻辑为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM Trips AS T</span><br><span class="line">JOIN Users AS U1 ON (T.client_id = U1.users_id AND U1.banned =&apos;No&apos;)</span><br><span class="line">JOIN Users AS U2 ON (T.driver_id = U2.users_id AND U2.banned =&apos;No&apos;)</span><br><span class="line">WHERE T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure><p>其中 SUM 求和函数，COUNT 计数函数，ROUND 四舍五入函数。</p><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>思路与解法一相同。而采用不同的方法排除掉被禁止用户的行程记录。想到排除，就联想到集合差。</p><p>client_id 和 driver_id 的全部为集合 U。被禁止的 users_id 集合为 A。</p><p>U 减去 A 的结果为没被禁止的用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A</span><br></pre></td></tr></table></figure><p>好了，先演示一个错误的解法：</p><p>行程表连接表 A，排除掉被被禁止的行程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM trips AS T,</span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A</span><br><span class="line">WHERE (T.Client_Id != A.users_id AND T.Driver_Id != A.users_id)</span><br></pre></td></tr></table></figure><p>剩下的逻辑与解法一后部分相同，完善后的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM trips AS T,</span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A</span><br><span class="line">WHERE (T.Client_Id != A.users_id AND T.Driver_Id != A.users_id) AND T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure><p>很可惜，当表 A 为空时，此方法的结果是空表。但是表 A 为空，可能是有用户但是没有被禁止的用户。因此方法是错误的。</p><p>正确的解法是：行程表 left join 表 A 两次，A.users_id 都为 NULL 的行都是没被排除的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM trips AS T LEFT JOIN </span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A ON (T.Client_Id = A.users_id)</span><br><span class="line">LEFT JOIN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A1</span><br><span class="line">ON (T.Driver_Id = A1.users_id)</span><br><span class="line">WHERE A.users_id IS NULL AND A1.users_id IS NULL</span><br></pre></td></tr></table></figure><p>补上其它部分的逻辑为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM trips AS T LEFT JOIN </span><br><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A ON (T.Client_Id = A.users_id)</span><br><span class="line">LEFT JOIN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">) AS A1</span><br><span class="line">ON (T.Driver_Id = A1.users_id)</span><br><span class="line">WHERE A.users_id IS NULL AND A1.users_id IS NULL AND T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>与解法二思路相同。找出被禁止的用户后，不再连接行程表和用户表，直接从行程表中排除掉被被禁止用户的行程记录。</p><p>被禁止的用户用子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>行程表中 client_id 和 driver_id 都在此子查询结果中的行要剔除掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM trips AS T</span><br><span class="line">WHERE </span><br><span class="line">T.Client_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br><span class="line">AND</span><br><span class="line">T.Driver_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>补上其它部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.request_at AS `Day`, </span><br><span class="line">ROUND(</span><br><span class="line">SUM(</span><br><span class="line">IF(T.STATUS = &apos;completed&apos;,0,1)</span><br><span class="line">)</span><br><span class="line">/ </span><br><span class="line">COUNT(T.STATUS),</span><br><span class="line">2</span><br><span class="line">) AS `Cancellation Rate`</span><br><span class="line">FROM trips AS T</span><br><span class="line">WHERE </span><br><span class="line">T.Client_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br><span class="line">AND</span><br><span class="line">T.Driver_Id NOT IN (</span><br><span class="line">SELECT users_id</span><br><span class="line">FROM users</span><br><span class="line">WHERE banned = &apos;Yes&apos;</span><br><span class="line">)</span><br><span class="line">AND T.request_at BETWEEN &apos;2013-10-01&apos; AND &apos;2013-10-03&apos;</span><br><span class="line">GROUP BY T.request_at</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一段 SQL 语句查出 “2013-10-01” 至 “2013-10-03” 期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 Ban&lt;br&gt;ned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。 &lt;/p&gt;
    
    </summary>
    
      <category term="2021年10月" scheme="http://yoursite.com/categories/2021%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
</feed>
