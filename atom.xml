<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-05-22T00:41:57.949Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从文本中读取数据</title>
    <link href="http://yoursite.com/2022/05/22/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2022/05/22/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/</id>
    <published>2022-05-22T00:12:12.000Z</published>
    <updated>2022-05-22T00:41:57.949Z</updated>
    
    <content type="html"><![CDATA[<p>从文本中读取数据</p><span id="more"></span><p>[TOC]</p><p>一些比赛遇到需要从文本中读取输入数据,读取方式如下</p><h1 id="fstream读取"><a href="#fstream读取" class="headerlink" title="fstream读取"></a>fstream读取</h1><details>    <summary>从文本中读取文件</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ifstream inFile(&quot;in.txt&quot;);</span><br><span class="line">    ofstream outFile(&quot;out.txt&quot;);</span><br><span class="line">    int a;</span><br><span class="line">    inFile&gt;&gt;a;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    outFile&lt;&lt;a;</span><br><span class="line">    inFile.close();</span><br><span class="line">    outFile.close();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="修改配置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory"><a href="#修改配置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory" class="headerlink" title="修改配置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory"></a>修改配置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory</h1><p>但是在Xcode中一开始无法读入，发现问题是因为没有配置路径<a href="http://stackoverflow.com/questions/23438393/new-to-xcode-cant-open-files-in-c">^1</a></p><p>Put your .txt files in the same directory where your main.cpp file is (or anywhere you like).</p><p>In Xcode go to Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top) </p><p>Down under Options check “Use custom working directory” and set it to the directory where you .txt files are located. </p><p>To work with the files, you will have to specify just file names, e.g. in_file.open(“inputFile.txt”); no path is necessary.</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Scanner scanner = new Scanner(new File(System.getProperty(&quot;user.dir&quot;) + &quot;/src/in.txt&quot;));</span><br><span class="line">       while (scanner.hasNext()) &#123;</span><br><span class="line">           String number = scanner.nextLine();</span><br><span class="line">           Integer num = Integer.valueOf(number);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;从文本中读取数据&lt;/p&gt;</summary>
    
    
    
    <category term="2022年5月" scheme="http://yoursite.com/categories/2022%E5%B9%B45%E6%9C%88/"/>
    
    
    <category term="fstream" scheme="http://yoursite.com/tags/fstream/"/>
    
  </entry>
  
  <entry>
    <title>固态电子器件（Solid State Electronic Devices）</title>
    <link href="http://yoursite.com/2022/03/10/%E5%9B%BA%E6%80%81%E7%94%B5%E5%AD%90%E5%99%A8%E4%BB%B6%EF%BC%88Solid%20State%20Electronic%20Devices%EF%BC%89/"/>
    <id>http://yoursite.com/2022/03/10/%E5%9B%BA%E6%80%81%E7%94%B5%E5%AD%90%E5%99%A8%E4%BB%B6%EF%BC%88Solid%20State%20Electronic%20Devices%EF%BC%89/</id>
    <published>2022-03-10T14:12:12.000Z</published>
    <updated>2022-03-15T13:14:55.606Z</updated>
    
    <content type="html"><![CDATA[<p>Exam 1,2<br>春假前已经讲完第五章，第六章讲到6.1</p><span id="more"></span><p>[TOC]</p><h1 id="Exam-1"><a href="#Exam-1" class="headerlink" title="Exam 1"></a>Exam 1</h1><ol><li><p>Calculate: (1) the mass dennsity and (2) nearest distance between Sb atoms for single crystalline AlSb, which is a binary compound semiconductor with a zincblende lattice structure, biven the following:<br>计算：（1）单晶AlSb的质量密度和（2）Sb原子之间的最近距离，单晶AlSb是具有锌blende晶格结构的二元化合物半导体，其分辨如下：</p></li><li><p>Consider a one-dimensional, infinite potential well of width L with one of the two walls positioned at x&#x3D; L&#x2F;2.<br>Using first principle-based calculations, determine the normalized wavefunction and average momentum for the 11th particle in this well.<br>考虑一个宽度为 L 的一维、无限势阱，其中两个壁中的一个位于 x&#x3D; L&#x2F;2。<br>使用基于第一个原理的计算，确定该孔中第11个粒子的归一化波函数和平均动量。</p></li><li><p>Consider a piece of single crystal silicon at room temperature that is doped with phosphorus at 10^17 atmos&#x2F;cn^3 and an unspecified concentration of boron atoms. The Fermi energy is displaced from the intrinsic energy level by 0.3471 eV. For this piece of silicon, calculate:<br>考虑一块室温下的单晶硅，其中掺杂了10 ^ 17 atmos &#x2F; cn ^ 3的磷和未指定浓度的硼原子。费米能量从内在能级移位0.3471 eV。对于这块硅片，计算：</p></li></ol><p>a. The electron concentration in the conduction band<br>b. The hole concentration in the valence band<br>c. The Fermi Energy relative to the valence band</p><p>a. 导带中的电子浓度<br>b.价带中的孔浓度<br>c. 相对于价带的费米能量</p><ol start="4"><li>Consider a semiconductor that has the following properties: (1) the effective mass of electrons is significantly smaller than the effective mass for holes, and (2) electrons cannot transit the bandgap by only a change in their potential energy. For this semiconductor make a sketch of an E vs k plot. Justify key attributes of your sketch with some descriptive text.</li></ol><p>考虑具有以下性质的半导体：（1）电子的有效质量明显小于空穴的有效质量，以及（2）电子不能仅通过其势能的变化来传递带隙。对于此半导体，请绘制E与k图的草图。使用一些描述性文本对齐草图的关键属性。</p><ol start="5"><li>Arsenic is a commonly used dopant in silicon-based solid state devices.</li></ol><p>a. What type of conductivity is produced in silicon that is doped with arsenic?<br>b. Give three reasons as to why arsenic is an excellent dopant in silicon.<br>砷是硅基固态器件中常用的掺杂剂。</p><p>一个。掺杂砷的硅会产生什么类型的电导率？<br>b.给出三个理由来解释为什么砷是硅中一种极好的掺杂剂。</p><ol start="6"><li>Consider a rectangular piece of single crystal Si that is doped with phosphorus atoms and held at constant temperautre. A metal electrode is placed at each end of the Si and a positive potential is placed on the left electrode.<br>a. Draw the simplified energy band diagram for this piece of silicon<br>b. Indicate the behavior of electrons and holes in this piece of silicon</li></ol><p>考虑一块长方形的单晶Si，它掺杂了磷原子并保持恒定的温度。在Si的两端放置一个金属电极，并在左电极上放置一个正电位。<br>一个。为这块硅绘制简化的能带图<br>b.指示这块硅片中电子和空穴的行为</p><h1 id="Exam-2"><a href="#Exam-2" class="headerlink" title="Exam 2"></a>Exam 2</h1><p>建议还是讲讲这次我们的考试卷子Exam2</p><p>第三和第六题尤其不会，第一、二题也可以讲一下</p><p>我们上次作业⬆️，书上第四和第五章的习题 4.24,5.9,5.15<br>上上次作业⬆️，也是书上3.13, 4.6,4.15</p><p>每周一次课，北京时间周末早上，从第五六章开始讲</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>For Si, the bandgap is 1.12eV, the intrinsic ccarrier concentration at 300K is 1.5x10^10 &#x2F;cm^3, The effective mass of electrons is 9.828x10^(-31)kg, the effective mass of holes is 7.371x10(-31)kg and the relative permittivity is 11.8. The permittivity of free space is 8.85 x 10^(-14) F&#x2F;cm, The charge on an electron is 1.6 x 10^(-19)C. 1µm &#x3D; 10^(-4)cm</p><p>对于Si，带隙为1.12eV，300K时本征载流子浓度为1.5x10^10 &#x2F;cm^3 ，电子有效质量为9.828x10^（-31）kg，空穴有效质量为7.371x10（-31）kg，相对介电常数为11.8。自由空间的介电常数ε为8.85 x 10^（-14） F&#x2F;cm，电子上的电荷为1.6 x 10^（-19）C。</p><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>Consider an ideal p-n with a cross-sectional area is 0.001 cm^2.You know nothing about doping other than the dopant concerntrations which are 10^18 &#x2F; cm^2 and 10^15 &#x2F; cm^3.You have been told that the electric field extends deeper into the p-type side than the n-type side. For this structure,calculate:<br>考虑横截面积为 0.001 cm^2 的理想 p-n。除了掺杂剂关注的 10^18 &#x2F; cm^2 和 10^15 &#x2F; cm^3 之外，您对掺杂一无所知。您被告知电场延伸到 p 型侧比 n 型侧更深。对于此结构，请计算：</p><p>由xp0&gt;&gt;xno 得Na&lt;&lt;Nd, 故Na&#x3D;10^15 &#x2F;cm^3 ,Nd &#x3D; 10^18 &#x2F;cm^3</p><p>a. The Fermi level positions with respect to the intrinsic level in both neutral regions.<br>b. The contact potential<br>c. The penetration depths into the n-type and p-type regions<br>d. The total uncompensated charge on the n-side of the metallurgical junction<br>e.The maximum electric field</p><p>a. 费米能级相对于两个中性区域的内在能级。</p><p>参考 P93, e.g 3-5</p><p>b. 接触电势</p><p>参考P173，e.g 5-1 (b)(c)有两种计算方法</p><p>c. 渗透深度进入n型和p型区域<br>d. 冶金结n侧的未补偿电荷总量<br>e. 最大电场</p><h3 id="a-b参考P173，e-g-5-1"><a href="#a-b参考P173，e-g-5-1" class="headerlink" title="a,b参考P173，e.g 5-1"></a>a,b参考P173，e.g 5-1</h3><h3 id="c-d-e-参考P179-e-g-5-2"><a href="#c-d-e-参考P179-e-g-5-2" class="headerlink" title="c,d,e 参考P179, e.g 5-2"></a>c,d,e 参考P179, e.g 5-2</h3><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1><p>Consider a long, thin rectangular Si rod that is uniformly doped with phosphorus at a concentration of 10^17 &#x2F;cm^3 . As show in the diagram below, the top surface of the bar is uniformly illuminated by a small,<br>narrow sliver of light positioned ar the center of the bar. 10^20&#x2F;cm^3 electron-hole pairs are generated per second in the region of illuminations. The electron and hole lifetimes are both 10µs. The hole mobility is 500cm^2&#x2F;V-s and the electron diffusion coefficient is 36cm^2&#x2F;s. Calculate the position of the quasi fermi energy for holes with respect to the intrinsic energy level at a distance of 35 µm from the point of illumination?</p><p>考虑一根长而细的矩形Si棒，均匀地掺杂磷，浓度为10 ^ 17 &#x2F; cm ^ 3。如下图所示，条形图的顶部表面由一个小的，<br>狭窄的光线条位于杆的中心。在照明区域中每秒产生10 ^ 20 &#x2F; cm ^ 3电子 - 空穴对。电子和空穴寿命均为10μs。空穴迁移率µp为500cm^2 &#x2F;V-s，电子扩散系数Dn为36cm^2 &#x2F;s。计算相对于距照明点35μm距离的空穴的准费米能量固有能级的位置？</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>P81掺杂III族施主杂质 磷元素 N型半导体 </p><p>EHP 电子-空穴对</p><p>P101 迁移率<br>P130 4.3.3 稳态载流子产生：准费米能级</p><p>过剩载流子是指在外界因素影响下，非平衡态中比平衡态多的载流子。</p><p>δp 载流子浓度相对于热平衡载流子浓度的偏移<br>可以认为过剩载流子同时向两侧移动，所以分出一半来</p><p>P130 （4-11） gοp 光产生速率</p><p>P131 准费米能级的定义（存在过剩载流子时使用）<br>P135 Dp 空穴扩散系数</p><p>P136<br>爱因斯坦关系 （4-28）</p><p>D&#x2F;μ&#x3D;ΚΤ&#x2F;q</p><p>P141<br>空穴扩散长度Lp<br>过剩空穴注入半无限长的条状半导体中δp(x)&#x3D;Δp e^(-x&#x2F;Lp)</p><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><p>Consider a long, thin rectangular Si rod that is uniformly doped with phosphorus at a concentration of 10^16&#x2F;cm^3. The electron and hole lifetimes are 10µs. The diffusion coefficients for electrons and holes are 36 cm&#x2F;s and 12 cm&#x2F;s, respectively. Initially, the rod is uniformly illuminated with light on its left cross-sectional face and 10^19&#x2F;cm^3 electron-hole pairs are generated per second in the region of illumination. The light source is then shut off. Calculate the diffusion current density for holes at a distance of 5x10^(-3)cm from the left end of the bar after the light source has been off for 50µs</p><p>考虑一根长而细的矩形Si棒，均匀掺杂磷，浓度为10 ^ 16 &#x2F; cm ^ 3。电子和空穴寿命为10μs。电子和空穴的扩散系数分别为36 cm&#x2F;s和12 cm&#x2F;s。最初，杆在其左侧横截面上均匀地被光照亮，并且在照明区域中每秒产生10 ^ 19 &#x2F; cm ^ 3电子 - 空穴对。然后关闭光源。计算光源关闭50μs后，距离棒材左端5x10^（-3）cm处的孔的扩散电流密度</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>P135 Dp 空穴扩散系数<br>P136 通过单位面积扩散的电流密度Jn(diff)， Jp(diff)<br>空穴扩散随时间和距离的变化<br>过剩载流子浓度随时间的衰减规律一般服从exp(-t&#x2F;τ）的关系，常数τ表示过剩载流子在复合前的平均生存时间，称为非平衡&#x2F;过剩载流子寿命</p><p>P125 84页的 （4-6）<br> <a href="https://baike.baidu.com/item/%E5%B0%91%E6%95%B0%E8%BD%BD%E6%B5%81%E5%AD%90%E5%AF%BF%E5%91%BD/3111959">https://baike.baidu.com/item/少数载流子寿命/3111959</a><br>空穴的寿命τ，也就是空穴的平均生存时间，1&#x2F;τ就是单位时间内空穴的复合几率，Δp&#x2F;τ称为非平衡空穴的复合率 （即n型半导体中单位时间、单位体积内、净复合消失的电子-空穴对的数目）；非平衡载流子空穴的浓度随时间的变化率为dΔp &#x2F;dt &#x3D;－Δp &#x2F;τp, 如果τp与Δp 无关， 则Δp 有指数衰减规律：Δp &#x3D; (Δp) exp( -t&#x2F;τp ) 。</p><p>δp(t)&#x3D;Δp(t&#x3D;0) e^(-t&#x2F;τp)<br>P141<br>从（4-33b）95页 P141上面的部分那里应该也能推算出来</p><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1><p>Consider a direct semiconductor the has been exposed to photons having an energy that is greater than the bandgap under steady state conditions. Much to your surprise, you oberve that this semiconductor does not emit light. Using a simplified energy band diagram and supporting text, provide an explanation for your observations.</p><p>考虑一个直接半导体，它暴露在光子中，其能量在稳态条件下大于带隙。令您惊讶的是，您怀疑这种半导体不会发光。使用简化的能量带图和支持文本，为您的观测提供解释。</p><p>A: The schihar describes a semiconductor with a trapping skfe. The trapping skfe introduces an availabel energy skfe in the bandgap. Transforms from the trapping skfe (also known as a recombination skfe or recombination center) to the valence band do not lead to the creaha of a photom because the energy difference is too small. The two energy transform lead to lathce vibrahms, not photom creathm</p><p>schihar描述了一种带有捕获skfe的半导体。陷印 skfe 在带隙中引入了可用的能量 skfe。从捕获skfe（也称为重组skfe或重组中心）到价带的转换不会导致光子的吱吱声，因为能量差太小。两种能量变换导致花边振动，而不是光刻</p><h1 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h1><p>The following plot has been generated for an ideal p-n junction that is under equilibrium conditions. For this p-n junction, do the following:</p><p>为处于平衡条件下的理想 p-n 结生成了以下图。对于此 p-n 结点，请执行以下操作：</p><p>a. Sketch a cross-sectional diagram of the p-n junction showing all relevant regions. Indicate the location and direction of the electric field</p><p>b. Make a sketch of the simplified energy band diagram for this p-n junction (no calculations are necessary. Relative energy positions are sufficient).</p><p>c. What 3 important assumptions are made about the ideal p-n junction that are relevant to your energy band diagram?</p><p>a. 绘制显示所有相关区域的 p-n 交汇点的横截面图。指示电场的位置和方向</p><p>b.为此 p-n 结绘制简化能带图的草图（无需计算。相对能量位置就足够了）。</p><p>c. 关于理想 p-n 结，有哪些 3 个重要假设与您的能带图相关？</p><h2 id="P176-P178"><a href="#P176-P178" class="headerlink" title="P176 P178"></a>P176 P178</h2><h1 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h1><p>The figure below shows electron and hole concentrations in a single crystal silicon sample. Briefly describe key characteristics of the semiconductor and under what conditions this graph was likely collected.</p><p>下图显示了单个晶体硅样品中的电子和空穴浓度。简要描述半导体的关键特征以及在什么条件下可能收集此图。</p><p>横轴是时间，纵轴是空穴或电子浓度</p><p>（1）假设只掺杂了一种杂质，晶体硅是P型半导体,Na&#x3D;1x10^15 &#x2F;cm^3</p><p>（2） The semi conductor has been illuminated with photoms that have energy that is greater than then bandgap, so excess charge carriers are generated,<br>Δp&#x3D;Δn&#x3D;10^14 &#x2F;cm^3</p><p>半导体已经用光子照亮，这些光子的能量大于带隙，因此会产生多余的电荷载流子，<br>Δp&#x3D;Δn&#x3D;10^14 &#x2F;cm^3<br>因为少数载流子随时间衰减</p><p>(3)  electrons are the majority carriers<br>电子是多数载流子？ 此处应该是笔误，应该是空穴是多数载流子<br>Δn&#x3D;10^14 &#x2F;cm^3</p><p>no&#x3D;ni^2 &#x2F;po&#x3D;2.25x10^5 &#x2F;cm^3</p><p>？此时空穴浓度大于电子，所以是P型，而电子浓度低应该是P型半导体</p><p>(4) the photom source is shut off and the excess electron hole concentrations are exponentially decaying with time<br>光源被关闭，过剩电子空穴浓度随时间呈指数衰减</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>此题是P126 85页的e.g 4-2不是原题<br>图是一样的e.g 4-2不是硅晶，而此题是指定了硅晶体</p><p>掺杂砷是N型半导体，掺杂了Ga又是P型，此时空穴浓度大于电子，所以是P型，而电子浓度低应该是P型半导体</p><p>注意不是硅晶体所以本征载流子浓度近似为10^6 &#x2F;cm^-3</p><p>P84 56页掺杂两种GaAs<br>要看硅原子替换的是As原子的位置还是Ga原子的位置。如果取代的是As的位置，就会少一个成对电子（即对出一个空穴）就是P型半导体，如果取代的是Ga的位置就会多出一个成对电子，就是N型半导体</p><p>P96, 64页<br>P型半导体中Na 受主杂质浓度 &#x3D; p0</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Exam 1,2&lt;br&gt;春假前已经讲完第五章，第六章讲到6.1&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Electronic" scheme="http://yoursite.com/tags/Electronic/"/>
    
  </entry>
  
  <entry>
    <title>399. 除法求值</title>
    <link href="http://yoursite.com/2022/03/09/399.%20%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>http://yoursite.com/2022/03/09/399.%20%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</id>
    <published>2022-03-09T13:12:12.000Z</published>
    <updated>2022-03-09T15:02:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>返回 所有除法求值问题的答案</p><span id="more"></span><p>[TOC]</p><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] &#x3D; [Ai, Bi] 和 values[i] 共同表示等式 Ai &#x2F; Bi &#x3D; values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] &#x3D; [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj &#x2F; Dj &#x3D; ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p>示例 1：</p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]解释：条件：a / b = 2.0, b / c = 3.0问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</code></pre><p>示例 2：</p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]输出：[3.75000,0.40000,5.00000,0.20000]</code></pre><p>示例 3：</p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]输出：[0.50000,2.00000,-1.00000,-1.00000]</code></pre><p>提示：</p><pre><code>1 &lt;= equations.length &lt;= 20equations[i].length == 21 &lt;= Ai.length, Bi.length &lt;= 5values.length == equations.length0.0 &lt; values[i] &lt;= 20.01 &lt;= queries.length &lt;= 20queries[i].length == 21 &lt;= Cj.length, Dj.length &lt;= 5Ai, Bi, Cj, Dj 由小写英文字母与数字组成</code></pre><p>这道题是在「力扣」第 990 题（等式方程的可满足性）的基础上，在变量和变量之间有了倍数关系。由于 变量之间的倍数关系具有传递性，处理有传递性关系的问题，可以使用「并查集」，我们需要在并查集的「合并」与「查询」操作中 维护这些变量之间的倍数关系。</p><p>说明：请大家注意看一下题目中的「注意」和「数据范围」，例如：每个 Ai 或 Bi 是一个表示单个变量的字符串。所以用例 equation &#x3D; [“ab”, “cd”] ，这里的 ab 视为一个变量，不表示 a * b。如果面试中遇到这样的问题，一定要和面试官确认清楚题目的条件。还有 1 &lt;&#x3D; equations.length &lt;&#x3D; 20 和 values[i] &gt; 0.0 可以避免一些特殊情况的讨论。</p><h1 id="方法：并查集-1"><a href="#方法：并查集-1" class="headerlink" title="方法：并查集^1"></a>方法：并查集<a href="https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/">^1</a></h1><p>分析示例 1：</p><ul><li>a &#x2F; b &#x3D; 2.0 说明 a&#x3D;2b， a 和 b 在同一个集合中；</li><li>b &#x2F; c &#x3D; 3.0 说明 b&#x3D;3c ，b 和 c 在同一个集合中。</li></ul><p>求a&#x2F;c和b&#x2F;a</p><p>我们计算了两个结果，不难知道：可以将题目给出的 equation 中的两个变量所在的集合进行「合并」，同在一个集合中的两个变量就可以通过某种方式计算出它们的比值。具体来说，可以把 不同的变量的比值转换成为相同的变量的比值，这样在做除法的时候就可以消去相同的变量，然后再计算转换成相同变量以后的系数的比值，就是题目要求的结果。统一了比较的标准，可以以 O(1) 的时间复杂度完成计算。</p><p>如果两个变量不在同一个集合中， 返回 −1.0。并且根据题目的意思，如果两个变量中 至少有一个 变量没有出现在所有 equations 出现的字符集合中，也返回 −1.0。</p><h2 id="构建有向图"><a href="#构建有向图" class="headerlink" title="构建有向图"></a>构建有向图</h2><p>通过例 1 的分析，我们就知道了，题目给出的 equations 和 values 可以表示成一个图，equations 中出现的变量就是图的顶点，「分子」于「分母」的比值可以表示成一个有向关系（因为「分子」和「分母」是有序的，不可以对换），并且这个图是一个带权图，values 就是对应的有向边的权值。例 1 中给出的 equations 和 values 表示的「图形表示」、「数学表示」和「代码表示」如下表所示。其中 parent[a] &#x3D; b 表示：结点 a 的（直接）父亲结点是 b，与之对应的有向边的权重，记为 weight[a] &#x3D; 2.0，即 weight[a] 表示结点 a 到它的 直接父亲结点 的有向边的权重。</p><h2 id="「统一变量」与「路径压缩」的关系"><a href="#「统一变量」与「路径压缩」的关系" class="headerlink" title="「统一变量」与「路径压缩」的关系"></a>「统一变量」与「路径压缩」的关系</h2><p>刚刚在分析例 1 的过程中，提到了：可以把一个一个 query 中的不同变量转换成 同一个变量，这样在计算 query 的时候就可以以 O(1) 的时间复杂度计算出结果，在「并查集」的一个优化技巧中，「路径压缩」就恰好符合了这样的应用场景。</p><p>为了避免并查集所表示的树形结构高度过高，影响查询性能。「路径压缩」就是针对树的高度的优化。「路径压缩」的效果是：在查询一个结点 a 的根结点同时，把结点 a 到根结点的沿途所有结点的父亲结点都指向根结点。如下图所示，除了根结点以外，所有的结点的父亲结点都指向了根结点。特别地，也可以认为根结点的父亲结点就是根结点自己。如下国所示：路径压缩前后，并查集所表示的两棵树形结构等价，路径压缩以后的树的高度为 2，查询性能最好。</p><p>由于有「路径压缩」的优化，两个同在一个连通分量中的不同的变量，它们分别到根结点（父亲结点）的权值的比值，就是题目的要求的结果。</p><h2 id="如何在「查询」操作的「路径压缩」优化中维护权值变化"><a href="#如何在「查询」操作的「路径压缩」优化中维护权值变化" class="headerlink" title="如何在「查询」操作的「路径压缩」优化中维护权值变化"></a>如何在「查询」操作的「路径压缩」优化中维护权值变化</h2><p>如下图所示，我们在结点 a 执行一次「查询」操作。路径压缩会先一层一层向上先找到根结点 d，然后依次把 c、b 、a 的父亲结点指向根结点 d。</p><ul><li>c 的父亲结点已经是根结点了，它的权值不用更改；</li><li>b 的父亲结点要修改成根结点，它的权值就是从当前结点到根结点经过的所有有向边的权值的乘积，因此是 3.0 乘以 4.0 也就是 12.0；</li><li>a 的父亲结点要修改成根结点，它的权值就是依然是从当前结点到根结点经过的所有有向边的权值的乘积，但是我们 没有必要把这三条有向边的权值乘起来，这是因为 b 到 c，c 到 d 这两条有向边的权值的乘积，我们在把 b 指向 d 的时候已经计算出来了。因此，a 到根结点的权值就等于 b 到根结点 d 的新的权值乘以 a 到 b 的原来的有向边的权值。</li></ul><h2 id="如何在「合并」操作中维护权值的变化"><a href="#如何在「合并」操作中维护权值的变化" class="headerlink" title="如何在「合并」操作中维护权值的变化"></a>如何在「合并」操作中维护权值的变化</h2><p> 「合并」操作基于这样一个 很重要的前提：我们将要合并的两棵树的高度最多为 2，换句话说两棵树都必需是「路径压缩」以后的效果，两棵树的叶子结点到根结点最多只需要经过一条有向边。</p><p>例如已知  a&#x2F;b&#x3D;3.0， d&#x2F;c&#x3D;4.0 ，又已知  a&#x2F;d&#x3D; &#x3D;6.0 ，现在合并结点 a 和 d 所在的集合，其实就是把 a 的根结点 b 指向 d 的根结 c，那么如何计算 b 指向 c 的这条有向边的权重呢？</p><p>根据 a 经过 b 可以到达 c，a 经过 d 也可以到达 c，因此 两条路径上的有向边的权值的乘积是一定相等的。设 b 到 c 的权值为 x，那么 3.0⋅x&#x3D;6.0⋅4.0 ，得 x&#x3D;8.0。</p><h2 id="一个容易忽略的细节"><a href="#一个容易忽略的细节" class="headerlink" title="一个容易忽略的细节"></a>一个容易忽略的细节</h2><p>接下来还有一个小的细节问题：在合并以后，产生了一棵高度为 3 的树，那么我们在执行查询的时候，例如下图展示的绿色结点和黄色结点，绿色结点并不直接指向根结点，在计算这两个变量的比值的时候，计算边的权值的比值得到的结果是不对的。</p><p>但其实不用担心这个问题，并查集的「查询」操作会执行「路径压缩」，所以真正在计算两个变量的权值的时候，绿色结点已经指向了根结点，和黄色结点的根结点相同。因此可以用它们指向根结点的有向边的权值的比值作为两个变量的比值。</p><p>我们通过这个细节向大家强调：一边查询一边修改结点指向是并查集的特色。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        int equationsSize = equations.size();</span><br><span class="line"></span><br><span class="line">        UnionFind unionFind = new UnionFind(2 * equationsSize);</span><br><span class="line">        // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span><br><span class="line">        Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(2 * equationsSize);</span><br><span class="line">        int id = 0;</span><br><span class="line">        for (int i = 0; i &lt; equationsSize; i++) &#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            String var1 = equation.get(0);</span><br><span class="line">            String var2 = equation.get(1);</span><br><span class="line"></span><br><span class="line">            if (!hashMap.containsKey(var1)) &#123;</span><br><span class="line">                hashMap.put(var1, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!hashMap.containsKey(var2)) &#123;</span><br><span class="line">                hashMap.put(var2, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第 2 步：做查询</span><br><span class="line">        int queriesSize = queries.size();</span><br><span class="line">        double[] res = new double[queriesSize];</span><br><span class="line">        for (int i = 0; i &lt; queriesSize; i++) &#123;</span><br><span class="line">            String var1 = queries.get(i).get(0);</span><br><span class="line">            String var2 = queries.get(i).get(1);</span><br><span class="line"></span><br><span class="line">            Integer id1 = hashMap.get(var1);</span><br><span class="line">            Integer id2 = hashMap.get(var2);</span><br><span class="line"></span><br><span class="line">            if (id1 == null || id2 == null) &#123;</span><br><span class="line">                res[i] = -1.0d;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res[i] = unionFind.isConnected(id1, id2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class UnionFind &#123;</span><br><span class="line"></span><br><span class="line">        private int[] parent;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 指向的父结点的权值</span><br><span class="line">         */</span><br><span class="line">        private double[] weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public UnionFind(int n) &#123;</span><br><span class="line">            this.parent = new int[n];</span><br><span class="line">            this.weight = new double[n];</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                weight[i] = 1.0d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void union(int x, int y, double value) &#123;</span><br><span class="line">            int rootX = find(x);</span><br><span class="line">            int rootY = find(y);</span><br><span class="line">            if (rootX == rootY) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">          // 关系式的推导请见「参考代码」下方的示意图</span><br><span class="line">            weight[rootX] = weight[y] * value / weight[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 路径压缩</span><br><span class="line">         *</span><br><span class="line">         * @param x</span><br><span class="line">         * @return 根结点的 id</span><br><span class="line">         */</span><br><span class="line">        public int find(int x) &#123;</span><br><span class="line">            if (x != parent[x]) &#123;</span><br><span class="line">                int origin = parent[x];</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">                weight[x] *= weight[origin];</span><br><span class="line">            &#125;</span><br><span class="line">            return parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public double isConnected(int x, int y) &#123;</span><br><span class="line">            int rootX = find(x);</span><br><span class="line">            int rootY = find(y);</span><br><span class="line">            if (rootX == rootY) &#123;</span><br><span class="line">                return weight[x] / weight[y];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return -1.0d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>说明：代码 weight[rootX] &#x3D; weight[y] * value &#x2F; weight[x]; 的推导过程，主要需要明白各个变量的含义，由两条路径有向边的权值乘积相等得到相等关系，然后做等价变换即可。</p><h1 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h1><p>时间复杂度：O((N+Q)logA)，</p><ul><li>构建并查集 O(NlogA) ，这里 N 为输入方程 equations 的长度，每一次执行合并操作的时间复杂度是 O(logA)，这里 A 是 equations 里不同字符的个数；</li><li>查询并查集 O(QlogA)，这里 Q 为查询数组 queries 的长度，每一次查询时执行「路径压缩」的时间复杂度是 O(logA)。</li></ul><p>空间复杂度：O(A)：创建字符与 id 的对应关系 hashMap 长度为 A，并查集底层使用的两个数组 parent 和 weight 存储每个变量的连通分量信息，parent 和 weight 的长度均为 A。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;返回 所有除法求值问题的答案&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
    <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
    <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
    <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>394. 字符串解码</title>
    <link href="http://yoursite.com/2022/03/09/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2022/03/09/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</id>
    <published>2022-03-09T07:12:12.000Z</published>
    <updated>2022-03-09T07:11:33.114Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个经过编码的字符串，返回它解码后的字符串。</p><span id="more"></span><p>[TOC]</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例 1：</p><pre><code>输入：s = &quot;3[a]2[bc]&quot;输出：&quot;aaabcbc&quot;</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;3[a2[c]]&quot;输出：&quot;accaccacc&quot;</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;输出：&quot;abcabccdcdcdef&quot;</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;abc3[cd]xyz&quot;输出：&quot;abccdcdcdxyz&quot;</code></pre><h1 id="方法一：栈操作-1"><a href="#方法一：栈操作-1" class="headerlink" title="方法一：栈操作^1"></a>方法一：栈操作<a href="https://leetcode-cn.com/problems/decode-string/solution/zi-fu-chuan-jie-ma-by-leetcode-solution/">^1</a></h1><h2 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h2><p>本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：</p><ul><li>如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈</li><li>如果当前的字符为字母或者左括号，直接进栈</li><li>如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈</li></ul><p>重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：这里可以用不定长数组来模拟栈操作，方便从栈底向栈顶遍历。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string getDigits(string &amp;s, size_t &amp;ptr) &#123;</span><br><span class="line">        string ret = &quot;&quot;;</span><br><span class="line">        while (isdigit(s[ptr])) &#123;</span><br><span class="line">            ret.push_back(s[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getString(vector &lt;string&gt; &amp;v) &#123;</span><br><span class="line">        string ret;</span><br><span class="line">        for (const auto &amp;s: v) &#123;</span><br><span class="line">            ret += s;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        vector &lt;string&gt; stk;</span><br><span class="line">        size_t ptr = 0;</span><br><span class="line"></span><br><span class="line">        while (ptr &lt; s.size()) &#123;</span><br><span class="line">            char cur = s[ptr];</span><br><span class="line">            if (isdigit(cur)) &#123;</span><br><span class="line">                // 获取一个数字并进栈</span><br><span class="line">                string digits = getDigits(s, ptr);</span><br><span class="line">                stk.push_back(digits);</span><br><span class="line">            &#125; else if (isalpha(cur) || cur == &#x27;[&#x27;) &#123;</span><br><span class="line">                // 获取一个字母并进栈</span><br><span class="line">                stk.push_back(string(1, s[ptr++])); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                vector &lt;string&gt; sub;</span><br><span class="line">                while (stk.back() != &quot;[&quot;) &#123;</span><br><span class="line">                    sub.push_back(stk.back());</span><br><span class="line">                    stk.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(sub.begin(), sub.end());</span><br><span class="line">                // 左括号出栈</span><br><span class="line">                stk.pop_back();</span><br><span class="line">                // 此时栈顶为当前 sub 对应的字符串应该出现的次数</span><br><span class="line">                int repTime = stoi(stk.back()); </span><br><span class="line">                stk.pop_back();</span><br><span class="line">                string t, o = getString(sub);</span><br><span class="line">                // 构造字符串</span><br><span class="line">                while (repTime--) t += o; </span><br><span class="line">                // 将构造好的字符串入栈</span><br><span class="line">                stk.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getString(stk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int ptr;</span><br><span class="line"></span><br><span class="line">    public String decodeString(String s) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; stk = new LinkedList&lt;String&gt;();</span><br><span class="line">        ptr = 0;</span><br><span class="line"></span><br><span class="line">        while (ptr &lt; s.length()) &#123;</span><br><span class="line">            char cur = s.charAt(ptr);</span><br><span class="line">            if (Character.isDigit(cur)) &#123;</span><br><span class="line">                // 获取一个数字并进栈</span><br><span class="line">                String digits = getDigits(s);</span><br><span class="line">                stk.addLast(digits);</span><br><span class="line">            &#125; else if (Character.isLetter(cur) || cur == &#x27;[&#x27;) &#123;</span><br><span class="line">                // 获取一个字母并进栈</span><br><span class="line">                stk.addLast(String.valueOf(s.charAt(ptr++))); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                LinkedList&lt;String&gt; sub = new LinkedList&lt;String&gt;();</span><br><span class="line">                while (!&quot;[&quot;.equals(stk.peekLast())) &#123;</span><br><span class="line">                    sub.addLast(stk.removeLast());</span><br><span class="line">                &#125;</span><br><span class="line">                Collections.reverse(sub);</span><br><span class="line">                // 左括号出栈</span><br><span class="line">                stk.removeLast();</span><br><span class="line">                // 此时栈顶为当前 sub 对应的字符串应该出现的次数</span><br><span class="line">                int repTime = Integer.parseInt(stk.removeLast());</span><br><span class="line">                StringBuffer t = new StringBuffer();</span><br><span class="line">                String o = getString(sub);</span><br><span class="line">                // 构造字符串</span><br><span class="line">                while (repTime-- &gt; 0) &#123;</span><br><span class="line">                    t.append(o);</span><br><span class="line">                &#125;</span><br><span class="line">                // 将构造好的字符串入栈</span><br><span class="line">                stk.addLast(t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getString(stk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDigits(String s) &#123;</span><br><span class="line">        StringBuffer ret = new StringBuffer();</span><br><span class="line">        while (Character.isDigit(s.charAt(ptr))) &#123;</span><br><span class="line">            ret.append(s.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString(LinkedList&lt;String&gt; v) &#123;</span><br><span class="line">        StringBuffer ret = new StringBuffer();</span><br><span class="line">        for (String s : v) &#123;</span><br><span class="line">            ret.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">func decodeString(s string) string &#123;</span><br><span class="line">    stk := []string&#123;&#125;</span><br><span class="line">    ptr := 0</span><br><span class="line">    for ptr &lt; len(s) &#123;</span><br><span class="line">        cur := s[ptr]</span><br><span class="line">        if cur &gt;= &#x27;0&#x27; &amp;&amp; cur &lt;= &#x27;9&#x27; &#123;</span><br><span class="line">            digits := getDigits(s, &amp;ptr)</span><br><span class="line">            stk = append(stk, digits)</span><br><span class="line">        &#125; else if (cur &gt;= &#x27;a&#x27; &amp;&amp; cur &lt;= &#x27;z&#x27; || cur &gt;= &#x27;A&#x27; &amp;&amp; cur &lt;= &#x27;Z&#x27;) || cur == &#x27;[&#x27; &#123;</span><br><span class="line">            stk = append(stk, string(cur))</span><br><span class="line">            ptr++</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ptr++</span><br><span class="line">            sub := []string&#123;&#125;</span><br><span class="line">            for stk[len(stk)-1] != &quot;[&quot; &#123;</span><br><span class="line">                sub = append(sub, stk[len(stk)-1])</span><br><span class="line">                stk = stk[:len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            for i := 0; i &lt; len(sub)/2; i++ &#123;</span><br><span class="line">                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = stk[:len(stk)-1]</span><br><span class="line">            repTime, _ := strconv.Atoi(stk[len(stk)-1])</span><br><span class="line">            stk = stk[:len(stk)-1]</span><br><span class="line">            t := strings.Repeat(getString(sub), repTime)</span><br><span class="line">            stk = append(stk, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getString(stk)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getDigits(s string, ptr *int) string &#123;</span><br><span class="line">    ret := &quot;&quot;</span><br><span class="line">    for ; s[*ptr] &gt;= &#x27;0&#x27; &amp;&amp; s[*ptr] &lt;= &#x27;9&#x27;; *ptr++ &#123;</span><br><span class="line">        ret += string(s[*ptr])</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getString(v []string) string &#123;</span><br><span class="line">    ret := &quot;&quot;</span><br><span class="line">    for _, s := range v &#123;</span><br><span class="line">        ret += s</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：记解码后得出的字符串长度为 S，除了遍历一次原字符串 s，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S)。</p><p>空间复杂度：记解码后得出的字符串长度为 S，这里用栈维护 TOKEN，栈的总大小最终与 S 相同，故渐进空间复杂度为 O(S)。</p><h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><h2 id="思路和算法-1"><a href="#思路和算法-1" class="headerlink" title="思路和算法"></a>思路和算法</h2><p>我们也可以用递归来解决这个问题，从左向右解析字符串：</p><p>如果当前位置为数字位，那么后面一定包含一个用方括号表示的字符串，即属于这种情况：k[…]：<br>我们可以先解析出一个数字，然后解析到了左括号，递归向下解析后面的内容，遇到对应的右括号就返回，此时我们可以根据解析出的数字 x 解析出的括号里的字符串s′构造出一个新的字符串 x×s′</p><p>我们把 k[…] 解析结束后，再次调用递归函数，解析右括号右边的内容。<br>如果当前位置是字母位，那么我们直接解析当前这个字母，然后递归向下解析这个字母后面的内容。<br>如果觉得这里讲的比较抽象，可以结合代码理解一下这个过程。</p><p>下面我们可以来讲讲这样做的依据，涉及到《编译原理》相关内容，感兴趣的同学可以参考阅读。 根据题目的定义，我们可以推导出这样的巴科斯范式（BNF）：</p><pre><code>String-&gt;Digit [String]String|Alpha String|StringDigits-&gt;Digit Digits |DigitsAlpha-&gt;a|...|z|A|...|ZDigit-&gt;0|...|9</code></pre><ul><li>Digit 表示十进制数位，可能的取值是 0 到 9 之间的整数</li><li>Alpha 表示字母，可能的取值是大小写字母的集合，共 52 个</li><li>Digit 表示一个整数，它的组成是 Digit 出现一次或多次</li><li>String 代表一个代解析的字符串，它可能有三种构成，如 BNF 所示</li><li>epsilon 表示空串，即没有任何子字符</li></ul><p> 由于 Digits 和 Alpha 构成简单，很容易进行词法分析，我们把它他们看作独立的 TOKEN。那么此时的非终结符有 String，终结符有 Digits、Alpha 和 ϵ，我们可以根据非终结符和 FOLLOW 集构造出这样的预测分析表：</p><p>可见不含多重定义的项，为 LL(1) 文法，即：</p><ul><li>从左向右分析（Left-to-right-parse）</li><li>最左推导（Leftmost-derivation）</li><li>超前查看一个符号（1-symbol lookahead）<br>它决定了我们从左向右遍历这个字符串，每次只判断当前最左边的一个字符的分析方法是正确的。</li></ul><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string src; </span><br><span class="line">    size_t ptr;</span><br><span class="line"></span><br><span class="line">    int getDigits() &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        while (ptr &lt; src.size() &amp;&amp; isdigit(src[ptr])) &#123;</span><br><span class="line">            ret = ret * 10 + src[ptr++] - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getString() &#123;</span><br><span class="line">        if (ptr == src.size() || src[ptr] == &#x27;]&#x27;) &#123;</span><br><span class="line">            // String -&gt; EPS</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char cur = src[ptr]; int repTime = 1;</span><br><span class="line">        string ret;</span><br><span class="line"></span><br><span class="line">        if (isdigit(cur)) &#123;</span><br><span class="line">            // String -&gt; Digits [ String ] String</span><br><span class="line">            // 解析 Digits</span><br><span class="line">            repTime = getDigits(); </span><br><span class="line">            // 过滤左括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 解析 String</span><br><span class="line">            string str = getString(); </span><br><span class="line">            // 过滤右括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 构造字符串</span><br><span class="line">            while (repTime--) ret += str; </span><br><span class="line">        &#125; else if (isalpha(cur)) &#123;</span><br><span class="line">            // String -&gt; Char String</span><br><span class="line">            // 解析 Char</span><br><span class="line">            ret = string(1, src[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        src = s;</span><br><span class="line">        ptr = 0;</span><br><span class="line">        return getString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    String src;</span><br><span class="line">    int ptr;</span><br><span class="line"></span><br><span class="line">    public String decodeString(String s) &#123;</span><br><span class="line">        src = s;</span><br><span class="line">        ptr = 0;</span><br><span class="line">        return getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        if (ptr == src.length() || src.charAt(ptr) == &#x27;]&#x27;) &#123;</span><br><span class="line">            // String -&gt; EPS</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char cur = src.charAt(ptr);</span><br><span class="line">        int repTime = 1;</span><br><span class="line">        String ret = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        if (Character.isDigit(cur)) &#123;</span><br><span class="line">            // String -&gt; Digits [ String ] String</span><br><span class="line">            // 解析 Digits</span><br><span class="line">            repTime = getDigits(); </span><br><span class="line">            // 过滤左括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 解析 String</span><br><span class="line">            String str = getString(); </span><br><span class="line">            // 过滤右括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 构造字符串</span><br><span class="line">            while (repTime-- &gt; 0) &#123;</span><br><span class="line">                ret += str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (Character.isLetter(cur)) &#123;</span><br><span class="line">            // String -&gt; Char String</span><br><span class="line">            // 解析 Char</span><br><span class="line">            ret = String.valueOf(src.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDigits() &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        while (ptr &lt; src.length() &amp;&amp; Character.isDigit(src.charAt(ptr))) &#123;</span><br><span class="line">            ret = ret * 10 + src.charAt(ptr++) - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    src string</span><br><span class="line">    ptr int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func decodeString(s string) string &#123;</span><br><span class="line">    src = s</span><br><span class="line">    ptr = 0</span><br><span class="line">    return getString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getString() string &#123;</span><br><span class="line">    if ptr == len(src) || src[ptr] == &#x27;]&#x27; &#123;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    cur := src[ptr]</span><br><span class="line">    repTime := 1</span><br><span class="line">    ret := &quot;&quot;</span><br><span class="line">    if cur &gt;= &#x27;0&#x27; &amp;&amp; cur &lt;= &#x27;9&#x27; &#123;</span><br><span class="line">        repTime = getDigits()</span><br><span class="line">        ptr++</span><br><span class="line">        str := getString()</span><br><span class="line">        ptr++</span><br><span class="line">        ret = strings.Repeat(str, repTime)</span><br><span class="line">    &#125; else if cur &gt;= &#x27;a&#x27; &amp;&amp; cur &lt;= &#x27;z&#x27; || cur &gt;= &#x27;A&#x27; &amp;&amp; cur &lt;= &#x27;Z&#x27; &#123;</span><br><span class="line">        ret = string(cur)</span><br><span class="line">        ptr++</span><br><span class="line">    &#125;</span><br><span class="line">    return ret + getString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getDigits() int &#123;</span><br><span class="line">    ret := 0</span><br><span class="line">    for ; src[ptr] &gt;= &#x27;0&#x27; &amp;&amp; src[ptr] &lt;= &#x27;9&#x27;; ptr++ &#123;</span><br><span class="line">        ret = ret * 10 + int(src[ptr] - &#x27;0&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：记解码后得出的字符串长度为 S，除了遍历一次原字符串 s，我们还需要将解码后的字符串中的每个字符都拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S)。</p><p>空间复杂度：若不考虑答案所占用的空间，那么就只剩递归使用栈空间的大小，这里栈空间的使用和递归树的深度成正比，最坏情况下为 O(∣s∣)，故渐进空间复杂度为 O(∣s∣)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Recursive" scheme="http://yoursite.com/tags/Recursive/"/>
    
  </entry>
  
  <entry>
    <title>494. 目标和</title>
    <link href="http://yoursite.com/2022/03/09/494.%20%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <id>http://yoursite.com/2022/03/09/494.%20%E7%9B%AE%E6%A0%87%E5%92%8C/</id>
    <published>2022-03-09T07:12:12.000Z</published>
    <updated>2022-03-09T06:52:42.114Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><span id="more"></span><p>[TOC]</p><p>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>示例 1：</p><pre><code>输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3</code></pre><p>示例 2：</p><pre><code>输入：nums = [1], target = 1输出：1</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 200 &lt;= nums[i] &lt;= 10000 &lt;= sum(nums[i]) &lt;= 1000-1000 &lt;= target &lt;= 1000</code></pre><h1 id="方法一：回溯-1"><a href="#方法一：回溯-1" class="headerlink" title="方法一：回溯^1"></a>方法一：回溯<a href="https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/">^1</a></h1><p>数组 nums 的每个元素都可以添加符号 + 或 -，因此每个元素有 2 种添加符号的方法，n 个数共有 2^n 种添加符号的方法，对应 2^n 种不同的表达式。当 n 个元素都添加符号之后，即得到一种表达式，如果表达式的结果等于目标数 target，则该表达式即为符合要求的表达式。</p><p>可以使用回溯的方法遍历所有的表达式，回溯过程中维护一个计数器 count，当遇到一种表达式的结果等于目标数 target 时，将 count 的值加 1。遍历完所有的表达式之后，即可得到结果等于目标数 target 的表达式的数目。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        backtrack(nums, target, 0, 0);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtrack(int[] nums, int target, int index, int sum) &#123;</span><br><span class="line">        if (index == nums.length) &#123;</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    public int FindTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        Backtrack(nums, target, 0, 0);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Backtrack(int[] nums, int target, int index, int sum) &#123;</span><br><span class="line">        if (index == nums.Length) &#123;</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            Backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var findTargetSumWays = function(nums, target) &#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    const backtrack = (nums, target, index, sum) =&gt; &#123;</span><br><span class="line">        if (index === nums.length) &#123;</span><br><span class="line">            if (sum === target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(nums, target, 0, 0);</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func findTargetSumWays(nums []int, target int) (count int) &#123;</span><br><span class="line">    var backtrack func(int, int)</span><br><span class="line">    backtrack = func(index, sum int) &#123;</span><br><span class="line">        if index == len(nums) &#123;</span><br><span class="line">            if sum == target &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(index+1, sum+nums[index])</span><br><span class="line">        backtrack(index+1, sum-nums[index])</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(0, 0)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        backtrack(nums, target, 0, 0);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backtrack(vector&lt;int&gt;&amp; nums, int target, int index, int sum) &#123;</span><br><span class="line">        if (index == nums.size()) &#123;</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int count;</span><br><span class="line"></span><br><span class="line">int findTargetSumWays(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    count = 0;</span><br><span class="line">    backtrack(nums, numsSize, target, 0, 0);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(int* nums, int numSize, int target, int index, int sum) &#123;</span><br><span class="line">    if (index == numSize) &#123;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        backtrack(nums, numSize, target, index + 1, sum + nums[index]);</span><br><span class="line">        backtrack(nums, numSize, target, index + 1, sum - nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(2^n)，其中 n 是数组 nums 的长度。回溯需要遍历所有不同的表达式，共有 2^n 种不同的表达式，每种表达式计算结果需要 O(1) 的时间，因此总时间复杂度是 O(2^n)。<br>空间复杂度：O(n)，其中 n 是数组 nums 的长度。空间复杂度主要取决于递归调用的栈空间，栈的深度不超过 n。</p><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p>记数组的元素和为 sum，添加 - 号的元素之和为 neg，则其余添加 + 的元素之和为 sum−neg，得到的表达式的结果为</p><pre><code>(sum−neg)−neg=sum−2⋅neg=target</code></pre><p>即</p><pre><code>neg= (sum−target)/2</code></pre><p>由于数组 nums 中的元素都是非负整数，neg 也必须是非负整数，所以上式成立的前提是 sum−target 是非负偶数。若不符合该条件可直接返回 0。</p><p>若上式成立，问题转化成在数组 nums 中选取若干元素，使得这些元素之和等于 neg，计算选取元素的方案数。我们可以使用动态规划的方法求解。</p><p>定义二维数组 dp，其中 dp[i][j] 表示在数组 nums 的前 i 个数中选取元素，使得这些元素之和等于 j 的方案数。假设数组 nums 的长度为 n，则最终答案为 dp[n][neg]。</p><p>当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：</p><p>当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：</p><pre><code>dp[0][j]=&#123;  1,j=0            0,j≥1</code></pre><p>当 1≤i≤n 时，对于数组 nums 中的第 i 个元素 num（i 的计数从 1 开始），遍历 0≤j≤neg，计算 dp[i][j] 的值：</p><ul><li>如果 j&lt;num，则不能选 num，此时有 dp[i][j]&#x3D;dp[i−1][j]；</li><li>如果 j≥num，则如果不选 num，方案数是 dp[i−1][j]，如果选 num，方案数是 dp[i−1][j−num]，此时有 dp[i][j]&#x3D;dp[i−1][j]+dp[i−1][j−num]。</li></ul><p>因此状态转移方程如下：</p><pre><code>dp&#125;[i][j]=&#123; dp[i-1][j], j&lt;nums[i]            dp[i-1][j]+dp[i-1][j-nums[i]], j&gt;=nums[i]</code></pre><p>最终得到 dp[n][neg] 的值即为答案。</p><p>由此可以得到空间复杂度为 O(n×neg) 的实现。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums.length, neg = diff / 2;</span><br><span class="line">        int[][] dp = new int[n + 1][neg + 1];</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        foreach (int num in nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums.Length, neg = diff / 2;</span><br><span class="line">        int[,] dp = new int[n + 1, neg + 1];</span><br><span class="line">        dp[0, 0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">                dp[i, j] = dp[i - 1, j];</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i, j] += dp[i - 1, j - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n, neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var findTargetSumWays = function(nums, target) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    const diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 !== 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const n = nums.length, neg = diff / 2;</span><br><span class="line">    const dp = new Array(n + 1).fill(0).map(() =&gt; new Array(neg + 1).fill(0));</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (let i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        const num = nums[i - 1];</span><br><span class="line">        for (let j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][neg];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func findTargetSumWays(nums []int, target int) int &#123;</span><br><span class="line">    sum := 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    diff := sum - target</span><br><span class="line">    if diff &lt; 0 || diff%2 == 1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    n, neg := len(nums), diff/2</span><br><span class="line">    dp := make([][]int, n+1)</span><br><span class="line">    for i := range dp &#123;</span><br><span class="line">        dp[i] = make([]int, neg+1)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][0] = 1</span><br><span class="line">    for i, num := range nums &#123;</span><br><span class="line">        for j := 0; j &lt;= neg; j++ &#123;</span><br><span class="line">            dp[i+1][j] = dp[i][j]</span><br><span class="line">            if j &gt;= num &#123;</span><br><span class="line">                dp[i+1][j] += dp[i][j-num]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][neg]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums.size(), neg = diff / 2;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(neg + 1));</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int findTargetSumWays(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = numsSize, neg = diff / 2;</span><br><span class="line">    int dp[n + 1][neg + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int num = nums[i - 1];</span><br><span class="line">        for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][neg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>由于 dp 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，将空间复杂度优化到 O(neg)。</p><p>实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 dp[i−1][] 中的元素值。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int neg = diff / 2;</span><br><span class="line">        int[] dp = new int[neg + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        foreach (int num in nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int neg = diff / 2;</span><br><span class="line">        int[] dp = new int[neg + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        foreach (int num in nums) &#123;</span><br><span class="line">            for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var findTargetSumWays = function(nums, target) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    const diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 !== 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const neg = Math.floor(diff / 2);</span><br><span class="line">    const dp = new Array(neg + 1).fill(0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        for (let j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[neg];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func findTargetSumWays(nums []int, target int) int &#123;</span><br><span class="line">    sum := 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    diff := sum - target</span><br><span class="line">    if diff &lt; 0 || diff%2 == 1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    neg := diff / 2</span><br><span class="line">    dp := make([]int, neg+1)</span><br><span class="line">    dp[0] = 1</span><br><span class="line">    for _, num := range nums &#123;</span><br><span class="line">        for j := neg; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] += dp[j-num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[neg]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int neg = diff / 2;</span><br><span class="line">        vector&lt;int&gt; dp(neg + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int&amp; num : nums) &#123;</span><br><span class="line">            for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int findTargetSumWays(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int neg = diff / 2;</span><br><span class="line">    int dp[neg + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        int num = nums[i];</span><br><span class="line">        for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[neg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n×(sum−target))，其中 n 是数组 nums 的长度，sum 是数组 nums 的元素和，target 是目标数。动态规划有 (n+1)×((sum−target)&#x2F;2+1) 个状态，需要计算每个状态的值。</p><p>空间复杂度：O(sum−target)，其中 sum 是数组 nums 的元素和，target 是目标数。使用空间优化的实现，需要创建长度为  (sum−target)&#x2F;2+1 的数组 dp。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个整数数组 nums 和一个整数 target 。&lt;/p&gt;
&lt;p&gt;向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>416. 分割等和子集</title>
    <link href="http://yoursite.com/2022/03/08/416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2022/03/08/416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</id>
    <published>2022-03-08T09:12:12.000Z</published>
    <updated>2022-03-08T09:28:09.428Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 只包含正整数 的 非空 数组nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2001 &lt;= nums[i] &lt;= 100</code></pre><h1 id="文字题解-1"><a href="#文字题解-1" class="headerlink" title="文字题解^1"></a>文字题解<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/">^1</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作者在这里希望读者认真阅读前言部分。</p><p>本题是经典的「NP 完全问题」，也就是说，如果你发现了该问题的一个多项式算法，那么恭喜你证明出了 P&#x3D;NP，可以期待一下图灵奖了。</p><p>正因如此，我们不应期望该问题有多项式时间复杂度的解法。我们能想到的，例如基于贪心算法的「将数组降序排序后，依次将每个元素添加至当前元素和较小的子集中」之类的方法都是错误的，可以轻松地举出反例。因此，我们必须尝试非多项式时间复杂度的算法，例如时间复杂度与元素大小相关的动态规划。</p><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>这道题可以换一种表述：给定一个只包含正整数的非空数组 nums[0]，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。因此这个问题可以转换成「0−1 背包问题」。这道题与传统的「0−1 背包问题」的区别在于，传统的「0−1 背包问题」要求选取的物品的重量之和不能超过背包的总容量，这道题则要求选取的数字的和恰好等于整个数组的元素和的一半。类似于传统的「0−1 背包问题」，可以使用动态规划求解。</p><p>在使用动态规划求解之前，首先需要进行以下判断。</p><ul><li><p>根据数组的长度 n 判断数组是否可以被划分。如果 n&lt;2，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。</p></li><li><p>计算整个数组的元素和 sum 以及最大元素 maxNum。如果 sum 是奇数，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。如果 sum 是偶数，则令 target&#x3D; 2sum，需要判断是否可以从数组中选出一些数字，使得这些数字的和等于 target。如果 maxNum&gt;target，则除了 maxNum 以外的所有元素之和一定小于 target，因此不可能将数组分割成元素和相等的两个子集，直接返回 false。</p></li></ul><p>创建二维数组 dp，包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。</p><p>在定义状态之后，需要考虑边界情况。以下两种情况都属于边界情况。</p><ul><li>如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有 0≤i&lt;n，都有 dp[i][0]&#x3D;true。</li><li>当 i&#x3D;&#x3D;0 时，只有一个正整数 nums[0] 可以被选取，因此 dp[0][nums[0]]&#x3D;true。</li></ul><p>对于 i&gt;0 且 j&gt;0 的情况，如何确定 dp[i][j] 的值？需要分别考虑以下两种情况。</p><ul><li><p>如果 j≥nums[i]，则对于当前的数字 nums[i]，可以选取也可以不选取，两种情况只要有一个为 true，就有 dp[i][j]&#x3D;true。</p><p>  如果不选取 nums[i]，则 dp[i][j]&#x3D;dp[i−1][j]；<br>  如果选取 nums[i]，则 dp[i][j]&#x3D;dp[i−1][j−nums[i]]。</p></li><li><p>如果 j&lt;nums[i]，则在选取的数字的和等于 j 的情况下无法选取当前的数字 nums[i]，因此有 dp[i][j]&#x3D;dp[i−1][j]。</p></li></ul><p>状态转移方程如下：</p><pre><code>dp[i][j]=&#123; dp[i−1][j] ∣ dp[i−1][j−nums[i]], j≥nums[i]           dp[i−1][j],  j&lt;nums[i]</code></pre><p>最终得到 dp[n−1][target] 即为答案。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0, maxNum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 2 != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[][] dp = new boolean[n][target + 1];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][nums[0]] = true;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0);</span><br><span class="line">        int maxNum = *max_element(nums.begin(), nums.end());</span><br><span class="line">        if (sum &amp; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(target + 1, 0));</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][nums[0]] = true;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var canPartition = function(nums) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    if (n &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let sum = 0, maxNum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        maxNum = maxNum &gt; num ? maxNum : num;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const target = Math.floor(sum / 2);</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const dp = new Array(n).fill(0).map(v =&gt; new Array(target + 1, false));</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][0] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][nums[0]] = true;</span><br><span class="line">    for (let i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        const num = nums[i];</span><br><span class="line">        for (let j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][target];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func canPartition(nums []int) bool &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    if n &lt; 2 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum, max := 0, 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        if v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if sum%2 != 0 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target := sum / 2</span><br><span class="line">    if max &gt; target &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp := make([][]bool, n)</span><br><span class="line">    for i := range dp &#123;</span><br><span class="line">        dp[i] = make([]bool, target+1)</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i][0] = true</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][nums[0]] = true</span><br><span class="line">    for i := 1; i &lt; n; i++ &#123;</span><br><span class="line">        v := nums[i]</span><br><span class="line">        for j := 1; j &lt;= target; j++ &#123;</span><br><span class="line">            if j &gt;= v &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j] || dp[i-1][j-v]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1][target]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">bool canPartition(int* nums, int numsSize) &#123;</span><br><span class="line">    if (numsSize &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0, maxNum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        maxNum = fmax(maxNum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int target = sum / 2;</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int dp[numsSize][target + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        dp[i][0] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][nums[0]] = true;</span><br><span class="line">    for (int i = 1; i &lt; numsSize; i++) &#123;</span><br><span class="line">        int num = nums[i];</span><br><span class="line">        for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[numsSize - 1][target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canPartition(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        if n &lt; 2:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        total = sum(nums)</span><br><span class="line">        maxNum = max(nums)</span><br><span class="line">        if total &amp; 1:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        target = total // 2</span><br><span class="line">        if maxNum &gt; target:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        dp = [[False] * (target + 1) for _ in range(n)]</span><br><span class="line">        for i in range(n):</span><br><span class="line">            dp[i][0] = True</span><br><span class="line">        </span><br><span class="line">        dp[0][nums[0]] = True</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            num = nums[i]</span><br><span class="line">            for j in range(1, target + 1):</span><br><span class="line">                if j &gt;= num:</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] = dp[i - 1][j]</span><br><span class="line">        </span><br><span class="line">        return dp[n - 1][target]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>上述代码的空间复杂度是 O(n×target)。但是可以发现在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：</p><pre><code>dp[j]=dp[j] ∣ dp[j−nums[i]]</code></pre><p>且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 dp[j] 值的时候，dp[j−nums[i]] 已经是被更新过的状态，不再是上一行的 dp 值。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0, maxNum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 2 != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] dp = new boolean[target + 1];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0, maxNum = 0;</span><br><span class="line">        for (auto&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum &amp; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp(target + 1, 0);</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var canPartition = function(nums) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    if (n &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let sum = 0, maxNum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        maxNum = maxNum &gt; num ? maxNum : num;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const target = Math.floor(sum / 2);</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const dp = new Array(target + 1).fill(false);</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        for (let j = target; j &gt;= num; --j) &#123;</span><br><span class="line">            dp[j] |= dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func canPartition(nums []int) bool &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    if n &lt; 2 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum, max := 0, 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        if v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if sum%2 != 0 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target := sum / 2</span><br><span class="line">    if max &gt; target &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp := make([]bool, target+1)</span><br><span class="line">    dp[0] = true</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        v := nums[i]</span><br><span class="line">        for j := target; j &gt;= v; j-- &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-v]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool canPartition(int* nums, int numsSize) &#123;</span><br><span class="line">    if (numsSize &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0, maxNum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        maxNum = fmax(maxNum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int target = sum / 2;</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int dp[target + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        int num = nums[i];</span><br><span class="line">        for (int j = target; j &gt;= num; --j) &#123;</span><br><span class="line">            dp[j] |= dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canPartition(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        if n &lt; 2:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        total = sum(nums)</span><br><span class="line">        if total % 2 != 0:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        target = total // 2</span><br><span class="line">        dp = [True] + [False] * target</span><br><span class="line">        for i, num in enumerate(nums):</span><br><span class="line">            for j in range(target, num - 1, -1):</span><br><span class="line">                dp[j] |= dp[j - num]</span><br><span class="line">        </span><br><span class="line">        return dp[target]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n×target)，其中 n 是数组的长度，target 是整个数组的元素和的一半。需要计算出所有的状态，每个状态在进行转移时的时间复杂度为 O(1)。</p><p>空间复杂度：O(target)，其中 target 是整个数组的元素和的一半。空间复杂度取决于 dp 数组，在不进行空间优化的情况下，空间复杂度是 O(n×target)，在进行空间优化的情况下，空间复杂度可以降到 O(target)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 只包含正整数 的 非空 数组nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>581. 最短无序连续子数组</title>
    <link href="http://yoursite.com/2022/03/08/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2022/03/08/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2022-03-08T08:12:12.000Z</published>
    <updated>2022-03-08T07:55:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,3,4]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [1]输出：0</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 104-105 &lt;= nums[i] &lt;= 105</code></pre><p>进阶：你可以设计一个时间复杂度为 O(n) 的解决方案吗？</p><h1 id="方法一：排序-1"><a href="#方法一：排序-1" class="headerlink" title="方法一：排序^1"></a>方法一：排序<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leet-yhlf/">^1</a></h1><p>思路与算法</p><p>我们将给定的数组nums表示为三段子数组拼接的形式，分别记作 numsA，numsB，numsC。当我们对numsB进行排序，整个数组将变为有序。换而言之，当我们对整个序列进行排序，numsA和 numsC都不会改变。</p><p>本题要求我们找到最短的numsB，即找到最大的numsA和numsC的长度之和。因此我们将原数组 nums 排序与原数组进行比较，取最长的相同的前缀为 numsA ，取最长的相同的后缀为 numsC，这样我们就可以取到最短的 numsB。</p><p>具体地，我们创建数组  nums 的拷贝，记作数组  numsSorted，并对该数组进行排序，然后我们从左向右找到第一个两数组不同的位置，即为<br>numsB的左边界。同理也可以找到 numsB 右边界。最后我们输出 numsB的长度即可。</p><p>特别地，当原数组有序时，numsB的长度为0，我们可以直接返回结果。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (is_sorted(nums.begin(), nums.end())) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; numsSorted(nums);</span><br><span class="line">        sort(numsSorted.begin(), numsSorted.end());</span><br><span class="line">        int left = 0;</span><br><span class="line">        while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        if (isSorted(nums)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] numsSorted = new int[nums.length];</span><br><span class="line">        System.arraycopy(nums, 0, numsSorted, 0, nums.length);</span><br><span class="line">        Arrays.sort(numsSorted);</span><br><span class="line">        int left = 0;</span><br><span class="line">        while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isSorted(int[] nums) &#123;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        if (IsSorted(nums)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] numsSorted = new int[nums.Length];</span><br><span class="line">        Array.Copy(nums, numsSorted, nums.Length);</span><br><span class="line">        Array.Sort(numsSorted);</span><br><span class="line">        int left = 0;</span><br><span class="line">        while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        int right = nums.Length - 1;</span><br><span class="line">        while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsSorted(int[] nums) &#123;</span><br><span class="line">        for (int i = 1; i &lt; nums.Length; i++) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        def isSorted() -&gt; bool:</span><br><span class="line">            for i in range(1, n):</span><br><span class="line">                if nums[i - 1] &gt; nums[i]:</span><br><span class="line">                    return False</span><br><span class="line">            return True</span><br><span class="line">        </span><br><span class="line">        if isSorted():</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        numsSorted = sorted(nums)</span><br><span class="line">        left = 0</span><br><span class="line">        while nums[left] == numsSorted[left]:</span><br><span class="line">            left += 1</span><br><span class="line"></span><br><span class="line">        right = n - 1</span><br><span class="line">        while nums[right] == numsSorted[right]:</span><br><span class="line">            right -= 1</span><br><span class="line">        </span><br><span class="line">        return right - left + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var findUnsortedSubarray = function(nums) &#123;</span><br><span class="line">    if (isSorted(nums)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const numsSorted = [...nums].sort((a, b) =&gt; a - b);</span><br><span class="line">    let left = 0;</span><br><span class="line">    while (nums[left] === numsSorted[left]) &#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    let right = nums.length - 1;</span><br><span class="line">    while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const isSorted = (nums) =&gt; &#123;</span><br><span class="line">    for (let i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func findUnsortedSubarray(nums []int) int &#123;</span><br><span class="line">    if sort.IntsAreSorted(nums) &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    numsSorted := append([]int(nil), nums...)</span><br><span class="line">    sort.Ints(numsSorted)</span><br><span class="line">    left, right := 0, len(nums)-1</span><br><span class="line">    for nums[left] == numsSorted[left] &#123;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    for nums[right] == numsSorted[right] &#123;</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">bool is_sorted(int* arr, int arrSize) &#123;</span><br><span class="line">    for (int i = 1; i &lt; arrSize; i++) &#123;</span><br><span class="line">        if (arr[i - 1] &gt; arr[i]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(int* a, int* b) &#123;</span><br><span class="line">    return *a - *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findUnsortedSubarray(int* nums, int numsSize) &#123;</span><br><span class="line">    if (is_sorted(nums, numsSize)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int numsSorted[numsSize];</span><br><span class="line">    memcpy(numsSorted, nums, sizeof(int) * numsSize);</span><br><span class="line">    qsort(numsSorted, numsSize, sizeof(int), cmp);</span><br><span class="line">    int left = 0;</span><br><span class="line">    while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    int right = numsSize - 1;</span><br><span class="line">    while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(nlogn)，其中 n 为给定数组的长度。我们需要  O(nlogn) 的时间进行排序，以及  O(n) 的时间遍历数组，因此总时间复杂度为 O(n)。<br>空间复杂度： O(n)，其中  n 为给定数组的长度。我们需要额外的一个数组保存排序后的数组  numsSorted。</p><h1 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h1><p>思路与算法</p><p>假设 numsB 在  nums 中对应区间为  [left,right]。<br> 注意到 numsB和  numsC 中任意一个数都大于等于  numsA 中任意一个数。因此有<br>numsA 中每一个数 numsi 都满足：</p><p>我们可以从大到小枚举  i，用一个变量  minn 记录 i后的numsi 。每次移动  i，都可以<br> O(1) 地更新  minn。这样最后一个使得不等式不成立的 i 即为  left 左侧即为  numsA 能取得的最大范围。</p><p>同理，我们可以用类似的方法确定 right。在实际代码中，我们可以在一次循环中同时完成左右边界的计算。</p><p>特别地，我们需要特判  nums 有序的情况，此时  numsB 的长度为  0。当我们计算完成左右边界，即可返回  numsB 的长度。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int maxn = INT_MIN, right = -1;</span><br><span class="line">        int minn = INT_MAX, left = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">                left = n - i - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minn = nums[n - i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right == -1 ? 0 : right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int maxn = Integer.MIN_VALUE, right = -1;</span><br><span class="line">        int minn = Integer.MAX_VALUE, left = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">                left = n - i - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minn = nums[n - i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right == -1 ? 0 : right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int maxn = int.MinValue, right = -1;</span><br><span class="line">        int minn = int.MaxValue, left = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">                left = n - i - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minn = nums[n - i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right == -1 ? 0 : right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxn, right = float(&quot;-inf&quot;), -1</span><br><span class="line">        minn, left = float(&quot;inf&quot;), -1</span><br><span class="line"></span><br><span class="line">        for i in range(n):</span><br><span class="line">            if maxn &gt; nums[i]:</span><br><span class="line">                right = i</span><br><span class="line">            else:</span><br><span class="line">                maxn = nums[i]</span><br><span class="line">            </span><br><span class="line">            if minn &lt; nums[n - i - 1]:</span><br><span class="line">                left = n - i - 1</span><br><span class="line">            else:</span><br><span class="line">                minn = nums[n - i - 1]</span><br><span class="line">        </span><br><span class="line">        return 0 if right == -1 else right - left + 1</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var findUnsortedSubarray = function(nums) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    let maxn = -Number.MAX_VALUE, right = -1;</span><br><span class="line">    let minn = Number.MAX_VALUE, left = -1;</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (maxn &gt; nums[i]) &#123;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">            left = n - i - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = nums[n - i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return right === -1 ? 0 : right - left + 1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func findUnsortedSubarray(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    minn, maxn := math.MaxInt64, math.MinInt64</span><br><span class="line">    left, right := -1, -1</span><br><span class="line">    for i, num := range nums &#123;</span><br><span class="line">        if maxn &gt; num &#123;</span><br><span class="line">            right = i</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn = num</span><br><span class="line">        &#125;</span><br><span class="line">        if minn &lt; nums[n-i-1] &#123;</span><br><span class="line">            left = n - i - 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = nums[n-i-1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if right == -1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int findUnsortedSubarray(int* nums, int numsSize) &#123;</span><br><span class="line">    int n = numsSize;</span><br><span class="line">    int maxn = INT_MIN, right = -1;</span><br><span class="line">    int minn = INT_MAX, left = -1;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (maxn &gt; nums[i]) &#123;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">            left = n - i - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = nums[n - i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return right == -1 ? 0 : right - left + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度： O(n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。<br>时间复杂度： O(1)。我们只需要常数的空间保存若干变量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。&lt;/p&gt;
&lt;p&gt;请你找出符合题意的 最短 子数组，并输出它的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
    <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
    <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
    <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>Latex极简教程</title>
    <link href="http://yoursite.com/2022/02/28/Latex%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2022/02/28/Latex%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/</id>
    <published>2022-02-28T03:12:12.000Z</published>
    <updated>2022-03-07T12:56:58.784Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上快速安装使用Latex</p><span id="more"></span><h1 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h1><p>步骤参照<a href="https://www.cnblogs.com/ouyangsong/p/9348175.html">^1</a><br>Latex 是个复杂但是很强大的排版工具，在 MAC 系统上如果不想安装 3G 大的 MacTex 的话，可以试试 BasicTex。</p><p>安装<br>MacTex 安装包非常大，而且自带了很多图形应用。我更喜欢用命令行，所以选择 BasicTex。使用 Homebrew 安装非常简单，一条命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install basictex</span><br></pre></td></tr></table></figure><p>如果报错：</p><p>Error: Unknown command: cask</p><p>原因就是新版本的 homebrew 已经取消了 cask 这条命令，改用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask basictex</span><br></pre></td></tr></table></figure><p>安装完还不能直接使用，还需要把 texlive 添加到环境变量中，才能找到相关的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/usr/local/texlive/2020basic/bin/x86_64-darwin:$PATH</span><br></pre></td></tr></table></figure><p>然后就是安装相关的包，以及更新包,要cd到目录&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2020basic&#x2F;bin&#x2F;x86_64-darwin中运行下列命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr update --self --repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br><span class="line">sudo tlmgr install latexmk --repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br></pre></td></tr></table></figure><p>安装包的时候推荐使用清华的 CTAN 镜像，不然的话下载速度实在太慢了。</p><p>到了2021年这个目录也要换成21年的，安装包可以在<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/%E9%87%8C%E4%B8%8B%E8%BD%BDBasicTex.pkg">https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/里下载BasicTex.pkg</a></p><p>特别注意，如果你是 macOS 用户，那么今年的安装与往年的有点不一样，主要是 texlive 的文件结构稍有改变，在配置 PATH、MAN、INFO 等环境变量时，应特别注意。以下是 2021 版 TeXlive 的 macOS 环境变量配置： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export MANPATH=/usr/local/texlive/2021/texmf-dist/doc/man:$&#123;MANPATH&#125;</span><br><span class="line">export INFOPATH=/usr/local/texlive/2021/texmf-dist/doc/info:$&#123;INFOPATH&#125;</span><br><span class="line">export PATH=/usr/local/texlive/2021/bin/universal-darwin:$&#123;PATH&#125;</span><br><span class="line">alias tlmgr=&#x27;sudo /usr/local/texlive/2021/bin/universal-darwin/tlmgr&#x27;</span><br></pre></td></tr></table></figure><p>PATH 里的 universal-darwim 代表此后无论是 Intel Core 还是 M1 芯片，都将得到适配。不过 M1 的兼容性此处未验证。特别强调，下文的配置是全平台通用的，无论你的操作系统是 macOS 还是 Windows，抑或是 Linux，只要不是太小众，应该都没问题。全网只有一个 texlive 的 iso 镜像，并没有特殊适配某个操作系统或某种 CPU 体系结构的版本。</p><h1 id="Atom开发"><a href="#Atom开发" class="headerlink" title="Atom开发"></a>Atom开发</h1><p>配合Atom来运行latex，参照<a href="https://blog.csdn.net/violet_echo_0908/article/details/78160273">^2</a></p><p>安装好插件后会报错缺失一些包可以更新插件或者npm install相应的包</p><h1 id="命令行直接编译"><a href="#命令行直接编译" class="headerlink" title="命令行直接编译"></a>命令行直接编译</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex demo.tex</span><br></pre></td></tr></table></figure><h1 id="遇到错误-LaTeX-Error-File-xifthen-sty-39-not-found"><a href="#遇到错误-LaTeX-Error-File-xifthen-sty-39-not-found" class="headerlink" title="遇到错误 ! LaTeX Error: File `xifthen.sty&#39; not found"></a>遇到错误 <code>! LaTeX Error: File `xifthen.sty&#39; not found</code></h1><p>那么去搜索一下它被包含在哪个包中，比如 xifthen.sty 就是包含在 xifthen 中。那么使用 tlmgr 安装即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr install xifthen</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在mac上快速安装使用Latex&lt;/p&gt;</summary>
    
    
    
    <category term="2022年2月" scheme="http://yoursite.com/categories/2022%E5%B9%B42%E6%9C%88/"/>
    
    
    <category term="Latex" scheme="http://yoursite.com/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>85. 最大矩形</title>
    <link href="http://yoursite.com/2022/02/17/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2022/02/17/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</id>
    <published>2022-02-17T14:34:12.000Z</published>
    <updated>2022-02-17T15:54:59.632Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：6解释：最大矩形如上图所示。</code></pre><p>示例 2：</p><pre><code>输入：matrix = []输出：0</code></pre><p>示例 3：</p><pre><code>输入：matrix = [[&quot;0&quot;]]输出：0</code></pre><p>示例 4：</p><pre><code>输入：matrix = [[&quot;1&quot;]]输出：1</code></pre><p>示例 5：</p><pre><code>输入：matrix = [[&quot;0&quot;,&quot;0&quot;]]输出：0</code></pre><p>提示：</p><pre><code>rows == matrix.lengthcols == matrix[0].length1 &lt;= row, cols &lt;= 200matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39;</code></pre><h1 id="方法一-使用柱状图的优化暴力方法-1"><a href="#方法一-使用柱状图的优化暴力方法-1" class="headerlink" title="方法一: 使用柱状图的优化暴力方法^1"></a>方法一: 使用柱状图的优化暴力方法<a href="https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode-solution-bjlu/">^1</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>最原始地，我们可以列举每个可能的矩形。我们枚举矩形所有可能的左上角坐标和右下角坐标，并检查该矩形是否符合要求。然而该方法的时间复杂度过高，不能通过所有的测试用例，因此我们必须寻找其他方法。</p><p>我们首先计算出矩阵的每个元素的左边连续 1 的数量，使用二维数组 left 记录，其中 left[i][j] 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。</p><p>随后，对于矩阵中任意一个点，我们枚举以该点为右下角的全 1 矩形。</p><p>具体而言，当考察以 </p><p>matrix[i][j] 为右下角的矩形时，我们枚举满足  0≤k≤i 的所有可能的 k，此时矩阵的最大宽度就为</p><p>left[i][j],left[i−1][j],…,left[k][j]</p><p>的最小值。</p><p>下图有助于理解。给定每个点的最大宽度，可计算出底端黄色方块的最大矩形面积。</p><p>对每个点重复这一过程，就可以得到全局的最大矩形。</p><p>我们预计算最大宽度的方法事实上将输入转化成了一系列的柱状图，我们针对每个柱状图计算最大面积。</p><p>于是，上述方法本质上是「84. 柱状图中最大的矩形」题中优化暴力算法的复用。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; left(m, vector&lt;int&gt;(n, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int width = left[i][j];</span><br><span class="line">                int area = width;</span><br><span class="line">                for (int k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                    width = min(width, left[k][j]);</span><br><span class="line">                    area = max(area, (i - k + 1) * width);</span><br><span class="line">                &#125;</span><br><span class="line">                ret = max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        int m = matrix.length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].length;</span><br><span class="line">        int[][] left = new int[m][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int width = left[i][j];</span><br><span class="line">                int area = width;</span><br><span class="line">                for (int k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                    width = Math.min(width, left[k][j]);</span><br><span class="line">                    area = Math.max(area, (i - k + 1) * width);</span><br><span class="line">                &#125;</span><br><span class="line">                ret = Math.max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var maximalRectangle = function(matrix) &#123;</span><br><span class="line">    const m = matrix.length;</span><br><span class="line">    if (m === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const n = matrix[0].length;</span><br><span class="line">    const left = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0));</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] === &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j === 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let ret = 0;</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] === &#x27;0&#x27;) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            let width = left[i][j];</span><br><span class="line">            let area = width;</span><br><span class="line">            for (let k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                width = Math.min(width, left[k][j]);</span><br><span class="line">                area = Math.max(area, (i - k + 1) * width);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = Math.max(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">func maximalRectangle(matrix [][]byte) (ans int) &#123;</span><br><span class="line">    if len(matrix) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    m, n := len(matrix), len(matrix[0])</span><br><span class="line">    left := make([][]int, m)</span><br><span class="line">    for i, row := range matrix &#123;</span><br><span class="line">        left[i] = make([]int, n)</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == &#x27;0&#x27; &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            if j == 0 &#123;</span><br><span class="line">                left[i][j] = 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left[i][j] = left[i][j-1] + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i, row := range matrix &#123;</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == &#x27;0&#x27; &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            width := left[i][j]</span><br><span class="line">            area := width</span><br><span class="line">            for k := i - 1; k &gt;= 0; k-- &#123;</span><br><span class="line">                width = min(width, left[k][j])</span><br><span class="line">                area = max(area, (i-k+1)*width)</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, area)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(a, b int) int &#123;</span><br><span class="line">    if a &lt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if a &gt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize) &#123;</span><br><span class="line">    int m = matrixSize;</span><br><span class="line">    if (m == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = matrixColSize[0];</span><br><span class="line">    int left[m][n];</span><br><span class="line">    memset(left, 0, sizeof(left));</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int width = left[i][j];</span><br><span class="line">            int area = width;</span><br><span class="line">            for (int k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                width = fmin(width, left[k][j]);</span><br><span class="line">                area = fmax(area, (i - k + 1) * width);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = fmax(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>O(m^2 *n)，其中 m 和 n 分别是矩阵的行数和列数。计算 left 矩阵需要 O(mn) 的时间。随后对于矩阵的每个点，需要 O(m) 的时间枚举高度。故总的时间复杂度为 </p><p>O(mn)+O(mn)⋅O(m)&#x3D;O(m^2 *n)。</p><p>空间复杂度：<br>O(mn)，其中<br>m 和 n 分别是矩阵的行数和列数。我们分配了一个与给定矩阵等大的数组，用于存储每个元素的左边连续 1 的数量。</p><h1 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h1><p>思路与算法</p><p>在方法一中，我们讨论了将输入拆分成一系列的柱状图。为了计算矩形的最大面积，我们只需要计算每个柱状图中的最大面积，并找到全局最大值。</p><p>我们可以使用「84. 柱状图中最大的矩形的官方题解」中的单调栈的做法，将其应用在我们生成的柱状图中。</p><p>代码</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; left(m, vector&lt;int&gt;(n, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">            vector&lt;int&gt; up(m, 0), down(m, 0);</span><br><span class="line"></span><br><span class="line">            stack&lt;int&gt; stk;</span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; left[stk.top()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stk.empty() ? -1 : stk.top();</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stk = stack&lt;int&gt;();</span><br><span class="line">            for (int i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; left[stk.top()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stk.empty() ? m : stk.top();</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                int height = down[i] - up[i] - 1;</span><br><span class="line">                int area = height * left[i][j];</span><br><span class="line">                ret = max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        int m = matrix.length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].length;</span><br><span class="line">        int[][] left = new int[m][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">            int[] up = new int[m];</span><br><span class="line">            int[] down = new int[m];</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();</span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stack.isEmpty() ? -1 : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.clear();</span><br><span class="line">            for (int i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stack.isEmpty() ? m : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                int height = down[i] - up[i] - 1;</span><br><span class="line">                int area = height * left[i][j];</span><br><span class="line">                ret = Math.max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var maximalRectangle = function(matrix) &#123;</span><br><span class="line">    const m = matrix.length;</span><br><span class="line">    if (m === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const n = matrix[0].length;</span><br><span class="line">    const left = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0));</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] === &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j === 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let ret = 0;</span><br><span class="line">    for (let j = 0; j &lt; n; j++) &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">        const up = new Array(m).fill(0);</span><br><span class="line">        const down = new Array(m).fill(0);</span><br><span class="line"></span><br><span class="line">        let stack = new Array();</span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            while (stack.length &amp;&amp; left[stack[stack.length - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            up[i] = stack.length === 0 ? -1 : stack[stack.length - 1];</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack = [];</span><br><span class="line">        for (let i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            while (stack.length &amp;&amp; left[stack[stack.length - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            down[i] = stack.length === 0 ? m : stack[stack.length - 1];</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            const height = down[i] - up[i] - 1;</span><br><span class="line">            const area = height * left[i][j];</span><br><span class="line">            ret = Math.max(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func maximalRectangle(matrix [][]byte) (ans int) &#123;</span><br><span class="line">    if len(matrix) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    m, n := len(matrix), len(matrix[0])</span><br><span class="line">    left := make([][]int, m)</span><br><span class="line">    for i, row := range matrix &#123;</span><br><span class="line">        left[i] = make([]int, n)</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == &#x27;0&#x27; &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            if j == 0 &#123;</span><br><span class="line">                left[i][j] = 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left[i][j] = left[i][j-1] + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for j := 0; j &lt; n; j++ &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">        up := make([]int, m)</span><br><span class="line">        down := make([]int, m)</span><br><span class="line">        stk := []int&#123;&#125;</span><br><span class="line">        for i, l := range left &#123;</span><br><span class="line">            for len(stk) &gt; 0 &amp;&amp; left[stk[len(stk)-1]][j] &gt;= l[j] &#123;</span><br><span class="line">                stk = stk[:len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            up[i] = -1</span><br><span class="line">            if len(stk) &gt; 0 &#123;</span><br><span class="line">                up[i] = stk[len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = append(stk, i)</span><br><span class="line">        &#125;</span><br><span class="line">        stk = nil</span><br><span class="line">        for i := m - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">            for len(stk) &gt; 0 &amp;&amp; left[stk[len(stk)-1]][j] &gt;= left[i][j] &#123;</span><br><span class="line">                stk = stk[:len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            down[i] = m</span><br><span class="line">            if len(stk) &gt; 0 &#123;</span><br><span class="line">                down[i] = stk[len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = append(stk, i)</span><br><span class="line">        &#125;</span><br><span class="line">        for i, l := range left &#123;</span><br><span class="line">            height := down[i] - up[i] - 1</span><br><span class="line">            area := height * l[j]</span><br><span class="line">            ans = max(ans, area)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if a &gt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize) &#123;</span><br><span class="line">    int m = matrixSize;</span><br><span class="line">    if (m == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = matrixColSize[0];</span><br><span class="line">    int left[m][n];</span><br><span class="line">    memset(left, 0, sizeof(left));</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (int j = 0; j &lt; n; j++) &#123;  // 对于每一列，使用基于柱状图的方法</span><br><span class="line">        int up[m], down[m];</span><br><span class="line">        memset(up, 0, sizeof(up));</span><br><span class="line">        memset(down, 0, sizeof(down));</span><br><span class="line">        int stk[m], top = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            while (top &gt; 0 &amp;&amp; left[stk[top - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            up[i] = top == 0 ? -1 : stk[top - 1];</span><br><span class="line">            stk[top++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        top = 0;</span><br><span class="line">        for (int i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            while (top &gt; 0 &amp;&amp; left[stk[top - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            down[i] = top == 0 ? m : stk[top - 1];</span><br><span class="line">            stk[top++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            int height = down[i] - up[i] - 1;</span><br><span class="line">            int area = height * left[i][j];</span><br><span class="line">            ret = fmax(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>读者可以自行比对上面的代码与此前第 84 题的代码的相似之处。</p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>O(mn)，其中 m 和 n 分别是矩阵的行数和列数。计算 left 矩阵需要 O(mn) 的时间；对每一列应用柱状图算法需要 O(m) 的时间，一共需要 O(mn) 的时间。</p><p>空间复杂度：</p><p>O(mn)，其中 m 和 n 分别是矩阵的行数和列数。我们分配了一个与给定矩阵等大的数组，用于存储每个元素的左边连续 1 的数量。</p><h1 id="方法三：单调栈优化"><a href="#方法三：单调栈优化" class="headerlink" title="方法三：单调栈优化"></a>方法三：单调栈优化</h1><p>参考84题的优化方法</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        if (row == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int[][] num = new int[row][col];</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                num[i][j] = matrix[i][j] - &#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //原地修改矩阵，使其每行都是柱状图的高度</span><br><span class="line">        for (int i = 1; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                num[i][j] = num[i][j] == 0 ? 0 : num[i - 1][j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxarea = 0;</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            maxarea = Math.max(maxarea, largestRectangleArea(num[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        int len = heights.length;</span><br><span class="line">        int[] left = new int[len];</span><br><span class="line">        int[] right = new int[len];</span><br><span class="line">        Arrays.fill(right, len);</span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            while (!mono_stack.isEmpty() &amp;&amp; heights[i] &lt;= heights[mono_stack.peek()]) &#123;</span><br><span class="line">                right[mono_stack.pop()] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = mono_stack.isEmpty() ? -1 : mono_stack.peek();</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int maxarea = 0;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            maxarea = Math.max(maxarea, heights[i] * (right[i] - left[i] - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年2月" scheme="http://yoursite.com/categories/2022%E5%B9%B42%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
    <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github搭建个人博客问题总结</title>
    <link href="http://yoursite.com/2022/02/17/Hexo%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/02/17/Hexo%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-02-17T06:12:12.000Z</published>
    <updated>2022-03-08T02:49:20.811Z</updated>
    
    <content type="html"><![CDATA[<p>总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法</p><span id="more"></span><p>[TOC]</p><h1 id="Mac-上配置多个git账号"><a href="#Mac-上配置多个git账号" class="headerlink" title="Mac 上配置多个git账号"></a>Mac 上配置多个git账号</h1><p><a href="https://www.jianshu.com/p/698f82e72415">https://www.jianshu.com/p/698f82e72415</a></p><p>此处将公司gitlab地址假设为company.cn</p><pre><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitlab -C &quot;yiyeli@company.cn&quot;ssh-keygen -t rsa -f ~/.ssh/id_rsa_github -C &quot;15652771941@163.com&quot;ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitee -C &quot;15652771941@163.com&quot;ssh -T git@company.cnssh -T git@gitee.comssh -T git@github.comssh: connect to host github.com port 22: Operation timed out</code></pre><p>连接其它git时都成功了，只有github报错，可以换个端口,在github下加一栏 Port 443，但还是没作用</p><pre><code>#公司Host gitlab.company.corpHostname gitlab.company.corpIdentityFile ~/.ssh/id_rsa_gitlabUser gitlabLoginName  #个人githubHost github.comHostname github.comIdentityFile ~/.ssh/id_rsa_githubUser githubLoginName# Port 443#个人giteeHost gitee.comHostname gitee.comIdentityFile ~/.ssh/id_rsa_giteeUser giteeLoginName</code></pre><h2 id="使用公司gitlab时出错"><a href="#使用公司gitlab时出错" class="headerlink" title="使用公司gitlab时出错"></a>使用公司gitlab时出错</h2><pre><code>Total 10 (delta 4), reused 0 (delta 0), pack-reused 0remote: git rev-list xxxx--after=&#39;2021-11-29 15:55:00&#39;        remote: GL-HOOK-ERR: 6xxxx的提交者xxxx@163.com不是公司邮箱，请修改您的邮箱为公司邮箱,若仍无法解决，请提交jira工单:remote: error: hook declined to update refs/heads/feature-chinese2022        error: failed to push some refs to &#39;gitlab.company.corp:ce-datamonitorsystem/grafana.git&#39;</code></pre><p>从错误原因可以看到是提交的邮箱错误，原因是第一次commit时IDE会弹出一个Git User Name Is Not Defined的窗口，填完用户名和邮箱后会默认将Set properties globally的选项打上勾，这样在配置多个git账户时就会出错，因为邮箱等参数不能是全局一致的，记得每次把这个Set properties globally选项去掉就好了。</p><h1 id="问题：本地同时配置多个github账号导致博客部署失败"><a href="#问题：本地同时配置多个github账号导致博客部署失败" class="headerlink" title="问题：本地同时配置多个github账号导致博客部署失败"></a>问题：本地同时配置多个github账号导致博客部署失败</h1><p>因为本地同时配置有两个github账号，在Hexo+github搭建个人博客部署到账号A成功后用相同方式部署到账号B时执行hexo d时出现问题</p><pre><code>remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &#39;https://github.com/B/B.github.io.git/&#39;: The requested URL returned error: 403FATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &#39;https://github.com/B/B.github.io.git/&#39;: The requested URL returned error: 403</code></pre><p>原因是在缺省设置下，github page只有该page对应的账号A才能push，为了解决该问题，在hexo的 _config.yml部署的repo地址改用ssh而不是用https，同时对ssh地址做Host别名替换，原有repo地址为repository: <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#109;</a>:Name&#x2F;Name.github.io.git，替换为repository: git@B:Name&#x2F;Name.github.io.git。<br>在原有的~.ssh\config中配置内容如下：</p><pre><code># 该配置用于账户AHost A # Host 服务器别名HostName github.com  # HostName 服务器ip地址或机器名User A # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa # IdentityFile 密匙文件的具体路径# 该配置用于账户BHost B # Host 服务器别名HostName github.com # HostName 服务器ip地址或机器名User B # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa_new # IdentityFile 密匙文件的具体路径</code></pre><p>这样ssh解析的时候就会自动把B转换为 github.com，push的时候系统就会根据不同的仓库地址使用不同的账号提交</p><h1 id="问题：历史删除文件仍存在于repository中"><a href="#问题：历史删除文件仍存在于repository中" class="headerlink" title="问题：历史删除文件仍存在于repository中"></a>问题：历史删除文件仍存在于repository中</h1><p>原本删除的文件仍存在于生成的blog\public中，这是因为没有执行hexo clean命令</p><p>##问题3：Hexo deploy 发布不成功<br>始终停留在</p><pre><code>nothing to commit (working directory clean)</code></pre><p>Hexo的issue中有提到这个问题哦，原因就是第一次设置错了，然后即使正确设置 Repository 再次 Deploy 的时候它也会报错：nothing to commit, working directory clean；error: src refspec master does not match any。所以，当重新设置 Repo 的时候要把 .deploy_git&#x2F; 文件夹删掉，让 Hexo 再次初始化，否则 Hexo 只是执行 push 操作，所以会一直报错。解决方法是删除.deploy_git</p><pre><code>rm -rf .deploy_githexo generaterhexo deploy</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法&lt;/p&gt;</summary>
    
    
    
    <category term="2022年2月" scheme="http://yoursite.com/categories/2022%E5%B9%B42%E6%9C%88/"/>
    
    
    <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
    <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
    <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>312. 戳气球</title>
    <link href="http://yoursite.com/2022/01/18/312.%20%E6%88%B3%E6%B0%94%E7%90%83%E4%BA%8C%E5%88%B7/"/>
    <id>http://yoursite.com/2022/01/18/312.%20%E6%88%B3%E6%B0%94%E7%90%83%E4%BA%8C%E5%88%B7/</id>
    <published>2022-01-18T15:50:12.000Z</published>
    <updated>2022-01-18T15:54:23.897Z</updated>
    
    <content type="html"><![CDATA[<p>求所能获得硬币的最大数量。</p><span id="more"></span><p>[TOC]</p><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例 1：</p><pre><code>输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,5]输出：10</code></pre><p>提示：</p><pre><code>n == nums.length1 &lt;= n &lt;= 5000 &lt;= nums[i] &lt;= 100</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode-cn.com/problems/burst-balloons/solution/chuo-qi-qiu-by-leetcode-solution/">^1</a></h1><p>为了方便处理，我们对 nums 数组稍作处理，将其两边各加上题目中假设存在的 nums[n] ，并保存在 val 数组中，即 val[i]&#x3D;nums[i−1] 。之所以这样处理是为了处理 nums[−1] ，防止下标越界。</p><p>下文中的区间均指数组 val 上的区间。</p><h1 id="方法一：记忆化搜索"><a href="#方法一：记忆化搜索" class="headerlink" title="方法一：记忆化搜索"></a>方法一：记忆化搜索</h1><h2 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>我们观察戳气球的操作，发现这会导致两个气球从不相邻变成相邻，使得后续操作难以处理。于是我们倒过来看这些操作，将全过程看作是每次添加一个气球。</p><p>我们定义方法 solve，令 solve(i,j) 表示将开区间 (i,j) 内的位置全部填满气球能够得到的最多硬币数。由于是开区间，因此区间两端的气球的编号就是 i 和 j，对应着 val[i] 和 val[j]。</p><p>当 i≥j−1 时，开区间中没有气球，solve(i,j) 的值为 0；</p><p>当 i&lt;j−1 时，我们枚举开区间 (i,j) 内的全部位置 mid，令 mid 为当前区间第一个添加的气球，该操作能得到的硬币数为 val[i]×val[mid]×val[j]。同时我们递归地计算分割出的两区间对 solve(i,j) 的贡献，这三项之和的最大值，即为 solve(i,j) 的值。这样问题就转化为求 solve(i,mid) 和 solve(mid,j) ，可以写出方程：</p><pre><code>if i&lt;j−1solve(i,j)=max(mid in (i+1, j−1)) val[i]×val[mid]×val[j]+solve(i,mid)+solve(mid,j),if i≥j−1solve(i,j)=0,</code></pre><p>为了防止重复计算，我们存储 solve 的结果，使用记忆化搜索的方法优化时间复杂度。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; rec;</span><br><span class="line">    vector&lt;int&gt; val;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int solve(int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right - 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rec[left][right] != -1) &#123;</span><br><span class="line">            return rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = left + 1; i &lt; right; i++) &#123;</span><br><span class="line">            int sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        val.resize(n + 2);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        rec.resize(n + 2, vector&lt;int&gt;(n + 2, -1));</span><br><span class="line">        return solve(0, n + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] rec;</span><br><span class="line">    public int[] val;</span><br><span class="line"></span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        val = new int[n + 2];</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        rec = new int[n + 2][n + 2];</span><br><span class="line">        for (int i = 0; i &lt;= n + 1; i++) &#123;</span><br><span class="line">            Arrays.fill(rec[i], -1);</span><br><span class="line">        &#125;</span><br><span class="line">        return solve(0, n + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int solve(int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right - 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rec[left][right] != -1) &#123;</span><br><span class="line">            return rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = left + 1; i &lt; right; i++) &#123;</span><br><span class="line">            int sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxCoins(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        val = [1] + nums + [1]</span><br><span class="line">        </span><br><span class="line">        @lru_cache(None)</span><br><span class="line">        def solve(left: int, right: int) -&gt; int:</span><br><span class="line">            if left &gt;= right - 1:</span><br><span class="line">                return 0</span><br><span class="line">            </span><br><span class="line">            best = 0</span><br><span class="line">            for i in range(left + 1, right):</span><br><span class="line">                total = val[left] * val[i] * val[right]</span><br><span class="line">                total += solve(left, i) + solve(i, right)</span><br><span class="line">                best = max(best, total)</span><br><span class="line">            </span><br><span class="line">            return best</span><br><span class="line"></span><br><span class="line">        return solve(0, n + 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">func maxCoins(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    val := make([]int, n + 2)</span><br><span class="line">    for i := 1; i &lt;= n; i++ &#123;</span><br><span class="line">        val[i] = nums[i - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    val[0], val[n+1] = 1, 1</span><br><span class="line">    rec := make([][]int, n + 2)</span><br><span class="line">    for i := 0; i &lt; len(rec); i++ &#123;</span><br><span class="line">        rec[i] = make([]int, n + 2)</span><br><span class="line">        for j := 0; j &lt; len(rec[i]); j++ &#123;</span><br><span class="line">            rec[i][j] = -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return solve(0, n + 1, val, rec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func solve(left, right int, val []int, rec [][]int) int &#123;</span><br><span class="line">    if left &gt;= right - 1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    if rec[left][right] != -1 &#123;</span><br><span class="line">        return rec[left][right]</span><br><span class="line">    &#125;</span><br><span class="line">    for i := left + 1; i &lt; right; i++ &#123;</span><br><span class="line">        sum := val[left] * val[i] * val[right]</span><br><span class="line">        sum += solve(left, i, val, rec) + solve(i, right, val, rec)</span><br><span class="line">        rec[left][right] = max(rec[left][right], sum)</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[left][right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int rec[502][502];</span><br><span class="line">int val[502];</span><br><span class="line">int solve(int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rec[left][right] != -1) &#123;</span><br><span class="line">        return rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = left + 1; i &lt; right; i++) &#123;</span><br><span class="line">        int sum = val[left] * val[i] * val[right];</span><br><span class="line">        sum += solve(left, i) + solve(i, right);</span><br><span class="line">        rec[left][right] = fmax(rec[left][right], sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxCoins(int* nums, int numsSize) &#123;</span><br><span class="line">    memset(rec, -1, sizeof(rec));</span><br><span class="line">    val[0] = val[numsSize + 1] = 1;</span><br><span class="line">    for (int i = 1; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        val[i] = nums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return solve(0, numsSize + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^3)，其中 n 是气球数量。区间数为 n^2 ，区间迭代复杂度为 O(n)，最终复杂度为 O(n^2 × n)&#x3D;O(n^3)。</p><p>空间复杂度：O(n^2)，其中 n 是气球数量。缓存大小为区间的个数。</p><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><h2 id="思路及算法-1"><a href="#思路及算法-1" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>按照方法一的思路，我们发现我们可以通过变换计算顺序，从「自顶向下」的记忆化搜索变为「自底向上」的动态规划。</p><p>令 dp[i][j] 表示填满开区间 (i,j) 能得到的最多硬币数，那么边界条件是 i≥j−1，此时有 dp[i][j]&#x3D;0。</p><p>可以写出状态转移方程：</p><pre><code>if i&lt;j−1dp[i][j]=max(k in (i+1, j−1)) val[i]×val[k]×val[j]+dp[i][k]+dp[k][j]if i≥j−1dp[i][j]=0,</code></pre><p>最终答案即为 dp[0][n+1]。实现时要注意到动态规划的次序。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; rec(n + 2, vector&lt;int&gt;(n + 2));</span><br><span class="line">        vector&lt;int&gt; val(n + 2);</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i + 2; j &lt;= n + 1; j++) &#123;</span><br><span class="line">                for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                    int sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[0][n + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[][] rec = new int[n + 2][n + 2];</span><br><span class="line">        int[] val = new int[n + 2];</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i + 2; j &lt;= n + 1; j++) &#123;</span><br><span class="line">                for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                    int sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = Math.max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[0][n + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxCoins(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        rec = [[0] * (n + 2) for _ in range(n + 2)]</span><br><span class="line">        val = [1] + nums + [1]</span><br><span class="line"></span><br><span class="line">        for i in range(n - 1, -1, -1):</span><br><span class="line">            for j in range(i + 2, n + 2):</span><br><span class="line">                for k in range(i + 1, j):</span><br><span class="line">                    total = val[i] * val[k] * val[j]</span><br><span class="line">                    total += rec[i][k] + rec[k][j]</span><br><span class="line">                    rec[i][j] = max(rec[i][j], total)</span><br><span class="line">        </span><br><span class="line">        return rec[0][n + 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func maxCoins(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    rec := make([][]int, n + 2)</span><br><span class="line">    for i := 0; i &lt; n + 2; i++ &#123;</span><br><span class="line">        rec[i] = make([]int, n + 2)</span><br><span class="line">    &#125;</span><br><span class="line">    val := make([]int, n + 2)</span><br><span class="line">    val[0], val[n+1] = 1, 1</span><br><span class="line">    for i := 1; i &lt;= n; i++ &#123;</span><br><span class="line">        val[i] = nums[i-1]</span><br><span class="line">    &#125;</span><br><span class="line">    for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">        for j := i + 2; j &lt;= n + 1; j++ &#123;</span><br><span class="line">            for k := i + 1; k &lt; j; k++ &#123;</span><br><span class="line">                sum := val[i] * val[k] * val[j]</span><br><span class="line">                sum += rec[i][k] + rec[k][j]</span><br><span class="line">                rec[i][j] = max(rec[i][j], sum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[0][n+1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int maxCoins(int* nums, int numsSize) &#123;</span><br><span class="line">    int rec[numsSize + 2][numsSize + 2];</span><br><span class="line">    memset(rec, 0, sizeof(rec));</span><br><span class="line">    int val[numsSize + 2];</span><br><span class="line">    val[0] = val[numsSize + 1] = 1;</span><br><span class="line">    for (int i = 1; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        val[i] = nums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = numsSize - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (int j = i + 2; j &lt;= numsSize + 1; j++) &#123;</span><br><span class="line">            for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                int sum = val[i] * val[k] * val[j];</span><br><span class="line">                sum += rec[i][k] + rec[k][j];</span><br><span class="line">                rec[i][j] = fmax(rec[i][j], sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[0][numsSize + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^3)，其中 n 是气球数量。状态数为 n^2 ，状态转移复杂度为 O(n)，最终复杂度为 O(n^2 × n)&#x3D;O(n^3)。</p><p>空间复杂度：O(n^2)，其中 n 是气球数量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;求所能获得硬币的最大数量。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>114. 二叉树展开为链表</title>
    <link href="http://yoursite.com/2022/01/18/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/01/18/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-18T15:12:12.000Z</published>
    <updated>2022-01-18T15:06:19.158Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><span id="more"></span><p>[TOC]</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</p><p>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p>示例 1：</p><pre><code>输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6]</code></pre><p>示例 2：</p><pre><code>输入：root = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：root = [0]输出：[0]</code></pre><p>提示：</p><pre><code>树中结点数在范围 [0, 2000] 内-100 &lt;= Node.val &lt;= 100</code></pre><p>进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？</p><h1 id="方法一：前序遍历-1"><a href="#方法一：前序遍历-1" class="headerlink" title="方法一：前序遍历^1"></a>方法一：前序遍历<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/">^1</a></h1><p>将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。</p><p>对二叉树的前序遍历不熟悉的读者请自行练习「144. 二叉树的前序遍历」。</p><p>前序遍历可以通过递归或者迭代的方式实现。以下代码通过递归实现前序遍历。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        int size = list.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode prev = list.get(i - 1), curr = list.get(i);</span><br><span class="line">            prev.left = null;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preorderTraversal(TreeNode root, List&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; l;</span><br><span class="line">        preorderTraversal(root, l);</span><br><span class="line">        int n = l.size();</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode *prev = l.at(i - 1), *curr = l.at(i);</span><br><span class="line">            prev-&gt;left = nullptr;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preorderTraversal(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) &#123;</span><br><span class="line">        if (root != NULL) &#123;</span><br><span class="line">            l.push_back(root);</span><br><span class="line">            preorderTraversal(root-&gt;left, l);</span><br><span class="line">            preorderTraversal(root-&gt;right, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    list := preorderTraversal(root)</span><br><span class="line">    for i := 1; i &lt; len(list); i++ &#123;</span><br><span class="line">        prev, curr := list[i-1], list[i]</span><br><span class="line">        prev.Left, prev.Right = nil, curr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func preorderTraversal(root *TreeNode) []*TreeNode &#123;</span><br><span class="line">    list := []*TreeNode&#123;&#125;</span><br><span class="line">    if root != nil &#123;</span><br><span class="line">        list = append(list, root)</span><br><span class="line">        list = append(list, preorderTraversal(root.Left)...)</span><br><span class="line">        list = append(list, preorderTraversal(root.Right)...)</span><br><span class="line">    &#125;</span><br><span class="line">    return list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        preorderList = list()</span><br><span class="line"></span><br><span class="line">        def preorderTraversal(root: TreeNode):</span><br><span class="line">            if root:</span><br><span class="line">                preorderList.append(root)</span><br><span class="line">                preorderTraversal(root.left)</span><br><span class="line">                preorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        preorderTraversal(root)</span><br><span class="line">        size = len(preorderList)</span><br><span class="line">        for i in range(1, size):</span><br><span class="line">            prev, curr = preorderList[i - 1], preorderList[i]</span><br><span class="line">            prev.left = None</span><br><span class="line">            prev.right = curr</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    const list = [];</span><br><span class="line">    preorderTraversal(root, list);</span><br><span class="line">    const size = list.length;</span><br><span class="line">    for (let i = 1; i &lt; size; i++) &#123;</span><br><span class="line">        const prev = list[i - 1], curr = list[i];</span><br><span class="line">        prev.left = null;</span><br><span class="line">        prev.right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const preorderTraversal = (root, list) =&gt; &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        list.push(root);</span><br><span class="line">        preorderTraversal(root.left, list);</span><br><span class="line">        preorderTraversal(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line"></span><br><span class="line">void flatten(struct TreeNode* root) &#123;</span><br><span class="line">    num = 0;</span><br><span class="line">    struct TreeNode** l = (struct TreeNode**)malloc(0);</span><br><span class="line">    preorderTraversal(root, &amp;l);</span><br><span class="line">    for (int i = 1; i &lt; num; i++) &#123;</span><br><span class="line">        struct TreeNode *prev = l[i - 1], *curr = l[i];</span><br><span class="line">        prev-&gt;left = NULL;</span><br><span class="line">        prev-&gt;right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    free(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preorderTraversal(struct TreeNode* root, struct TreeNode*** l) &#123;</span><br><span class="line">    if (root != NULL) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        (*l) = (struct TreeNode**)realloc((*l), sizeof(struct TreeNode*) * num);</span><br><span class="line">        (*l)[num - 1] = root;</span><br><span class="line">        preorderTraversal(root-&gt;left, l);</span><br><span class="line">        preorderTraversal(root-&gt;right, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>以下代码通过迭代实现前序遍历。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        while (node != null || !stack.isEmpty()) &#123;</span><br><span class="line">            while (node != null) &#123;</span><br><span class="line">                list.add(node);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = list.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode prev = list.get(i - 1), curr = list.get(i);</span><br><span class="line">            prev.left = null;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        auto v = vector&lt;TreeNode*&gt;();</span><br><span class="line">        auto stk = stack&lt;TreeNode*&gt;();</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        while (node != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                v.push_back(node);</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top(); stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = v.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">            auto prev = v.at(i - 1), curr = v.at(i);</span><br><span class="line">            prev-&gt;left = nullptr;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    list := []*TreeNode&#123;&#125;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    for node != nil || len(stack) &gt; 0 &#123;</span><br><span class="line">        for node != nil &#123;</span><br><span class="line">            list = append(list, node)</span><br><span class="line">            stack = append(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack[len(stack)-1]</span><br><span class="line">        node = node.Right</span><br><span class="line">        stack = stack[:len(stack)-1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 1; i &lt; len(list); i++ &#123;</span><br><span class="line">        prev, curr := list[i-1], list[i]</span><br><span class="line">        prev.Left, prev.Right = nil, curr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        preorderList = list()</span><br><span class="line">        stack = list()</span><br><span class="line">        node = root</span><br><span class="line"></span><br><span class="line">        while node or stack:</span><br><span class="line">            while node:</span><br><span class="line">                preorderList.append(node)</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.right</span><br><span class="line">        </span><br><span class="line">        size = len(preorderList)</span><br><span class="line">        for i in range(1, size):</span><br><span class="line">            prev, curr = preorderList[i - 1], preorderList[i]</span><br><span class="line">            prev.left = None</span><br><span class="line">            prev.right = curr</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    const list = [];</span><br><span class="line">    const stack = [];</span><br><span class="line">    let node = root;</span><br><span class="line">    while (node !== null || stack.length) &#123;</span><br><span class="line">        while (node !== null) &#123;</span><br><span class="line">            list.push(node);</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    const size = list.length;</span><br><span class="line">    for (let i = 1; i &lt; size; i++) &#123;</span><br><span class="line">        const prev = list[i - 1], curr = list[i];</span><br><span class="line">        prev.left = null;</span><br><span class="line">        prev.right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void flatten(struct TreeNode* root) &#123;</span><br><span class="line">    struct TreeNode** stk = (struct TreeNode**)malloc(0);</span><br><span class="line">    int stk_top = 0;</span><br><span class="line">    struct TreeNode** vec = (struct TreeNode**)malloc(0);</span><br><span class="line">    int vec_len = 0;</span><br><span class="line">    struct TreeNode* node = root;</span><br><span class="line">    while (node != NULL || stk_top != 0) &#123;</span><br><span class="line">        while (node != NULL) &#123;</span><br><span class="line">            vec_len++;</span><br><span class="line">            vec = (struct TreeNode**)realloc(vec, sizeof(struct TreeNode*) * vec_len);</span><br><span class="line">            vec[vec_len - 1] = node;</span><br><span class="line">            stk_top++;</span><br><span class="line">            stk = (struct TreeNode**)realloc(stk, sizeof(struct TreeNode*) * stk_top);</span><br><span class="line">            stk[stk_top - 1] = node;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stk[--stk_top];</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; vec_len; i++) &#123;</span><br><span class="line">        struct TreeNode *prev = vec[i - 1], *curr = vec[i];</span><br><span class="line">        prev-&gt;left = NULL;</span><br><span class="line">        prev-&gt;right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    free(stk);</span><br><span class="line">    free(vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>O(n)，其中 n 是二叉树的节点数。前序遍历的时间复杂度是 O(n)，前序遍历之后，需要对每个节点更新左右子节点的信息，时间复杂度也是 O(n)。</p><p>空间复杂度：</p><p>O(n)，其中 n 是二叉树的节点数。空间复杂度取决于栈（递归调用栈或者迭代中显性使用的栈）和存储前序遍历结果的列表的大小，栈内的元素个数不会超过 n，前序遍历列表中的元素个数是 n。</p><h1 id="方法二：前序遍历和展开同步进行"><a href="#方法二：前序遍历和展开同步进行" class="headerlink" title="方法二：前序遍历和展开同步进行"></a>方法二：前序遍历和展开同步进行</h1><p>使用方法一的前序遍历，由于将节点展开之后会破坏二叉树的结构而丢失子节点的信息，因此前序遍历和展开为单链表分成了两步。能不能在不丢失子节点的信息的情况下，将前序遍历和展开为单链表同时进行？</p><p>之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历时，没有存储右子节点的信息，在遍历完左子树之后才获得右子节点的信息。只要对前序遍历进行修改，在遍历左子树之前就获得左右子节点的信息，并存入栈内，子节点的信息就不会丢失，就可以将前序遍历和展开为单链表同时进行。</p><p>该做法不适用于递归实现的前序遍历，只适用于迭代实现的前序遍历。修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则依次将右子节点和左子节点压入栈内（注意入栈顺序）。</p><p>展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode prev = null;</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode curr = stack.pop();</span><br><span class="line">            if (prev != null) &#123;</span><br><span class="line">                prev.left = null;</span><br><span class="line">                prev.right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode left = curr.left, right = curr.right;</span><br><span class="line">            if (right != null) &#123;</span><br><span class="line">                stack.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left != null) &#123;</span><br><span class="line">                stack.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        auto stk = stack&lt;TreeNode*&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        TreeNode *prev = nullptr;</span><br><span class="line">        while (!stk.empty()) &#123;</span><br><span class="line">            TreeNode *curr = stk.top(); stk.pop();</span><br><span class="line">            if (prev != nullptr) &#123;</span><br><span class="line">                prev-&gt;left = nullptr;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *left = curr-&gt;left, *right = curr-&gt;right;</span><br><span class="line">            if (right != nullptr) &#123;</span><br><span class="line">                stk.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left != nullptr) &#123;</span><br><span class="line">                stk.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line">    var prev *TreeNode</span><br><span class="line">    for len(stack) &gt; 0 &#123;</span><br><span class="line">        curr := stack[len(stack)-1]</span><br><span class="line">        stack = stack[:len(stack)-1]</span><br><span class="line">        if prev != nil &#123;</span><br><span class="line">            prev.Left, prev.Right = nil, curr</span><br><span class="line">        &#125;</span><br><span class="line">        left, right := curr.Left, curr.Right</span><br><span class="line">        if right != nil &#123;</span><br><span class="line">            stack = append(stack, right)</span><br><span class="line">        &#125;</span><br><span class="line">        if left != nil &#123;</span><br><span class="line">            stack = append(stack, left)</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        if not root:</span><br><span class="line">            return</span><br><span class="line">        </span><br><span class="line">        stack = [root]</span><br><span class="line">        prev = None</span><br><span class="line">        </span><br><span class="line">        while stack:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            if prev:</span><br><span class="line">                prev.left = None</span><br><span class="line">                prev.right = curr</span><br><span class="line">            left, right = curr.left, curr.right</span><br><span class="line">            if right:</span><br><span class="line">                stack.append(right)</span><br><span class="line">            if left:</span><br><span class="line">                stack.append(left)</span><br><span class="line">            prev = curr</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    const stack = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    let prev = null;</span><br><span class="line">    while (stack.length) &#123;</span><br><span class="line">        const curr = stack.pop();</span><br><span class="line">        if (prev !== null) &#123;</span><br><span class="line">            prev.left = null;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        const left = curr.left, right = curr.right;</span><br><span class="line">        if (right !== null) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (left !== null) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void flatten(struct TreeNode *root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    struct TreeNode **stk = (struct TreeNode **)malloc(sizeof(struct TreeNode *));</span><br><span class="line">    int stk_top = 1;</span><br><span class="line">    stk[0] = root;</span><br><span class="line">    struct TreeNode *prev = NULL;</span><br><span class="line">    while (stk_top != 0) &#123;</span><br><span class="line">        struct TreeNode *curr = stk[--stk_top];</span><br><span class="line">        if (prev != NULL) &#123;</span><br><span class="line">            prev-&gt;left = NULL;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        struct TreeNode *left = curr-&gt;left, *right = curr-&gt;right;</span><br><span class="line">        if (right != NULL) &#123;</span><br><span class="line">            stk_top++;</span><br><span class="line">            stk = (struct TreeNode **)realloc(stk, sizeof(struct TreeNode *) * stk_top);</span><br><span class="line">            stk[stk_top - 1] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left != NULL) &#123;</span><br><span class="line">            stk_top++;</span><br><span class="line">            stk = (struct TreeNode **)realloc(stk, sizeof(struct TreeNode *) * stk_top);</span><br><span class="line">            stk[stk_top - 1] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    free(stk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。前序遍历的时间复杂度是 O(n)，前序遍历的同时对每个节点更新左右子节点的信息，更新子节点信息的时间复杂度是 O(1)，因此总时间复杂度是 O(n)。</p><p>空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度取决于栈的大小，栈内的元素个数不会超过 n。</p><h1 id="方法三：寻找前驱节点"><a href="#方法三：寻找前驱节点" class="headerlink" title="方法三：寻找前驱节点"></a>方法三：寻找前驱节点</h1><p>前两种方法都借助前序遍历，前序遍历过程中需要使用栈存储节点。有没有空间复杂度是 O(1) 的做法呢？</p><p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p><p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        while (curr != null) &#123;</span><br><span class="line">            if (curr.left != null) &#123;</span><br><span class="line">                TreeNode next = curr.left;</span><br><span class="line">                TreeNode predecessor = next;</span><br><span class="line">                while (predecessor.right != null) &#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor.right = curr.right;</span><br><span class="line">                curr.left = null;</span><br><span class="line">                curr.right = next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *curr = root;</span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            if (curr-&gt;left != nullptr) &#123;</span><br><span class="line">                auto next = curr-&gt;left;</span><br><span class="line">                auto predecessor = next;</span><br><span class="line">                while (predecessor-&gt;right != nullptr) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor-&gt;right = curr-&gt;right;</span><br><span class="line">                curr-&gt;left = nullptr;</span><br><span class="line">                curr-&gt;right = next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    curr := root</span><br><span class="line">    for curr != nil &#123;</span><br><span class="line">        if curr.Left != nil &#123;</span><br><span class="line">            next := curr.Left</span><br><span class="line">            predecessor := next</span><br><span class="line">            for predecessor.Right != nil &#123;</span><br><span class="line">                predecessor = predecessor.Right</span><br><span class="line">            &#125;</span><br><span class="line">            predecessor.Right = curr.Right</span><br><span class="line">            curr.Left, curr.Right = nil, next</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.Right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        curr = root</span><br><span class="line">        while curr:</span><br><span class="line">            if curr.left:</span><br><span class="line">                predecessor = nxt = curr.left</span><br><span class="line">                while predecessor.right:</span><br><span class="line">                    predecessor = predecessor.right</span><br><span class="line">                predecessor.right = curr.right</span><br><span class="line">                curr.left = None</span><br><span class="line">                curr.right = nxt</span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    let curr = root;</span><br><span class="line">    while (curr !== null) &#123;</span><br><span class="line">        if (curr.left !== null) &#123;</span><br><span class="line">            const next = curr.left;</span><br><span class="line">            let predecessor = next;</span><br><span class="line">            while (predecessor.right !== null) &#123;</span><br><span class="line">                predecessor = predecessor.right;</span><br><span class="line">            &#125;</span><br><span class="line">            predecessor.right = curr.right;</span><br><span class="line">            curr.left = null;</span><br><span class="line">            curr.right = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void flatten(struct TreeNode* root) &#123;</span><br><span class="line">    struct TreeNode* curr = root;</span><br><span class="line">    while (curr != NULL) &#123;</span><br><span class="line">        if (curr-&gt;left != NULL) &#123;</span><br><span class="line">            struct TreeNode* next = curr-&gt;left;</span><br><span class="line">            struct TreeNode* predecessor = next;</span><br><span class="line">            while (predecessor-&gt;right != NULL) &#123;</span><br><span class="line">                predecessor = predecessor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            predecessor-&gt;right = curr-&gt;right;</span><br><span class="line">            curr-&gt;left = NULL;</span><br><span class="line">            curr-&gt;right = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。展开为单链表的过程中，需要对每个节点访问一次，在寻找前驱节点的过程中，每个节点最多被额外访问一次。</p><p>空间复杂度：O(1)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根结点 root ，请你将它展开为一个单链表：&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="http://yoursite.com/2022/01/18/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/01/18/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-01-18T10:12:12.000Z</published>
    <updated>2022-01-18T15:04:46.678Z</updated>
    
    <content type="html"><![CDATA[<p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：root = [1,null,2,3]输出：[3,2,1]</code></pre><p>示例 2：</p><pre><code>输入：root = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：root = [1]输出：[1]</code></pre><p>提示：</p><pre><code>树中节点的数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100</code></pre><p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>首先我们需要了解什么是二叉树的后序遍历：按照访问左子树——右子树——根节点的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。</p><p>定义 postorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要递归调用 postorder(root-&gt;left) 来遍历 root 节点的左子树，然后递归调用 postorder(root-&gt;right) 来遍历 root 节点的右子树，最后将 root 节点的值加入答案即可，递归终止的条件为碰到空节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void postorder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root-&gt;left, res);</span><br><span class="line">        postorder(root-&gt;right, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void postorder(TreeNode root, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, res);</span><br><span class="line">        postorder(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        def postorder(root: TreeNode):</span><br><span class="line">            if not root:</span><br><span class="line">                return</span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        res = list()</span><br><span class="line">        postorder(root)</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func postorderTraversal(root *TreeNode) (res []int) &#123;</span><br><span class="line">    var postorder func(*TreeNode)</span><br><span class="line">    postorder = func(node *TreeNode) &#123;</span><br><span class="line">        if node == nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.Left)</span><br><span class="line">        postorder(node.Right)</span><br><span class="line">        res = append(res, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void postorder(struct TreeNode *root, int *res, int *resSize) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root-&gt;left, res, resSize);</span><br><span class="line">    postorder(root-&gt;right, res, resSize);</span><br><span class="line">    res[(*resSize)++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *postorderTraversal(struct TreeNode *root, int *returnSize) &#123;</span><br><span class="line">    int *res = malloc(sizeof(int) * 2001);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    postorder(root, res, returnSize);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。<br>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)</p><h1 id="方法二：迭代-1"><a href="#方法二：迭代-1" class="headerlink" title="方法二：迭代^1"></a>方法二：迭代<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/">^1</a></h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = nullptr;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            if (root-&gt;right == nullptr || root-&gt;right == prev) &#123;</span><br><span class="line">                res.emplace_back(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = nullptr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = null;</span><br><span class="line">        while (root != null || !stack.isEmpty()) &#123;</span><br><span class="line">            while (root != null) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            //右子树为空或者已经遍历过</span><br><span class="line">            if (root.right == null || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        if not root:</span><br><span class="line">            return list()</span><br><span class="line">        </span><br><span class="line">        res = list()</span><br><span class="line">        stack = list()</span><br><span class="line">        prev = None</span><br><span class="line"></span><br><span class="line">        while root or stack:</span><br><span class="line">            while root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            if not root.right or root.right == prev:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                prev = root</span><br><span class="line">                root = None</span><br><span class="line">            else:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">        </span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal(root *TreeNode) (res []int) &#123;</span><br><span class="line">    stk := []*TreeNode&#123;&#125;</span><br><span class="line">    var prev *TreeNode</span><br><span class="line">    for root != nil || len(stk) &gt; 0 &#123;</span><br><span class="line">        for root != nil &#123;</span><br><span class="line">            stk = append(stk, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[len(stk)-1]</span><br><span class="line">        stk = stk[:len(stk)-1]</span><br><span class="line">        if root.Right == nil || root.Right == prev &#123;</span><br><span class="line">            res = append(res, root.Val)</span><br><span class="line">            prev = root</span><br><span class="line">            root = nil</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stk = append(stk, root)</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int *postorderTraversal(struct TreeNode *root, int *returnSize) &#123;</span><br><span class="line">    int *res = malloc(sizeof(int) * 2001);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    struct TreeNode **stk = malloc(sizeof(struct TreeNode *) * 2001);</span><br><span class="line">    int top = 0;</span><br><span class="line">    struct TreeNode *prev = NULL;</span><br><span class="line">    while (root != NULL || top &gt; 0) &#123;</span><br><span class="line">        while (root != NULL) &#123;</span><br><span class="line">            stk[top++] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[--top];</span><br><span class="line">        if (root-&gt;right == NULL || root-&gt;right == prev) &#123;</span><br><span class="line">            res[(*returnSize)++] = root-&gt;val;</span><br><span class="line">            prev = root;</span><br><span class="line">            root = NULL;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stk[top++] = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>二叉树前中后序的递归版本属于easy题，而迭代版本通常是medium甚至是hard。</p><p>在做迭代版本之前，我建议大家先问问各类“遍历”算法的本质是什么？是最后输出的那一串有序的数字吗？数字的顺序是对的，遍历算法就是对的吗？</p><p>个人认为，以上问题的答案都应该是：否。“遍历”的本质是对内存的有序访问，失去了访问顺序，即便你用各种数据结构恢复了这个次序，遍历本身也显得毫无意义。常见的后序遍历写法中有一种已经出现在评论区了——它的思想也很简单，大家做过单词串翻转吗？</p><p>String in  &#x3D; “it is a word”</p><p>String out &#x3D; “word a is it”</p><p>这个问题有一种很优雅的写法是先reverse(in)，然后再逐词翻转——“两次反转”，最后得到的就是正确顺序。</p><p>回到二叉树后序遍历，你也可以利用这种思想，利用双向链表的addFirst，对外部次序和内含次序进行同时翻转，同样会得到一种非常”优雅”的解法，结构简单明晰，甚至还有点好背（狗头）。但是，它并没有真正实现“遍历”——仔细看会发现，该算法其实在使用一种异构的前序遍历：“中-&gt;右-&gt;左”，而非传统意义上的“中-&gt;左-&gt;右”，而这种异构也正是他的第一次反转。而第二次反转就在输出序列上。</p><p>所以本质上，这是一个“前序遍历”，而不是所谓的“后序遍历”。只有当你的各个节点以“左-&gt;右-&gt;中”的次序依次出现在迭代的loop当中时，它才是真正的后序遍历，就像官解那样。更易理解的版本。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; seen = new HashSet&lt;&gt;();</span><br><span class="line">        while (root != null || !s.isEmpty()) &#123;</span><br><span class="line">            if (root == null &amp;&amp; seen.contains(s.peek())) &#123;</span><br><span class="line">                ans.add(s.pop().val);</span><br><span class="line">            &#125; else if (root == null) &#123;</span><br><span class="line">                seen.add(s.peek());</span><br><span class="line">                root = s.peek().right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p><h1 id="方法三：Morris-遍历"><a href="#方法三：Morris-遍历" class="headerlink" title="方法三：Morris 遍历"></a>方法三：Morris 遍历</h1><h2 id="思路与算法-2"><a href="#思路与算法-2" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现后序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其后序遍历规则总结如下：</p><ol><li>新建临时节点，令该节点为 root；</li><li>如果当前节点的左子节点为空，则遍历当前节点的右子节点；</li><li>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；</li></ol><ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。</li><li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。</li></ul><ol start="4"><li>重复步骤 2 和步骤 3，直到遍历结束。</li></ol><p>这样我们利用 Morris 遍历的方法，后序遍历该二叉搜索树，即可实现线性时间与常数空间的遍历。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode p1 = root, p2 = null;</span><br><span class="line"></span><br><span class="line">        while (p1 != null) &#123;</span><br><span class="line">            p2 = p1.left;</span><br><span class="line">            if (p2 != null) &#123;</span><br><span class="line">                while (p2.right != null &amp;&amp; p2.right != p1) &#123;</span><br><span class="line">                    p2 = p2.right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (p2.right == null) &#123;</span><br><span class="line">                    p2.right = p1;</span><br><span class="line">                    p1 = p1.left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    p2.right = null;</span><br><span class="line">                    addPath(res, p1.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(res, root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addPath(List&lt;Integer&gt; res, TreeNode node) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (node != null) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = res.size() - count, right = res.size() - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int temp = res.get(left);</span><br><span class="line">            res.set(left, res.get(right));</span><br><span class="line">            res.set(right, temp);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void addPath(vector&lt;int&gt; &amp;vec, TreeNode *node) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            vec.emplace_back(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(vec.end() - count, vec.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = nullptr;</span><br><span class="line"></span><br><span class="line">        while (p1 != nullptr) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            if (p2 != nullptr) &#123;</span><br><span class="line">                while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (p2-&gt;right == nullptr) &#123;</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    p2-&gt;right = nullptr;</span><br><span class="line">                    addPath(res, p1-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(res, root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        def addPath(node: TreeNode):</span><br><span class="line">            count = 0</span><br><span class="line">            while node:</span><br><span class="line">                count += 1</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                node = node.right</span><br><span class="line">            i, j = len(res) - count, len(res) - 1</span><br><span class="line">            while i &lt; j:</span><br><span class="line">                res[i], res[j] = res[j], res[i]</span><br><span class="line">                i += 1</span><br><span class="line">                j -= 1</span><br><span class="line">        </span><br><span class="line">        if not root:</span><br><span class="line">            return list()</span><br><span class="line">        </span><br><span class="line">        res = list()</span><br><span class="line">        p1 = root</span><br><span class="line"></span><br><span class="line">        while p1:</span><br><span class="line">            p2 = p1.left</span><br><span class="line">            if p2:</span><br><span class="line">                while p2.right and p2.right != p1:</span><br><span class="line">                    p2 = p2.right</span><br><span class="line">                if not p2.right:</span><br><span class="line">                    p2.right = p1</span><br><span class="line">                    p1 = p1.left</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    p2.right = None</span><br><span class="line">                    addPath(p1.left)</span><br><span class="line">            p1 = p1.right</span><br><span class="line">        </span><br><span class="line">        addPath(root)</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func reverse(a []int) &#123;</span><br><span class="line">    for i, n := 0, len(a); i &lt; n/2; i++ &#123;</span><br><span class="line">        a[i], a[n-1-i] = a[n-1-i], a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func postorderTraversal(root *TreeNode) (res []int) &#123;</span><br><span class="line">    addPath := func(node *TreeNode) &#123;</span><br><span class="line">        resSize := len(res)</span><br><span class="line">        for ; node != nil; node = node.Right &#123;</span><br><span class="line">            res = append(res, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res[resSize:])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1 := root</span><br><span class="line">    for p1 != nil &#123;</span><br><span class="line">        if p2 := p1.Left; p2 != nil &#123;</span><br><span class="line">            for p2.Right != nil &amp;&amp; p2.Right != p1 &#123;</span><br><span class="line">                p2 = p2.Right</span><br><span class="line">            &#125;</span><br><span class="line">            if p2.Right == nil &#123;</span><br><span class="line">                p2.Right = p1</span><br><span class="line">                p1 = p1.Left</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            p2.Right = nil</span><br><span class="line">            addPath(p1.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.Right</span><br><span class="line">    &#125;</span><br><span class="line">    addPath(root)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void addPath(int *vec, int *vecSize, struct TreeNode *node) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (node != NULL) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        vec[(*vecSize)++] = node-&gt;val;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = (*vecSize) - count, j = (*vecSize) - 1; i &lt; j; ++i, --j) &#123;</span><br><span class="line">        int t = vec[i];</span><br><span class="line">        vec[i] = vec[j];</span><br><span class="line">        vec[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *postorderTraversal(struct TreeNode *root, int *returnSize) &#123;</span><br><span class="line">    int *res = malloc(sizeof(int) * 2001);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct TreeNode *p1 = root, *p2 = NULL;</span><br><span class="line"></span><br><span class="line">    while (p1 != NULL) &#123;</span><br><span class="line">        p2 = p1-&gt;left;</span><br><span class="line">        if (p2 != NULL) &#123;</span><br><span class="line">            while (p2-&gt;right != NULL &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                p2 = p2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            if (p2-&gt;right == NULL) &#123;</span><br><span class="line">                p2-&gt;right = p1;</span><br><span class="line">                p1 = p1-&gt;left;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p2-&gt;right = NULL;</span><br><span class="line">                addPath(res, returnSize, p1-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    addPath(res, returnSize, root);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</p><p>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>84.柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2022/01/12/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2022/01/12/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2022-01-12T02:50:12.000Z</published>
    <updated>2022-02-17T15:51:36.043Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><span id="more"></span><p>[TOC]</p><p>柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例1:</p><pre><code>输入: [2,1,5,6,2,3]输出: 10解释：最大的矩形为图中红色区域，面积为 10</code></pre><p>示例 2：</p><pre><code>输入： heights = [2,4]输出： 4</code></pre><p>提示：</p><pre><code>1 &lt;= heights.length &lt;=1050 &lt;= heights[i] &lt;= 104</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/">^1</a></h1><p>我们需要在柱状图中找出最大的矩形，因此我们可以考虑枚举矩形的宽和高，其中「宽」表示矩形贴着柱状图底边的宽度，「高」表示矩形在柱状图上的高度。</p><ul><li>如果我们枚举「宽」，我们可以使用两重循环枚举矩形的左右边界以固定宽度 <em>w</em>，此时矩形的高度 <em>h</em>，就是所有包含在内的柱子的「最小高度」，对应的面积为 <img src="/./p__w_times_h_.png" alt="w\timesh "> 。下面给出了这种方法的 <code>C++</code> 代码。</li></ul><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol01-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left &lt; n; ++left) &#123;</span><br><span class="line">            <span class="type">int</span> minHeight = INT_MAX;</span><br><span class="line">            <span class="comment">// 枚举右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                <span class="comment">// 确定高度</span></span><br><span class="line">                minHeight = <span class="built_in">min</span>(minHeight, heights[right]);</span><br><span class="line">                <span class="comment">// 计算面积</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * minHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><ul><li>如果我们枚举「高」，我们可以使用一重循环枚举某一根柱子，将其固定为矩形的高度 <em>h</em>。随后我们从这跟柱子开始向两侧延伸，直到遇到高度小于 <em>h</em> 的柱子，就确定了矩形的左右边界。如果左右边界之间的宽度为 <em>w</em>，那么对应的面积为 <img src="/./p__w_times_h_.png" alt="w\timesh "> 。下面给出了这种方法的 <code>C++</code> 代码。</li></ul><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol02-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">0</span>; mid &lt; n; ++mid) &#123;</span><br><span class="line">            <span class="comment">// 枚举高</span></span><br><span class="line">            <span class="type">int</span> height = heights[mid];</span><br><span class="line">            <span class="type">int</span> left = mid, right = mid;</span><br><span class="line">            <span class="comment">// 确定左右边界</span></span><br><span class="line">            <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= height) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right + <span class="number">1</span> &lt; n &amp;&amp; heights[right + <span class="number">1</span>] &gt;= height) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算面积</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>可以发现，这两种暴力方法的时间复杂度均为 *O(N^2)*，会超出时间限制，我们必须要进行优化。考虑到枚举「宽」的方法使用了两重循环，本身就已经需要 <em>O(N^2)</em> 的时间复杂度，不容易优化，因此我们可以考虑优化只使用了一重循环的枚举「高」的方法。</p><h1 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h1><p><strong>思路</strong></p><p>我们归纳一下枚举「高」的方法：</p><ul><li><p>首先我们枚举某一根柱子 <em>i</em> 作为高 heights；</p></li><li><p>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 <em>h</em>。换句话说，我们需要找到<strong>左右两侧最近的高度小于 <em>h</em> 的柱子</strong>，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 <em>h</em>，并且就是 <em>i</em> 能够扩展到的最远范围。</p></li></ul><p>那么我们先来看看如何求出<strong>一根柱子的左侧且最近的小于其高度的柱子</strong>。除了根据「前言」部分暴力地进行枚举之外，我们可以通过如下的一个结论来深入地进行思考：</p><blockquote><p>对于两根柱子 <em>j_0</em> 以及 <em>j_1</em>，如果 <em>j_0 &lt; j_1* 并且<br>heights[j_0]&gt;&#x3D;heights[j_1] ，那么**对于任意的在它们之后出现的柱子 <em>i</em>（</em>j_1 &lt; i<em>），</em>j_0* 一定不会是 <em>i</em> 左侧且最近的小于其高度的柱子**。</p></blockquote><p>换句话说，如果有两根柱子 <em>j_0</em> 和 <em>j_1</em>，其中 <em>j_0</em> 在 <em>j_1</em> 的左侧，并且 <em>j_0</em> 的高度大于等于 <em>j_1</em>，那么在后面的柱子 <em>i</em> 向左找小于其高度的柱子时，<em>j_1</em> 会「挡住」<em>j_0</em>，<em>j_0</em> 就不会作为答案了。</p><p>这样以来，我们可以对数组从左向右进行遍历，同时维护一个「可能作为答案」的数据结构，其中按照从小到大的顺序存放了一些 <em>j</em> 值。根据上面的结论，如果我们存放了 j_0,j_1,…,j_s ，那么一定有 height[j_0]&lt;height[j_1]&lt;…&lt;height[j_s] ，因为如果有两个相邻的 <em>j</em> 值对应的高度不满足 <em>&lt;</em> 关系，那么后者会「挡住」前者，前者就不可能作为答案了。</p><p>当我们枚举到第 <em>i</em> 根柱子时，我们的数据结构中存放了j_0,j_1,…,j_s  ，如果第 <em>i</em> 根柱子左侧且最近的小于其高度的柱子为 <em>j_i</em>，那么必然有</p><p><img src="/./p___textit%7Bheight%7D_j_0____textit%7Bheight%7D_j_1____cdots___textit%7Bheight%7D_j_i____textit%7Bheight%7D_i__leq_textit%7Bheight%7D_j_%7Bi+1%7D____cdots___textit%7Bheight%7D_j_s___.png" alt="\textit{height}[j_0]&lt;\textit{height}[j_1]&lt;\cdots&lt;\textit{height}[j_i]&lt;\textit{height}[i]\leq\textit{height}[j_{i+1}]&lt;\cdots&lt;\textit{height}[j_s] "> </p><p>这样我们就可以使用二分查找的方法找到 <em>i</em> 对应的 <em>j_i</em>，<strong>但真的需要吗</strong>？当我们枚举到 <em>i+1</em> 时，原来的 <em>i</em> 也变成了 <em>j</em> 值，因此 <em>i</em> 会被放入数据结构。由于所有在数据结构中的 <em>j</em> 值均小于 <em>i</em>，那么所有高度大于等于 height[i] 的 <em>j</em> 都不会作为答案，需要从数据结构中移除。而我们发现，这些被移除的 <em>j</em> 值恰好就是</p><p>j_i+1,…j_s</p><p>这样我们在枚举到第 <em>i</em> 根柱子的时候，就可以先把所有高度大于等于 <img src="/./p__textit%7Bheight%7D_i__.png" alt="\textit{height}[i] ">  的 <em>j</em> 值全部移除，剩下的 <em>j</em> 值中高度最高的即为答案。在这之后，我们将 <em>i</em> 放入数据结构中，开始接下来的枚举。此时，我们需要使用的数据结构也就呼之欲出了，它就是<strong>栈</strong>。</p><ul><li><p>栈中存放了 <em>j</em> 值。从栈底到栈顶，<em>j</em> 的值严格单调递增，同时对应的高度值也严格单调递增；</p></li><li><p>当我们枚举到第 <em>i</em> 根柱子时，我们从栈顶不断地移除 <img src="/./p__textit%7Bheight%7D_j__geq_textit%7Bheight%7D_i__.png" alt="\textit{height}[j]\geq\textit{height}[i] ">  的 <em>j</em> 值。在移除完毕后，栈顶的 <em>j</em> 值就一定满足 <img src="/./p__textit%7Bheight%7D_j____textit%7Bheight%7D_i__.png" alt="\textit{height}[j]&lt;\textit{height}[i] "> ，此时 <em>j</em> 就是 <em>i</em> 左侧且最近的小于其高度的柱子。</p><ul><li>这里会有一种特殊情况。如果我们移除了栈中所有的 <em>j</em> 值，那就说明 <em>i</em> 左侧所有柱子的高度都大于 <img src="/./p__textit%7Bheight%7D_i__.png" alt="\textit{height}[i] "> ，那么我们可以认为 <em>i</em> 左侧且最近的小于其高度的柱子在位置 <em>j&#x3D;-1</em>，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。</li></ul></li><li><p>我们再将 <em>i</em> 放入栈顶。</p></li></ul><p>栈中存放的元素具有单调性，这就是经典的数据结构「单调栈」了。</p><p><strong>例子</strong></p><p>我们用一个具体的例子 <em>[6, 7, 5, 2, 4, 5, 9, 3]</em> 来帮助读者理解单调栈。我们需要求出每一根柱子的左侧且最近的小于其高度的柱子。初始时的栈为空。</p><ul><li><p>我们枚举 <em>6</em>，因为栈为空，所以 <em>6</em> 左侧的柱子是「哨兵」，位置为 -1。随后我们将 <em>6</em> 入栈。</p><ul><li>栈：<code>[6(0)]</code>。（这里括号内的数字表示柱子在原数组中的位置）</li></ul></li><li><p>我们枚举 <em>7</em>，由于 <em>6&lt;7</em>，因此不会移除栈顶元素，所以 <em>7</em> 左侧的柱子是 <em>6</em>，位置为 <em>0</em>。随后我们将 <em>7</em> 入栈。</p><ul><li>栈：<code>[6(0), 7(1)]</code></li></ul></li><li><p>我们枚举 <em>5</em>，由于 7&gt;&#x3D;5 ，因此移除栈顶元素 <em>7</em>。同样地，6&gt;&#x3D;5 ，再移除栈顶元素 <em>6</em>。此时栈为空，所以 <em>5</em> 左侧的柱子是「哨兵」，位置为 <em>-1</em>。随后我们将 <em>5</em> 入栈。</p><ul><li>栈：<code>[5(2)]</code></li></ul></li><li><p>接下来的枚举过程也大同小异。我们枚举 <em>2</em>，移除栈顶元素 <em>5</em>，得到 <em>2</em> 左侧的柱子是「哨兵」，位置为 <em>-1</em>。将 <em>2</em> 入栈。</p><ul><li>栈：<code>[2(3)]</code></li></ul></li><li><p>我们枚举 <em>4</em>，<em>5</em> 和 <em>9</em>，都不会移除任何栈顶元素，得到它们左侧的柱子分别是 <em>2</em>，<em>4</em> 和 <em>5</em>，位置分别为 <em>3</em>，<em>4</em> 和 <em>5</em>。将它们入栈。</p><ul><li>栈：<code>[2(3), 4(4), 5(5), 9(6)]</code></li></ul></li><li><p>我们枚举 <em>3</em>，依次移除栈顶元素 <em>9</em>，<em>5</em> 和 <em>4</em>，得到 <em>3</em> 左侧的柱子是 <em>2</em>，位置为 <em>3</em>。将 <em>3</em> 入栈。</p><ul><li>栈：<code>[2(3), 3(7)]</code></li></ul></li></ul><p>这样以来，我们得到它们左侧的柱子编号分别为 *[-1, 0, -1, -1, 3, 4, 5, 3]*。用相同的方法，我们从右向左进行遍历，也可以得到它们右侧的柱子编号分别为 *[2, 2, 3, 8, 7, 7, 7, 8]*，这里我们将位置 <em>8</em> 看作「哨兵」。</p><p>在得到了左右两侧的柱子之后，我们就可以计算出每根柱子对应的左右边界，并求出答案了。</p><p><strong>分析</strong></p><p>单调栈的时间复杂度是多少？直接计算十分困难，但是我们可以发现：</p><blockquote><p>每一个位置只会入栈一次（在枚举到它时），并且最多出栈一次。</p></blockquote><p>因此当我们从左向右&#x2F;总右向左遍历数组时，对栈的操作的次数就为 *O(N)*。所以单调栈的总时间复杂度为 *O(N)*。</p><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; mono_stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.<span class="built_in">empty</span>() ? n : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        left, right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            right[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> n</span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line">    left, right := <span class="built_in">make</span>([]<span class="type">int</span>, n), <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    mono_stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(mono_stack) &gt; <span class="number">0</span> &amp;&amp; heights[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] &gt;= heights[i] &#123;</span><br><span class="line">            mono_stack = mono_stack[:<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mono_stack) == <span class="number">0</span> &#123;</span><br><span class="line">            left[i] = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        mono_stack = <span class="built_in">append</span>(mono_stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    mono_stack = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(mono_stack) &gt; <span class="number">0</span> &amp;&amp; heights[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] &gt;= heights[i] &#123;</span><br><span class="line">            mono_stack = mono_stack[:<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mono_stack) == <span class="number">0</span> &#123;</span><br><span class="line">            right[i] = n</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right[i] = mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        mono_stack = <span class="built_in">append</span>(mono_stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*。</p></li><li><p>空间复杂度：*O(N)*。</p></li></ul><h1 id="方法二：单调栈-常数优化"><a href="#方法二：单调栈-常数优化" class="headerlink" title="方法二：单调栈 + 常数优化"></a>方法二：单调栈 + 常数优化</h1><p>在方法一中，我们首先从左往右对数组进行遍历，借助单调栈求出了每根柱子的左边界，随后从右往左对数组进行遍历，借助单调栈求出了每根柱子的右边界。那么我们是否可以只遍历一次就求出答案呢？</p><p>答案是可以的。在方法一中，我们在对位置 <em>i</em> 进行入栈操作时，确定了它的左边界。从直觉上来说，与之对应的我们在对位置 <em>i</em> 进行出栈操作时可以确定它的右边界！仔细想一想，这确实是对的。当位置 <em>i</em> 被弹出栈时，说明此时遍历到的位置 <em>i_0</em> 的高度<strong>小于等于</strong> height[i] ，并且在 <em>i_0</em> 与 <em>i</em> 之间没有其他高度小于等于 height[i] 的柱子。这是因为，如果在 <em>i</em> 和 <em>i_0</em> 之间还有其它位置的高度小于等于 height[i] 的，那么在遍历到那个位置的时候，<em>i</em> 应该已经被弹出栈了。所以位置 <em>i_0</em> 就是位置 <em>i</em> 的右边界。</p><p>等等，我们需要的是「一根柱子的左侧且最近的<strong>小于</strong>其高度的柱子」，但这里我们求的是<strong>小于等于</strong>，那么会造成什么影响呢？答案是：我们确实无法求出正确的右边界，但对最终的答案没有任何影响。这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么<strong>最右侧的那根柱子是可以求出正确的右边界的</strong>，而我们没有对求出左边界的算法进行任何改动，因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的。读者可以仔细思考一下这一步。</p><p>在遍历结束后，栈中仍然有一些位置，这些位置对应的右边界就是位置为 <em>n</em> 的「哨兵」。我们可以将它们依次出栈并更新右边界，也可以在初始化右边界数组时就将所有的元素的值置为 <em>n</em>。</p><p>我们沿用方法一中的例子 *[6, 7, 5, 2, 4, 5, 9, 3]*，下面的幻灯片给出了优化后的流程。</p><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; mono_stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(right, n);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.peek()] = i;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        left, right = [<span class="number">0</span>] * n, [n] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                right[mono_stack[-<span class="number">1</span>]] = i</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line">    left, right := <span class="built_in">make</span>([]<span class="type">int</span>, n), <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        right[i] = n</span><br><span class="line">    &#125;</span><br><span class="line">    mono_stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(mono_stack) &gt; <span class="number">0</span> &amp;&amp; heights[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] &gt;= heights[i] &#123;</span><br><span class="line">            right[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] = i</span><br><span class="line">            mono_stack = mono_stack[:<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mono_stack) == <span class="number">0</span> &#123;</span><br><span class="line">            left[i] = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        mono_stack = <span class="built_in">append</span>(mono_stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*。</p></li><li><p>空间复杂度：*O(N)*。</p></li></ul><h1 id="方法三：单调栈-空间优化"><a href="#方法三：单调栈-空间优化" class="headerlink" title="方法三：单调栈+空间优化"></a>方法三：单调栈+空间优化</h1><p>分析寻找的过程，如果要在O(n)的时间内找到最大的面积，则需要记录下来每个高度为N的矩形，其长度最大可以达到多少。这样就分为两种情况，如图中描述的，首先是高度N越来越大，其次是高度N越来越小。</p><ul><li><p>在高度N越来越大时，其上一个数字构成的高度的矩形的最大长度则增加1，例如，[2 3]，高度为3时，则高度为2的矩形的长度就加1. </p></li><li><p>在高度N越来越小时，其上一个数字构成的高度的矩形的最大长度就不变，例如[4 3]，高度为4时，其构成的矩形长度为1，到了3，矩形长度没有递增，而4之前的数字3构成的矩形的长度也加1。</p></li></ul><p>可以使用一个stack来存储矩形的高度和长度，其中长度会动态的变化。当遇到一个数字大于栈顶数字的时候就压入栈，小于栈顶的数字就弹出栈，在这个动态过程中，更新最大的矩形面积。</p><p><strong>重点在于每次弹出时，首先需要给heights数组加一个右边界，每次弹出时的高度heights[h]是要计算的矩形高度，右边界是i位置，左边界是从右往左第一个比高度heights[h]低的位置，如果栈为空的话左边界位置为-1，不为空则为弹出后栈顶的位置。</strong></p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        heights.push_back(0);</span><br><span class="line">        int len=heights.size();</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int i=0,maxarea=0;</span><br><span class="line">        while(i&lt;len)&#123;</span><br><span class="line">            if(stk.empty() || heights[i]&gt;=heights[stk.top()]) &#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                int h=stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                maxarea=max(maxarea,heights[h]*(stk.empty()? i: i-stk.top()-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        int len = heights.length;</span><br><span class="line">        int[] heightnew = new int[len + 1];</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            heightnew[i] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int maxarea = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt;= len) &#123;</span><br><span class="line">            if (mono_stack.isEmpty() || heightnew[mono_stack.peek()] &lt; heightnew[i]) &#123;</span><br><span class="line">                mono_stack.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int h = mono_stack.pop();</span><br><span class="line">                maxarea = Math.max(maxarea, (mono_stack.isEmpty() ? i : i - mono_stack.peek() - 1) * heightnew[h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>32. 最长有效括号</title>
    <link href="http://yoursite.com/2022/01/11/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2022/01/11/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-01-11T10:12:12.000Z</published>
    <updated>2022-01-12T01:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个只包含 ‘(‘和’)’的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：s = &quot;(()&quot;输出：2解释：最长有效括号子串是 &quot;()&quot;</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;)()())&quot;输出：4解释：最长有效括号子串是 &quot;()()&quot;</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;&quot;输出：0</code></pre><p>提示：</p><pre><code>0 &lt;= s.length &lt;= 3 * 104s[i] 为 &#39;(&#39; 或 &#39;)&#39;</code></pre><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/">^1</a></h1><p><strong>思路和算法</strong></p><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = Math.max(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>        <figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxans = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = <span class="built_in">max</span>(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>        <figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxans = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp[n];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] +</span><br><span class="line">                        ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = fmax(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>        <figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxAns := <span class="number">0</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxAns = max(maxAns, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： *O(n)*，其中 <em>n</em> 为字符串的长度。我们只需遍历整个字符串一次，即可将 dp 数组求出来。</p></li><li><p>空间复杂度： *O(n)*。我们需要一个大小为 <em>n</em> 的 dp 数组。</p></li></ul><h1 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h1><p><strong>思路和算法</strong></p><p>撇开方法一提及的动态规划方法，相信大多数人对于这题的第一直觉是找到每个可能的子串后判断它的有效性，但这样的时间复杂度会达到 *O(n^3)*，无法通过所有测试用例。但是通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。</p><p>具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p><ul><li>对于遇到的每个 ‘(’ ，我们将它的下标放入栈中</li><li>对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li></ul></li></ul><p>我们从前往后遍历字符串并更新答案即可。</p><p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 <em>-1</em> 的元素。</p><details>    <summary>Java</summary>        <figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxans = Math.max(maxans, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>        <figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxans = <span class="built_in">max</span>(maxans, i - stk.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>        <figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxans = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> stk[n + <span class="number">1</span>], top = <span class="number">-1</span>;</span><br><span class="line">    stk[++top] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk[++top] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --top;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">                stk[++top] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxans = fmax(maxans, i - stk[top]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>        <figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxAns := <span class="number">0</span></span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxAns = max(maxAns, i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n)<em>，</em>n</em> 是给定字符串的长度。我们只需要遍历字符串一次即可。</p></li><li><p>空间复杂度： *O(n)*。栈的大小在最坏情况下会达到 <em>n</em>，因此空间复杂度为 <em>O(n)</em> 。</p></li></ul><h1 id="方法三：不需要额外的空间"><a href="#方法三：不需要额外的空间" class="headerlink" title="方法三：不需要额外的空间"></a>方法三：不需要额外的空间</h1><p><strong>思路和算法</strong></p><details>    <summary>Java</summary>        <figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>        <figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>        <figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxlength = fmax(maxlength, <span class="number">2</span> * right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left = right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxlength = fmax(maxlength, <span class="number">2</span> * left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>        <figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right, maxLength := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            maxLength = max(maxLength, <span class="number">2</span> * right)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> right &gt; left &#123;</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            maxLength = max(maxLength, <span class="number">2</span> * left)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： *O(n)*，其中 <em>n</em> 为字符串长度。我们只要正反遍历两边字符串即可。</p></li><li><p>空间复杂度： *O(1)*。我们只需要常数空间存放若干变量。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个只包含 ‘(‘和’)’的字符串，找出最长有效（格式正确且连续）括号子串的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>438. 找到字符串中所有字母异位词</title>
    <link href="http://yoursite.com/2022/01/11/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>http://yoursite.com/2022/01/11/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</id>
    <published>2022-01-11T08:12:12.000Z</published>
    <updated>2022-01-11T10:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用数据结构</p><span id="more"></span><p>[TOC]</p><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>示例 1:</p><pre><code>输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]</code></pre><p>解释:</p><pre><code>起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</code></pre><p>示例 2:</p><pre><code>输入: s = &quot;abab&quot;, p = &quot;ab&quot;输出: [0,1,2]</code></pre><p>解释:</p><pre><code>起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</code></pre><p>提示:</p><pre><code>1 &lt;= s.length, p.length &lt;= 3 * 104s 和 p 仅包含小写字母</code></pre><h1 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h1><p><strong>思路</strong></p><p>根据题目要求，我们需要在字符串 <em>s</em> 寻找字符串 <em>p</em> 的异位词。因为字符串 <em>p</em> 的异位词的长度一定与字符串 <em>p</em> 的长度相同，所以我们可以在字符串 <em>s</em> 中构造一个长度为与字符串 <em>p</em> 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串 <em>p</em> 中每种字母的数量相同时，则说明当前窗口为字符串 <em>p</em> 的异位词。</p><p><strong>算法</strong></p><p>在算法的实现中，我们可以使用数组来存储字符串 <em>p</em> 和滑动窗口中每种字母的数量。</p><p><strong>细节</strong></p><p>当字符串 <em>s</em> 的长度小于字符串 <em>p</em> 的长度时，字符串 <em>s</em> 中一定不存在字符串 <em>p</em> 的异位词。但是因为字符串 <em>s</em> 中无法构造长度与字符串 <em>p</em> 的长度相同的窗口，所以这种情况需要单独处理。</p><p><strong>代码</strong></p><details>    <summary>Python3</summary>    <figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s_len, p_len = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s_len &lt; p_len:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        s_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        p_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p_len):</span><br><span class="line">            s_count[<span class="built_in">ord</span>(s[i]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">            p_count[<span class="built_in">ord</span>(p[i]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s_count == p_count:</span><br><span class="line">            ans.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len - p_len):</span><br><span class="line">            s_count[<span class="built_in">ord</span>(s[i]) - <span class="number">97</span>] -= <span class="number">1</span></span><br><span class="line">            s_count[<span class="built_in">ord</span>(s[i + p_len]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s_count == p_count:</span><br><span class="line">                ans.append(i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details> <details>    <summary>Java</summary> <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">            ++sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">            --sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++sCount[s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">                ans.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <details>    <summary>C#</summary> <figure class="highlight c#"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">FindAnagrams</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> p</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> sLen = s.Length, pLen = p.Length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span>[] sCount = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">int</span>[] pCount = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">            ++sCount[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++pCount[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Enumerable.SequenceEqual(sCount, pCount)) &#123;</span><br><span class="line">            ans.Add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">            --sCount[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++sCount[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Enumerable.SequenceEqual(sCount, pCount)) &#123;</span><br><span class="line">                ans.Add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <details>    <summary>C++</summary> <figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">            ++sCount[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++pCount[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sCount == pCount) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">            --sCount[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++sCount[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sCount == pCount) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details> <details>    <summary>Golang</summary> <figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAnagrams</span><span class="params">(s, p <span class="type">string</span>)</span></span> (ans []<span class="type">int</span>) &#123;</span><br><span class="line">    sLen, pLen := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">if</span> sLen &lt; pLen &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sCount, pCount [<span class="number">26</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> p &#123;</span><br><span class="line">        sCount[s[i]-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">        pCount[ch-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sCount == pCount &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> s[:sLen-pLen] &#123;</span><br><span class="line">        sCount[ch-<span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line">        sCount[s[i+pLen]-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">        <span class="keyword">if</span> sCount == pCount &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, i+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <details>    <summary>JavaScript</summary> <figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sLen = s.<span class="property">length</span>, pLen = p.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> sCount = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> pCount = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        ++sCount[s[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line">        ++pCount[p[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sCount.<span class="title function_">toString</span>() === pCount.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">        ans.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        --sCount[s[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line">        ++sCount[s[i + pLen].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sCount.<span class="title function_">toString</span>() === pCount.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details> <h1 id="方法二：优化的滑动窗口"><a href="#方法二：优化的滑动窗口" class="headerlink" title="方法二：优化的滑动窗口"></a>方法二：优化的滑动窗口</h1><p><strong>思路和算法</strong></p><p>在方法一的基础上，我们不再分别统计滑动窗口和字符串 <em>p</em> 中每种字母的数量，而是统计滑动窗口和字符串 <em>p</em> 中每种字母数量的差；并引入变量 differ  来记录当前窗口与字符串 <em>p</em> 中数量不同的字母的个数，并在滑动窗口的过程中维护它。</p><p>在判断滑动窗口中每种字母的数量与字符串 <em>p</em> 中每种字母的数量是否相同时，只需要判断 differ  是否为零即可。</p><p><strong>代码</strong></p><details>    <summary>Python3</summary> <figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s_len, p_len = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s_len &lt; p_len:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p_len):</span><br><span class="line">            count[<span class="built_in">ord</span>(s[i]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">            count[<span class="built_in">ord</span>(p[i]) - <span class="number">97</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        differ = [c != <span class="number">0</span> <span class="keyword">for</span> c <span class="keyword">in</span> count].count(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> differ == <span class="number">0</span>:</span><br><span class="line">            ans.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len - p_len):</span><br><span class="line">            <span class="keyword">if</span> count[<span class="built_in">ord</span>(s[i]) - <span class="number">97</span>] == <span class="number">1</span>:  <span class="comment"># 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                differ -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count[<span class="built_in">ord</span>(s[i]) - <span class="number">97</span>] == <span class="number">0</span>:  <span class="comment"># 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                differ += <span class="number">1</span></span><br><span class="line">            count[<span class="built_in">ord</span>(s[i]) - <span class="number">97</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count[<span class="built_in">ord</span>(s[i + p_len]) - <span class="number">97</span>] == -<span class="number">1</span>:  <span class="comment"># 窗口中字母 s[i+p_len] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                differ -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count[<span class="built_in">ord</span>(s[i + p_len]) - <span class="number">97</span>] == <span class="number">0</span>:  <span class="comment"># 窗口中字母 s[i+p_len] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                differ += <span class="number">1</span></span><br><span class="line">            count[<span class="built_in">ord</span>(s[i + p_len]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> differ == <span class="number">0</span>:</span><br><span class="line">                ans.append(i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details> <details>    <summary>Java</summary> <figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">            ++count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            --count[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">differ</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                --differ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">            --count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count[s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>] == -<span class="number">1</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                --differ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count[s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (differ == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <details>    <summary>C#</summary> <figure class="highlight c#"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">FindAnagrams</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">string</span> p</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> sLen = s.Length, pLen = p.Length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IList&lt;<span class="built_in">int</span>&gt; ans = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="built_in">int</span>[] count = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">            ++count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            --count[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> differ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.Add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                --differ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">            --count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                --differ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (differ == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.Add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <details>    <summary>C++</summary> <figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">            ++count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            --count[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> differ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                --differ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">            --count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">                --differ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">                ++differ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (differ == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details> <details>    <summary>Golang</summary> <figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAnagrams</span><span class="params">(s, p <span class="type">string</span>)</span></span> (ans []<span class="type">int</span>) &#123;</span><br><span class="line">    sLen, pLen := <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">if</span> sLen &lt; pLen &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> p &#123;</span><br><span class="line">        count[s[i]-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">        count[ch-<span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    differ := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> count &#123;</span><br><span class="line">        <span class="keyword">if</span> c != <span class="number">0</span> &#123;</span><br><span class="line">            differ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> differ == <span class="number">0</span> &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> s[:sLen-pLen] &#123;</span><br><span class="line">        <span class="keyword">if</span> count[ch-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span> &#123; <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">            differ--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> count[ch-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span> &#123; <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">            differ++</span><br><span class="line">        &#125;</span><br><span class="line">        count[ch-<span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> count[s[i+pLen]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span> &#123; <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">            differ--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> count[s[i+pLen]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span> &#123; <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">            differ++</span><br><span class="line">        &#125;</span><br><span class="line">        count[s[i+pLen]-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> differ == <span class="number">0</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, i+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <details>    <summary>JavaScript</summary> <figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sLen = s.<span class="property">length</span>, pLen = p.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        ++count[s[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line">        --count[p[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> differ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[j] !== <span class="number">0</span>) &#123;</span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (differ === <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[s[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()] === <span class="number">1</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()] === <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        --count[s[i].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count[s[i + pLen].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()] === -<span class="number">1</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同</span></span><br><span class="line">            --differ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i + pLen].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()] === <span class="number">0</span>) &#123;  <span class="comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同</span></span><br><span class="line">            ++differ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++count[s[i + pLen].<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (differ === <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details> <p>复杂度<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/">^1</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用数据结构&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Hexo与Nodejs版本不匹配问题解决方案</title>
    <link href="http://yoursite.com/2022/01/10/Hexo%E4%B8%8ENodejs%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2022/01/10/Hexo%E4%B8%8ENodejs%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2022-01-10T08:12:12.000Z</published>
    <updated>2022-01-10T08:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo与Nodejs版本不匹配问题解决方案，升级hexo或者降级nodejs</p><span id="more"></span><p>[TOC]</p><h1 id="部署hexo报错"><a href="#部署hexo报错" class="headerlink" title="部署hexo报错"></a>部署hexo报错</h1><pre><code>FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object    at copyFile (node:fs:2774:10)</code></pre><h1 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h1><p>hexo暂时不能在新版的nodejs环境下运行</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>降级nodejs即可，卸载现有nodejs，安装旧版nodejs。</p><p>如果有nvm的话，可以直接用nvm切换版本</p><p>查看当前的node版本</p><pre><code>node -v</code></pre><p>目前是<br>v16.13.1</p><p>查看安装过的node版本 </p><pre><code>nvm list</code></pre><p>安装某个node版本 </p><pre><code>nvm install &lt;version&gt;nvm install 12</code></pre><p>使用某个node版本 </p><pre><code>nvm use&lt;version&gt;nvm use 12</code></pre><p>卸载某个node版本</p><pre><code>nvm uninstall &lt;version&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo与Nodejs版本不匹配问题解决方案，升级hexo或者降级nodejs&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（数据结构）</title>
    <link href="http://yoursite.com/2022/01/10/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/10/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/</id>
    <published>2022-01-10T08:12:12.000Z</published>
    <updated>2022-01-11T07:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用数据结构</p><span id="more"></span><p>[TOC]</p><h1 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h1><p>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。</p><h1 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h1><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><h1 id="链表（Link）"><a href="#链表（Link）" class="headerlink" title="链表（Link）"></a>链表（Link）</h1><p>链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。</p><h1 id="散列表（Hash-Table）"><a href="#散列表（Hash-Table）" class="headerlink" title="散列表（Hash Table）"></a>散列表（Hash Table）</h1><p>散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。</p><p>散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素，因而必须要在数据元素的存储位置和它的关键字（可用 key 表示）之间建立一个确定的对应关系，使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用 h(key)表示)。</p><p>用的构造散列函数的方法有：</p><p>（1）直接定址法： 取关键字或关键字的某个线性函数值为散列地址。</p><pre><code>即：h(key) = key 或 h(key) = a * key + b，其中 a 和 b 为常数。</code></pre><p>（2）数字分析法</p><p>（3）平方取值法： 取关键字平方后的中间几位为散列地址。</p><p>（4）折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。</p><p>（5）除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，</p><pre><code>即：h(key) = key MOD p p ≤ m</code></pre><p>（6）随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址，</p><pre><code>即：h(key) = random(key)</code></pre><h1 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h1><p>首先如果普通二叉树每个节点满足：左子树所有节点值小于它的根节点值，且右子树所有节点值大于它的根节点值，则这样的二叉树就是排序二叉树。</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>首先要从根节点开始往下找到自己要插入的位置（即新节点的父节点）；具体流程是：新节点与当前节点比较，如果相同则表示已经存在且不能再重复插入；如果小于当前节点，则到左子树中寻找，如果左子树为空则当前节点为要找的父节点，新节点插入到当前节点的左子树即可；如果大于当前节点，则到右子树中寻找，如果右子树为空则当前节点为要找的父节点，新节点插入到当前节点的右子树即可。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作主要分为三种情况，即要删除的节点无子节点，要删除的节点只有一个子节点，要删除的节点有两个子节点。</p><ol><li><p>对于要删除的节点无子节点可以直接删除，即让其父节点将该子节点置空即可。</p></li><li><p>对于要删除的节点只有一个子节点，则替换要删除的节点为其子节点。</p></li><li><p>对于要删除的节点有两个子节点，则首先找该节点的替换节点（即右子树中最小的节点），接着替换要删除的节点为替换节点，然后删除替换节点。</p></li></ol><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>查找操作的主要流程为：先和根节点比较，如果相同就返回，如果小于根节点则到左子树中递归查找，如果大于根节点则到右子树中递归查找。因此在排序二叉树中可以很容易获取最大（最右最深子节点）和最小（最左最深子节点）值。</p><h1 id="红黑树（带有自平衡功能的AVL二叉平衡树）"><a href="#红黑树（带有自平衡功能的AVL二叉平衡树）" class="headerlink" title="红黑树（带有自平衡功能的AVL二叉平衡树）"></a>红黑树（带有自平衡功能的AVL二叉平衡树）</h1><p>R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><h2 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h2><ul><li>节点分为红色或者黑色；</li><li>根节点必为黑色；</li><li>叶子节点都为黑色，且为null；</li><li>连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；</li><li>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；</li><li>新加入到红黑树的节点为红色节点；(其实这个是推断出来的，下面会说)</li></ul><h2 id="红黑树的规则特点能够推断出什么东西？-1-2-3"><a href="#红黑树的规则特点能够推断出什么东西？-1-2-3" class="headerlink" title="红黑树的规则特点能够推断出什么东西？^1 ^2 ^3"></a>红黑树的规则特点能够推断出什么东西？<a href="https://cloud.tencent.com/developer/article/1660840">^1</a> <a href="https://zhuanlan.zhihu.com/p/273829162">^2</a> <a href="https://blog.csdn.net/u014454538/article/details/120120216">^3</a></h2><p>从根节点到叶子节点的最长路径不大于最短路径的2倍</p><p>Q：怎么样的路径算最短路径？</p><p>A：从规则5中，我们知道从根节点到每个叶子节点的黑色节点数量是一样的，那么纯由黑色节点组成的路径就是最短路径；</p><p>Q：什么样的路径算是最长路径？</p><p>A：根据规则4和规则3，红黑树不可能出现连续的红色节点，若有红色节点，则必然有一个连接的黑色节点，当红色节点和黑色节点数量相同时，就是最长路径，也就是黑色节点（或红色节点）* 2</p><h2 id="对于第6条：新加入的节点为红色节点，为什么呢？"><a href="#对于第6条：新加入的节点为红色节点，为什么呢？" class="headerlink" title="对于第6条：新加入的节点为红色节点，为什么呢？"></a>对于第6条：新加入的节点为红色节点，为什么呢？</h2><p>从规则4中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新插入的是黑色节点的话，必然破坏规则(它所在的路径上会多出一个黑色节点)，但加入红色节点却不一定，除非其父节点就是红色节点才会破坏规则，因此加入红色节点，破坏规则的可能性小一些</p><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点(x成了为 z 的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。</p><details>    <summary>左旋</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LEFT-ROTATE(T, x)</span><br><span class="line">y ← right[x] // 前提：这里假设 x 的右孩子为 y。下面开始正式操作</span><br><span class="line">right[x] ← left[y] // 将 “y 的左孩子” 设为 “x 的右孩子”，即 将β设为 x 的右孩子</span><br><span class="line">p[left[y]] ← x // 将 “x” 设为 “y 的左孩子的父亲”，即 将β的父亲设为 x</span><br><span class="line">p[y] ← p[x] // 将 “x 的父亲” 设为 “y 的父亲”</span><br><span class="line">if p[x] = nil[T]</span><br><span class="line">then root[T] ← y // 情况 1：如果 “x 的父亲” 是空节点，则将 y 设为根节点</span><br><span class="line">else if x = left[p[x]]</span><br><span class="line"> then left[p[x]] ← y // 情况 2：如果 x 是它父节点的左孩子，则将 y 设为“x 的父节点</span><br><span class="line">的左孩子”</span><br><span class="line"> else right[p[x]] ← y // 情况 3：(x 是它父节点的右孩子) 将 y 设为“x 的父节点的右孩</span><br><span class="line">子”</span><br><span class="line">left[y] ← x // 将 “x” 设为 “y 的左孩子”</span><br><span class="line">p[x] ← y // 将 “x 的父节点” 设为 “y”</span><br></pre></td></tr></table></figure></details><h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p>对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点(x成了为 y 的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。</p><details>    <summary>右旋</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RIGHT-ROTATE(T, y)</span><br><span class="line">x ← left[y] // 前提：这里假设 y 的左孩子为 x。下面开始正式操作</span><br><span class="line">left[y] ← right[x] // 将 “x 的右孩子” 设为 “y 的左孩子”，即 将β设为 y 的左孩子</span><br><span class="line">p[right[x]] ← y // 将 “y” 设为 “x 的右孩子的父亲”，即 将β的父亲设为 y</span><br><span class="line">p[x] ← p[y] // 将 “y 的父亲” 设为 “x 的父亲”</span><br><span class="line">if p[y] = nil[T]</span><br><span class="line">then root[T] ← x // 情况 1：如果 “y 的父亲” 是空节点，则将 x 设为根节点</span><br><span class="line">else if y = right[p[y]]</span><br><span class="line"> then right[p[y]] ← x // 情况 2：如果 y 是它父节点的右孩子，则将 x 设为“y 的父节</span><br><span class="line">点的左孩子”</span><br><span class="line"> else left[p[y]] ← x // 情况 3：(y 是它父节点的左孩子) 将 x 设为“y 的父节点的左孩</span><br><span class="line">子”</span><br><span class="line">right[x] ← y // 将 “y” 设为 “x 的右孩子”</span><br><span class="line">p[y] ← x // 将 “y 的父节点” 设为 “x”</span><br></pre></td></tr></table></figure></details><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</p><p>第二步：将插入的节点着色为”红色”。</p><p> 根据被插入节点的父节点的情况，可以将”当节点 z 被着色为红色节点，并插入二叉树”划分为三种情况来处理。</p><p>① 情况说明：被插入的节点是根节点。</p><p>处理方法：直接把此节点涂为黑色。</p><p>② 情况说明：被插入的节点的父节点是黑色。</p><p>处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</p><p>③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为 3种情况(Case)。</p><p>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</p><h2 id="插入节点的另一种解释"><a href="#插入节点的另一种解释" class="headerlink" title="插入节点的另一种解释"></a>插入节点的另一种解释</h2><p>插入步骤：</p><ul><li>根据二叉搜索树的特性，找到新的节点合适的插入位置，也就是找到它的爸爸</li><li>决定将它作为它爸爸的左孩子还是右孩子(还是二叉搜树的特点)</li><li>把它标记为红色节点，因为它可能破坏了原红黑树的规则，所以需要变色+旋转来进行调整</li></ul><p>情况一：插入之后不破坏规则，不需要旋转，也不需要变色：</p><p>情况二、插入之后只需要变色，不需要旋转</p><p>情况二、插入之后只需要变色，不需要旋转</p><p>总结红黑树的调整情形：</p><ol><li><p>新插入红黑树的节点一定是红色</p></li><li><p>若新插入节点的爸爸是黑色节点，红黑树不需要调整</p></li><li><p>若新插入节点的爸爸和它叔叔都是红色节点，红黑树只需要变色，不需要旋转</p></li><li><p>若新插入节点的爸爸是红色，但是它叔叔是黑色（可能为null，但是null是叶子节点，正儿八经的黑色），这时，一定是变色+旋转</p></li></ol><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>第一步：将红黑树当作一颗二叉查找树，将节点删除。</p><p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况：</p><p>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。</p><p>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</p><p>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给</p><p>“该节点的内容”；之后，删除“它的后继节点”。</p><p>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</p><p>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><p>选择重着色 3 种情况。</p><p>① 情况说明：x 是“红+黑”节点。</p><p>处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。</p><p>② 情况说明：x 是“黑+黑”节点，且 x 是根。</p><p>处理方法：什么都不做，结束。此时红黑树性质全部恢复。</p><p>③ 情况说明：x 是“黑+黑”节点，且 x 不是根。</p><p>处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：</p><p>参考：<a href="https://www.jianshu.com/p/038585421b73">https://www.jianshu.com/p/038585421b73</a></p><p>代码实现：<a href="https://www.cnblogs.com/skywang12345/p/3624343.html">https://www.cnblogs.com/skywang12345/p/3624343.html</a></p><h1 id="B-TREE"><a href="#B-TREE" class="headerlink" title="B-TREE"></a>B-TREE</h1><p>B-tree 又叫平衡多路查找树。B-树，也称为B树，是一种平衡的多叉树。一棵 m 阶的 B-tree (m 叉树)的特性如下（其中 ceil(x)是一个取上限的函数）：</p><ol><li><p>树中每个结点至多有 m 个孩子；</p></li><li><p>除根结点和叶子结点外，其它每个结点至少有有 ceil(m &#x2F; 2)个孩子；</p></li><li><p>若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</p></li><li><p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为 null)；</p></li><li><p>每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：</p></li></ol><p>a) Ki (i&#x3D;1…n)为关键字，且关键字按顺序排序 K(i-1)&lt; Ki。</p><p>b) Pi 为指向子树根的接点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i1)。</p><p>c) 关键字的个数 n 必须满足： ceil(m &#x2F; 2)-1 &lt;&#x3D; n &lt;&#x3D; m-1。</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h1><p>B+树是B-树的变体，也是一颗多路搜索树。一棵m阶的B+树主要有这些特点：</p><p>1.每个结点至多有m个子女;</p><p>2.非根节点关键值个数范围：⌈m&#x2F;2⌉ - 1 &lt;&#x3D; k &lt;&#x3D; m-1</p><p>3.相邻叶子节点是通过指针连起来的，并且是关键字大小排序的。</p><h2 id="B-树和B-树的主要区别如下："><a href="#B-树和B-树的主要区别如下：" class="headerlink" title="B+树和B-树的主要区别如下："></a>B+树和B-树的主要区别如下：</h2><ul><li>B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。</li><li>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。</li><li>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束</li><li>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。</li></ul><h2 id="一棵-m-阶的-B-tree-和-m-阶的-B-tree-的差异在于："><a href="#一棵-m-阶的-B-tree-和-m-阶的-B-tree-的差异在于：" class="headerlink" title="一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于："></a>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于：</h2><p>1.有 n 棵子树的结点中含有 n 个关键字； (B-tree 是 n 棵子树有 n-1 个关键字)</p><p>2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息)</p><p>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(B-tree 的非终节点也包含需要查找的有效信息)</p><p>参考：<a href="https://www.jianshu.com/p/1ed61b4cca12">https://www.jianshu.com/p/1ed61b4cca12</a></p><h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>位图的原理就是用一个 bit 来标识一个数字是否存在，采用一个 bit 来存储一个数据，所以这样可以大大的节省空间。 bitmap 是很常用的数据结构，比如用于 Bloom Filter 中；用于无重复整数的排序等等。bitmap 通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素<br>组成更大的二进制集合。</p><p><a href="https://www.cnblogs.com/polly333/p/4760275.html">https://www.cnblogs.com/polly333/p/4760275.html</a></p><h1 id="布隆过滤器-4"><a href="#布隆过滤器-4" class="headerlink" title="布隆过滤器^4"></a>布隆过滤器<a href="https://developer.aliyun.com/article/773205">^4</a></h1><h1 id="跳表-5"><a href="#跳表-5" class="headerlink" title="跳表^5"></a>跳表<a href="https://cloud.tencent.com/developer/article/1769157">^5</a></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用数据结构&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Data Structure" scheme="http://yoursite.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（算法）</title>
    <link href="http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89/</id>
    <published>2022-01-07T10:12:12.000Z</published>
    <updated>2022-01-10T07:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>查找，排序，回溯等算法</p><span id="more"></span><p>[TOC]</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><p>二分法模板参见笔记：</p><ol start="69"><li>x 的平方根(二分法模板题及经典解释）</li></ol><h1 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h1><p>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。</p><p>（2）这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1 个位置。</p><p>（3）N&#x3D;N-1，如果 N 不为 0 就重复前面二步，否则排序完成</p><h1 id="选择排序算法-1"><a href="#选择排序算法-1" class="headerlink" title="选择排序算法^1"></a>选择排序算法<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">^1</a></h1><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><details>    <summary>选择排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SelectionSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        // 总共要经过 N-1 轮比较</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line"></span><br><span class="line">            // 每轮需要比较的次数 N-i</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    // 记录目前能找到的最小值元素的下标</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将找到的最小值和i位置所在的值进行交换</span><br><span class="line">            if (i != min) &#123;</span><br><span class="line">                int tmp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h1><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。</p><p>如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><details>    <summary>插入排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void sort(int arr[])&#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++)&#123;</span><br><span class="line">        //插入的数</span><br><span class="line">        int insertVal = arr[i];</span><br><span class="line">        //被插入的位置(准备和前一个数比较)</span><br><span class="line">        int index = i - 1;</span><br><span class="line">        //如果插入的数比被插入的数小</span><br><span class="line">        while (index &gt;= 0 &amp;&amp; insertVal &lt; arr[index]) &#123;</span><br><span class="line">            //将把 arr[index] 向后移动</span><br><span class="line">            arr[index + 1] = arr[index];</span><br><span class="line">            //让 index 向前移动</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        //把插入的数放入合适位置</span><br><span class="line">        arr[index + 1] = insertVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h1><p>快速排序的原理：</p><p>选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</p><p>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><p>此代码仅是快排的一种写法，更多需要搜索</p><details>    <summary>快速排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void sort(int[] a, int low, int high) &#123;</span><br><span class="line">       int start = low;</span><br><span class="line">       int end = high;</span><br><span class="line">       int key = a[low];</span><br><span class="line">       while (end &gt; start) &#123;</span><br><span class="line">           //从后往前比较</span><br><span class="line">           while (end &gt; start &amp;&amp; a[end] &gt;= key) &#123;</span><br><span class="line">               //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span><br><span class="line">               end--;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[end] &lt;= key) &#123;</span><br><span class="line">               int temp = a[end];</span><br><span class="line">               a[end] = a[start];</span><br><span class="line">               a[start] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           //从前往后比较</span><br><span class="line">           while (end &gt; start &amp;&amp; a[start] &lt;= key) &#123;</span><br><span class="line">               //如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span><br><span class="line">               start++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[start] &gt;= key) &#123;</span><br><span class="line">               int temp = a[start];</span><br><span class="line">               a[start] = a[end];</span><br><span class="line">               a[end] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，</span><br><span class="line">           // 右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span><br><span class="line">       &#125;</span><br><span class="line">       //递归</span><br><span class="line">       if (start &gt; low) sort(a, low, start - 1);//左边序列。第一个索引位置到关键值索引-1</span><br><span class="line">       if (end &lt; high) sort(a, end + 1, high);//右边序列。从关键值索引+1 到最后一个</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h1><p>基本思想：希尔排序，通过增量(gap)将元素分成n组，对每组使用直接插入排序算法排序。增量(gap)逐渐减少，当增量(gap)减至1时，整个数据恰被分成一组，最后进行一次插入排序。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><ol><li>操作方法：<br>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><details>    <summary>希尔排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void shellSort(int[] a) &#123;</span><br><span class="line">    int dk = a.length/2;</span><br><span class="line">    while( dk &gt;= 1 )&#123;</span><br><span class="line">        ShellInsertSort(a, dk);</span><br><span class="line">        dk = dk/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void ShellInsertSort(int[] a, int dk) &#123;</span><br><span class="line">    //类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了</span><br><span class="line">    for(int i=dk;i&lt;a.length;i++)&#123;</span><br><span class="line">        if(a[i]&lt;a[i-dk])&#123;</span><br><span class="line">            int j;</span><br><span class="line">            int x=a[i];//x 为待插入元素</span><br><span class="line">            a[i]=a[i-dk];</span><br><span class="line">            for(j=i-dk; j&gt;=0 &amp;&amp; x&lt;a[j];j=j-dk)&#123;</span><br><span class="line">                //通过循环，逐个后移一位找到要插入的位置。</span><br><span class="line">                a[j+dk]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+dk]=x;//插入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h1><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><details>    <summary>归并排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MergeSortTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] data = new int[]&#123;5, 3, 6, 2, 1, 9, 4, 8, 7&#125;;</span><br><span class="line">        print(data);</span><br><span class="line">        mergeSort(data);</span><br><span class="line">        System.out.println(&quot;排序后的数组：&quot;);</span><br><span class="line">        print(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void mergeSort(int[] data) &#123;</span><br><span class="line">        sort(data, 0, data.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] data, int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right)</span><br><span class="line">            return;</span><br><span class="line">        // 找出中间索引</span><br><span class="line">        int center = (left + right) / 2;</span><br><span class="line">        // 对左边数组进行递归</span><br><span class="line">        sort(data, left, center);</span><br><span class="line">        // 对右边数组进行递归</span><br><span class="line">        sort(data, center + 1, right);</span><br><span class="line">        // 合并</span><br><span class="line">        merge(data, left, center, right);</span><br><span class="line">        print(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将两个数组进行归并，归并前面 2 个数组已有序，归并后依然有序</span><br><span class="line">     *</span><br><span class="line">     * @param data   数组对象</span><br><span class="line">     * @param left   左数组的第一个元素的索引</span><br><span class="line">     * @param center 左数组的最后一个元素的索引，center+1 是右数组第一个元素的索引</span><br><span class="line">     * @param right  右数组最后一个元素的索引</span><br><span class="line">     */</span><br><span class="line">    public static void merge(int[] data, int left, int center, int right) &#123;</span><br><span class="line">        // 临时数组</span><br><span class="line">        int[] tmpArr = new int[data.length];</span><br><span class="line">        // 右数组第一个元素索引</span><br><span class="line">        int mid = center + 1;</span><br><span class="line">        // third 记录临时数组的索引</span><br><span class="line">        int third = left;</span><br><span class="line">        // 缓存左数组第一个元素的索引</span><br><span class="line">        int tmp = left;</span><br><span class="line">        while (left &lt;= center &amp;&amp; mid &lt;= right) &#123;</span><br><span class="line">            // 从两个数组中取出最小的放入临时数组</span><br><span class="line">            if (data[left] &lt;= data[mid]) &#123;</span><br><span class="line">                tmpArr[third++] = data[left++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmpArr[third++] = data[mid++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 剩余部分依次放入临时数组（实际上两个 while 只会执行其中一个）</span><br><span class="line">        while (mid &lt;= right) &#123;</span><br><span class="line">            tmpArr[third++] = data[mid++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (left &lt;= center) &#123;</span><br><span class="line">            tmpArr[third++] = data[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将临时数组中的内容拷贝回原数组中</span><br><span class="line">        // （原 left-right 范围的内容被复制回原数组）</span><br><span class="line">        while (tmp &lt;= right) &#123;</span><br><span class="line">            data[tmp] = tmpArr[tmp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print(int[] data) &#123;</span><br><span class="line">        for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            System.out.print(data[i] + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="桶排序算法"><a href="#桶排序算法" class="headerlink" title="桶排序算法"></a>桶排序算法</h1><p>桶排序的基本思想是： 把数组 arr 划分为 n 个大小相同子区间（桶），每个子区间各自排序，最后合并。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值 max、最小值 min</p><p>2.我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)&#x2F;arr.length+1</p><p>3.遍历数组 arr，计算每个元素 arr[i] 放的桶</p><p>4.每个桶各自排序</p><details>    <summary>桶排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建桶</span><br><span class="line">    int bucketNum = (max - min) / arr.length + 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i = 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    //将每个元素放入桶</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int num = (arr[i] - min) / (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //对每个桶进行排序</span><br><span class="line">    for(int i = 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p><p>大顶堆：arr[i] &gt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &gt;&#x3D; arr[2i+2]  </p><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p><p>小顶堆：arr[i] &lt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &lt;&#x3D; arr[2i+2]</p><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)</p><p>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><p>简单总结下堆排序的基本思路：</p><p>　　a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>　　b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p><p>　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p><details>    <summary>堆排序</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;7, 6, 7, 11, 5, 12, 3, 0, 1&#125;;</span><br><span class="line">        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] arr) &#123;</span><br><span class="line">        //1.构建大顶堆</span><br><span class="line">        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            //从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">        for (int j = arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">            swap(arr, 0, j);//将堆顶元素与末尾元素进行交换</span><br><span class="line">            adjustHeap(arr, 0, j);//重新对堆进行调整</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="line">     */</span><br><span class="line">    public static void adjustHeap(int[] arr, int i, int length) &#123;</span><br><span class="line">        int temp = arr[i];//先取出当前元素i</span><br><span class="line">        for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123;//从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;//如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[k] &gt; temp) &#123;//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;//将temp值放到最终的位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交换元素</span><br><span class="line">     */</span><br><span class="line">    public static void swap(int[] arr, int a, int b) &#123;</span><br><span class="line">        int temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h2 id="计数排序的特征"><a href="#计数排序的特征" class="headerlink" title="计数排序的特征"></a>计数排序的特征</h2><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p> 算法的步骤如下：</p><p>（1）找出待排序的数组中最大和最小的元素</p><p>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p><p>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p><p>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><details>    <summary>计数排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CountingSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        int maxValue = getMaxValue(arr);</span><br><span class="line"></span><br><span class="line">        return countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int[] countingSort(int[] arr, int maxValue) &#123;</span><br><span class="line">        int bucketLen = maxValue + 1;</span><br><span class="line">        int[] bucket = new int[bucketLen];</span><br><span class="line"></span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int sortedIndex = 0;</span><br><span class="line">        for (int j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            while (bucket[j] &gt; 0) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxValue(int[] arr) &#123;</span><br><span class="line">        int maxValue = arr[0];</span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            if (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="基数排序算法"><a href="#基数排序算法" class="headerlink" title="基数排序算法"></a>基数排序算法</h1><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><details>    <summary>基数排序算法</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static int[] RadixSort(int[] array) &#123;</span><br><span class="line">    if (array == null || array.length &lt; 2)</span><br><span class="line">        return array;</span><br><span class="line">    // 1.先算出最大数的位数；</span><br><span class="line">    int max = array[0];</span><br><span class="line">    for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //最大数的位数</span><br><span class="line">    int maxDigit = 0;</span><br><span class="line">    while (max != 0) &#123;</span><br><span class="line">        max /= 10;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    int mod = 10, div = 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        bucketList.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) &#123;</span><br><span class="line">        for (int j = 0; j &lt; array.length; j++) &#123;</span><br><span class="line">            int num = (array[j] % mod) / div;</span><br><span class="line">            bucketList.get(num).add(array[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int j = 0; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">            for (int k = 0; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                array[index++] = bucketList.get(j).get(k);</span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>**最佳情况：T(n) &#x3D; O(n * k) **</p><p>**最差情况：T(n) &#x3D; O(n * k) **</p><p>平均情况：T(n) &#x3D; O(n * k)</p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序</p><p>LSD 从低位开始进行排序</p><h2 id="与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题"><a href="#与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题" class="headerlink" title="与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题"></a>与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题</h2><p>从高位可以，但是麻烦</p><p>道理是基数排序每次都调用一个稳定排序，也就是说这一轮比不出大小的数据，保持原来的相对位置顺序不变。(这是稳定排序的定义，是性质，不是某种随意的文字描述) 而数字比较大小就是从高位开始，比不出大小去看低位，当然应该让低位先排出“原来的相对顺序”了。</p><p>从高位开始排，就要分段了，每排完一位，把分不出大小的几个当成一段，一段段的排，不要让排完的数据跨段移动，保证这一段的数都比下一段小，排到最后每段就只有一个数了。这样就完全没有利用到每次调用的都是稳定排序这一点</p><p>以 [111, 22, 3] 三个数从小排到大为例如果完全按照从低位开始排的写法，简单换成从高位开始排的话，每轮结果分别为：<br>第一轮：比较百位</p><p>百位为 0 的有 [22, 3]百位为 1 的有 [111]合并一下，本轮结果为 [22, 3, 111]</p><p>第二轮：比较十位 </p><p>十位为 0 的有 [3]十位为 1 的有 [111]十位为 2 的有 [22]合并一下，本轮结果为 [3, 111, 22]</p><p>第三轮：比较个位</p><p>个位为 1 的有 [111]个位为 2 的有 [22]个位为 3 的有 [3]合并一下，本轮结果为 [111, 22, 3]最终结果为 [111, 22, 3]，结果是完全错的错在哪儿了呢？</p><p>错在 个位的排序结果完全覆盖了百位的排序结果从例子里可以看到，排序轮数越靠后，相当于其权重越高，会覆盖之前的在从低位到高位的模式下，这个逻辑完全没问题，我们先按个位排序，再按十位排序，十位的排序结果会覆盖个位的排序结果，只有在两个数字十位相同的情况下，才会使用上一轮的个位排序而在从高位到低位的模式下，这个逻辑就完全行不通了，低位的排序结果覆盖高位的排序结果，这是不正确的为了解决这个问题，从高位排序的话，每轮要额外用一个数组，或是递归，来继承高位排序的结果，避免被低位覆盖</p><p>仍然以 [111, 22, 3] 为例</p><p>第一轮：比较百位</p><p>百位为 0 的有 [22, 3]百位为 1 的有 [111]合并一下，本轮结果为</p><pre><code>[   [22, 3],   [111]]</code></pre><p>注意，这一步不是把结果合并成一维数组 [22, 3, 111] 了，而是变成了二维数组，用来保证百位上的排序不被下一轮覆盖</p><p>第二轮：比较十位</p><p>由于数组变成了二维数组，这一轮要分别对数组里的子数组进行遍历对 [22, 3] 来说十位为 0 的有 [3]十位为 2 的有 [22]合并一下，结果为</p><pre><code>[   [3],   [22],]</code></pre><p>对 [111] 来说，本轮结果为</p><pre><code>[   [111]]</code></pre><p>合并一下，本轮结果总共为</p><pre><code>[   [      [3],      [22],   ],   [      [111]   ]]</code></pre><p>可以看到，现在又变成了三维数组，下一轮判断个位，又将变成四维所以说为什么高位麻烦，就是麻烦在递归这里。回到题目本身，从例子里可以看到，每轮遍历结果数组都是从前往后遍历，因此原始数据里 相同数据的相对顺序 是会被保留的，所以从高位排序其实也是稳定的。</p><h1 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h1><p>在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。</p><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><p>从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最短路径。解决最短路的问题有以下算法，Dijkstra 算法，Bellman-Ford 算法，Floyd 算法和 SPFA算法等。</p><h1 id="最大子数组算法"><a href="#最大子数组算法" class="headerlink" title="最大子数组算法"></a>最大子数组算法</h1><h1 id="最长公共子序算法"><a href="#最长公共子序算法" class="headerlink" title="最长公共子序算法"></a>最长公共子序算法</h1><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><p>现在假设有一个很实际的问题：我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要布置 n-1 一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？</p><p>于是我们就可以引入连通图来解决我们遇到的问题，n 个城市就是图上的 n 个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有 n 个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。</p><p>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST 性质（假设N&#x3D;(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果（u，v）是一条具有最小权值的边，其中 u 属于 U，v 属于 V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使<br>用 MST 性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;查找，排序，回溯等算法&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（YARN）</title>
    <link href="http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88YARN%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88YARN%EF%BC%89/</id>
    <published>2022-01-07T07:12:12.000Z</published>
    <updated>2022-01-07T07:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。</p><span id="more"></span><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。其中，ResourceManager 负责所有资源的监控、分配和管理； ApplicationMaster 负责每一个具体应用程序的调度和协调；NodeManager 负责每一个节点的维护。对于所有的 applications，RM 拥有绝对的控制权和对资源的分配权。而每个 AM 则会和 RM 协商资源，同时和 NodeManager 通信来执行和监控 task。 几个模块之间的关系如图所示。</p><h1 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h1><ol><li><p>ResourceManager 负责整个集群的资源管理和分配，是一个全局的资源管理系统。</p></li><li><p>NodeManager 以心跳的方式向 ResourceManager 汇报资源使用情况（目前主要是 CPU 和内存的使用情况）。RM 只接受 NM 的资源回报信息，对于具体的资源处理则交给 NM 自己处理。</p></li><li><p>YARN Scheduler 根据 application 的请求为其分配资源，不负责 application job 的监控、追踪、运行状态反馈、启动等工作。</p></li></ol><h1 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h1><ol><li><p>NodeManager 是每个节点上的资源和任务管理器，它是管理这台机器的代理，负责该节点程序的运行，以及该节点资源的管理和监控。YARN集群每个节点都运行一个NodeManager</p></li><li><p>NodeManager 定时向 ResourceManager 汇报本节点资源（CPU、内存）的使用情况和Container 的运行状态。当 ResourceManager 宕机时 NodeManager 自动连接 RM 备用节点。</p></li><li><p>NodeManager 接收并处理来自 ApplicationMaster 的 Container 启动、停止等各种请求。</p></li></ol><h1 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h1><p>用户提交的每个应用程序均包含一个 ApplicationMaster，它可以运行在 ResourceManager 以外的机器上。</p><ol><li>负责与 RM 调度器协商以获取资源（用 Container 表示）。</li><li>将得到的任务进一步分配给内部的任务(资源的二次分配)。</li><li>与 NM 通信以启动&#x2F;停止任务。</li><li>监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。</li><li>当前 YARN 自带了两个 ApplicationMaster 实现，一个是用于演示 AM 编写方法的实例程序DistributedShell，它可以申请一定数目的 Container 以并行运行一个 Shell 命令或者 Shell脚本；另一个是运行 MapReduce 应用程序的 AM—MRAppMaster。</li></ol><p>注：RM 只负责监控 AM，并在 AM 运行失败时候启动它。RM 不负责 AM 内部任务的容错，任务的容错由 AM 完成。 </p><h1 id="YARN-运行流程"><a href="#YARN-运行流程" class="headerlink" title="YARN 运行流程"></a>YARN 运行流程</h1><ol><li>client 向 RM 提交应用程序，其中包括启动该应用的 ApplicationMaster 的必须信息，例如ApplicationMaster 程序、启动 ApplicationMaster 的命令、用户程序等。</li><li>ResourceManager 启动一个 container 用于运行 ApplicationMaster。</li><li>启动中的ApplicationMaster向ResourceManager注册自己，启动成功后与RM保持心跳。</li><li>ApplicationMaster 向 ResourceManager 发送请求，申请相应数目的 container。</li><li>ResourceManager 返回 ApplicationMaster 的申请的 containers 信息。申请成功的container，由 ApplicationMaster 进行初始化。container 的启动信息初始化后，AM 与对应的 NodeManager 通信，要求 NM 启动 container。AM 与 NM 保持心跳，从而对 NM 上运行的任务进行监控和管理。</li><li>container 运行期间，ApplicationMaster 对 container 进行监控。container 通过 RPC 协议向对应的 AM 汇报自己的进度和状态等信息。</li><li>应用运行期间，client 直接与 AM 通信获取应用的状态、进度更新等信息。</li><li>应用运行结束后，ApplicationMaster 向 ResourceManager 注销自己，并允许属于它的container 被收回</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="YARN" scheme="http://yoursite.com/tags/YARN/"/>
    
  </entry>
  
</feed>
