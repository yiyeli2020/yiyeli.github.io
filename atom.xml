<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-09-25T02:26:49.776Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/09/25/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0(Catalan%20number)/"/>
    <id>http://yoursite.com/2022/09/25/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0(Catalan%20number)/</id>
    <published>2022-09-25T02:26:49.775Z</published>
    <updated>2022-09-25T02:26:49.776Z</updated>
    
    <content type="html"><![CDATA[<p>title: 卡特兰数(Catalan number)</p><p>date: 2022-09-19 17:05:12</p><p>categories: 2022年9月</p><p>tags: [Leetcode, Math]</p><hr><p>卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。<br>以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。</p><span id="more"></span><p>[TOC]</p><h1 id="卡特兰数（Catalan-number）-1"><a href="#卡特兰数（Catalan-number）-1" class="headerlink" title="卡特兰数（Catalan number） ^1"></a>卡特兰数（Catalan number） <a href="https://leetcode.cn/circle/article/lWYCzv/">^1</a></h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。<br>以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。</p><p>卡塔兰数的通项公式为</p><p>Cn&#x3D; C(2n, n)&#x2F;(n+1) &#x3D; (2n)!&#x2F;(n+1)!n!</p><p>令其为h(n)的话，满足<br>h(n)&#x3D;h(0)*h(n-1) + h(1)*h(n-2) + … + h(n-1)h(0)  (n&gt;&#x3D;2)</p><p>数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862，…</p><p>本文将会选取几个经典的卡特兰问题，难度先易后难，带领读者逐个击破解决，最后给出相关的解题模板。</p><h2 id="二、经典问题"><a href="#二、经典问题" class="headerlink" title="二、经典问题"></a>二、经典问题</h2><h3 id="2-1-进出栈序列"><a href="#2-1-进出栈序列" class="headerlink" title="2.1 进出栈序列"></a>2.1 进出栈序列</h3><p>这是一道最经典的入门级卡特兰数题目，如果能把这题看懂，相信后面的题目也能迎刃而解。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>n 个元素进栈序列为：1，2，3，4，…，n，则有多少种出栈序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们将进栈表示为 +1，出栈表示为 -1，则 1 3 2 的出栈序列可以表示为：+1 -1 +1 +1 -1 -1。</p><p>根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的所有前缀和必然大于等于 0，并且 +1 的数量等于 -1 的数量。</p><p>接下来让我们观察一下 n &#x3D; 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。</p><p>如果将第一个前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。</p><p>因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，<strong>对于 n  元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。</strong></p><p>如何证明这两种序列是一一对应的？</p><p>假设非法序列为 A，对应的序列为 B。每个 A 只有一个”第一个前缀和小于 0 的前缀”，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到”第一个前缀和大于 0 的前缀”，显然 B 也只能产生一个 A。</p><p>每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为C(2n, n+1)​ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 C(2n,n+1)</p><p>出栈序列的总数量共有C(2n,n) ​ ，因此，合法的出栈序列的数量为 C(2n,n)-C(2n,n+1) &#x3D; C(2n,n)&#x2F;(n+1)</p><p>此时我们就得到了卡特兰数的通项C(2n,n)&#x2F;(n+1) ，至于具体如何计算结果将会在后面进行介绍。</p><h3 id="2-2-括号序列"><a href="#2-2-括号序列" class="headerlink" title="2.2 括号序列"></a>2.2 括号序列</h3><p><strong>题目描述</strong></p><p>n 对括号，则有多少种 “括号匹配” 的括号序列</p><p><strong>思路</strong></p><p>左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，共有C(2n,n)&#x2F;(n+1) 种序列。</p><h3 id="2-3-二叉树"><a href="#2-3-二叉树" class="headerlink" title="2.3 二叉树"></a>2.3 二叉树</h3><p>题目描述</p><p>n + 1 个叶子节点能够构成多少种形状不同的（国际）满二叉树</p><p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是(2^k) -1 ，则它就是满二叉树。(一棵满二叉树的每一个结点要么是叶子结点，要么它有两个子结点，但是反过来不成立，因为完全二叉树也满足这个要求，但不是满二叉树)</p><p>国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.</p><p>大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>（国际）满二叉树定义：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>思路</p><p>使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。</p><p>由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。n + 1 个叶子结点会有 2n 次扩展，构成​<br>种形状不同的满二叉树。</p><h3 id="2-4-电影购票"><a href="#2-4-电影购票" class="headerlink" title="2.4 电影购票"></a>2.4 电影购票</h3><p>题目描述</p><p>电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。</p><p>则有多少种排队方式，可以让每个人都买到电影票。</p><p>思路</p><p>持有 50 coin 的人每次购票时不需要找零，并且可以帮助后面持有 100 coin 的人找零；而对于持有 100 coin 的人每次购票时需要找零，但 100 coin 对后面的找零没有任何作用。</p><p>因此，相当于每个持有 100 coin 的人都需要和一个持有 50 coin 的人进行匹配。我们将持有 50 coin 的标记为 +1，持有 100 coin 的标记为 -1，此时又回到了进出栈问题。</p><p>不同的是，m 并一定等于 n，且排队序列是一种排列，需要考虑先后顺序，例如各自持有 50 coin 的甲和乙的前后关系会造成两种不同的排队序列。所以，将会有(C(m+n, m)-C(m+n,m+1)) * m! * n!</p><p>第二项为什么是C(m+n,m+1)​ ，其实很简单，我们每次把第一个前缀小于0 的前缀取反后，会造成 +1 多了一个而 -1 少了一个。这里 +1 有 m 个，-1 有 n 个，取反后 +1 变成 m + 1 个，-1 变成 n - 1 个，总和不变。</p><h2 id="三、解题模板"><a href="#三、解题模板" class="headerlink" title="三、解题模板"></a>三、解题模板</h2><p>最后我们需要来计算一下卡特兰数的通项Cn &#x3D; C(2n,n)&#x2F;(n+1)</p><p>卡特兰数满足以下递推式：</p><p>C1 &#x3D; 1, Cn &#x3D; Cn-1(4*n-2)&#x2F;(n+1) ​ （证明从略）</p><p>因此，我们可以通过递推来得到第 n 个卡特兰数。</p><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="comment">// 打印前 n 个卡特兰数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;1:&quot;</span> + ans.toString());</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">four</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">4</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">one</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">two</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(i);</span><br><span class="line">ans = ans.multiply(four.multiply(bi).subtract(two)).divide(bi.add(one));</span><br><span class="line">System.out.println(i + <span class="string">&quot;:&quot;</span> + ans.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line"></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">ans = ans \* (<span class="number">4</span> \* i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>需要注意的是，由于卡特兰数增长速度较快，当 n 等于 17 时，卡特兰数将会超过 int 最大值，造成溢出（Python 除外）。对于 Java 语言来说，可以使用 BigInteger 来计算大整数。</p><p>那如果 +1 的数量不等于 -1 的数量呢，如前面提到的电影购票问题。此时<br>，不是卡特兰数的通项，也就不能够继续使用原有的递推性质。</p><p>那就推导新的公式，一般而言，为了降低难度，题目会要求我们计算排列数量An&#x3D;Cn * m! * n!&#x3D;(m+n)!*(m+1-n)&#x2F;(m+1)</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题。因此，只要我们能够学会进出栈问题的解法，无论问题再怎么变化，本质还是不变的。</p><p>卡特兰数问题中都会存在一种匹配关系，如进出栈匹配，括号匹配等，一旦计数问题中存在这种关系，那我们就需要去考虑这是否是卡特兰数问题。此外，我们还可以记住序列前四项：1, 1, 2, 5，这些将有利于我们联想到卡特兰数。1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,…</p><p>目前，LeetCode 已经出现一道卡特兰数问题 1259. 不相交的握手 <a href="https://leetcode-cn.com/problems/handshakes-that-dont-cross">^2</a>，这也是这篇文章编写的原因之一。同时，近年某巴巴，某讯的笔试题中也有出现过这类题目，无非将背景换成买烧饼，借书排队等，相信这些都难不倒读者。</p><h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><p>最后留一道比较有意思的卡特兰数问题，欢迎读者留言，提出自己的看法。</p><p>8 个高矮不同的人需要排成两队，每队 4 个人。其中，每排都是从低到高排列，且第二排的第 i 个人比第一排中第 i 个人高，则有多少种排队方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;title: 卡特兰数(Catalan number)&lt;/p&gt;
&lt;p&gt;date: 2022-09-19 17:05:12&lt;/p&gt;
&lt;p&gt;categories: 2022年9月&lt;/p&gt;
&lt;p&gt;tags: [Leetcode, Math]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。&lt;br&gt;以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/09/25/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2022/09/25/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-09-25T02:26:30.286Z</published>
    <updated>2022-09-25T02:26:30.287Z</updated>
    
    <content type="html"><![CDATA[<p>title: 110. 平衡二叉树</p><p>date: 2022-09-21 11:15:12</p><p>categories: 2022年9月</p><p>tags: [Leetcode, Tree, Depth-First Search, Binary Tree]</p><hr><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><span id="more"></span><p>[TOC]</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：true</code></pre><p>示例 2：</p><pre><code>输入：root = [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：true</code></pre><p>提示：</p><pre><code>树中的节点数在范围 [0, 5000] 内-104 &lt;= Node.val &lt;= 104</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode.cn/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/">^1</a></h1><p>这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。</p><h1 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h1><p>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：</p><p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过<br>1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.max(height(root.left), height(root.right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.max(height(root.left), height(root.right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isBalanced(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        def height(root: TreeNode) -&gt; int:</span><br><span class="line">            if not root:</span><br><span class="line">                return 0</span><br><span class="line">            return max(height(root.left), height(root.right)) + 1</span><br><span class="line"></span><br><span class="line">        if not root:</span><br><span class="line">            return True</span><br><span class="line">        return abs(height(root.left) - height(root.right)) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int height(struct TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return fmax(height(root-&gt;left), height(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isBalanced(struct TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return fabs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func isBalanced(root *TreeNode) bool &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return abs(height(root.Left) - height(root.Right)) &lt;= 1 &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func height(root *TreeNode) int &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    return max(height(root.Left), height(root.Right)) + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func abs(x int) int &#123;</span><br><span class="line">    if x &lt; 0 &#123;</span><br><span class="line">        return -1 * x</span><br><span class="line">    &#125;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。<br>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。<br>对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足<br>O(h)&#x3D;O(logn)，因为 d≤h，所以总时间复杂度为O(nlogn)。对于最坏的情况，二叉树形成链式结构，高度为O(n)，此时总时间复杂度为 </p><p>空间复杂度：<br>O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p><h1 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h1><p>方法一由于是自顶向下递归，因此对于同一个节点，函数<br>height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数<br>height 只会被调用一次。</p><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return height(root) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = height(root.left);</span><br><span class="line">        int rightHeight = height(root.right);</span><br><span class="line">        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Math.max(leftHeight, rightHeight) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int height(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = height(root-&gt;left);</span><br><span class="line">        int rightHeight = height(root-&gt;right);</span><br><span class="line">        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return max(leftHeight, rightHeight) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return height(root) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int height(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = height(root-&gt;left);</span><br><span class="line">        int rightHeight = height(root-&gt;right);</span><br><span class="line">        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return max(leftHeight, rightHeight) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return height(root) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int height(struct TreeNode* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int leftHeight = height(root-&gt;left);</span><br><span class="line">    int rightHeight = height(root-&gt;right);</span><br><span class="line">    if (leftHeight == -1 || rightHeight == -1 || fabs(leftHeight - rightHeight) &gt; 1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return fmax(leftHeight, rightHeight) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isBalanced(struct TreeNode* root) &#123;</span><br><span class="line">    return height(root) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func isBalanced(root *TreeNode) bool &#123;</span><br><span class="line">    return height(root) &gt;= 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func height(root *TreeNode) int &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    leftHeight := height(root.Left)</span><br><span class="line">    rightHeight := height(root.Right)</span><br><span class="line">    if leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1 &#123;</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">    return max(leftHeight, rightHeight) + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func abs(x int) int &#123;</span><br><span class="line">    if x &lt; 0 &#123;</span><br><span class="line">        return -1 * x</span><br><span class="line">    &#125;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中<br>n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是<br>O(n)。</p><p>空间复杂度：<br>O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;title: 110. 平衡二叉树&lt;/p&gt;
&lt;p&gt;date: 2022-09-21 11:15:12&lt;/p&gt;
&lt;p&gt;categories: 2022年9月&lt;/p&gt;
&lt;p&gt;tags: [Leetcode, Tree, Depth-First Search, Binary Tree]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>103. 二叉树的锯齿形层序遍历</title>
    <link href="http://yoursite.com/2022/09/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/09/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-09-23T07:39:12.000Z</published>
    <updated>2022-09-23T07:39:56.144Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]]</code></pre><p>示例 2：</p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>[TOC]</p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：广度优先遍历"><a href="#方法一：广度优先遍历" class="headerlink" title="方法一：广度优先遍历"></a>方法一：广度优先遍历</h2><p>此题是「102. 二叉树的层序遍历」的变种，最后输出的要求有所变化，要求我们按层数的奇偶来决定每一层的输出顺序。规定二叉树的根节点为第<br>0<br>0 层，如果当前层数是偶数，从左至右输出当前层的节点值，否则，从右至左输出当前层的节点值。</p><p>我们依然可以沿用第 102 题的思想，修改广度优先搜索，对树进行逐层遍历，用队列维护当前层的所有元素，当队列不为空的时候，求得当前队列的长度 size，每次从队列中取出 size 个元素进行拓展，然后进行下一次迭代。</p><p>为了满足题目要求的返回值为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用「双端队列」的数据结构来维护当前层节点值输出的顺序。</p><p>双端队列是一个可以在队列任意一端插入元素的队列。在广度优先搜索遍历当前层节点拓展下一层节点的时候我们仍然从左往右按顺序拓展，但是对当前层节点的存储我们维护一个变量 isOrderLeft 记录是从左至右还是从右至左的：</p><p>如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。<br>如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。<br>当遍历结束的时候我们就得到了答案数组。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        bool isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            deque&lt;int&gt; levelList;</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                auto node = nodeQueue.front();</span><br><span class="line">                nodeQueue.pop();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.push_back(node-&gt;val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.push_front(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;left) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right) &#123;</span><br><span class="line">                    nodeQueue.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(vector&lt;int&gt;&#123;levelList.begin(), levelList.end()&#125;);</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        boolean isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; levelList = new LinkedList&lt;Integer&gt;();</span><br><span class="line">            int size = nodeQueue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode curNode = nodeQueue.poll();</span><br><span class="line">                if (isOrderLeft) &#123;</span><br><span class="line">                    levelList.offerLast(curNode.val);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    levelList.offerFirst(curNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.left != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (curNode.right != null) &#123;</span><br><span class="line">                    nodeQueue.offer(curNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(new LinkedList&lt;Integer&gt;(levelList));</span><br><span class="line">            isOrderLeft = !isOrderLeft;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var zigzagLevelOrder = function(root) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ans = [];</span><br><span class="line">    const nodeQueue = [root];</span><br><span class="line"></span><br><span class="line">    let isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">    while (nodeQueue.length) &#123;</span><br><span class="line">        let levelList = [];</span><br><span class="line">        const size = nodeQueue.length;</span><br><span class="line">        for (let i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">            const node = nodeQueue.shift();</span><br><span class="line">            if (isOrderLeft) &#123;</span><br><span class="line">                levelList.push(node.val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                levelList.unshift(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left !== null) &#123;</span><br><span class="line">                nodeQueue.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right !== null) &#123;</span><br><span class="line">                nodeQueue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">        ans.push(levelList);</span><br><span class="line">        isOrderLeft = !isOrderLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func zigzagLevelOrder(root *TreeNode) (ans [][]int) &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    for level := 0; len(queue) &gt; 0; level++ &#123;</span><br><span class="line">        vals := []int&#123;&#125;</span><br><span class="line">        q := queue</span><br><span class="line">        queue = nil</span><br><span class="line">        for _, node := range q &#123;</span><br><span class="line">            vals = append(vals, node.Val)</span><br><span class="line">            if node.Left != nil &#123;</span><br><span class="line">                queue = append(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            if node.Right != nil &#123;</span><br><span class="line">                queue = append(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 本质上和层序遍历一样，我们只需要把奇数层的元素翻转即可</span><br><span class="line">        if level%2 == 1 &#123;</span><br><span class="line">            for i, n := 0, len(vals); i &lt; n/2; i++ &#123;</span><br><span class="line">                vals[i], vals[n-1-i] = vals[n-1-i], vals[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, vals)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#define N 2000</span><br><span class="line"></span><br><span class="line">int** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int** ans = malloc(sizeof(int*) * N);</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * N);</span><br><span class="line">    struct TreeNode* nodeQueue[N];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    nodeQueue[right++] = root;</span><br><span class="line">    bool isOrderLeft = true;</span><br><span class="line"></span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int levelList[N * 2];</span><br><span class="line">        int front = N, rear = N;</span><br><span class="line">        int size = right - left;</span><br><span class="line">        for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">            struct TreeNode* node = nodeQueue[left++];</span><br><span class="line">            if (isOrderLeft) &#123;</span><br><span class="line">                levelList[rear++] = node-&gt;val;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                levelList[--front] = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;left) &#123;</span><br><span class="line">                nodeQueue[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right) &#123;</span><br><span class="line">                nodeQueue[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * (rear - front));</span><br><span class="line">        for (int i = 0; i &lt; rear - front; i++) &#123;</span><br><span class="line">            tmp[i] = levelList[i + front];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[*returnSize] = tmp;</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = rear - front;</span><br><span class="line">        (*returnSize)++;</span><br><span class="line">        isOrderLeft = !isOrderLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(N)，其中 N 为二叉树的节点数。每个节点会且仅会被遍历一次。<br>空间复杂度：<br>O(N)。我们需要维护存储节点的队列和存储节点值的双端队列，空间复杂度为 O(N)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>1162. 地图分析</title>
    <link href="http://yoursite.com/2022/09/22/1162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2022/09/22/1162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</id>
    <published>2022-09-22T06:00:12.000Z</published>
    <updated>2022-09-22T09:21:31.231Z</updated>
    
    <content type="html"><![CDATA[<p>你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。</p><p>请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。</p><span id="more"></span><p>[TOC]</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>示例 1：</p><pre><code>输入：grid = [[1,0,1],[0,0,0],[1,0,1]]输出：2解释： 海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。</code></pre><p>示例 2：</p><pre><code>输入：grid = [[1,0,0],[0,0,0],[0,0,0]]输出：4解释： 海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。</code></pre><p>提示：</p><pre><code>n == grid.lengthn == grid[i].length1 &lt;= n &lt;= 100grid[i][j] 不是 0 就是 1</code></pre><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>「离陆地区域最远」要求海洋区域距离它最近的陆地区域的曼哈顿距离是最大的。所以我们需要找一个海洋区域，满足它到陆地的最小距离是最大的。</p><h1 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑最朴素的方法，即求出每一个海洋区域（grid[i][j] &#x3D;&#x3D; 0 的区域）的「最近陆地区域」，然后记录下它们的距离，然后在这些距离里面取一个最大值。<br>对于一个给定的区域 (x,y) ，求它的「最近陆地区域」，可以使用广度优先搜索思想。我们把每个区域的坐标作以及这个区域与 (x,y) 的曼哈顿距离为搜索状态，即 Coordinate 结构体的 x、y 和 step 属性。findNearestLand 方法实现了广度优先搜索的过程，我们用一个 vis[u][v] 数组记录 (u,v) 区域是否被访问过，在拓展新状态的时候按照如下四个方向：<br>(x−1,y)<br>(x,y+1)<br>(x+1,y)<br>(x,y−1)<br>在这里我们可以把四个方向定义为常量增量数组 dx 和 dy。</p><p>思考：我们需不需要搜索到队列为空才停止 BFS ？ 答案是不需要。当我们搜索到一个新入队的区域它的 grid 值为 1，即这个区域是陆地区域的时候我们就可以停止搜索，因为 BFS 能保证当前的这个区域是最近的陆地区域（BFS 的性质决定了这里求出来的一定是最短路）。</p><p>findNearestLand如果我们找不不到任何一个点是陆地区域则返回 -1。最终我们把 ans 的初始值置为 -1，然后与所有的 BFS 结果取最大。</p><p>代码实现如下。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y, step;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int n, m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    bool vis[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    int findNearestLand(int x, int y) &#123;</span><br><span class="line">        memset(vis, 0, sizeof vis);</span><br><span class="line">        queue &lt;Coordinate&gt; q;</span><br><span class="line">        q.push(&#123;x, y, 0&#125;);</span><br><span class="line">        vis[x][y] = 1;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= m - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!vis[nx][ny]) &#123;</span><br><span class="line">                    q.push(&#123;nx, ny, f.step + 1&#125;);</span><br><span class="line">                    vis[nx][ny] = 1;</span><br><span class="line">                    if (a[nx][ny]) &#123;</span><br><span class="line">                        return f.step + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        this-&gt;m = grid.at(0).size();</span><br><span class="line">        a = grid;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, findNearestLand(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">    static int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    int n;</span><br><span class="line">    int[][] grid;</span><br><span class="line"></span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        this.n = grid.length;</span><br><span class="line">        this.grid = grid;</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, findNearestLand(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int findNearestLand(int x, int y) &#123;</span><br><span class="line">        boolean[][] vis = new boolean[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;x, y, 0&#125;);</span><br><span class="line">        vis[x][y] = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!vis[nx][ny]) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;nx, ny, f[2] + 1&#125;);</span><br><span class="line">                    vis[nx][ny] = true;</span><br><span class="line">                    if (grid[nx][ny] == 1) &#123;</span><br><span class="line">                        return f[2] + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>我的另一种解法Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int max = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    max = Math.max(findNearestLand(i, j,grid), max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    public int findNearestLand(int x, int y, int[][] grid) &#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] vis=new int[n][n];</span><br><span class="line">        int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        int dis = 0;</span><br><span class="line">        Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;x, y&#125;);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            vis[x][y] = 2;</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                int[] index = queue.poll();</span><br><span class="line">                int prevX = index[0];</span><br><span class="line">                int prevY = index[1];</span><br><span class="line">                for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                    int nx = prevX + dirs[j][0];</span><br><span class="line">                    int ny = prevY + dirs[j][1];</span><br><span class="line">                    if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; vis[nx][ny] != 2) &#123;</span><br><span class="line">                        if (grid[nx][ny] == 1) &#123;</span><br><span class="line">                            dis++;</span><br><span class="line">                            return dis;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            vis[nx][ny] = 2;</span><br><span class="line">                            queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dis++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>## 复杂度分析<p>时间复杂度：该算法最多执行 n^2次 BFS，即我们考虑最坏情况所有的区域都是海洋，那么每一个区域都会进行 BFS。对于每一次 BFS，最坏的情况是找不到陆地区域，我们只能遍历完剩下的 n^2−1 个海洋区域，由于 vis 数组确保每个区域只被访问一次，所以单次 BFS 的渐进时间复杂度是 O(n^2)，程序的总的渐进时间复杂度是 O(n^4)。<br>空间复杂度：该算法使用了 vis 数组，渐进空间复杂度为 O(n^2)。</p><h1 id="方法二：多源最短路"><a href="#方法二：多源最短路" class="headerlink" title="方法二：多源最短路"></a>方法二：多源最短路</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实在方法一中我们已经发现我们 BFS 的过程是求最短路的过程，但是这里不是求某一个海洋区域到陆地区域的最短路，而是求所有的海洋区域到陆地区域这个「点集」的最短路。显然这不是一个「单源」最短路问题（SSSP）。在我们学习过的最短路算法中，求解 SSSP 问题的方法有 Dijkstra 算法和 SPFA算法，而求解任意两点之间的最短路一般使用 Floyd 算法。那我们在这里就应该使用 Floyd 算法吗？要考虑这个问题，我们需要分析一下这里使用 Floyd 算法的时间复杂度。我们知道在网格图中求最短路，每个区域（格子）相当于图中的顶点，而每个格子和上下左右四个格子的相邻关系相当于边，我们记顶点的个数为 V，Floyd 算法的时间复杂度为 O(V^3)，而这里 V&#x3D;n^2 ，所以<br>O(V^3)&#x3D;O(n^6)，显然是不现实的。</p><p>考虑 SSSP 是求一个源点到一个点集中所有点的最短路，而这个问题的本质是求某个点集到另一个点集中所有点的最短路，即「多源最短路」，我们只需要对 Dijkstra 算法或者 SPFA 算法稍作修改。这里以 Dijkstra 算法为例，我们知道堆优化的 Dijkstra 算法实际上是 BFS 的一个变形，把 BFS 中的队列变成了优先队列，在拓展新状态的时候加入了松弛操作。Dijkstra 的堆优化版本第一步是源点入队，我们只需要把它改成源点集合中的所有的点入队就可以实现求「多源最短路」。</p><p>思考：为什么？ 因为我们这样做相当于建立了一个超级源点 S，这个点与源点集中的<br>s0, s1,  ⋯s∣V∣<br>都有边，并且权都为 0。这样求源点集到目标点集的最短路就变成了求超级源点 S 到它们的最短路，于是又转化成了 SSSP 问题。</p><p>思考：海洋区域和陆地区域，应该哪一个作为源点集？ 也许你分析出「我们需要找一个海洋区域，满足它到陆地的最小距离是最大」会把海洋区域作为源点集。我们可以考虑后续的实现，我们知道 Dijkstra 中一个 d 数组用来维护当前源点集到其他点的最短路，而对于源点集中的任意一个点 s，d[s_x][s_y] &#x3D; 0，这很好理解，源点到源点的最短路就是 0。如果我们把海洋区域作为源点集、陆地区域作为目标点集，假设 t 是目标点集中的一个点，算法执行结束后 d[t_x][t_y] 就是海洋区域中的点到 t 的最短距离，但是我们却不知道哪些 t 是海洋区域的这些点的「最近陆地区域」，我们也不知道每个 s 距离它的「最近陆地区域」的曼哈顿距离。考虑我们把陆地区域作为源点集、海洋区域作为目标点集，目标点集中的点 t 对应的 d[t_x][t_y] 就是海洋区域 t 对应的距离它的「最近陆地区域」的曼哈顿距离，正是我们需要的，所以应该把陆地区域作为源点集。</p><h3 id="Dijkstra-版"><a href="#Dijkstra-版" class="headerlink" title="Dijkstra 版"></a>Dijkstra 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Status &#123;</span><br><span class="line">        int v, x, y;</span><br><span class="line">        bool operator &lt; (const Status &amp;rhs) const &#123;</span><br><span class="line">            return v &gt; rhs.v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;0, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.top(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (f.v + 1 &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f.v + 1;</span><br><span class="line">                    q.push(&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] status1, int[] status2) &#123;</span><br><span class="line">                return status1[0] - status2[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;0, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[1] + dx[i], ny = f[2] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (f[0] + 1 &lt; d[nx][ny]) &#123;</span><br><span class="line">                    d[nx][ny] = f[0] + 1;</span><br><span class="line">                    queue.offer(new int[]&#123;d[nx][ny], nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="多源-BFS-版"><a href="#多源-BFS-版" class="headerlink" title="多源 BFS 版"></a>多源 BFS 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    queue &lt;Coordinate&gt; q;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) continue;</span><br><span class="line">                if (d[nx][ny] &gt; d[f.x][f.y] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + 1;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f[0]][f[1]] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f[0]][f[1]] + 1;</span><br><span class="line">                    queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="SPFA-版"><a href="#SPFA-版" class="headerlink" title="SPFA 版"></a>SPFA 版</h3><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    static constexpr int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    int d[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    struct Coordinate &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    queue &lt;Coordinate&gt; q;</span><br><span class="line">    bool inq[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        auto &amp;a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    q.push(&#123;i, j&#125;);</span><br><span class="line">                    inq[i][j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto f = q.front(); q.pop(); inq[f.x][f.y] = 0;</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt;= n - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= n - 1)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f.x][f.y] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f.x][f.y] + 1;</span><br><span class="line">                    if (!inq[nx][ny]) &#123;</span><br><span class="line">                        q.push(&#123;nx, ny&#125;);</span><br><span class="line">                        inq[nx][ny] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (ans == INF) ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int[] dx = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">        int[] dy = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] d = new int[n][n];</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        boolean[][] inq = new boolean[n][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    d[i][j] = 0;</span><br><span class="line">                    queue.offer(new int[]&#123;i, j&#125;);</span><br><span class="line">                    inq[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] f = queue.poll();</span><br><span class="line">            inq[f[0]][f[1]] = false;</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                int nx = f[0] + dx[i], ny = f[1] + dy[i];</span><br><span class="line">                if (!(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (d[nx][ny] &gt; d[f[0]][f[1]] + 1) &#123;</span><br><span class="line">                    d[nx][ny] = d[f[0]][f[1]] + 1;</span><br><span class="line">                    if (!inq[nx][ny]) &#123;</span><br><span class="line">                        queue.offer(new int[]&#123;nx, ny&#125;);</span><br><span class="line">                        inq[nx][ny] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans == INF ? -1 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：考虑这里的「多源最短路」的本质还是「单源最短路」，因此就是 Dijkstra 算法堆优化版本的渐进时间复杂度 O(ElogV)，这里 E 为边的个数，约等于<br>4n^2&#x2F;2 ，V 为顶点个数，约等于 n^2 ，所以这里的渐进时间复杂度为<br>O(n^2 logn^2 )&#x3D;O(n^2 logn)；在多源 BFS 当中，由于每个点只能被访问一次，渐进时间复杂度为<br>O(V+E)&#x3D;O(n^2)；SPFA 算法的理论渐进上界是 O(VE)&#x3D;O(n^2)，但是由于这里的边权都为 1，于是它退化成了 BFS，渐进时间复杂度 O(n^2)。<br>空间复杂度：该算法使用了 d 数组，渐进空间复杂度为 O(n^2)</p><h1 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>考虑优化方法二中的「把陆地区域作为源点集、海洋区域作为目标点集，求最短路」的过程。我们知道对于每个海洋区域 (x,y)，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x,y) 为 (x,y) 距离最近的陆地区域的曼哈顿距离，则我们可以推出这样的转移方程：</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>f(x,y)&#x3D;{ 0, (x,y)island<br>        min{f(x−1,y),f(x,y−1)}+1,(x,y)isocean</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>f(x,y)&#x3D;{ 0,(x,y)island<br>        min{f(x+1,y),f(x,y+1)}+1, (x,y)isocean</p><p>我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 INF，做完两个阶段的动态规划后，我们在所有的不为零的 f[i][j] 中比一个最大值即可，如果最终比较出的最大值为 INF，就返回 -1。</p><p>思考：如果用 f(x,y) 记录左上方的 DP 结果，g(x,y) 记录右下方的DP结果可行吗？ 答案是不可行。因为考虑距离点 (x,y) 最近的点可能既不来自左上方，也不来自右下方，比如它来自右上方，这个时候，第二阶段我们就需要用到第一阶段的计算结果。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr int MAX_N = 100 + 5;</span><br><span class="line">    static constexpr int INF = int(1E6);</span><br><span class="line">    </span><br><span class="line">    int f[MAX_N][MAX_N];</span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        this-&gt;n = grid.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;&amp; a = grid;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (a[i][j] ? 0 : INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i - 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = n - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (a[i][j]) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i + 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = min(f[i][j], f[i][j + 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (!a[i][j]) &#123;</span><br><span class="line">                    ans = max(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans == INF) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDistance(int[][] grid) &#123;</span><br><span class="line">        final int INF = 1000000;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int[][] f = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = grid[i][j] == 1 ? 0 : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i - 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j - 1 &gt;= 0) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i][j - 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = n - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i + 1][j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                if (j + 1 &lt; n) &#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i][j + 1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 0) &#123;</span><br><span class="line">                    ans = Math.max(ans, f[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ans == INF) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：从代码不难看出，这个算法的过程就是四个双重 for 循环，渐进时间复杂度为 O(n^2)。<br>空间复杂度：该算法使用了 f 数组，渐进空间复杂度为 O(n^2)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。&lt;/p&gt;
&lt;p&gt;请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="http://yoursite.com/2022/09/22/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/09/22/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-09-22T03:39:12.000Z</published>
    <updated>2022-09-22T05:55:54.531Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p>示例 2：</p><pre><code>输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code>输入：root = []输出：[]</code></pre><p>提示：</p><pre><code>树中节点数目在范围 [0, 2000] 内-1000 &lt;= Node.val &lt;= 1000</code></pre><p>[TOC]</p><h1 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路^1"></a>解题思路<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/">^1</a></h1><p>本文将会讲解为什么这道题适合用广度优先搜索（BFS），以及 BFS 适用于什么样的场景。</p><p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p><p>如果我们使用 DFS&#x2F;BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。</p><p>本文包括以下内容：</p><p>DFS 与 BFS 的特点比较<br>BFS 的适用场景<br>如何用 BFS 进行层序遍历<br>如何用 BFS 求解最短路径问题</p><h1 id="DFS-与-BFS"><a href="#DFS-与-BFS" class="headerlink" title="DFS 与 BFS"></a>DFS 与 BFS</h1><p>让我们先看看在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。</p><p>DFS 遍历使用递归：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void dfs(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void bfs(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()</span><br><span class="line">        if (node.left != null) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right != null) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。<p>虽然 DFS 与 BFS 都是将二叉树的所有结点遍历了一遍，但它们遍历结点的顺序不同。</p><p>这个遍历顺序也是 BFS 能够用来解「层序遍历」、「最短路径」问题的根本原因。下面，我们结合几道例题来讲讲 BFS 是如何求解层序遍历和最短路径问题的。</p><p>BFS 的应用一：层序遍历</p><p>BFS 的层序遍历应用就是本题了：</p><p>LeetCode 102. Binary Tree Level Order Traversal 二叉树的层序遍历（Medium）</p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：<br>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。<br>那么，怎么给 BFS 遍历的结果分层呢？我们首先来观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：</p><p>截取 BFS 遍历过程中的某个时刻：</p><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的n 个结点。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 二叉树的层序遍历</span><br><span class="line">void bfs(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            // 变量 i 无实际意义，只是为了循环 n 次</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。<p>最终我们得到的题解代码为：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="BFS-的应用二：最短路径"><a href="#BFS-的应用二：最短路径" class="headerlink" title="BFS 的应用二：最短路径"></a>BFS 的应用二：最短路径</h1><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><h2 id="小贴士："><a href="#小贴士：" class="headerlink" title="小贴士："></a>小贴士：</h2><p>很多同学一看到「最短路径」，就条件反射地想到「Dijkstra 算法」。为什么 BFS 遍历也能找到最短路径呢？</p><p>这是因为，Dijkstra 算法解决的是带权最短路径问题，而我们这里关注的是无权最短路径问题。也可以看成每条边的权重都是 1。这样的最短路径问题，用 BFS 求解就行了。</p><p>在面试中，你可能更希望写 BFS 而不是 Dijkstra。毕竟，敢保证自己能写对 Dijkstra 算法的人不多。</p><p>最短路径问题属于图算法。由于图的表示和描述比较复杂，本文用比较简单的网格结构代替。网格结构是一种特殊的图，它的表示和遍历都比较简单，适合作为练习题。在 LeetCode 中，最短路径问题也以网格结构为主。</p><h1 id="最短路径例题讲解"><a href="#最短路径例题讲解" class="headerlink" title="最短路径例题讲解"></a>最短路径例题讲解</h1><p>LeetCode 1162. As Far from Land as Possible 离开陆地的最远距离（Medium）<a href="https://leetcode.cn/problems/as-far-from-land-as-possible/">^2</a></p><p>你现在手里有一份大小为 n×n 的地图网格 grid，上面的每个单元格都标记为 0 或者 1，其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」。(x0 ,y0 ) 和 (x1,y1)这两个区域之间的距离是 ∣x0−x1∣+∣y0−y1∣ 。</p><p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p><p>这道题就是一个在网格结构中求最短路径的问题。同时，它也是一个「岛屿问题」，即用网格中的 1 和 0 表示陆地和海洋，模拟出若干个岛屿。</p><p>在上一篇文章中，我们介绍了网格结构的基本概念，以及网格结构中的 DFS 遍历。其中一些概念和技巧也可以用在 BFS 遍历中：</p><p>格子 (r, c) 的相邻四个格子为：(r-1, c)、(r+1, c)、(r, c-1) 和 (r, c+1)；<br>使用函数 inArea 判断当前格子的坐标是否在网格范围内；<br>将遍历过的格子标记为 2，避免重复遍历。<br>对于网格结构的性质、网格结构的 DFS 遍历技巧不是很了解的同学，可以复习一下上一篇文章：LeetCode 例题精讲 | 12 岛屿问题：网格结构中的 DFS。</p><p>上一篇文章讲过了网格结构 DFS 遍历，这篇文章正好讲解一下网格结构的 BFS 遍历。要解最短路径问题，我们首先要写出层序遍历的代码，仿照上面的二叉树层序遍历代码，类似地可以写出网格层序遍历：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 网格结构的层序遍历</span><br><span class="line">// 从格子 (i, j) 开始遍历</span><br><span class="line">void bfs(int[][] grid, int i, int j) &#123;</span><br><span class="line">    Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(new int[]&#123;r, c&#125;);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            int[] node = queue.poll();</span><br><span class="line">            int r = node[0];</span><br><span class="line">            int c = node[1];</span><br><span class="line">            if (r-1 &gt;= 0 &amp;&amp; grid[r-1][c] == 0) &#123;</span><br><span class="line">                grid[r-1][c] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r-1, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (r+1 &lt; N &amp;&amp; grid[r+1][c] == 0) &#123;</span><br><span class="line">                grid[r+1][c] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r+1, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (c-1 &gt;= 0 &amp;&amp; grid[r][c-1] == 0) &#123;</span><br><span class="line">                grid[r][c-1] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r, c-1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (c+1 &lt; N &amp;&amp; grid[r][c+1] == 0) &#123;</span><br><span class="line">                grid[r][c+1] = 2;</span><br><span class="line">                queue.add(new int[]&#123;r, c+1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>以上的层序遍历代码有几个注意点：</p><p>队列中的元素类型是 int[] 数组，每个数组的长度为 2，包含格子的行坐标和列坐标。<br>为了避免重复遍历，这里使用到了和 DFS 遍历一样的技巧：把已遍历的格子标记为 2。注意：我们在将格子放入队列之前就将其标记为 2。想一想，这是为什么？<br>在将格子放入队列之前就检查其坐标是否在网格范围内，避免将「不存在」的格子放入队列。<br>这段网格遍历代码还有一些可以优化的地方。由于一个格子有四个相邻的格子，代码中判断了四遍格子坐标的合法性，代码稍微有点啰嗦。我们可以用一个 moves 数组存储相邻格子的四个方向：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">int[][] moves = &#123;</span><br><span class="line">    &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>然后把四个 if 判断变成一个循环：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int[][] move : moves) &#123;</span><br><span class="line">    int r2 = r + move[0];</span><br><span class="line">    int c2 = c + move[1];</span><br><span class="line">    if (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == 0) &#123;</span><br><span class="line">        grid[r2][c2] = 2;</span><br><span class="line">        queue.add(new int[]&#123;r2, c2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>写好了层序遍历的代码，接下来我们看看如何来解决本题中的最短路径问题。</p><p>这道题要找的是距离陆地最远的海洋格子。假设网格中只有一个陆地格子，我们可以从这个陆地格子出发做层序遍历，直到所有格子都遍历完。最终遍历了几层，海洋格子的最远距离就是几。<br>那么有多个陆地格子的时候怎么办呢？一种方法是将每个陆地格子都作为起点做一次层序遍历，但是这样的时间开销太大。</p><p>BFS 完全可以以多个格子同时作为起点。我们可以把所有的陆地格子同时放入初始队列，然后开始层序遍历，这样遍历的效果如下图所示：<br>这种遍历方法实际上叫做「多源 BFS」。多源 BFS 的定义不是今天讨论的重点，你只需要记住多源 BFS 很方便，只需要把多个源点同时放入初始队列即可。</p><p>需要注意的是，虽然上面的图示用 1、2、3、4 表示层序遍历的层数，但是在代码中，我们不需要给每个遍历到的格子标记层数，只需要用一个 distance 变量记录当前的遍历的层数（也就是到陆地格子的距离）即可。</p><p>最终，我们得到的题解代码为：</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public int maxDistance(int[][] grid) &#123;</span><br><span class="line">    int N = grid.length;</span><br><span class="line"></span><br><span class="line">    Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    // 将所有的陆地格子加入队列</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                queue.add(new int[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果地图上只有陆地或者海洋，返回 -1</span><br><span class="line">    if (queue.isEmpty() || queue.size() == N * N) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[][] moves = &#123;</span><br><span class="line">        &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int distance = -1; // 记录当前遍历的层数（距离）</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        distance++;</span><br><span class="line">        int n = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            int[] node = queue.poll();</span><br><span class="line">            int r = node[0];</span><br><span class="line">            int c = node[1];</span><br><span class="line">            for (int[] move : moves) &#123;</span><br><span class="line">                int r2 = r + move[0];</span><br><span class="line">                int c2 = c + move[1];</span><br><span class="line">                if (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == 0) &#123;</span><br><span class="line">                    grid[r2][c2] = 2;</span><br><span class="line">                    queue.add(new int[]&#123;r2, c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断坐标 (r, c) 是否在网格中</span><br><span class="line">boolean inArea(int[][] grid, int r, int c) &#123;</span><br><span class="line">    return 0 &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].length;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到，「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。</p><p>BFS 遍历是一类很值得反复体会和练习的题目。一方面，BFS 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 BFS 遍历。</p><p>本文讲解的只是两道非常典型的例题。LeetCode 中还有许多层序遍历和最短路径的题目</p><p>层序遍历的一些变种题目：</p><p>LeetCode 103. Binary Tree Zigzag Level Order Traversal 之字形层序遍历<br>LeetCode 199. Binary Tree Right Side View 找每一层的最右结点<br>LeetCode 515. Find Largest Value in Each Tree Row 计算每一层的最大值<br>LeetCode 637. Average of Levels in Binary Tree 计算每一层的平均值</p><p>对于最短路径问题，还有两道题目也是求网格结构中的最短路径，和我们讲解的距离岛屿的最远距离非常类似：</p><p>LeetCode 542. 01 Matrix<br>LeetCode 994. Rotting Oranges<br>还有一道在真正的图结构中求最短路径的问题：</p><p>LeetCode 310. Minimum Height Trees<br>经过了本文的讲解，相信解决这些题目也不是难事。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2022/09/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98%E7%BB%83%E4%B9%A0/</id>
    <published>2022-09-21T03:10:39.647Z</published>
    <updated>2022-09-21T03:10:39.647Z</updated>
    
    <content type="html"><![CDATA[<p>title: 滑动窗口专题练习</p><p>date: 2022-09-21 11:15:12</p><p>categories: 2022年9月</p><p>tags: [Leetcode, Sliding Window]</p><hr><p>滑动窗口专题及模板</p><p>[TOC]</p><p>从 3. 无重复字符的最长子串 开始滑动窗口专题：</p><p>这道题主要用到思路是：滑动窗口 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/">^1</a></p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：O(n)</p><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        if not s:return 0</span><br><span class="line">        left = 0</span><br><span class="line">        lookup = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = 0</span><br><span class="line">        cur_len = 0</span><br><span class="line">        for i in range(n):</span><br><span class="line">            cur_len += 1</span><br><span class="line">            while s[i] in lookup:</span><br><span class="line">                lookup.remove(s[left])</span><br><span class="line">                left += 1</span><br><span class="line">                cur_len -= 1</span><br><span class="line">            if cur_len &gt; max_len:max_len = cur_len</span><br><span class="line">            lookup.add(s[i])</span><br><span class="line">        return max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if (s.length()==0) return 0;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        int max = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        if(s.size() == 0) return 0;</span><br><span class="line">        unordered_set&lt;char&gt; lookup;</span><br><span class="line">        int maxStr = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            while (lookup.find(s[i]) != lookup.end())&#123;</span><br><span class="line">                lookup.erase(s[left]);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxStr = max(maxStr,i-left+1);</span><br><span class="line">            lookup.insert(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        return maxStr;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>滑动窗口题目:</p><ol start="3"><li><p>无重复字符的最长子串</p></li><li><p>串联所有单词的子串</p></li><li><p>最小覆盖子串 <a href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></p></li><li><p>至多包含两个不同字符的最长子串</p></li><li><p>长度最小的子数组</p></li><li><p>滑动窗口最大值</p></li><li><p>字符串的排列</p></li><li><p>最小区间</p></li><li><p>最小窗口子序列</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 滑动窗口专题练习&lt;/p&gt;
&lt;p&gt;date: 2022-09-21 11:15:12&lt;/p&gt;
&lt;p&gt;categories: 2022年9月&lt;/p&gt;
&lt;p&gt;tags: [Leetcode, Sliding Window]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;滑动窗口专题及模板</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/09/21/256.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <id>http://yoursite.com/2022/09/21/256.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</id>
    <published>2022-09-21T02:53:44.947Z</published>
    <updated>2022-09-21T02:53:44.947Z</updated>
    
    <content type="html"><![CDATA[<p>title: 256. 粉刷房子</p><p>date: 2022-09-20 15:15:12</p><p>categories: 2022年9月</p><p>tags: [Leetcode, Dynamic Programming]</p><hr><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其与相邻的两个房子颜色不能相同。</p><p>[TOC]</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p><p>注意：<br>所有花费均为正整数。</p><p>示例：<br>输入: [[17,2,17],[16,16,5],[14,3,19]]<br>输出: 10<br>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>最少花费: 2 + 5 + 3 &#x3D; 10。</p><p>参考<a href="https://codetop.cc/home">^1</a>是字节跳动商业变现是最近的高频题</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>初始态</p><pre><code>red[0] = costs[0][0]blue[0] = costs[0][0]green[0] = costs[0][0]</code></pre><p>过程</p><pre><code>red[i] = Min(blue[i-1], green[i-1]) + costs[i][0]blue[i] = Min(red[i-1], green[i-1]) + costs[i][1]green[i] = Min(red[i-1], blue[i-1]) + costs[i][2]</code></pre><p>结果：</p><pre><code>result = Min(red[n-1], blue[n-1], green[n-1])</code></pre><p>时间复杂度为O(n).</p><p>dp[i][c] 表示刷完 i 房子后，i 房子是 c 颜色时，花费最小多少</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;</span><br><span class="line">    int n = costs.size(), house, color;</span><br><span class="line">        if(n==0) return 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(3,INT_MAX));</span><br><span class="line">    dp[0] = costs[0];</span><br><span class="line">    for(house = 1; house &lt; n; house++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(color = 0; color &lt; 3; ++color)</span><br><span class="line">    &#123;</span><br><span class="line">    dp[house][color] = min(dp[house][color], costs[house][color]+min(dp[house-1][(color+1)%3], dp[house-1][(color+2)%3]));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 256. 粉刷房子&lt;/p&gt;
&lt;p&gt;date: 2022-09-20 15:15:12&lt;/p&gt;
&lt;p&gt;categories: 2022年9月&lt;/p&gt;
&lt;p&gt;tags: [Leetcode, Dynamic Programming]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;假如有</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/09/21/1259.%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E6%8F%A1%E6%89%8B/"/>
    <id>http://yoursite.com/2022/09/21/1259.%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E6%8F%A1%E6%89%8B/</id>
    <published>2022-09-21T02:53:38.025Z</published>
    <updated>2022-09-21T02:53:38.025Z</updated>
    
    <content type="html"><![CDATA[<p>title: 1259. 不相交的握手</p><p>date: 2022-09-15 11:15:12</p><p>categories: 2022年9月</p><p>tags: [Leetcode, Math]</p><hr><p>偶数 个人站成一个圆，总人数为 n 。每个人与除自己外的一个人握手，所以总共会有 n &#x2F; 2 次握手。</p><p>将握手的人之间连线，请你返回连线不会相交的握手方案数。</p><p>[TOC]</p><p>由于结果可能会很大，请你返回答案 模 10^9+7 后的结果<a href="https://leetcode-cn.com/problems/handshakes-that-dont-cross">^2</a></p><p>示例 1：</p><pre><code>输入：num_people = 2输出：1    </code></pre><p>示例 2：</p><pre><code>输入：num_people = 4输出：2 解释：总共有两种方案，第一种方案是 [(1,2),(3,4)] ，第二种方案是 [(2,3),(4,1)] 。</code></pre><p>示例 3：</p><pre><code>输入：num_people = 6输出：5</code></pre><p>示例 4：</p><pre><code>输入：num_people = 8输出：14</code></pre><p>提示：<br>2 &lt;&#x3D; num_people &lt;&#x3D; 1000<br>num_people % 2 &#x3D;&#x3D; 0</p><p>本题是一道字节跳动的面试题</p><h1 id="递归-3"><a href="#递归-3" class="headerlink" title="递归^3"></a>递归<a href="https://blog.csdn.net/qq_32424059/article/details/103105435">^3</a></h1><p>当第一个人和第 i 个人握手了之后，剩下的人被分割成了两个部分：</p><ol><li><p>i - 2， 即前 i 个人去掉 第一个人和 第 i 个人。</p></li><li><p>num_people - i， 总人数去掉前 i 个人。</p></li></ol><p>现在这两部分是和原问题种类相同，但规模更小的问题，因此可以采用递归求解。</p><p>递归的问题在于，重复计算非常多，因此效率很低，当输入等于24的时候就会超时。</p><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, num_people</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num_people: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num_people:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num_people + <span class="number">1</span>):</span><br><span class="line">            res += self.numberOfWays(i - <span class="number">2</span>) * self.numberOfWays(num_people - i)</span><br><span class="line">        <span class="keyword">return</span> res % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>观察一下前四项可以发现， 1， 2， 5， 14，</p><p>这就是熟悉的卡特兰数，直接套公式：Cn&#x3D; C(2n, n)&#x2F;(n+1) &#x3D; (2n)!&#x2F;(n+1)!n!</p><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> factorial <span class="keyword">as</span> fac</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, num_people</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num_people: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">catalan</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">return</span> fac(<span class="number">2</span>*n) // (fac(n+<span class="number">1</span>) * fac(n))</span><br><span class="line">        <span class="keyword">return</span> catalan(num_people // <span class="number">2</span>) % ( <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>时间复杂度： O((2n)!)，不过因为factorial是用c实现的，所以飞快</p><p>空间复杂度：O（1）</p><h1 id="动态规划解法1"><a href="#动态规划解法1" class="headerlink" title="动态规划解法1"></a>动态规划解法1</h1><p>用dp[i] 代表输入为 i 时的解，</p><p>根据之前的分析， dp[i] &#x3D; sum(dp[j - 2] * dp[i - j] for j in range(2, i + 1, 2))</p><p>时间复杂度：O(N ^ 2)</p><p>空间复杂度：O(N)</p><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, num_people</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num_people: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_people + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_people + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, i + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                dp[i] += (dp[j - <span class="number">2</span>] * dp[i - j]) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[num_people] % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="动态规划2-4"><a href="#动态规划2-4" class="headerlink" title="动态规划2^4"></a><a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&spm=1001.2101.3001.7020">动态规划2</a><a href="https://blog.csdn.net/yu_duan_hun/article/details/125948450">^4</a></h1><ol><li>假设有 x 个人，我们从中任选了一个人 a,这个 a和一个人握手，要保证后续有解，则分割出的两部分必须都为偶数</li><li>a 握手以后，还剩下，x-2个人没握手，x 握手以后，把剩余人员通过握手的连线分割为两部分，假设其中一个部分为 y 个人，则剩余部分为 x-2-y 个人</li><li>这个 y 人握手问题，就化解为了 x 人握手的子问题，枚举 所有可行的 y 和 x-2-y 握手可能性，两者互不干涉，可相乘处理</li></ol><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>由于都是偶数，我们只关心有多少对握手，可将空间范围缩减为 n&#x2F;2</li><li>一边分割为 y 人，一边分割为 x-2-y 人，与反过来的结果是相同的，那么对于两边数目不同的情况，可以乘以2，从而减少一半循环次数，特别注意的是，当 y&#x3D;x-2-y时，只有一种可能性，</li></ol><details>    <summary></summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfWays</span><span class="params">(<span class="type">int</span> numPeople)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> numPeople/<span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[half+<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>) (<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= half; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i-j-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                    dp[i]+=dp[j]*dp[i-j-<span class="number">1</span>]*<span class="number">2</span>;</span><br><span class="line">                    dp[i] = dp[i]%MOD;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]+=dp[i/<span class="number">2</span>]*dp[i-i/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">                    dp[i] = dp[i]%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) dp[half];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="卡特兰数（Catalan-number）-1"><a href="#卡特兰数（Catalan-number）-1" class="headerlink" title="卡特兰数（Catalan number） ^1"></a>卡特兰数（Catalan number） <a href="https://leetcode.cn/circle/article/lWYCzv/">^1</a></h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。<br>以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名。</p><p>卡塔兰数的通项公式为</p><p>Cn&#x3D; C(2n, n)&#x2F;(n+1) &#x3D; (2n)!&#x2F;(n+1)!n!</p><p>令其为h(n)的话，满足<br>h(n)&#x3D;h(0)*h(n-1) + h(1)*h(n-2) + … + h(n-1)h(0)  (n&gt;&#x3D;2)</p><p>数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862，…</p><p>本文将会选取几个经典的卡特兰问题，难度先易后难，带领读者逐个击破解决，最后给出相关的解题模板。</p><h2 id="二、经典问题"><a href="#二、经典问题" class="headerlink" title="二、经典问题"></a>二、经典问题</h2><h3 id="2-1-进出栈序列"><a href="#2-1-进出栈序列" class="headerlink" title="2.1 进出栈序列"></a>2.1 进出栈序列</h3><p>这是一道最经典的入门级卡特兰数题目，如果能把这题看懂，相信后面的题目也能迎刃而解。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>n 个元素进栈序列为：1，2，3，4，…，n，则有多少种出栈序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们将进栈表示为 +1，出栈表示为 -1，则 1 3 2 的出栈序列可以表示为：+1 -1 +1 +1 -1 -1。</p><p>根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的所有前缀和必然大于等于 0，并且 +1 的数量等于 -1 的数量。</p><p>接下来让我们观察一下 n &#x3D; 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。</p><p>如果将第一个前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。</p><p>因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，<strong>对于 n  元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。</strong></p><p>如何证明这两种序列是一一对应的？</p><p>假设非法序列为 A，对应的序列为 B。每个 A 只有一个”第一个前缀和小于 0 的前缀”，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到”第一个前缀和大于 0 的前缀”，显然 B 也只能产生一个 A。</p><p>每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为C(2n, n+1)​ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 C(2n,n+1)</p><p>出栈序列的总数量共有C(2n,n) ​ ，因此，合法的出栈序列的数量为 C(2n,n)-C(2n,n+1) &#x3D; C(2n,n)&#x2F;(n+1)</p><p>此时我们就得到了卡特兰数的通项C(2n,n)&#x2F;(n+1) ，至于具体如何计算结果将会在后面进行介绍。</p><h3 id="2-2-括号序列"><a href="#2-2-括号序列" class="headerlink" title="2.2 括号序列"></a>2.2 括号序列</h3><p><strong>题目描述</strong></p><p>n 对括号，则有多少种 “括号匹配” 的括号序列</p><p><strong>思路</strong></p><p>左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，共有C(2n,n)&#x2F;(n+1) 种序列。</p><h3 id="2-3-二叉树"><a href="#2-3-二叉树" class="headerlink" title="2.3 二叉树"></a>2.3 二叉树</h3><p>题目描述</p><p>n + 1 个叶子节点能够构成多少种形状不同的（国际）满二叉树</p><p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是(2^k) -1 ，则它就是满二叉树。(一棵满二叉树的每一个结点要么是叶子结点，要么它有两个子结点，但是反过来不成立，因为完全二叉树也满足这个要求，但不是满二叉树)</p><p>国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.</p><p>大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>（国际）满二叉树定义：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。</p><p>思路</p><p>使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。</p><p>由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。n + 1 个叶子结点会有 2n 次扩展，构成​<br>种形状不同的满二叉树。</p><h3 id="2-4-电影购票"><a href="#2-4-电影购票" class="headerlink" title="2.4 电影购票"></a>2.4 电影购票</h3><p>题目描述</p><p>电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。</p><p>则有多少种排队方式，可以让每个人都买到电影票。</p><p>思路</p><p>持有 50 coin 的人每次购票时不需要找零，并且可以帮助后面持有 100 coin 的人找零；而对于持有 100 coin 的人每次购票时需要找零，但 100 coin 对后面的找零没有任何作用。</p><p>因此，相当于每个持有 100 coin 的人都需要和一个持有 50 coin 的人进行匹配。我们将持有 50 coin 的标记为 +1，持有 100 coin 的标记为 -1，此时又回到了进出栈问题。</p><p>不同的是，m 并一定等于 n，且排队序列是一种排列，需要考虑先后顺序，例如各自持有 50 coin 的甲和乙的前后关系会造成两种不同的排队序列。所以，将会有(C(m+n, m)-C(m+n,m+1)) * m! * n!</p><p>第二项为什么是C(m+n,m+1)​ ，其实很简单，我们每次把第一个前缀小于0 的前缀取反后，会造成 +1 多了一个而 -1 少了一个。这里 +1 有 m 个，-1 有 n 个，取反后 +1 变成 m + 1 个，-1 变成 n - 1 个，总和不变。</p><h2 id="三、解题模板"><a href="#三、解题模板" class="headerlink" title="三、解题模板"></a>三、解题模板</h2><p>最后我们需要来计算一下卡特兰数的通项Cn &#x3D; C(2n,n)&#x2F;(n+1)</p><p>卡特兰数满足以下递推式：</p><p>C1 &#x3D; 1, Cn &#x3D; Cn-1(4*n-2)&#x2F;(n+1) ​ （证明从略）</p><p>因此，我们可以通过递推来得到第 n 个卡特兰数。</p><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="comment">// 打印前 n 个卡特兰数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;1:&quot;</span> + ans.toString());</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">four</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">4</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">one</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">two</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> BigInteger.valueOf(i);</span><br><span class="line">ans = ans.multiply(four.multiply(bi).subtract(two)).divide(bi.add(one));</span><br><span class="line">System.out.println(i + <span class="string">&quot;:&quot;</span> + ans.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line"></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">ans = ans \* (<span class="number">4</span> \* i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>需要注意的是，由于卡特兰数增长速度较快，当 n 等于 17 时，卡特兰数将会超过 int 最大值，造成溢出（Python 除外）。对于 Java 语言来说，可以使用 BigInteger 来计算大整数。</p><p>那如果 +1 的数量不等于 -1 的数量呢，如前面提到的电影购票问题。此时<br>，不是卡特兰数的通项，也就不能够继续使用原有的递推性质。</p><p>那就推导新的公式，一般而言，为了降低难度，题目会要求我们计算排列数量An&#x3D;Cn * m! * n!&#x3D;(m+n)!*(m+1-n)&#x2F;(m+1)</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题。因此，只要我们能够学会进出栈问题的解法，无论问题再怎么变化，本质还是不变的。</p><p>卡特兰数问题中都会存在一种匹配关系，如进出栈匹配，括号匹配等，一旦计数问题中存在这种关系，那我们就需要去考虑这是否是卡特兰数问题。此外，我们还可以记住序列前四项：1, 1, 2, 5，这些将有利于我们联想到卡特兰数。1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,…</p><p>目前，LeetCode 已经出现一道卡特兰数问题 1259. 不相交的握手，这也是这篇文章编写的原因之一。同时，近年某巴巴，某讯的笔试题中也有出现过这类题目，无非将背景换成买烧饼，借书排队等，相信这些都难不倒读者。</p><h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><p>最后留一道比较有意思的卡特兰数问题，欢迎读者留言，提出自己的看法。</p><p>8 个高矮不同的人需要排成两队，每队 4 个人。其中，每排都是从低到高排列，且第二排的第 i 个人比第一排中第 i 个人高，则有多少种排队方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 1259. 不相交的握手&lt;/p&gt;
&lt;p&gt;date: 2022-09-15 11:15:12&lt;/p&gt;
&lt;p&gt;categories: 2022年9月&lt;/p&gt;
&lt;p&gt;tags: [Leetcode, Math]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;偶数 个人站成一个圆，总人数为</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>239. 滑动窗口最大值</title>
    <link href="http://yoursite.com/2022/09/21/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2022/09/21/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2022-09-20T17:12:12.000Z</published>
    <updated>2022-09-21T09:24:44.884Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><span id="more"></span><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p>示例:</p><pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] </code></pre><p>解释: </p><pre><code>  滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7 </code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^41 &lt;= k &lt;= nums.length</code></pre><p>[TOC]</p><h1 id="我的解法："><a href="#我的解法：" class="headerlink" title="我的解法："></a>我的解法：</h1><p>我首先想到的是用一个max保存窗口中的最大值，每次滑动窗口时都更新一下max并放到结果数组中，但是遇到问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试用例:[1,-1]</span><br><span class="line">1</span><br><span class="line">测试结果:[1,1]</span><br><span class="line">期望结果:[1,-1]</span><br></pre></td></tr></table></figure><p>是因为没有考虑到滑动到新窗口时如果原来的最大值恰好是原窗口的首个这种情况，需要把原来的最大值去掉，然后找到剩余元素的最大值，再去更新新窗口中的最大值。</p><details>    <summary>我的解法Java版</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int[] res = new int[nums.length - k + 1];</span><br><span class="line">        int max = findMax(nums, 0, k - 1);</span><br><span class="line">        res[0]=max;</span><br><span class="line">        int index = 1;</span><br><span class="line">        for (int i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (max == nums[i - k]) &#123;</span><br><span class="line">                max = findMax(nums, i - k + 1, i - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            res[index++] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int findMax(int[] nums, int begin, int end) &#123;</span><br><span class="line">        int max=Integer.MIN_VALUE;</span><br><span class="line">        for (int i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>哈哈哈通过了，这道Hard的题目只改了一次就过了，前所未有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info</span><br><span class="line">解答成功:</span><br><span class="line">执行耗时:4 ms,击败了92.27% 的Java用户</span><br><span class="line">内存消耗:51.1 MB,击败了6.67% 的Java用户</span><br></pre></td></tr></table></figure><p>但2022年时再用此方法就超时了。两年没做再做犯的错误还是一模一样。</p><h1 id="方法一：暴力法-1"><a href="#方法一：暴力法-1" class="headerlink" title="方法一：暴力法^1"></a>方法一：暴力法<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/">^1</a></h1><p><strong>直觉</strong></p><p>最简单直接的方法是遍历每个滑动窗口，找到每个窗口的最大值。一共有  <code>N - k + 1</code> 个滑动窗口，每个有 <code>k</code> 个元素，于是算法的时间复杂度为 *O(N k)*，表现较差。</p><p><strong>实现</strong></p><details>    <summary>暴力解法Python版</summary><figure class="highlight python"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="string">&#x27;List[int]&#x27;</span>, k: <span class="string">&#x27;int&#x27;</span></span>) -&gt; <span class="string">&#x27;List[int]&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(nums[i:i + k]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力解法Java版</summary>    <figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> [] output = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; i + k; j++) </span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">            output[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N k)*。其中 <code>N</code> 为数组中元素个数。</p></li><li><p>空间复杂度：*O(N - k + 1)*，用于输出数组。</p><br /><br /></li></ul><hr><h1 id="方法二：双向队列"><a href="#方法二：双向队列" class="headerlink" title="方法二：双向队列"></a>方法二：双向队列</h1><p><strong>直觉</strong></p><p>如何优化时间复杂度呢？首先想到的是使用<strong>堆</strong>，因为在最大堆中 <code>heap[0]</code> 永远是最大的元素。在大小为 <code>k</code> 的堆中插入一个元素消耗log(k) 时间，因此算法的时间复杂度为 O(Nlog(k))。</p><blockquote><p>能否得到只要 <em>O(N)</em> 的算法？</p></blockquote><p>我们可以使用<strong>双向队列</strong>，该数据结构可以从两端以常数时间压入&#x2F;弹出元素。</p><p>存储双向队列的索引比存储元素更方便，因为两者都能在数组解析中使用。</p><p><strong>算法</strong></p><p>算法非常直截了当：</p><ul><li><p>处理前 <code>k</code> 个元素，初始化双向队列。</p></li><li><p>遍历整个数组。在每一步 :</p><p>  清理双向队列 :</p><pre><code>  - 只保留当前滑动窗口中有的元素的索引。  - 移除比当前元素小的所有元素，它们不可能是最大的。</code></pre></li></ul><ul><li>将当前元素添加到双向队列中。</li><li>将 <code>deque[0]</code> 添加到输出中。</li><li>返回输出数组。</li></ul><p><strong>实现</strong></p><details>    <summary>双向队列Python实现</summary><figure class="highlight python"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="string">&#x27;List[int]&#x27;</span>, k: <span class="string">&#x27;int&#x27;</span></span>) -&gt; <span class="string">&#x27;List[int]&#x27;</span>:</span><br><span class="line">        <span class="comment"># base cases</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">clean_deque</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># remove indexes of elements not from sliding window</span></span><br><span class="line">            <span class="keyword">if</span> deq <span class="keyword">and</span> deq[<span class="number">0</span>] == i - k:</span><br><span class="line">                deq.popleft()</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># remove from deq indexes of all elements </span></span><br><span class="line">            <span class="comment"># which are smaller than current element nums[i]</span></span><br><span class="line">            <span class="keyword">while</span> deq <span class="keyword">and</span> nums[i] &gt; nums[deq[-<span class="number">1</span>]]:</span><br><span class="line">                deq.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># init deque and output</span></span><br><span class="line">        deq = deque()</span><br><span class="line">        max_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            clean_deque(i)</span><br><span class="line">            deq.append(i)</span><br><span class="line">            <span class="comment"># compute max in nums[:k]</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[max_idx]:</span><br><span class="line">                max_idx = i</span><br><span class="line">        output = [nums[max_idx]]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build output</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            clean_deque(i)          </span><br><span class="line">            deq.append(i)</span><br><span class="line">            output.append(nums[deq[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></details><details>    <summary>双向队列Java实现</summary>    <figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  ArrayDeque&lt;Integer&gt; deq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">  <span class="type">int</span> [] nums;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean_deque</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// remove indexes of elements not from sliding window</span></span><br><span class="line">    <span class="keyword">if</span> (!deq.isEmpty() &amp;&amp; deq.getFirst() == i - k)</span><br><span class="line">      deq.removeFirst();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove from deq indexes of all elements </span></span><br><span class="line">    <span class="comment">// which are smaller than current element nums[i]</span></span><br><span class="line">    <span class="keyword">while</span> (!deq.isEmpty() &amp;&amp; nums[i] &gt; nums[deq.getLast()])   </span><br><span class="line">    deq.removeLast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init deque and output</span></span><br><span class="line">    <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max_idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      clean_deque(i, k);</span><br><span class="line">      deq.addLast(i);</span><br><span class="line">      <span class="comment">// compute max in nums[:k]</span></span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[max_idx]) max_idx = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> [] output = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    output[<span class="number">0</span>] = nums[max_idx];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> k; i &lt; n; i++) &#123;</span><br><span class="line">      clean_deque(i, k);</span><br><span class="line">      deq.addLast(i);</span><br><span class="line">      output[i - k + <span class="number">1</span>] = nums[deq.getFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。</p></li><li><p>空间复杂度：*O(N)*，输出数组使用了 <em>O(N - k + 1)</em> 空间，双向队列使用了 *O(k)*。</p><br /><br /></li></ul><hr><h1 id="方法三-动态规划"><a href="#方法三-动态规划" class="headerlink" title="方法三: 动态规划"></a>方法三: 动态规划</h1><p><strong>直觉</strong></p><p>这是另一个 <em>{O}(N)</em> 的算法。本算法的优点是不需要使用 <code>数组 / 列表</code> 之外的任何数据结构。</p><p>算法的思想是将输入数组分割成有 <code>k</code> 个元素的块。<br>若 <code>n % k != 0</code>，则最后一块的元素个数可能更少。</p><p> <a href="https://pic.leetcode-cn.com/95c5c42bcedb9c417b96925e5204e5bdad34456e29bd1b61a41138abd80e4b0b-image.png">image.png</a></p><p>开头元素为 <code>i</code> ，结尾元素为 <code>j</code> 的当前滑动窗口可能在一个块内，也可能在两个块中。</p><p> <a href="https://pic.leetcode-cn.com/27af2b52e80803bcb7a8285dbd27cfa9292a6cf6dd0a6454454d6d3357da15c6-image.png">image.png</a></p><p>情况 <code>1</code> 比较简单。 建立数组 <code>left</code>， 其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向 <code>左-&gt;右</code>。</p><p> <a href="https://pic.leetcode-cn.com/79cbfbefc4c891c337f6b5de8c29f9d3ab39883c92c084a46163f2fa4f0f1d37-image.png">image.png</a></p><p>为了处理更复杂的情况 <code>2</code>，我们需要数组 <code>right</code>，其中 <code>right[j]</code> 是从块的结尾到下标 <code>j</code> 最大的元素，方向 <code>右-&gt;左</code>。<code>right</code> 数组和 <code>left</code> 除了方向不同以外基本一致。</p><p> <a href="https://pic.leetcode-cn.com/b404188e760dd82a2bd4ebf4f6fe2e8b3c229bb506ed2f3cc8a01675744c351b-image.png">image.png</a></p><p>两数组一起可以提供两个块内元素的全部信息。考虑从下标 <code>i</code> 到下标 <code>j</code>的滑动窗口。 根据定义，<code>right[i]</code> 是<strong>左侧块内的最大元素</strong>， <code>left[j]</code> 是<strong>右侧块内的最大元素</strong>。因此滑动窗口中的最大元素为 <code>max(right[i], left[j])</code>。</p><p> <a href="https://pic.leetcode-cn.com/3074f1eb068151ebdebbf1b605234815c64d0bf7812d33c8eb5ba044ab625300-image.png">image.png</a></p><p>说实话我一开始看到这个方法有点儿迷糊，但重点理解<code>right[i]</code> 是<strong>左侧块内的最大元素</strong>， <code>left[j]</code> 是<strong>右侧块内的最大元素</strong>，配合下面的图解就能轻松理解了。</p><p><strong>算法</strong></p><p>算法十分直截了当：</p><ul><li><p>从左到右遍历数组，建立数组 <code>left</code>。</p></li><li><p>从右到左遍历数组，建立数组 <code>right</code>。</p></li><li><p>建立输出数组 <code>max(right[i], left[i + k - 1])</code>，其中 <code>i</code> 取值范围为 <code>(0, n - k + 1)</code>。</p></li></ul><p><strong>实现</strong></p><p>  <a href="https://pic.leetcode-cn.com/e793d5c8ede0be91804b291f1565ab90c980371879d6ec683d0a05c1b4f7e984-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/4a699746334bfd5548a8a2a920e5bcd2b2922f6c39ca0bf2a52bc741a8b9c10d-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/f20d788625572649bd3def127aafdd287eb9d958fdb7e8323183980a4721f7aa-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/df789ba3e0741df8493eaedbbb5cc483a5805e7f4fc65a5a16436749a29bd08b-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/f060cabc30a2f902c9be177070a68df07e9a1586aff921c4243dbc376c276738-image.png">image.png</a>  <a href="https://pic.leetcode-cn.com/263dd3579de8f15c38164db0e7c506d9269c657c34f50dff0512469867a26f78-image.png">image.png</a> </p><details>    <summary>动态规划Python</summary><figure class="highlight python"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="string">&#x27;List[int]&#x27;</span>, k: <span class="string">&#x27;int&#x27;</span></span>) -&gt; <span class="string">&#x27;List[int]&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        left = [<span class="number">0</span>] * n</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        right = [<span class="number">0</span>] * n</span><br><span class="line">        right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># from left to right</span></span><br><span class="line">            <span class="keyword">if</span> i % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block start</span></span><br><span class="line">                left[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left[i] = <span class="built_in">max</span>(left[i - <span class="number">1</span>], nums[i])</span><br><span class="line">            <span class="comment"># from right to left</span></span><br><span class="line">            j = n - i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block end</span></span><br><span class="line">                right[j] = nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right[j] = <span class="built_in">max</span>(right[j + <span class="number">1</span>], nums[j])</span><br><span class="line">        </span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k + <span class="number">1</span>):</span><br><span class="line">            output.append(<span class="built_in">max</span>(left[i + k - <span class="number">1</span>], right[i]))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary>    <figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n * k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> [] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> [] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    right[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// from left to right</span></span><br><span class="line">      <span class="keyword">if</span> (i % k == <span class="number">0</span>) left[i] = nums[i];  <span class="comment">// block_start</span></span><br><span class="line">      <span class="keyword">else</span> left[i] = Math.max(left[i - <span class="number">1</span>], nums[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// from right to left</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ((j + <span class="number">1</span>) % k == <span class="number">0</span>) right[j] = nums[j];  <span class="comment">// block_end</span></span><br><span class="line">      <span class="keyword">else</span> right[j] = Math.max(right[j + <span class="number">1</span>], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> [] output = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; i++)</span><br><span class="line">      output[i] = Math.max(left[i + k - <span class="number">1</span>], right[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：*O(N)*，我们对长度为 <code>N</code> 的数组处理了 <code>3</code>次。 </p></li><li><p>空间复杂度：*O(N)*，用于存储长度为 <code>N</code> 的 <code>left</code> 和 <code>right</code> 数组，以及长度为 <code>N - k + 1</code>的输出数组。</p></li></ul><h1 id="方法四：-优先队列-2"><a href="#方法四：-优先队列-2" class="headerlink" title="方法四： 优先队列^2"></a>方法四： 优先队列<a href="https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/">^2</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p><p>对于本题而言，初始时，我们将数组 nums 的前 k 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 nums 中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。</p><p>我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组<br>(num,index)，表示元素 num 在数组中的下标为 index。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        PriorityQueue&lt;int[]&gt; pq=new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">                return o1[0] != o2[0] ? o2[0]-o1[0] : o2[1]-o1[1];// 大根堆o1[1]-o2[1]也可以</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            pq.offer(new int[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ans = new int[n - k + 1];</span><br><span class="line">        ans[0]=pq.peek()[0];</span><br><span class="line">        for (int i = k; i &lt; n; i++) &#123;</span><br><span class="line">            pq.offer(new int[]&#123;nums[i], i&#125;);</span><br><span class="line">            while (pq.peek()[1] &lt;= i - k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i - k + 1] = pq.peek()[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans = &#123;q.top().first&#125;;</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">            while (q.top().second &lt;= i - k) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        # 注意 Python 默认的优先队列是小根堆</span><br><span class="line">        q = [(-nums[i], i) for i in range(k)]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line"></span><br><span class="line">        ans = [-q[0][0]]</span><br><span class="line">        for i in range(k, n):</span><br><span class="line">            heapq.heappush(q, (-nums[i], i))</span><br><span class="line">            while q[0][1] &lt;= i - k:</span><br><span class="line">                heapq.heappop(q)</span><br><span class="line">            ans.append(-q[0][0])</span><br><span class="line">        </span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">type hp struct&#123; sort.IntSlice &#125;</span><br><span class="line">func (h hp) Less(i, j int) bool  &#123; return a[h.IntSlice[i]] &gt; a[h.IntSlice[j]] &#125;</span><br><span class="line">func (h *hp) Push(v interface&#123;&#125;) &#123; h.IntSlice = append(h.IntSlice, v.(int)) &#125;</span><br><span class="line">func (h *hp) Pop() interface&#123;&#125;   &#123; a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v &#125;</span><br><span class="line"></span><br><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    a = nums</span><br><span class="line">    q := &amp;hp&#123;make([]int, k)&#125;</span><br><span class="line">    for i := 0; i &lt; k; i++ &#123;</span><br><span class="line">        q.IntSlice[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(q)</span><br><span class="line"></span><br><span class="line">    n := len(nums)</span><br><span class="line">    ans := make([]int, 1, n-k+1)</span><br><span class="line">    ans[0] = nums[q.IntSlice[0]]</span><br><span class="line">    for i := k; i &lt; n; i++ &#123;</span><br><span class="line">        heap.Push(q, i)</span><br><span class="line">        for q.IntSlice[0] &lt;= i-k &#123;</span><br><span class="line">            heap.Pop(q)</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, nums[q.IntSlice[0]])</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">void swap(int** a, int** b) &#123;</span><br><span class="line">    int* tmp = *a;</span><br><span class="line">    *a = *b, *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(int* a, int* b) &#123;</span><br><span class="line">    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Heap &#123;</span><br><span class="line">    int** heap;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void init(struct Heap* obj, int capacity) &#123;</span><br><span class="line">    obj-&gt;size = 0;</span><br><span class="line">    obj-&gt;heap = NULL;</span><br><span class="line">    obj-&gt;capacity = capacity;</span><br><span class="line">    obj-&gt;heap = malloc(sizeof(int*) * (obj-&gt;capacity + 1));</span><br><span class="line">    for (int i = 1; i &lt;= obj-&gt;capacity; i++) &#123;</span><br><span class="line">        obj-&gt;heap[i] = malloc(sizeof(int) * 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setFree(struct Heap* obj) &#123;</span><br><span class="line">    for (int i = 1; i &lt;= obj-&gt;capacity; i++) &#123;</span><br><span class="line">        free(obj-&gt;heap[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(obj-&gt;heap);</span><br><span class="line">    free(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(struct Heap* obj, int num0, int num1) &#123;</span><br><span class="line">    int sub1 = ++(obj-&gt;size), sub2 = sub1 &gt;&gt; 1;</span><br><span class="line">    (obj-&gt;heap[sub1])[0] = num0, (obj-&gt;heap[sub1])[1] = num1;</span><br><span class="line">    while (sub2 &gt; 0 &amp;&amp; cmp(obj-&gt;heap[sub2], obj-&gt;heap[sub1]) &lt; 0) &#123;</span><br><span class="line">        swap(&amp;(obj-&gt;heap[sub1]), &amp;(obj-&gt;heap[sub2]));</span><br><span class="line">        sub1 = sub2, sub2 = sub1 &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pop(struct Heap* obj) &#123;</span><br><span class="line">    int sub = 1;</span><br><span class="line">    swap(&amp;(obj-&gt;heap[sub]), &amp;(obj-&gt;heap[(obj-&gt;size)--]));</span><br><span class="line">    while (sub &lt;= obj-&gt;size) &#123;</span><br><span class="line">        int sub1 = sub &lt;&lt; 1, sub2 = sub &lt;&lt; 1 | 1;</span><br><span class="line">        int maxSub = sub;</span><br><span class="line">        if (sub1 &lt;= obj-&gt;size &amp;&amp; cmp(obj-&gt;heap[maxSub], obj-&gt;heap[sub1]) &lt; 0) &#123;</span><br><span class="line">            maxSub = sub1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sub2 &lt;= obj-&gt;size &amp;&amp; cmp(obj-&gt;heap[maxSub], obj-&gt;heap[sub2]) &lt; 0) &#123;</span><br><span class="line">            maxSub = sub2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sub == maxSub) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;(obj-&gt;heap[sub]), &amp;(obj-&gt;heap[maxSub]));</span><br><span class="line">        sub = maxSub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* top(struct Heap* obj) &#123;</span><br><span class="line">    return obj-&gt;heap[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) &#123;</span><br><span class="line">    struct Heap* q = malloc(sizeof(struct Heap));</span><br><span class="line">    init(q, numsSize);</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        push(q, nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    int* ans = malloc(sizeof(int) * (numsSize - k + 1));</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    ans[(*returnSize)++] = top(q)[0];</span><br><span class="line"></span><br><span class="line">    for (int i = k; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        push(q, nums[i], i);</span><br><span class="line">        while (top(q)[1] &lt;= i - k) &#123;</span><br><span class="line">            pop(q);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = top(q)[0];</span><br><span class="line">    &#125;</span><br><span class="line">    setFree(q);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。在最坏情况下，数组<br>nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为O(logn)，因此总时间复杂度为O(nlogn)。</p><p>空间复杂度：<br>O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的<br>O(n) 空间，只计算额外的空间使用。</p><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>思路与算法</p><p>我们可以顺着方法一的思路继续进行优化。</p><p>由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 i 和 j，其中<br>i 在 j 的左侧（i&lt;j），并且 i 对应的元素不大于 j 对应的元素（nums[i]≤nums[j]），那么会发生什么呢？<br>当滑动窗口向右移动时，只要<br>i 还在窗口中，那么 j 一定也还在窗口中，这是 i 在 j 的左侧所保证的。因此，由于<br>nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将<br>nums[i] 永久地移除。</p><p>因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 nums 中对应的值是严格单调递减的。因为如果队列中有两个相邻的下标，它们对应的值相等或者递增，那么令前者为 i，后者为 j，就对应了上面所说的情况，即 nums[i] 会被移除，这就产生了矛盾。</p><p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p><p>由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。</p><p>为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        deque&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; ans = &#123;nums[q.front()]&#125;;</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            while (q.front() &lt;= i - k) &#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] ans = new int[n - k + 1];</span><br><span class="line">        ans[0] = nums[deque.peekFirst()];</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            while (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i - k + 1] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        for i in range(k):</span><br><span class="line">            while q and nums[i] &gt;= nums[q[-1]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line"></span><br><span class="line">        ans = [nums[q[0]]]</span><br><span class="line">        for i in range(k, n):</span><br><span class="line">            while q and nums[i] &gt;= nums[q[-1]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            while q[0] &lt;= i - k:</span><br><span class="line">                q.popleft()</span><br><span class="line">            ans.append(nums[q[0]])</span><br><span class="line">        </span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    q := []int&#123;&#125;</span><br><span class="line">    push := func(i int) &#123;</span><br><span class="line">        for len(q) &gt; 0 &amp;&amp; nums[i] &gt;= nums[q[len(q)-1]] &#123;</span><br><span class="line">            q = q[:len(q)-1]</span><br><span class="line">        &#125;</span><br><span class="line">        q = append(q, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; k; i++ &#123;</span><br><span class="line">        push(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := len(nums)</span><br><span class="line">    ans := make([]int, 1, n-k+1)</span><br><span class="line">    ans[0] = nums[q[0]]</span><br><span class="line">    for i := k; i &lt; n; i++ &#123;</span><br><span class="line">        push(i)</span><br><span class="line">        for q[0] &lt;= i-k &#123;</span><br><span class="line">            q = q[1:]</span><br><span class="line">        &#125;</span><br><span class="line">        ans = append(ans, nums[q[0]])</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) &#123;</span><br><span class="line">    int q[numsSize];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; nums[i] &gt;= nums[q[right - 1]]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        q[right++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    int* ans = malloc(sizeof(int) * (numsSize - k + 1));</span><br><span class="line">    ans[(*returnSize)++] = nums[q[left]];</span><br><span class="line">    for (int i = k; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; nums[i] &gt;= nums[q[right - 1]]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        q[right++] = i;</span><br><span class="line">        while (q[left] &lt;= i - k) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[(*returnSize)++] = nums[q[left]];</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    const q = [];</span><br><span class="line">    for (let i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        while (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - 1]]) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ans = [nums[q[0]]];</span><br><span class="line">    for (let i = k; i &lt; n; i++) &#123;</span><br><span class="line">        while (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - 1]]) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(i);</span><br><span class="line">        while (q[0] &lt;= i - k) &#123;</span><br><span class="line">            q.shift();</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(nums[q[0]]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="方法六：分块-预处理"><a href="#方法六：分块-预处理" class="headerlink" title="方法六：分块 + 预处理"></a>方法六：分块 + 预处理</h1><p>思路与算法</p><p>除了基于「随着窗口的移动实时维护最大值」的方法一以及方法二之外，我们还可以考虑其他有趣的做法。</p><p>我们可以将数组 nums 从左到右按照 k 个一组进行分组，最后一组中元素的数量可能会不足 k 个。如果我们希望求出 nums[i] 到 nums[i+k−1] 的最大值，就会有两种情况：<br>如果 i 是 k 的倍数，那么 nums[i] 到 nums[i+k−1] 恰好是一个分组。我们只要预处理出每个分组中的最大值，即可得到答案；<br>如果 i 不是 k 的倍数，那么 nums[i] 到 nums[i+k−1] 会跨越两个分组，占有第一个分组的后缀以及第二个分组的前缀。假设<br>j 是 k 的倍数，并且满足 i&lt;j≤i+k−1，那么 nums[i] 到 nums[j−1] 就是第一个分组的后缀，<br>nums[j] 到 nums[i+k−1]就是第二个分组的前缀。如果我们能够预处理出每个分组中的前缀最大值以及后缀最大值，同样可以在 O(1) 的时间得到答案。<br>因此我们用 prefixMax[i] 表示下标 i 对应的分组中，以<br>i 结尾的前缀最大值；suffixMax[i] 表示下标 i 对应的分组中，以 i 开始的后缀最大值。它们分别满足如下的递推式</p><pre><code>prefixMax[i]=&#123;         nums[i],i 是 k 的倍数        max&#123;prefixMax[i−1],nums[i]&#125;,i 不是 k 的倍数suffixMax[i]=&#123;     nums[i],i+1 是 k 的倍数    max&#123;suffixMax[i+1],nums[i]&#125;,i+1 不是 k 的倍数</code></pre><p>需要注意在递推 suffixMax[i] 时需要考虑到边界条件<br>suffixMax[n−1]&#x3D;nums[n−1]，而在递推 prefixMax[i] 时的边界条件<br>prefixMax[0]&#x3D;nums[0] 恰好包含在递推式的第一种情况中，因此无需特殊考虑。</p><p>在预处理完成之后，对于 nums[i] 到 nums[i+k−1] 的所有元素，如果 i 不是<br>k 的倍数，那么窗口中的最大值为 suffixMax[i] 与 prefixMax[i+k−1] 中的较大值；如果<br>i 是 k 的倍数，那么此时窗口恰好对应一整个分组，suffixMax[i] 和<br>prefixMax[i+k−1] 都等于分组中的最大值，因此无论窗口属于哪一种情况，</p><p>max{suffixMax[i],prefixMax[i+k−1]}</p><p>即为答案。</p><p>这种方法与稀疏表（Sparse Table）非常类似。感兴趣的读者可以自行查阅资料进行学习</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; prefixMax(n), suffixMax(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (i % k == 0) &#123;</span><br><span class="line">                prefixMax[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                prefixMax[i] = max(prefixMax[i - 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (i == n - 1 || (i + 1) % k == 0) &#123;</span><br><span class="line">                suffixMax[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                suffixMax[i] = max(suffixMax[i + 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for (int i = 0; i &lt;= n - k; ++i) &#123;</span><br><span class="line">            ans.push_back(max(suffixMax[i], prefixMax[i + k - 1]));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] prefixMax = new int[n];</span><br><span class="line">        int[] suffixMax = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (i % k == 0) &#123;</span><br><span class="line">                prefixMax[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (i == n - 1 || (i + 1) % k == 0) &#123;</span><br><span class="line">                suffixMax[i] = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] ans = new int[n - k + 1];</span><br><span class="line">        for (int i = 0; i &lt;= n - k; ++i) &#123;</span><br><span class="line">            ans[i] = Math.max(suffixMax[i], prefixMax[i + k - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        prefixMax, suffixMax = [0] * n, [0] * n</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if i % k == 0:</span><br><span class="line">                prefixMax[i] = nums[i]</span><br><span class="line">            else:</span><br><span class="line">                prefixMax[i] = max(prefixMax[i - 1], nums[i])</span><br><span class="line">        for i in range(n - 1, -1, -1):</span><br><span class="line">            if i == n - 1 or (i + 1) % k == 0:</span><br><span class="line">                suffixMax[i] = nums[i]</span><br><span class="line">            else:</span><br><span class="line">                suffixMax[i] = max(suffixMax[i + 1], nums[i])</span><br><span class="line"></span><br><span class="line">        ans = [max(suffixMax[i], prefixMax[i + k - 1]) for i in range(n - k + 1)]</span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func maxSlidingWindow(nums []int, k int) []int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    prefixMax := make([]int, n)</span><br><span class="line">    suffixMax := make([]int, n)</span><br><span class="line">    for i, v := range nums &#123;</span><br><span class="line">        if i%k == 0 &#123;</span><br><span class="line">            prefixMax[i] = v</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prefixMax[i] = max(prefixMax[i-1], v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">        if i == n-1 || (i+1)%k == 0 &#123;</span><br><span class="line">            suffixMax[i] = nums[i]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            suffixMax[i] = max(suffixMax[i+1], nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := make([]int, n-k+1)</span><br><span class="line">    for i := range ans &#123;</span><br><span class="line">        ans[i] = max(suffixMax[i], prefixMax[i+k-1])</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if a &gt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) &#123;</span><br><span class="line">    int prefixMax[numsSize], suffixMax[numsSize];</span><br><span class="line">    for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        if (i % k == 0) &#123;</span><br><span class="line">            prefixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prefixMax[i] = fmax(prefixMax[i - 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = numsSize - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        if (i == numsSize - 1 || (i + 1) % k == 0) &#123;</span><br><span class="line">            suffixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            suffixMax[i] = fmax(suffixMax[i + 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    int* ans = malloc(sizeof(int) * (numsSize - k + 1));</span><br><span class="line">    for (int i = 0; i &lt;= numsSize - k; ++i) &#123;</span><br><span class="line">        ans[(*returnSize)++] = fmax(suffixMax[i], prefixMax[i + k - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    const prefixMax = new Array(n).fill(0);</span><br><span class="line">    const suffixMax = new Array(n).fill(0);</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (i % k === 0) &#123;</span><br><span class="line">            prefixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        if (i === n || (i + 1) % k === 0) &#123;</span><br><span class="line">            suffixMax[i] = nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const ans = [];</span><br><span class="line">    for (let i = 0; i &lt; n - k + 1; i++) &#123;</span><br><span class="line">        ans.push(Math.max(suffixMax[i], prefixMax[i + k - 1]));</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></details><p>复杂度分析</p><p>时间复杂度：<br>O(n)，其中 n 是数组 nums 的长度。我们需要 O(n) 的时间预处理出数组prefixMax，suffixMax 以及计算答案。</p><p>空间复杂度：<br>O(n)，即为存储prefixMax 和 suffixMax 需要的空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
    <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>829. 连续整数求和</title>
    <link href="http://yoursite.com/2022/09/14/829.%20%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2022/09/14/829.%20%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E6%B1%82%E5%92%8C/</id>
    <published>2022-09-14T08:43:12.000Z</published>
    <updated>2022-09-15T02:37:16.652Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个正整数 n，返回 连续正整数满足所有数字之和为 n的组数 。</p><span id="more"></span><p>[TOC]</p><p>示例 1:</p><pre><code>输入: n = 5输出: 2解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。</code></pre><p>示例 2:</p><pre><code>输入: n = 9输出: 3解释: 9 = 4 + 5 = 2 + 3 + 4</code></pre><p>示例 3:</p><pre><code>输入: n = 15输出: 4解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</code></pre><p>提示:</p><p>1 &lt;&#x3D; n &lt;&#x3D; 10^9</p><h1 id="双重循环求解【超时】"><a href="#双重循环求解【超时】" class="headerlink" title="双重循环求解【超时】"></a>双重循环求解【超时】</h1><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int consecutiveNumbersSum(int n) &#123;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int j=i;</span><br><span class="line">            int sum=0;</span><br><span class="line">            while (sum&lt;n &amp;&amp; j&lt;=n)&#123;</span><br><span class="line">                sum+=j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(n==sum)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="数学方法-1"><a href="#数学方法-1" class="headerlink" title="数学方法^1"></a>数学方法<a href="https://leetcode.cn/problems/consecutive-numbers-sum/solution/lian-xu-zheng-shu-qiu-he-by-leetcode-sol-33hc/">^1</a></h1><p>方法看着有些晕，说实在遇到这种题很难做出来，只能尽量找不等关系。</p><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def consecutiveNumbersSum(self, n: int) -&gt; int:</span><br><span class="line">        def isKConsecutive(n: int, k: int) -&gt; bool:</span><br><span class="line">            if k % 2:</span><br><span class="line">                return n % k == 0</span><br><span class="line">            return n % k and 2 * n % k == 0</span><br><span class="line"></span><br><span class="line">        ans = 0</span><br><span class="line">        k = 1</span><br><span class="line">        while k * (k + 1) &lt;= n * 2:</span><br><span class="line">            if isKConsecutive(n, k):</span><br><span class="line">                ans += 1</span><br><span class="line">            k += 1</span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int consecutiveNumbersSum(int n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int bound = 2 * n;</span><br><span class="line">        for (int k = 1; k * (k + 1) &lt;= bound; k++) &#123;</span><br><span class="line">            if (isKConsecutive(n, k)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isKConsecutive(int n, int k) &#123;</span><br><span class="line">        if (k % 2 == 1) &#123;</span><br><span class="line">            return n % k == 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return n % k != 0 &amp;&amp; 2 * n % k == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int ConsecutiveNumbersSum(int n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int bound = 2 * n;</span><br><span class="line">        for (int k = 1; k * (k + 1) &lt;= bound; k++) &#123;</span><br><span class="line">            if (IsKConsecutive(n, k)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsKConsecutive(int n, int k) &#123;</span><br><span class="line">        if (k % 2 == 1) &#123;</span><br><span class="line">            return n % k == 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return n % k != 0 &amp;&amp; 2 * n % k == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int consecutiveNumbersSum(int n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int bound = 2 * n;</span><br><span class="line">        for (int k = 1; k * (k + 1) &lt;= bound; k++) &#123;</span><br><span class="line">            if (isKConsecutive(n, k)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    bool isKConsecutive(int n, int k) &#123;</span><br><span class="line">        if (k % 2 == 1) &#123;</span><br><span class="line">            return n % k == 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return n % k != 0 &amp;&amp; 2 * n % k == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool isKConsecutive(int n, int k) &#123;</span><br><span class="line">    if (k % 2 == 1) &#123;</span><br><span class="line">        return n % k == 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n % k != 0 &amp;&amp; 2 * n % k == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int consecutiveNumbersSum(int n)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int bound = 2 * n;</span><br><span class="line">    for (int k = 1; k * (k + 1) &lt;= bound; k++) &#123;</span><br><span class="line">        if (isKConsecutive(n, k)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func isKConsecutive(n, k int) bool &#123;</span><br><span class="line">    if k%2 == 1 &#123;</span><br><span class="line">        return n%k == 0</span><br><span class="line">    &#125;</span><br><span class="line">    return n%k != 0 &amp;&amp; 2*n%k == 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func consecutiveNumbersSum(n int) (ans int) &#123;</span><br><span class="line">    for k := 1; k*(k+1) &lt;= n*2; k++ &#123;</span><br><span class="line">        if isKConsecutive(n, k) &#123;</span><br><span class="line">            ans++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var consecutiveNumbersSum = function(n) &#123;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    const bound = 2 * n;</span><br><span class="line">    for (let k = 1; k * (k + 1) &lt;= bound; k++) &#123;</span><br><span class="line">        if (isKConsecutive(n, k)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isKConsecutive = (n, k) =&gt; &#123;</span><br><span class="line">    if (k % 2 === 1) &#123;</span><br><span class="line">        return n % k === 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n % k !== 0 &amp;&amp; 2 * n % k === 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个正整数 n，返回 连续正整数满足所有数字之和为 n的组数 。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年9月" scheme="http://yoursite.com/categories/2022%E5%B9%B49%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
    <category term="Enumeration" scheme="http://yoursite.com/tags/Enumeration/"/>
    
  </entry>
  
  <entry>
    <title>64. 最小路径和</title>
    <link href="http://yoursite.com/2022/08/25/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yoursite.com/2022/08/25/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2022-08-25T03:55:12.000Z</published>
    <updated>2022-08-25T05:50:59.079Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><span id="more"></span><p>[TOC]</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><pre><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。</code></pre><p>示例 2：</p><pre><code>输入：grid = [[1,2,3],[4,5,6]]输出：12</code></pre><p>提示：</p><pre><code>m == grid.lengthn == grid[i].length1 &lt;= m, n &lt;= 2000 &lt;= grid[i][j] &lt;= 100</code></pre><h1 id="回溯解法-1"><a href="#回溯解法-1" class="headerlink" title="回溯解法^1"></a>回溯解法<a href="https://leetcode.cn/problems/minimum-path-sum/solution/hui-su-dao-dong-tai-gui-hua-zai-dao-kong-swk9/">^1</a></h1><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private int minPathSum = Integer.MAX_VALUE;</span><br><span class="line">private int[][] dirs = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">    dfs(grid, 0, 0, grid[0][0]);</span><br><span class="line">    return minPathSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dfs(int[][] grid, int row, int col, int sum) &#123;</span><br><span class="line">    if (row == grid.length - 1 &amp;&amp; col == grid[0].length - 1) &#123;</span><br><span class="line">        minPathSum = Math.min(minPathSum, sum);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int[] dir : dirs) &#123;</span><br><span class="line">        int nextRow = row + dir[0];</span><br><span class="line">        int nextCol = col + dir[1];</span><br><span class="line">        if (nextRow &lt; 0 || nextCol &lt; 0</span><br><span class="line">                || nextRow &gt;= grid.length</span><br><span class="line">                || nextCol &gt;= grid[0].length) continue;</span><br><span class="line">        sum += grid[nextRow][nextCol];</span><br><span class="line">        dfs(grid, nextRow, nextCol, sum);</span><br><span class="line">        sum -= grid[nextRow][nextCol];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private int[][] dirs = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">    int[][] memo = new int[grid.length][grid[0].length];</span><br><span class="line">    for (int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">        Arrays.fill(memo[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    return dfs(grid, 0, 0, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int dfs(int[][] grid, int row, int col, int[][] memo) &#123;</span><br><span class="line">    if (row == grid.length - 1 &amp;&amp; col == grid[0].length - 1) &#123;</span><br><span class="line">        return grid[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">    if (memo[row][col] != Integer.MAX_VALUE) return memo[row][col];</span><br><span class="line">    int minPathSum = Integer.MAX_VALUE;</span><br><span class="line">    for (int[] dir : dirs) &#123;</span><br><span class="line">        int nextRow = row + dir[0];</span><br><span class="line">        int nextCol = col + dir[1];</span><br><span class="line">        if (nextRow &lt; 0 || nextCol &lt; 0</span><br><span class="line">                || nextRow &gt;= grid.length</span><br><span class="line">                || nextCol &gt;= grid[0].length) continue;</span><br><span class="line">        int childMinPathSum = dfs(grid, nextRow, nextCol, memo);</span><br><span class="line">        minPathSum = Math.min(minPathSum, childMinPathSum);</span><br><span class="line">    &#125;</span><br><span class="line">    memo[row][col] = minPathSum + grid[row][col];</span><br><span class="line">    return memo[row][col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    // 3. 记忆化搜索</span><br><span class="line">    int minPathSum1(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; memo(grid.size(), vector&lt;int&gt;(grid[0].size(), INT_MAX));</span><br><span class="line">        return dfs(grid, 0, 0, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, vector&lt;vector&lt;int&gt;&gt;&amp; memo) &#123;</span><br><span class="line">        if (row == grid.size() - 1 &amp;&amp; col == grid[0].size() - 1) &#123;</span><br><span class="line">            return grid[row][col];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (memo[row][col] != INT_MAX) return memo[row][col];</span><br><span class="line"></span><br><span class="line">        int minPathSum = INT_MAX;</span><br><span class="line">        for (vector&lt;int&gt; dir : dirs) &#123;</span><br><span class="line">            int nextRow = row + dir[0];</span><br><span class="line">            int nextCol = col + dir[1];</span><br><span class="line">            if (nextRow &lt; 0 || nextCol &lt; 0</span><br><span class="line">                    || nextRow &gt;= grid.size()</span><br><span class="line">                    || nextCol &gt;= grid[0].size()) continue;</span><br><span class="line">            int childMinPathSum = dfs(grid, nextRow, nextCol, memo);</span><br><span class="line">            minPathSum = min(minPathSum, childMinPathSum);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[row][col] = minPathSum + grid[row][col];</span><br><span class="line">        return memo[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.dirs = [[1, 0], [0, 1]]</span><br><span class="line"></span><br><span class="line">    # 3. 记忆化搜索</span><br><span class="line">    def minPathSum1(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        MAX_INT = 2**31 - 1</span><br><span class="line">        m, n = len(grid), len(grid[0])</span><br><span class="line">        memo = [[MAX_INT] * n for _ in range(m)]</span><br><span class="line"></span><br><span class="line">        def dfs(row, col) -&gt; int:</span><br><span class="line">            if row == m - 1 and col == n - 1:</span><br><span class="line">                return grid[row][col]</span><br><span class="line"></span><br><span class="line">            if memo[row][col] != MAX_INT:</span><br><span class="line">                return memo[row][col]</span><br><span class="line"></span><br><span class="line">            min_path_sum = MAX_INT</span><br><span class="line">            for dir in self.dirs:</span><br><span class="line">                next_row, next_col = row + dir[0], col + dir[1]</span><br><span class="line">                if next_row &lt; 0 or next_row &gt;= m or next_col &lt; 0 or next_col &gt;= n:</span><br><span class="line">                    continue</span><br><span class="line">                child_min_path_sum = dfs(next_row, next_col)</span><br><span class="line">                min_path_sum = min(min_path_sum, child_min_path_sum)</span><br><span class="line"></span><br><span class="line">            memo[row][col] = min_path_sum + grid[row][col]</span><br><span class="line">            return memo[row][col]</span><br><span class="line"></span><br><span class="line">        return dfs(0, 0)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="动态规划-从终点到起始点"><a href="#动态规划-从终点到起始点" class="headerlink" title="动态规划 - 从终点到起始点"></a>动态规划 - 从终点到起始点</h1><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">    int m = grid.length;</span><br><span class="line">    int n = grid[0].length;</span><br><span class="line">    // 状态定义：dp[i][j] 表示从坐标 (i, j) 到右下角的最小路径和</span><br><span class="line">    int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">    // 状态初始化</span><br><span class="line">    dp[m - 1][n - 1] = grid[m - 1][n - 1];</span><br><span class="line"></span><br><span class="line">    // 状态转移</span><br><span class="line">    for (int i = m - 1; i &gt;= 0 ; i--) &#123;</span><br><span class="line">        for (int j = n - 1; j &gt;= 0 ; j--) &#123;</span><br><span class="line">            if (i == m - 1 &amp;&amp; j != n - 1) &#123; // 最后一行</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j + 1];</span><br><span class="line">            &#125; else if (i != m - 1 &amp;&amp; j == n - 1) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i + 1][j];</span><br><span class="line">            &#125; else if (i != m - 1 &amp;&amp; j != n - 1) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回结果</span><br><span class="line">    return dp[0][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 4. 动态规划：从终点到起始点</span><br><span class="line">    int minPathSum2(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size(), n = grid[0].size();</span><br><span class="line"></span><br><span class="line">        // 状态定义：dp[i][j] 表示从坐标 (i, j) 到右下角的最小路径和</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));</span><br><span class="line"></span><br><span class="line">        // 状态初始化</span><br><span class="line">        dp[m - 1][n - 1] = grid[m - 1][n - 1];</span><br><span class="line"></span><br><span class="line">        // 状态转移</span><br><span class="line">        for (int i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = n - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (i == m - 1 &amp;&amp; j != n - 1) &#123; // 最后一行</span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i][j + 1];</span><br><span class="line">                &#125; else if (i != m - 1 &amp;&amp; j == n - 1) &#123; // 最后一列</span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i + 1][j];</span><br><span class="line">                &#125; else if (i != m - 1 &amp;&amp; j != n - 1) &#123;</span><br><span class="line">                    dp[i][j] = grid[i][j] + min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回结果</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 4. 动态规划：从终点到起始点</span><br><span class="line">    def minPathSum2(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        m, n = len(grid), len(grid[0])</span><br><span class="line"></span><br><span class="line">        # 状态定义：dp[i][j] 表示从坐标 (i, j) 到右下角的最小路径和</span><br><span class="line">        dp = [[0] * n for _ in range(m)]</span><br><span class="line"></span><br><span class="line">        # 状态初始化</span><br><span class="line">        dp[m - 1][n - 1] = grid[m - 1][n - 1]</span><br><span class="line"></span><br><span class="line">        # 状态转移</span><br><span class="line">        for i in range(m - 1, -1, -1):</span><br><span class="line">            for j in range(n - 1, -1, -1):</span><br><span class="line">                if i == m - 1 and j != n - 1:</span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i][j + 1]</span><br><span class="line">                elif i != m - 1 and j == n - 1:</span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i + 1][j]</span><br><span class="line">                elif i != m - 1 and j != n - 1:</span><br><span class="line">                    dp[i][j] = grid[i][j] + min(dp[i + 1][j], dp[i][j + 1])</span><br><span class="line"></span><br><span class="line">        # 返回结果</span><br><span class="line">        return dp[0][0]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="动态规划-从起始点到终点"><a href="#动态规划-从起始点到终点" class="headerlink" title="动态规划 - 从起始点到终点"></a>动态规划 - 从起始点到终点</h1><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">    int m = grid.length;</span><br><span class="line">    int n = grid[0].length;</span><br><span class="line">    // 状态定义：dp[i][j] 表示从 [0,0] 到 [i,j] 的最小路径和</span><br><span class="line">    int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">    // 状态初始化</span><br><span class="line">    dp[0][0] = grid[0][0];</span><br><span class="line"></span><br><span class="line">    // 状态转移</span><br><span class="line">    for (int i = 0; i &lt; m ; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n ; j++) &#123;</span><br><span class="line">            if (i == 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j - 1];</span><br><span class="line">            &#125; else if (i != 0 &amp;&amp; j == 0) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i - 1][j];</span><br><span class="line">            &#125; else if (i != 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回结果</span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 5. 动态规划：从起始点到终点</span><br><span class="line">    int minPathSum3(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size(), n = grid[0].size();</span><br><span class="line"></span><br><span class="line">        // 状态定义：dp[i][j] 表示从 [0,0] 到 [i,j] 的最小路径和</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));</span><br><span class="line"></span><br><span class="line">        // 状态初始化</span><br><span class="line">        dp[0][0] = grid[0][0];</span><br><span class="line"></span><br><span class="line">        // 状态转移</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (i == 0 &amp;&amp; j != 0) &#123; //第一行</span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i][j - 1];</span><br><span class="line">                &#125; else if (i != 0 &amp;&amp; j == 0) &#123; // 第一列</span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i - 1][j];</span><br><span class="line">                &#125; else if (i != 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                    dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回结果</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def minPathSum3(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">    m, n = len(grid), len(grid[0])</span><br><span class="line"></span><br><span class="line">    # 状态定义：dp[i][j] 表示从 [0,0] 到 [i,j] 的最小路径和</span><br><span class="line">    dp = [[0] * n for _ in range(m)]</span><br><span class="line"></span><br><span class="line">    # 状态初始化</span><br><span class="line">    dp[0][0] = grid[0][0]</span><br><span class="line"></span><br><span class="line">    # 状态转移</span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if i == 0 and j != 0:</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j - 1]</span><br><span class="line">            elif i != 0 and j == 0:</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i - 1][j]</span><br><span class="line">            elif i != 0 and j != 0:</span><br><span class="line">                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])</span><br><span class="line"></span><br><span class="line">    # 返回结果</span><br><span class="line">    return dp[m - 1][n - 1]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="空间状态压缩和优化"><a href="#空间状态压缩和优化" class="headerlink" title="空间状态压缩和优化"></a>空间状态压缩和优化</h1><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">    int m = grid.length;</span><br><span class="line">    int n = grid[0].length;</span><br><span class="line">    // 状态定义：dp[i] 表示从 (0, 0) 到达第 i - 1 行的最短路径值</span><br><span class="line">    int[] dp = new int[n];</span><br><span class="line"></span><br><span class="line">    // 状态初始化</span><br><span class="line">    dp[0] = grid[0][0];</span><br><span class="line"></span><br><span class="line">    // 状态转移</span><br><span class="line">    for (int i = 0; i &lt; m ; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n ; j++) &#123;</span><br><span class="line">            if (i == 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                dp[j] = grid[i][j] + dp[j - 1];</span><br><span class="line">            &#125; else if (i != 0 &amp;&amp; j == 0) &#123;</span><br><span class="line">                dp[j] = grid[i][j] + dp[j];</span><br><span class="line">            &#125; else if (i != 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                dp[j] = grid[i][j] + Math.min(dp[j], dp[j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回结果</span><br><span class="line">    return dp[n - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 6. 动态规划：从起始点到终点 + 状态压缩</span><br><span class="line">public:</span><br><span class="line">    int minPathSum4(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size(), n = grid[0].size();</span><br><span class="line"></span><br><span class="line">        // 状态定义：dp[i] 表示从 (0, 0) 到达第 i - 1 行的最短路径值</span><br><span class="line">        vector&lt;int&gt; dp(n);</span><br><span class="line"></span><br><span class="line">        // 状态初始化</span><br><span class="line">        dp[0] = grid[0][0];</span><br><span class="line"></span><br><span class="line">        // 状态转移</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (i == 0 &amp;&amp; j != 0) &#123; //第一行</span><br><span class="line">                    dp[j] = grid[i][j] + dp[j - 1];</span><br><span class="line">                &#125; else if (i != 0 &amp;&amp; j == 0) &#123; // 第一列</span><br><span class="line">                    dp[j] = grid[i][j] + dp[j];</span><br><span class="line">                &#125; else if (i != 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                    dp[j] = grid[i][j] + min(dp[j], dp[j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回结果</span><br><span class="line">        return dp[n - 1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 6. 动态规划：从起始点到终点 + 状态压缩</span><br><span class="line">def minPathSum4(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">    m, n = len(grid), len(grid[0])</span><br><span class="line"></span><br><span class="line">    # 状态定义：dp[i] 表示从 (0, 0) 到达第 i - 1 行的最短路径值</span><br><span class="line">    dp = [0] * n</span><br><span class="line"></span><br><span class="line">    # 状态初始化</span><br><span class="line">    dp[0] = grid[0][0]</span><br><span class="line"></span><br><span class="line">    # 状态转移</span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if i == 0 and j != 0:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j - 1]</span><br><span class="line">            elif i != 0 and j == 0:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j]</span><br><span class="line">            elif i != 0 and j != 0:</span><br><span class="line">                dp[j] = grid[i][j] + min(dp[j], dp[j - 1])</span><br><span class="line"></span><br><span class="line">    # 返回结果</span><br><span class="line">    return dp[n - 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="空间优化代码如下："><a href="#空间优化代码如下：" class="headerlink" title="空间优化代码如下："></a>空间优化代码如下：</h1><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 动态规划：从起始点到终点 + 使用输入数组作为状态数组</span><br><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">    int m = grid.length;</span><br><span class="line">    int n = grid[0].length;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m ; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n ; j++) &#123;</span><br><span class="line">            if (i == 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i][j - 1];</span><br><span class="line">            &#125; else if (i != 0 &amp;&amp; j == 0) &#123;</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i - 1][j];</span><br><span class="line">            &#125; else if (i != 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                grid[i][j] = grid[i][j] + Math.min(grid[i - 1][j], grid[i][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return grid[m - 1][n - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">// 7. 动态规划：从起始点到终点 + 使用输入数组作为状态数组</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size(), n = grid[0].size();</span><br><span class="line"></span><br><span class="line">        // 状态转移</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (i == 0 &amp;&amp; j != 0) &#123; //第一行</span><br><span class="line">                    grid[i][j] = grid[i][j] + grid[i][j - 1];</span><br><span class="line">                &#125; else if (i != 0 &amp;&amp; j == 0) &#123; // 第一列</span><br><span class="line">                    grid[i][j] = grid[i][j] + grid[i - 1][j];</span><br><span class="line">                &#125; else if (i != 0 &amp;&amp; j != 0) &#123;</span><br><span class="line">                    grid[i][j] = grid[i][j] + min(grid[i - 1][j], grid[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回结果</span><br><span class="line">        return grid[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 7. 动态规划：从起始点到终点 + 使用输入数组作为状态数组</span><br><span class="line">def minPathSum(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">    m, n = len(grid), len(grid[0])</span><br><span class="line"></span><br><span class="line">    # 状态转移</span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if i == 0 and j != 0:</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i][j - 1]</span><br><span class="line">            elif i != 0 and j == 0:</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i - 1][j]</span><br><span class="line">            elif i != 0 and j != 0:</span><br><span class="line">                grid[i][j] = grid[i][j] + min(grid[i - 1][j], grid[i][j - 1])</span><br><span class="line"></span><br><span class="line">    # 返回结果</span><br><span class="line">    return grid[m - 1][n - 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>130. 被围绕的区域</title>
    <link href="http://yoursite.com/2022/08/24/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2022/08/24/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</id>
    <published>2022-08-24T02:45:12.000Z</published>
    <updated>2022-08-25T05:50:44.331Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</code></pre><p>示例 2：</p><pre><code>输入：board = [[&quot;X&quot;]]输出：[[&quot;X&quot;]]</code></pre><p>提示：</p><pre><code>m == board.lengthn == board[i].length1 &lt;= m, n &lt;= 200board[i][j] 为 &#39;X&#39; 或 &#39;O&#39;</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode.cn/problems/surrounded-regions/solution/bei-wei-rao-de-qu-yu-by-leetcode-solution/">^1</a></h1><p>本题给定的矩阵中有三种元素：</p><p>字母 X；<br>被字母 X 包围的字母 O；<br>没有被字母 X 包围的字母 O。<br>本题要求将所有被字母 X 包围的字母 O都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p><p>注意到题目解释中提到：任何边界上的 O 都不会被填充为 X。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p><p>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>最后我们遍历这个矩阵，对于每一个字母：<br>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</p><h1 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h1><h2 id="思路及解法"><a href="#思路及解法" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int n, m;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != &#x27;O&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = &#x27;A&#x27;;</span><br><span class="line">        dfs(board, x + 1, y);</span><br><span class="line">        dfs(board, x - 1, y);</span><br><span class="line">        dfs(board, x, y + 1);</span><br><span class="line">        dfs(board, x, y - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        n = board.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[0].size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, 0);</span><br><span class="line">            dfs(board, i, m - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            dfs(board, 0, i);</span><br><span class="line">            dfs(board, n - 1, i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    int n, m;</span><br><span class="line"></span><br><span class="line">    public void solve(char[][] board) &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[0].length;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, 0);</span><br><span class="line">            dfs(board, i, m - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            dfs(board, 0, i);</span><br><span class="line">            dfs(board, n - 1, i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(char[][] board, int x, int y) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != &#x27;O&#x27;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = &#x27;A&#x27;;</span><br><span class="line">        dfs(board, x + 1, y);</span><br><span class="line">        dfs(board, x - 1, y);</span><br><span class="line">        dfs(board, x, y + 1);</span><br><span class="line">        dfs(board, x, y - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def solve(self, board: List[List[str]]) -&gt; None:</span><br><span class="line">        if not board:</span><br><span class="line">            return</span><br><span class="line">        </span><br><span class="line">        n, m = len(board), len(board[0])</span><br><span class="line"></span><br><span class="line">        def dfs(x, y):</span><br><span class="line">            if not 0 &lt;= x &lt; n or not 0 &lt;= y &lt; m or board[x][y] != &#x27;O&#x27;:</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            board[x][y] = &quot;A&quot;</span><br><span class="line">            dfs(x + 1, y)</span><br><span class="line">            dfs(x - 1, y)</span><br><span class="line">            dfs(x, y + 1)</span><br><span class="line">            dfs(x, y - 1)</span><br><span class="line">        </span><br><span class="line">        for i in range(n):</span><br><span class="line">            dfs(i, 0)</span><br><span class="line">            dfs(i, m - 1)</span><br><span class="line">        </span><br><span class="line">        for i in range(m - 1):</span><br><span class="line">            dfs(0, i)</span><br><span class="line">            dfs(n - 1, i)</span><br><span class="line">        </span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(m):</span><br><span class="line">                if board[i][j] == &quot;A&quot;:</span><br><span class="line">                    board[i][j] = &quot;O&quot;</span><br><span class="line">                elif board[i][j] == &quot;O&quot;:</span><br><span class="line">                    board[i][j] = &quot;X&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var n, m int</span><br><span class="line"></span><br><span class="line">func solve(board [][]byte)  &#123;</span><br><span class="line">    if len(board) == 0 || len(board[0]) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    n, m = len(board), len(board[0])</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        dfs(board, i, 0)</span><br><span class="line">        dfs(board, i, m - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 1; i &lt; m - 1; i++ &#123;</span><br><span class="line">        dfs(board, 0, i)</span><br><span class="line">        dfs(board, n - 1, i)</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; m; j++ &#123;</span><br><span class="line">            if board[i][j] == &#x27;A&#x27; &#123;</span><br><span class="line">                board[i][j] = &#x27;O&#x27;</span><br><span class="line">            &#125; else if board[i][j] == &#x27;O&#x27; &#123;</span><br><span class="line">                board[i][j] = &#x27;X&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dfs(board [][]byte, x, y int) &#123;</span><br><span class="line">    if x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != &#x27;O&#x27; &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    board[x][y] = &#x27;A&#x27;</span><br><span class="line">    dfs(board, x + 1, y)</span><br><span class="line">    dfs(board, x - 1, y)</span><br><span class="line">    dfs(board, x, y + 1)</span><br><span class="line">    dfs(board, x, y - 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。<br>空间复杂度：<br>O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p><h1 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h1><h2 id="思路及解法-1"><a href="#思路及解法-1" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int dx[4] = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">    const int dy[4] = &#123;0, 0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int n = board.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = board[0].size();</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; que;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (board[i][0] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(i, 0);</span><br><span class="line">                board[i][0] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][m - 1] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(i, m - 1);</span><br><span class="line">                board[i][m - 1] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            if (board[0][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(0, i);</span><br><span class="line">                board[0][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[n - 1][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                que.emplace(n - 1, i);</span><br><span class="line">                board[n - 1][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int x = que.front().first, y = que.front().second;</span><br><span class="line">            que.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &lt; 0 || my &lt; 0 || mx &gt;= n || my &gt;= m || board[mx][my] != &#x27;O&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                que.emplace(mx, my);</span><br><span class="line">                board[mx][my] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    int[] dx = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">    int[] dy = &#123;0, 0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    public void solve(char[][] board) &#123;</span><br><span class="line">        int n = board.length;</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = board[0].length;</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (board[i][0] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;i, 0&#125;);</span><br><span class="line">                board[i][0] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][m - 1] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;i, m - 1&#125;);</span><br><span class="line">                board[i][m - 1] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">            if (board[0][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;0, i&#125;);</span><br><span class="line">                board[0][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[n - 1][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">                queue.offer(new int[]&#123;n - 1, i&#125;);</span><br><span class="line">                board[n - 1][i] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] cell = queue.poll();</span><br><span class="line">            int x = cell[0], y = cell[1];</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &lt; 0 || my &lt; 0 || mx &gt;= n || my &gt;= m || board[mx][my] != &#x27;O&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(new int[]&#123;mx, my&#125;);</span><br><span class="line">                board[mx][my] = &#x27;A&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def solve(self, board: List[List[str]]) -&gt; None:</span><br><span class="line">        if not board:</span><br><span class="line">            return</span><br><span class="line">        </span><br><span class="line">        n, m = len(board), len(board[0])</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if board[i][0] == &quot;O&quot;:</span><br><span class="line">                que.append((i, 0))</span><br><span class="line">                board[i][0] = &quot;A&quot;</span><br><span class="line">            if board[i][m - 1] == &quot;O&quot;:</span><br><span class="line">                que.append((i, m - 1))</span><br><span class="line">                board[i][m - 1] = &quot;A&quot;</span><br><span class="line">        for i in range(m - 1):</span><br><span class="line">            if board[0][i] == &quot;O&quot;:</span><br><span class="line">                que.append((0, i))</span><br><span class="line">                board[0][i] = &quot;A&quot;</span><br><span class="line">            if board[n - 1][i] == &quot;O&quot;:</span><br><span class="line">                que.append((n - 1, i))</span><br><span class="line">                board[n - 1][i] = &quot;A&quot;</span><br><span class="line">        </span><br><span class="line">        while que:</span><br><span class="line">            x, y = que.popleft()</span><br><span class="line">            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:</span><br><span class="line">                if 0 &lt;= mx &lt; n and 0 &lt;= my &lt; m and board[mx][my] == &quot;O&quot;:</span><br><span class="line">                    que.append((mx, my))</span><br><span class="line">                    board[mx][my] = &quot;A&quot;</span><br><span class="line">        </span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(m):</span><br><span class="line">                if board[i][j] == &quot;A&quot;:</span><br><span class="line">                    board[i][j] = &quot;O&quot;</span><br><span class="line">                elif board[i][j] == &quot;O&quot;:</span><br><span class="line">                    board[i][j] = &quot;X&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int dx[4] = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">const int dy[4] = &#123;0, 0, 1, -1&#125;;</span><br><span class="line"></span><br><span class="line">void solve(char** board, int boardSize, int* boardColSize) &#123;</span><br><span class="line">    int n = boardSize;</span><br><span class="line">    if (n == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m = boardColSize[0];</span><br><span class="line"></span><br><span class="line">    int** que = (int**)malloc(sizeof(int*) * n * m);</span><br><span class="line">    for (int i = 0; i &lt; n * m; i++) &#123;</span><br><span class="line">        que[i] = (int*)malloc(sizeof(int) * 2);</span><br><span class="line">    &#125;</span><br><span class="line">    int l = 0, r = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (board[i][0] == &#x27;O&#x27;) &#123;</span><br><span class="line">            board[i][0] = &#x27;A&#x27;;</span><br><span class="line">            que[r][0] = i, que[r++][1] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (board[i][m - 1] == &#x27;O&#x27;) &#123;</span><br><span class="line">            board[i][m - 1] = &#x27;A&#x27;;</span><br><span class="line">            que[r][0] = i, que[r++][1] = m - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; m - 1; i++) &#123;</span><br><span class="line">        if (board[0][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">            board[0][i] = &#x27;A&#x27;;</span><br><span class="line">            que[r][0] = 0, que[r++][1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (board[n - 1][i] == &#x27;O&#x27;) &#123;</span><br><span class="line">            board[n - 1][i] = &#x27;A&#x27;;</span><br><span class="line">            que[r][0] = n - 1, que[r++][1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        int x = que[l][0], y = que[l][1];</span><br><span class="line">        l++;</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            if (mx &lt; 0 || my &lt; 0 || mx &gt;= n || my &gt;= m || board[mx][my] != &#x27;O&#x27;) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            board[mx][my] = &#x27;A&#x27;;</span><br><span class="line">            que[r][0] = mx, que[r++][1] = my;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (board[i][j] == &#x27;A&#x27;) &#123;</span><br><span class="line">                board[i][j] = &#x27;O&#x27;;</span><br><span class="line">            &#125; else if (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n * m; i++) &#123;</span><br><span class="line">        free(que[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(que);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var (</span><br><span class="line">    dx = [4]int&#123;1, -1, 0, 0&#125;</span><br><span class="line">    dy = [4]int&#123;0, 0, 1, -1&#125;</span><br><span class="line">)</span><br><span class="line">func solve(board [][]byte)  &#123;</span><br><span class="line">    if len(board) == 0 || len(board[0]) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    n, m := len(board), len(board[0])</span><br><span class="line">    queue := [][]int&#123;&#125;</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        if board[i][0] == &#x27;O&#x27; &#123;</span><br><span class="line">            queue = append(queue, []int&#123;i, 0&#125;)</span><br><span class="line">            board[i][0] = &#x27;A&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        if board[i][m-1] == &#x27;O&#x27; &#123;</span><br><span class="line">            queue = append(queue, []int&#123;i, m - 1&#125;)</span><br><span class="line">            board[i][m - 1] = &#x27;A&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 1; i &lt; m - 1; i++ &#123;</span><br><span class="line">        if board[0][i] == &#x27;O&#x27; &#123;</span><br><span class="line">            queue = append(queue, []int&#123;0, i&#125;)</span><br><span class="line">            board[0][i] = &#x27;A&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        if board[n-1][i] == &#x27;O&#x27; &#123;</span><br><span class="line">            queue = append(queue, []int&#123;n - 1, i&#125;)</span><br><span class="line">            board[n - 1][i] = &#x27;A&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for len(queue) &gt; 0 &#123;</span><br><span class="line">        cell := queue[0]</span><br><span class="line">        queue = queue[1:]</span><br><span class="line">        x, y := cell[0], cell[1]</span><br><span class="line">        for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">            mx, my := x + dx[i], y + dy[i]</span><br><span class="line">            if mx &lt; 0 || my &lt; 0 || mx &gt;= n || my &gt;= m || board[mx][my] != &#x27;O&#x27; &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            queue = append(queue, []int&#123;mx, my&#125;)</span><br><span class="line">            board[mx][my] = &#x27;A&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; m; j++ &#123;</span><br><span class="line">            if board[i][j] == &#x27;A&#x27; &#123;</span><br><span class="line">                board[i][j] = &#x27;O&#x27;</span><br><span class="line">            &#125; else if board[i][j] == &#x27;O&#x27; &#123;</span><br><span class="line">                board[i][j] = &#x27;X&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。<br>空间复杂度：O(n×m)，其中 n 和 m 分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
    <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>419. 甲板上的战舰</title>
    <link href="http://yoursite.com/2022/08/24/419.%20%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0/"/>
    <id>http://yoursite.com/2022/08/24/419.%20%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0/</id>
    <published>2022-08-24T02:45:12.000Z</published>
    <updated>2022-08-25T05:50:51.636Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。</p><span id="more"></span><p>[TOC]</p><p>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p><p>示例 1：</p><pre><code>输入：board = [[&quot;X&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;]]输出：2</code></pre><p>示例 2：</p><pre><code>输入：board = [[&quot;.&quot;]]输出：0</code></pre><p>提示：</p><pre><code>m == board.lengthn == board[i].length1 &lt;= m, n &lt;= 200board[i][j] 是 &#39;.&#39; 或 &#39;X&#39;进阶：你可以实现一次扫描算法，并只使用 O(1) 额外空间，并且不修改 board 的值来解决这个问题吗？</code></pre><h1 id="方法一：遍历扫描"><a href="#方法一：遍历扫描" class="headerlink" title="方法一：遍历扫描"></a>方法一：遍历扫描</h1><p>题目要求找到矩阵中战舰的数量，战舰用 ’X’ 表示，空位用 ’.’，而矩阵中的战舰的满足以下两个条件：</p><p>战舰只能水平或者垂直放置。战舰只能由子矩阵 1×N（1 行，N 列）组成，或者子矩阵 N×1（N 行,<br>1 列）组成，其中 N 可以是任意大小。<br>两艘战舰之间至少有一个水平或垂直的空位分隔，没有相邻的战舰。<br>我们遍历矩阵中的每个位置 (i,j) 且满足 board[i][j]&#x3D;’X’，并将以 (i,j) 为起点的战舰的所有位置均设置为空位，从而我们即可统计出所有可能的战舰。</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countBattleships(char[][] board) &#123;</span><br><span class="line">        int row = board.length;</span><br><span class="line">        int col = board[0].length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    for (int k = j + 1; k &lt; col &amp;&amp; board[i][k] == &#x27;X&#x27;; ++k) &#123;</span><br><span class="line">                        board[i][k] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                    for (int k = i + 1; k &lt; row &amp;&amp; board[k][j] == &#x27;X&#x27;; ++k) &#123;</span><br><span class="line">                        board[k][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int row = board.size();</span><br><span class="line">        int col = board[0].size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                    board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    for (int k = j + 1; k &lt; col &amp;&amp; board[i][k] == &#x27;X&#x27;; ++k) &#123;</span><br><span class="line">                        board[i][k] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                    for (int k = i + 1; k &lt; row &amp;&amp; board[k][j] == &#x27;X&#x27;; ++k) &#123;</span><br><span class="line">                        board[k][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int countBattleships(char** board, int boardSize, int* boardColSize)&#123;</span><br><span class="line">    int row = boardSize;</span><br><span class="line">    int col = boardColSize[0];</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">            if (board[i][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                for (int k = j + 1; k &lt; col &amp;&amp; board[i][k] == &#x27;X&#x27;; ++k) &#123;</span><br><span class="line">                    board[i][k] = &#x27;.&#x27;;</span><br><span class="line">                &#125;                    </span><br><span class="line">                for (int k = i + 1; k &lt; row &amp;&amp; board[k][j] == &#x27;X&#x27;; ++k) &#123;</span><br><span class="line">                    board[k][j] = &#x27;.&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func countBattleships(board [][]byte) (ans int) &#123;</span><br><span class="line">    m, n := len(board), len(board[0])</span><br><span class="line">    for i, row := range board &#123;</span><br><span class="line">        for j, ch := range row &#123;</span><br><span class="line">            if ch == &#x27;X&#x27; &#123;</span><br><span class="line">                row[j] = &#x27;.&#x27;</span><br><span class="line">                for k := j + 1; k &lt; n &amp;&amp; row[k] == &#x27;X&#x27;; k++ &#123;</span><br><span class="line">                    row[k] = &#x27;.&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">                for k := i + 1; k &lt; m &amp;&amp; board[k][j] == &#x27;X&#x27;; k++ &#123;</span><br><span class="line">                    board[k][j] = &#x27;.&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">                ans++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countBattleships(self, board: List[List[str]]) -&gt; int:</span><br><span class="line">        ans = 0</span><br><span class="line">        m, n = len(board), len(board[0])</span><br><span class="line">        for i, row in enumerate(board):</span><br><span class="line">            for j, ch in enumerate(row):</span><br><span class="line">                if ch == &#x27;X&#x27;:</span><br><span class="line">                    row[j] = &#x27;.&#x27;</span><br><span class="line">                    for k in range(j + 1, n):</span><br><span class="line">                        if row[k] != &#x27;X&#x27;:</span><br><span class="line">                            break</span><br><span class="line">                        row[k] = &#x27;.&#x27;</span><br><span class="line">                    for k in range(i + 1, m):</span><br><span class="line">                        if board[k][j] != &#x27;X&#x27;:</span><br><span class="line">                            break</span><br><span class="line">                        board[k][j] = &#x27;.&#x27;</span><br><span class="line">                    ans += 1</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(m×n×max(m,n))，其中 m 是矩阵的行数，n 是矩阵的列数，我们对于矩阵的每个位置都会遍历一遍以该位置所在的行和列。<br>空间复杂度：O(1)。</p><h1 id="方法二：枚举起点"><a href="#方法二：枚举起点" class="headerlink" title="方法二：枚举起点"></a>方法二：枚举起点</h1><p>题目进阶要求一次扫描算法，只使用 O(1) 额外空间，并且不修改甲板的值。因为题目中给定的两艘战舰之间至少有一个水平或垂直的空位分隔，任意两个战舰之间是不相邻的，因此我们可以通过枚举每个战舰的左上顶点即可统计战舰的个数。假设矩阵的行数为 row，矩阵的列数 col，矩阵中的位置 (i,j) 为战舰的左上顶点，需满足以下条件：</p><p>满足当前位置所在的值 board[i][j]&#x3D;’X’；<br>满足当前位置的左则为空位，即board[i][j−1]&#x3D;’.’；<br>满足当前位置的上方为空位，即board[i−1][j]&#x3D;’.’；<br>我们统计出所有战舰的左上顶点的个数即为所有战舰的个数。</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int countBattleships(char[][] board) &#123;</span><br><span class="line">        int row = board.length;</span><br><span class="line">        int col = board[0].length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                    if (i &gt; 0 &amp;&amp; board[i - 1][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (j &gt; 0 &amp;&amp; board[i][j - 1] == &#x27;X&#x27;) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int row = board.size();</span><br><span class="line">        int col = board[0].size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; ++j) &#123; </span><br><span class="line">                if (board[i][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                    if (i &gt; 0 &amp;&amp; board[i - 1][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (j &gt; 0 &amp;&amp; board[i][j - 1] == &#x27;X&#x27;) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int countBattleships(char** board, int boardSize, int* boardColSize)&#123;</span><br><span class="line">    int row = boardSize;</span><br><span class="line">    int col = boardColSize[0];</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; row; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; col; ++j) &#123;</span><br><span class="line">            if (board[i][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                if (i &gt; 0 &amp;&amp; board[i - 1][j] == &#x27;X&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (j &gt; 0 &amp;&amp; board[i][j - 1] == &#x27;X&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func countBattleships(board [][]byte) (ans int) &#123;</span><br><span class="line">    for i, row := range board &#123;</span><br><span class="line">        for j, ch := range row &#123;</span><br><span class="line">            if ch == &#x27;X&#x27; &amp;&amp; !(i &gt; 0 &amp;&amp; board[i-1][j] == &#x27;X&#x27; || j &gt; 0 &amp;&amp; board[i][j-1] == &#x27;X&#x27;) &#123;</span><br><span class="line">                ans++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countBattleships(self, board: List[List[str]]) -&gt; int:</span><br><span class="line">        return sum(ch == &#x27;X&#x27; and not (i &gt; 0 and board[i - 1][j] == &#x27;X&#x27; or j &gt; 0 and board[i][j - 1] == &#x27;X&#x27;)</span><br><span class="line">                   for i, row in enumerate(board) for j, ch in enumerate(row))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(m×n)，其中 m 是矩阵的行数，n 是矩阵的列数，我们只需要遍历一遍矩阵中每个位置即可。<br>空间复杂度：O(1)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>733. 图像渲染</title>
    <link href="http://yoursite.com/2022/08/22/733.%20%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2022/08/22/733.%20%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</id>
    <published>2022-08-22T07:12:12.000Z</published>
    <updated>2022-08-22T07:44:11.656Z</updated>
    
    <content type="html"><![CDATA[<p>图像渲染。</p><span id="more"></span><p>[TOC]</p><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。</p><p>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。</p><p>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。</p><p>最后返回 经过上色渲染后的图像 。</p><p>示例 1:</p><pre><code>输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。</code></pre><p>示例 2:</p><pre><code>输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2输出: [[2,2,2],[2,2,2]]</code></pre><p>提示:</p><pre><code>m == image.lengthn == image[i].length1 &lt;= m, n &lt;= 500 &lt;= image[i][j], newColor &lt; 2160 &lt;= sr &lt; m0 &lt;= sc &lt; n</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题要求将给定的二维数组中指定的「色块」染成另一种颜色。「色块」的定义是：直接或间接相邻的同色方格构成的整体。</p><p>可以发现，「色块」就是被不同颜色的方格包围的一个同色岛屿。我们从色块中任意一个地方开始，利用广度优先搜索或深度优先搜索即可遍历整个岛屿。</p><p>注意：当目标颜色和初始颜色相同时，我们无需对原数组进行修改。</p><h1 id="方法一：广度优先搜索-1"><a href="#方法一：广度优先搜索-1" class="headerlink" title="方法一：广度优先搜索^1"></a>方法一：广度优先搜索<a href="https://leetcode.cn/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/">^1</a></h1><h2 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>我们从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。</p><p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor == newColor) return image;</span><br><span class="line">        int n = image.size(), m = image[0].size();</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; que;</span><br><span class="line">        que.emplace(sr, sc);</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int x = que.front().first, y = que.front().second;</span><br><span class="line">            que.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class="line">                    que.emplace(mx, my);</span><br><span class="line">                    image[mx][my] = newColor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] dx = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    int[] dy = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor == newColor) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = image.length, m = image[0].length;</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;sr, sc&#125;);</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] cell = queue.poll();</span><br><span class="line">            int x = cell[0], y = cell[1];</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;mx, my&#125;);</span><br><span class="line">                    image[mx][my] = newColor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]:</span><br><span class="line">        currColor = image[sr][sc]</span><br><span class="line">        if currColor == newColor:</span><br><span class="line">            return image</span><br><span class="line">        </span><br><span class="line">        n, m = len(image), len(image[0])</span><br><span class="line">        que = collections.deque([(sr, sc)])</span><br><span class="line">        image[sr][sc] = newColor</span><br><span class="line">        while que:</span><br><span class="line">            x, y = que.popleft()</span><br><span class="line">            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:</span><br><span class="line">                if 0 &lt;= mx &lt; n and 0 &lt;= my &lt; m and image[mx][my] == currColor:</span><br><span class="line">                    que.append((mx, my))</span><br><span class="line">                    image[mx][my] = newColor</span><br><span class="line">        </span><br><span class="line">        return image</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int newColor, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    int n = imageSize, m = imageColSize[0];</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    int currColor = image[sr][sc];</span><br><span class="line">    if (currColor == newColor) return image;</span><br><span class="line">    int que[n * m][2];</span><br><span class="line">    int l = 0, r = 0;</span><br><span class="line">    que[r][0] = sr, que[r++][1] = sc;</span><br><span class="line">    image[sr][sc] = newColor;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        int x = que[l][0], y = que[l++][1];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class="line">                que[r][0] = mx, que[r++][1] = my;</span><br><span class="line">                image[mx][my] = newColor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    dx = []int&#123;1, 0, 0, -1&#125;</span><br><span class="line">    dy = []int&#123;0, 1, -1, 0&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func floodFill(image [][]int, sr int, sc int, newColor int) [][]int &#123;</span><br><span class="line">    currColor := image[sr][sc]</span><br><span class="line">    if currColor == newColor &#123;</span><br><span class="line">        return image</span><br><span class="line">    &#125;</span><br><span class="line">    n, m := len(image), len(image[0])</span><br><span class="line">    queue := [][]int&#123;&#125;</span><br><span class="line">    queue = append(queue, []int&#123;sr, sc&#125;)</span><br><span class="line">    image[sr][sc] = newColor</span><br><span class="line">    for i := 0; i &lt; len(queue); i++ &#123;</span><br><span class="line">        cell := queue[i]</span><br><span class="line">        for j := 0; j &lt; 4; j++ &#123;</span><br><span class="line">            mx, my := cell[0] + dx[j], cell[1] + dy[j]</span><br><span class="line">            if mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor &#123;</span><br><span class="line">                queue = append(queue, []int&#123;mx, my&#125;)</span><br><span class="line">                image[mx][my] = newColor</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return image</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。<br>空间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。主要为队列的开销。</p><h1 id="方法二：深度优先搜索"><a href="#方法二：深度优先搜索" class="headerlink" title="方法二：深度优先搜索"></a>方法二：深度优先搜索</h1><h2 id="思路及算法-1"><a href="#思路及算法-1" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>我们从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。</p><p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int color, int newColor) &#123;</span><br><span class="line">        if (image[x][y] == color) &#123;</span><br><span class="line">            image[x][y] = newColor;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; image.size() &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; image[0].size()) &#123;</span><br><span class="line">                    dfs(image, mx, my, color, newColor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor != newColor) &#123;</span><br><span class="line">            dfs(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    int[] dx = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    int[] dy = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor != newColor) &#123;</span><br><span class="line">            dfs(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[][] image, int x, int y, int color, int newColor) &#123;</span><br><span class="line">        if (image[x][y] == color) &#123;</span><br><span class="line">            image[x][y] = newColor;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; image.length &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; image[0].length) &#123;</span><br><span class="line">                    dfs(image, mx, my, color, newColor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]:</span><br><span class="line">        n, m = len(image), len(image[0])</span><br><span class="line">        currColor = image[sr][sc]</span><br><span class="line"></span><br><span class="line">        def dfs(x: int, y: int):</span><br><span class="line">            if image[x][y] == currColor:</span><br><span class="line">                image[x][y] = newColor</span><br><span class="line">                for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:</span><br><span class="line">                    if 0 &lt;= mx &lt; n and 0 &lt;= my &lt; m and image[mx][my] == currColor:</span><br><span class="line">                        dfs(mx, my)</span><br><span class="line"></span><br><span class="line">        if currColor != newColor:</span><br><span class="line">            dfs(sr, sc)</span><br><span class="line">        return image</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">void dfs(int** image, int x, int y, int color, int newColor) &#123;</span><br><span class="line">    if (image[x][y] == color) &#123;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m) &#123;</span><br><span class="line">                dfs(image, mx, my, color, newColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int newColor, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    n = imageSize, m = imageColSize[0];</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    int currColor = image[sr][sc];</span><br><span class="line">    if (currColor != newColor) &#123;</span><br><span class="line">        dfs(image, sr, sc, currColor, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    dx = []int&#123;1, 0, 0, -1&#125;</span><br><span class="line">    dy = []int&#123;0, 1, -1, 0&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func floodFill(image [][]int, sr int, sc int, newColor int) [][]int &#123;</span><br><span class="line">    currColor := image[sr][sc]</span><br><span class="line">    if currColor != newColor &#123;</span><br><span class="line">        dfs(image, sr, sc, currColor, newColor)</span><br><span class="line">    &#125;</span><br><span class="line">    return image</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dfs(image [][]int, x, y, color, newColor int) &#123;</span><br><span class="line">    if image[x][y] == color &#123;</span><br><span class="line">        image[x][y] = newColor</span><br><span class="line">        for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">            mx, my := x + dx[i], y + dy[i]</span><br><span class="line">            if mx &gt;= 0 &amp;&amp; mx &lt; len(image) &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; len(image[0]) &#123;</span><br><span class="line">                dfs(image, mx, my, color, newColor)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。<br>空间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。主要为栈空间的开销。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像渲染。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
    <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>463. 岛屿的周长</title>
    <link href="http://yoursite.com/2022/08/22/463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://yoursite.com/2022/08/22/463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2022-08-22T03:12:12.000Z</published>
    <updated>2022-08-22T06:47:41.313Z</updated>
    
    <content type="html"><![CDATA[<p>计算这个岛屿的周长。</p><span id="more"></span><p>[TOC]</p><p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] &#x3D; 1 表示陆地， grid[i][j] &#x3D; 0 表示水域。</p><p>网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 1：</p><pre><code>输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边</code></pre><p>示例 2：</p><pre><code>输入：grid = [[1]]输出：4示例 3：输入：grid = [[1,0]]输出：4</code></pre><p>提示：</p><pre><code>row == grid.lengthcol == grid[i].length1 &lt;= row, col &lt;= 100grid[i][j] 为 0 或 1</code></pre><h1 id="方法一：迭代-1"><a href="#方法一：迭代-1" class="headerlink" title="方法一：迭代^1"></a>方法一：迭代<a href="https://leetcode.cn/problems/island-perimeter/solution/dao-yu-de-zhou-chang-by-leetcode-solution/">^1</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即1）加入答案 ans 中即可。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    constexpr static int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    constexpr static int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line">public:</span><br><span class="line">    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        int n = grid.size(), m = grid[0].size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j]) &#123;</span><br><span class="line">                    int cnt = 0;</span><br><span class="line">                    for (int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                        int tx = i + dx[k];</span><br><span class="line">                        int ty = j + dy[k];</span><br><span class="line">                        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || !grid[tx][ty]) &#123;</span><br><span class="line">                            cnt += 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int[] dx = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    static int[] dy = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int islandPerimeter(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length, m = grid[0].length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    int cnt = 0;</span><br><span class="line">                    for (int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                        int tx = i + dx[k];</span><br><span class="line">                        int ty = j + dy[k];</span><br><span class="line">                        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || grid[tx][ty] == 0) &#123;</span><br><span class="line">                            cnt += 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type pair struct&#123; x, y int &#125;</span><br><span class="line">var dir4 = []pair&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;</span><br><span class="line"></span><br><span class="line">func islandPerimeter(grid [][]int) (ans int) &#123;</span><br><span class="line">    n, m := len(grid), len(grid[0])</span><br><span class="line">    for i, row := range grid &#123;</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == 1 &#123;</span><br><span class="line">                for _, d := range dir4 &#123;</span><br><span class="line">                    if x, y := i+d.x, j+d.y; x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0 &#123;</span><br><span class="line">                        ans++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int islandPerimeter(int** grid, int gridSize, int* gridColSize) &#123;</span><br><span class="line">    int n = gridSize, m = gridColSize[0];</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (grid[i][j]) &#123;</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                for (int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                    int tx = i + dx[k];</span><br><span class="line">                    int ty = j + dy[k];</span><br><span class="line">                    if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || !grid[tx][ty]) &#123;</span><br><span class="line">                        cnt += 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(nm)，其中 n 为网格的高度，m 为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 4 个格子是否为岛屿，因此总时间复杂度为O(4nm)&#x3D;O(nm)。<br>空间复杂度：<br>O(1)。只需要常数空间存放若干变量。</p><h1 id="方法二：深度优先搜索"><a href="#方法二：深度优先搜索" class="headerlink" title="方法二：深度优先搜索"></a>方法二：深度优先搜索</h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>我们也可以将方法一改成深度优先搜索遍历的方式，此时遍历的方式可扩展至统计多个岛屿各自的周长。需要注意的是为了防止陆地格子在深度优先搜索中被重复遍历导致死循环，我们需要将遍历过的陆地格子标记为已经遍历过，下面的代码中我们设定值为 2 的格子为已经遍历过的陆地格子。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    constexpr static int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    constexpr static int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line">public:</span><br><span class="line">    int dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;grid, int n, int m) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[x][y] == 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = 2;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int tx = x + dx[i];</span><br><span class="line">            int ty = y + dy[i];</span><br><span class="line">            res += dfs(tx, ty, grid, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        int n = grid.size(), m = grid[0].size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    ans += dfs(i, j, grid, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int[] dx = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    static int[] dy = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int islandPerimeter(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length, m = grid[0].length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    ans += dfs(i, j, grid, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dfs(int x, int y, int[][] grid, int n, int m) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[x][y] == 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = 2;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int tx = x + dx[i];</span><br><span class="line">            int ty = y + dy[i];</span><br><span class="line">            res += dfs(tx, ty, grid, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type pair struct&#123; x, y int &#125;</span><br><span class="line">var dir4 = []pair&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;</span><br><span class="line"></span><br><span class="line">func islandPerimeter(grid [][]int) (ans int) &#123;</span><br><span class="line">    n, m := len(grid), len(grid[0])</span><br><span class="line">    var dfs func(x, y int)</span><br><span class="line">    dfs = func(x, y int) &#123;</span><br><span class="line">        if x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0 &#123;</span><br><span class="line">            ans++</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if grid[x][y] == 2 &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = 2</span><br><span class="line">        for _, d := range dir4 &#123;</span><br><span class="line">            dfs(x+d.x, y+d.y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i, row := range grid &#123;</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == 1 &#123;</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary></summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int dfs(int x, int y, int** grid, int n, int m) &#123;</span><br><span class="line">    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (grid[x][y] == 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = 2;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">        int tx = x + dx[i];</span><br><span class="line">        int ty = y + dy[i];</span><br><span class="line">        res += dfs(tx, ty, grid, n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int islandPerimeter(int** grid, int gridSize, int* gridColSize) &#123;</span><br><span class="line">    int n = gridSize, m = gridColSize[0];</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                ans += dfs(i, j, grid, n, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(nm)，其中 n 为网格的高度，m 为网格的宽度。每个格子至多会被遍历一次，因此总时间复杂度为 O(nm)。<br>空间复杂度：O(nm)。深度优先搜索复杂度取决于递归的栈空间，而栈空间最坏情况下会达到 O(nm)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算这个岛屿的周长。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
    <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>748. 最短补全词</title>
    <link href="http://yoursite.com/2022/08/09/748.%20%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/"/>
    <id>http://yoursite.com/2022/08/09/748.%20%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/</id>
    <published>2022-08-09T02:12:12.000Z</published>
    <updated>2022-08-09T03:37:36.854Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。</p><span id="more"></span><p>[TOC]</p><p>补全词 是一个包含 licensePlate 中所有字母的单词。忽略 licensePlate 中的 数字和空格 。不区分大小写。如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。</p><p>例如：licensePlate &#x3D; “aBc 12c”，那么它的补全词应当包含字母 ‘a’、’b’ （忽略大写）和两个 ‘c’ 。可能的 补全词 有 “abccdef”、”caaacab” 以及 “cbca” 。</p><p>请返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 第一个 出现的那个。<a href="https://leetcode.cn/problems/shortest-completing-word/">^1</a></p><p>示例 1：</p><pre><code>输入：licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]输出：&quot;steps&quot;解释：最短补全词应该包括 &quot;s&quot;、&quot;p&quot;、&quot;s&quot;（忽略大小写） 以及 &quot;t&quot;。&quot;step&quot; 包含 &quot;t&quot;、&quot;p&quot;，但只包含一个 &quot;s&quot;，所以它不符合条件。&quot;steps&quot; 包含 &quot;t&quot;、&quot;p&quot; 和两个 &quot;s&quot;。&quot;stripe&quot; 缺一个 &quot;s&quot;。&quot;stepple&quot; 缺一个 &quot;s&quot;。因此，&quot;steps&quot; 是唯一一个包含所有字母的单词，也是本例的答案。</code></pre><p>示例 2：</p><pre><code>输入：licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]输出：&quot;pest&quot;解释：licensePlate 只包含字母 &quot;s&quot; 。所有的单词都包含字母 &quot;s&quot; ，其中 &quot;pest&quot;、&quot;stew&quot;、和 &quot;show&quot; 三者最短。答案是 &quot;pest&quot; ，因为它是三个单词中在 words 里最靠前的那个。</code></pre><p>提示：</p><pre><code>1 &lt;= licensePlate.length &lt;= 7licensePlate 由数字、大小写字母或空格 &#39; &#39; 组成1 &lt;= words.length &lt;= 10001 &lt;= words[i].length &lt;= 15words[i] 由小写英文字母组成</code></pre><h1 id="根据字符串长度对vector数组进行稳定排序-哈希表"><a href="#根据字符串长度对vector数组进行稳定排序-哈希表" class="headerlink" title="根据字符串长度对vector数组进行稳定排序 + 哈希表"></a>根据字符串长度对vector数组进行稳定排序 + 哈希表</h1><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void sortByLen(vector&lt;string&gt; &amp;words)&#123;</span><br><span class="line">        stable_sort(words.begin(),words.end(),[](string a, string b)&#123;</span><br><span class="line">            return a.length()&lt;b.length();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;char,int&gt; sToMap(string s)&#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; map;</span><br><span class="line">        for(auto c: s)&#123;</span><br><span class="line">            if(isalpha(c))&#123;</span><br><span class="line">                map[tolower(c)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string shortestCompletingWord(string licensePlate, vector&lt;string&gt; &amp;words) &#123;</span><br><span class="line">        sortByLen(words);</span><br><span class="line">        unordered_map&lt;char, int&gt; map=sToMap(licensePlate);</span><br><span class="line">        for(auto &amp;s: words)&#123;</span><br><span class="line">            unordered_map&lt;char, int&gt; dic=sToMap(s);</span><br><span class="line">            bool contain=true;</span><br><span class="line">            for(auto a:map)&#123;</span><br><span class="line">                if(dic.count(a.first)==0)&#123;</span><br><span class="line">                    contain = false;</span><br><span class="line">                &#125;else if(dic[a.first] &lt; a.second)&#123;</span><br><span class="line">                    contain = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(contain)&#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void unstableSortByLen(String[] words) &#123;</span><br><span class="line">        Arrays.sort(words, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String o1, String o2) &#123;</span><br><span class="line">                return o1.length() - o2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stableSortByLen(ArrayList&lt;String&gt; words) &#123;</span><br><span class="line">        //对于Arrays.sort(int[] var0)使用的是快排,所以是不稳定的.但是试了下发现这个也能过</span><br><span class="line">        //对于Collections.sort(List&lt;T&gt; elements)使用的是归并排序,是稳定的.</span><br><span class="line">        Collections.sort(words, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String s1, String s2) &#123;</span><br><span class="line">                return s1.length() - s2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sToMap(HashMap&lt;Character, Integer&gt; map, String s) &#123;</span><br><span class="line">        for (Character c : s.toCharArray()) &#123;</span><br><span class="line">            if (Character.isAlphabetic(c)) &#123;</span><br><span class="line">                 map.put(Character.toLowerCase(c), map.getOrDefault(Character.toLowerCase(c), 0) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String shortestCompletingWord(String licensePlate, String[] words) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; word = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(word, words);</span><br><span class="line">        stableSortByLen(word);</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        sToMap(map, licensePlate);</span><br><span class="line">        for (String s : word) &#123;</span><br><span class="line">            boolean flag = true;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; mapWords = new HashMap&lt;&gt;();</span><br><span class="line">            sToMap(mapWords, s);</span><br><span class="line">            for (Character c : map.keySet()) &#123;</span><br><span class="line">                if (mapWords.getOrDefault(c, 0) == 0) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if (mapWords.getOrDefault(c, 0) &lt; map.get(c)) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>C++二维动态静态数组传参速查</title>
    <link href="http://yoursite.com/2022/08/05/C++%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E9%80%9F%E6%9F%A5/"/>
    <id>http://yoursite.com/2022/08/05/C++%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E9%80%9F%E6%9F%A5/</id>
    <published>2022-08-05T10:12:12.000Z</published>
    <updated>2022-08-08T02:16:55.082Z</updated>
    
    <content type="html"><![CDATA[<p>动态静态数组传参数都是引用传递</p><span id="more"></span><p>[TOC]</p><p>参考<a href="https://www.cnblogs.com/usa007lhy/p/3286186.html">^1</a></p><details>    <summary>动态静态数组传参</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//  二维数组</span><br><span class="line">//  Created by yiye on 2022/8/4.</span><br><span class="line">//https://www.cnblogs.com/usa007lhy/p/3286186.html</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//void iniMatrix(int a[3][5], int rows)&#123;</span><br><span class="line">void iniMatrix(int a[][5], int rows)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******初始化二维静态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;5;j++)&#123;</span><br><span class="line">            a[i][j]=i*10+j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void iniDynamicMatrix(int **a, int rows, int cols)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******初始化二维动态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;cols;j++)&#123;</span><br><span class="line">            a[i][j]=i*10+j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printStaticMatrix(int a[][5],int rows)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******打印二维静态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;5;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void printDynamicMatrix(int **a,int rows, int cols)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******打印二维动态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;cols;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void changeArray(int *num, int len)&#123;</span><br><span class="line">    for(int i=0;i&lt;len/2;i++)&#123;</span><br><span class="line">        num[i] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printArray(int *num, int len)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;**********打印一维数组**********&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printStaticMatrix(int **num, int row, int col)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******打印二维静态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for (int i=0; i&lt;row; i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;col; j++) &#123;</span><br><span class="line">            cout&lt;&lt;*((int *)num + col*i+j)&lt;&lt;&quot; &quot;; // 可行方案</span><br><span class="line">//            cout&lt;&lt;((int *)num + col*i)[j]&lt;&lt;&quot; &quot;; //可行方案</span><br><span class="line">//            cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;;//不可行方案</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int a[3][5];</span><br><span class="line">    iniMatrix(a, 3);</span><br><span class="line">    printStaticMatrix(a, 3);</span><br><span class="line">    printStaticMatrix((int **)a, 3, 5);</span><br><span class="line">    cout&lt;&lt;&quot;*******新的二维数组******&quot;&lt;&lt;endl;</span><br><span class="line">    int b[][5] = &#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;</span><br><span class="line">    printStaticMatrix(b, 3);</span><br><span class="line">    int len = 5;</span><br><span class="line">    int num[5]=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    printArray(num, 5);</span><br><span class="line">    changeArray(num, len);</span><br><span class="line">    printArray(num, 5);</span><br><span class="line">    cout&lt;&lt;&quot;#####静态数组传参数是引用传递#####&quot;&lt;&lt;endl;</span><br><span class="line">    int *num2 = new int[len];</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        num2[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(num2, len);</span><br><span class="line">    changeArray(num2, len);</span><br><span class="line">    printArray(num2, len);</span><br><span class="line">    cout&lt;&lt;&quot;#####动态数组传参数是引用传递#####&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] num2;</span><br><span class="line">    </span><br><span class="line">    int row = 3, col=5;</span><br><span class="line">    int **num3  = new int*[row];</span><br><span class="line">    for (int i=0; i&lt;row; i++) &#123;</span><br><span class="line">        num3[i]=new int[col];</span><br><span class="line">    &#125;</span><br><span class="line">    iniDynamicMatrix(num3, row, col);</span><br><span class="line">    printDynamicMatrix(num3, row, col);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态静态数组传参数都是引用传递&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树(剑指 Offer 07. 重建二叉树)</title>
    <link href="http://yoursite.com/2022/07/14/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91)/"/>
    <id>http://yoursite.com/2022/07/14/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91)/</id>
    <published>2022-07-14T06:12:12.000Z</published>
    <updated>2022-07-14T10:06:12.239Z</updated>
    
    <content type="html"><![CDATA[<p>剑指 Offer 07. 重建二叉树</p><span id="more"></span><p>[TOC]</p><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p>示例 1:</p><pre><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p>示例 2:</p><pre><code>输入: preorder = [-1], inorder = [-1]输出: [-1]</code></pre><p>提示:</p><pre><code>1 &lt;= preorder.length &lt;= 3000inorder.length == preorder.length-3000 &lt;= preorder[i], inorder[i] &lt;= 3000preorder 和 inorder 均 无重复 元素inorder 均出现在 preorderpreorder 保证 为二叉树的前序遍历序列inorder 保证 为二叉树的中序遍历序列</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二叉树前序遍历的顺序为：</p><p>先遍历根节点；<br>随后递归地遍历左子树；<br>最后递归地遍历右子树。<br>二叉树中序遍历的顺序为：</p><p>先递归地遍历左子树；<br>随后遍历根节点；<br>最后递归地遍历右子树。<br>在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于任意一颗树而言，前序遍历的形式总是</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)的时间对根节点进行定位了</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, int&gt; index;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 前序遍历中的第一个节点就是根节点</span><br><span class="line">        int preorder_root = preorder_left;</span><br><span class="line">        // 在中序遍历中定位根节点</span><br><span class="line">        int inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        </span><br><span class="line">        // 先把根节点建立出来</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[preorder_root]);</span><br><span class="line">        // 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        // 递归地构造左子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        // 递归地构造右子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        int n = preorder.size();</span><br><span class="line">        // 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 前序遍历中的第一个节点就是根节点</span><br><span class="line">        int preorder_root = preorder_left;</span><br><span class="line">        // 在中序遍历中定位根节点</span><br><span class="line">        int inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">        </span><br><span class="line">        // 先把根节点建立出来</span><br><span class="line">        TreeNode root = new TreeNode(preorder[preorder_root]);</span><br><span class="line">        // 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        // 递归地构造左子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        // 递归地构造右子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        int n = preorder.length;</span><br><span class="line">        // 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        indexMap = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:</span><br><span class="line">        def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int):</span><br><span class="line">            if preorder_left &gt; preorder_right:</span><br><span class="line">                return None</span><br><span class="line">            </span><br><span class="line">            # 前序遍历中的第一个节点就是根节点</span><br><span class="line">            preorder_root = preorder_left</span><br><span class="line">            # 在中序遍历中定位根节点</span><br><span class="line">            inorder_root = index[preorder[preorder_root]]</span><br><span class="line">            </span><br><span class="line">            # 先把根节点建立出来</span><br><span class="line">            root = TreeNode(preorder[preorder_root])</span><br><span class="line">            # 得到左子树中的节点数目</span><br><span class="line">            size_left_subtree = inorder_root - inorder_left</span><br><span class="line">            # 递归地构造左子树，并连接到根节点</span><br><span class="line">            # 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">            root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1)</span><br><span class="line">            # 递归地构造右子树，并连接到根节点</span><br><span class="line">            # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">            root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right)</span><br><span class="line">            return root</span><br><span class="line">        </span><br><span class="line">        n = len(preorder)</span><br><span class="line">        # 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        index = &#123;element: i for i, element in enumerate(inorder)&#125;</span><br><span class="line">        return myBuildTree(0, n - 1, 0, n - 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func buildTree(preorder []int, inorder []int) *TreeNode &#123;</span><br><span class="line">    if len(preorder) == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;preorder[0], nil, nil&#125;</span><br><span class="line">    i := 0</span><br><span class="line">    for ; i &lt; len(inorder); i++ &#123;</span><br><span class="line">        if inorder[i] == preorder[0] &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left = buildTree(preorder[1:len(inorder[:i])+1], inorder[:i])</span><br><span class="line">    root.Right = buildTree(preorder[len(inorder[:i])+1:], inorder[i+1:])</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是树中的节点个数。<br>空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及<br>O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</p><h1 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>迭代法是一种非常巧妙的实现方法。</p><p>对于前序遍历中的任意两个连续节点<br>u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：<br>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；</p><p>u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果<br>u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果<br>u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点 ua ，那么<br>v 就是 ua  的右儿子。</p><p>第二种关系看上去有些复杂。我们举一个例子来说明其正确性，并在例子中给出我们的迭代算法。</p><p>我们以树</p><pre><code>        3       / \      9  20     /  /  \    8  15   7   / \  5  10 /4</code></pre><p>为例，它的前序遍历和中序遍历分别为</p><p>preorder &#x3D; [3, 9, 8, 5, 4, 10, 20, 15, 7]<br>inorder &#x3D; [4, 5, 8, 10, 9, 3, 15, 20, 7]</p><p>我们用一个栈 stack 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 index 指向中序遍历的某个位置，初始值为 0。index 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p><p>首先我们将根节点 3 入栈，再初始化 index 所指向的节点为 4，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p><p>我们遍历 9。9 一定是栈顶节点 3 的左儿子。我们使用反证法，假设 9 是 3 的右儿子，那么 3 没有左儿子，index 应该恰好指向 3，但实际上为 4，因此产生了矛盾。所以我们将 9 作为 3 的左儿子，并将 9 入栈。</p><p>stack &#x3D; [3, 9]<br>index -&gt; inorder[0] &#x3D; 4</p><p>我们遍历 8，5 和 4。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p><p>stack &#x3D; [3, 9, 8, 5, 4]<br>index -&gt; inorder[0] &#x3D; 4</p><p>我们遍历 10，这时情况就不一样了。我们发现 index 恰好指向当前的栈顶节点 4，也就是说 4 没有左儿子，那么 10 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。</p><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p><p>因此我们可以把 index 不断向右移动，并与栈顶节点进行比较。如果 index 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 index 增加 1 并弹出栈顶节点，直到 index 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 x 就是 10 的双亲节点，这是因为 10 出现在了 x 与 x 在栈中的下一个节点的中序遍历之间，因此 10 就是 x 的右儿子。</p><p>回到我们的例子，我们会依次从栈顶弹出 4，5 和 8，并且将 index 向右移动了三次。我们将 10 作为最后弹出的节点 8 的右儿子，并将 10 入栈。</p><p>stack &#x3D; [3, 9, 10]<br>index -&gt; inorder[3] &#x3D; 10</p><p>我们遍历 20。同理，index 恰好指向当前栈顶节点 10，那么我们会依次从栈顶弹出 10，9 和 3，并且将 index 向右移动了三次。我们将 20 作为最后弹出的节点 3 的右儿子，并将 20 入栈。</p><p>stack &#x3D; [20]<br>index -&gt; inorder[6] &#x3D; 15</p><p>我们遍历 15，将 15 作为栈顶节点 20 的左儿子，并将 15 入栈。</p><p>stack &#x3D; [20, 15]<br>index -&gt; inorder[6] &#x3D; 15</p><p>我们遍历 7。index 恰好指向当前栈顶节点 15，那么我们会依次从栈顶弹出 15 和 20，并且将 index 向右移动了两次。我们将 7 作为最后弹出的节点 20 的右儿子，并将 7 入栈。</p><p>stack &#x3D; [7]<br>index -&gt; inorder[8] &#x3D; 7</p><p>此时遍历结束，我们就构造出了正确的二叉树。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>我们归纳出上述例子中的算法流程：</p><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p><p>无论是哪一种情况，我们最后都将当前的节点入栈。<br>最后得到的二叉树即为答案。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        if (!preorder.size()) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[0]);</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        int inorderIndex = 0;</span><br><span class="line">        for (int i = 1; i &lt; preorder.size(); ++i) &#123;</span><br><span class="line">            int preorderVal = preorder[i];</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            if (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;left = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    ++inorderIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;right = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if (preorder == null || preorder.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = new TreeNode(preorder[0]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        int inorderIndex = 0;</span><br><span class="line">        for (int i = 1; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            int preorderVal = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            if (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left = new TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = new TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:</span><br><span class="line">        if not preorder:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        root = TreeNode(preorder[0])</span><br><span class="line">        stack = [root]</span><br><span class="line">        inorderIndex = 0</span><br><span class="line">        for i in range(1, len(preorder)):</span><br><span class="line">            preorderVal = preorder[i]</span><br><span class="line">            node = stack[-1]</span><br><span class="line">            if node.val != inorder[inorderIndex]:</span><br><span class="line">                node.left = TreeNode(preorderVal)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            else:</span><br><span class="line">                while stack and stack[-1].val == inorder[inorderIndex]:</span><br><span class="line">                    node = stack.pop()</span><br><span class="line">                    inorderIndex += 1</span><br><span class="line">                node.right = TreeNode(preorderVal)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">func buildTree(preorder []int, inorder []int) *TreeNode &#123;</span><br><span class="line">    if len(preorder) == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;preorder[0], nil, nil&#125;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    stack = append(stack, root)</span><br><span class="line">    var inorderIndex int</span><br><span class="line">    for i := 1; i &lt; len(preorder); i++ &#123;</span><br><span class="line">        preorderVal := preorder[i]</span><br><span class="line">        node := stack[len(stack)-1]</span><br><span class="line">        if node.Val != inorder[inorderIndex] &#123;</span><br><span class="line">            node.Left = &amp;TreeNode&#123;preorderVal, nil, nil&#125;</span><br><span class="line">            stack = append(stack, node.Left)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for len(stack) != 0 &amp;&amp; stack[len(stack)-1].Val == inorder[inorderIndex] &#123;</span><br><span class="line">                node = stack[len(stack)-1]</span><br><span class="line">                stack = stack[:len(stack)-1]</span><br><span class="line">                inorderIndex++</span><br><span class="line">            &#125;</span><br><span class="line">            node.Right = &amp;TreeNode&#123;preorderVal, nil, nil&#125;</span><br><span class="line">            stack = append(stack, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中 n 是树中的节点个数。</p><p>空间复杂度：<br>O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里h&lt;n，所以（在最坏情况下）总空间复杂度为 O(n)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;剑指 Offer 07. 重建二叉树&lt;/p&gt;</summary>
    
    
    
    <category term="2022年7月" scheme="http://yoursite.com/categories/2022%E5%B9%B47%E6%9C%88/"/>
    
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
    <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/06/13/Flask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/06/13/Flask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-13T10:00:12.000Z</published>
    <updated>2022-07-07T09:03:20.135Z</updated>
    
    <content type="html"><![CDATA[<p>Flask学习笔记</p><span id="more"></span><p>[TOC]</p><p>学习教程参考<a href="https://www.w3cschool.cn/flask/flask_application.html">^1</a></p><h1 id="命令行启动notebook"><a href="#命令行启动notebook" class="headerlink" title="命令行启动notebook"></a>命令行启动notebook</h1><p>python3 -m IPython notebook</p><p>-m参数 “mod”是“module”的缩写，即“-m”选项后面的内容是 module（模块），其作用是把模块当成脚本来运行。<a href="https://zhuanlan.zhihu.com/p/91120727">^4</a></p><h1 id="内置变量：name"><a href="#内置变量：name" class="headerlink" title="内置变量：name"></a>内置变量：<strong>name</strong></h1><h2 id="不同情况下的-name-的值-2"><a href="#不同情况下的-name-的值-2" class="headerlink" title="不同情况下的 name 的值^2"></a>不同情况下的 <strong>name</strong> 的值<a href="https://zhuanlan.zhihu.com/p/157439994">^2</a></h2><p>首先我们需要知道 <strong>name</strong> 在不同情况下会有不同值，它的值取决于我们是如何执行脚本的.</p><p>有时候，我们用 Python 写了一个脚本，当我们既希望这个脚本可以单独运行，同样希望它可以在其他的脚本中发挥作用. 这个时候就需要考虑使用 <strong>name</strong> 了. </p><h1 id="运行遇到的错误及解决方案"><a href="#运行遇到的错误及解决方案" class="headerlink" title="运行遇到的错误及解决方案"></a>运行遇到的错误及解决方案</h1><h2 id="zmq-error-ZMQError-Address-already-in-use-3"><a href="#zmq-error-ZMQError-Address-already-in-use-3" class="headerlink" title="zmq.error.ZMQError: Address already in use ^3"></a>zmq.error.ZMQError: Address already in use <a href="https://www.cnblogs.com/shengulong/p/8207179.html">^3</a></h2><pre><code>app.run(debug = True)</code></pre><p>开启debug模式后端口报被占用</p><p>之前用的是<a href="http://localhost:5000/">http://localhost:5000</a></p><p>sudo lsof -i:5000</p><p>sudo kill PID</p><h2 id="查找指定名称（例如python）的进程并显示进程详细信息"><a href="#查找指定名称（例如python）的进程并显示进程详细信息" class="headerlink" title="查找指定名称（例如python）的进程并显示进程详细信息"></a>查找指定名称（例如python）的进程并显示进程详细信息</h2><p>ps -ef  | grep python</p><p>但是如果关掉flask的debug模式，就没有问题</p><p>6、原因是：flask的debug模式会额外开启一个进程，这个进程负责监控代码是否发生变化，如果发生变化，会自动重启应用，使新修改代码立即自动生效；因此我猜想，是这个进程破坏了rpc服务的启动。</p><p>DEBUG模式下flask多开一个线程来监视项目的变化。</p><p>The first thing it does is start the main function in a new thread so it can monitor &gt;the source files and restart the thread when they change.</p><p>参考自这篇文章<a href="http://stackoverflow.com/questions/9276078/whats-the-right-approach-for-calling-functions-after-a-flask-app-is-run%E3%80%82">http://stackoverflow.com/questions/9276078/whats-the-right-approach-for-calling-functions-after-a-flask-app-is-run。</a></p><p>如果你想要避免加载两次，应该设置</p><pre><code>app.run(debug=True, use_reloader=False)</code></pre><h2 id="文件上传报错：FileNotFoundError-Errno-2-No-such-file-or-directory"><a href="#文件上传报错：FileNotFoundError-Errno-2-No-such-file-or-directory" class="headerlink" title="文件上传报错：FileNotFoundError: [Errno 2] No such file or directory:"></a>文件上传报错：FileNotFoundError: [Errno 2] No such file or directory:</h2><p>根据代码内容，需要在代码的根目录下创建一个文件夹upload才能保存文件</p><h2 id="Flask-WTF-ImportError-cannot-import-name-‘ContactForm’-from-‘forms’"><a href="#Flask-WTF-ImportError-cannot-import-name-‘ContactForm’-from-‘forms’" class="headerlink" title="Flask WTF : ImportError: cannot import name ‘ContactForm’ from ‘forms’"></a>Flask WTF : ImportError: cannot import name ‘ContactForm’ from ‘forms’</h2><p>这个ContactForm是自己建的forms.py文件中的类</p><h2 id="ImportError-cannot-import-name-‘TextField’-from-‘wtforms’"><a href="#ImportError-cannot-import-name-‘TextField’-from-‘wtforms’" class="headerlink" title="ImportError: cannot import name ‘TextField’ from ‘wtforms’"></a>ImportError: cannot import name ‘TextField’ from ‘wtforms’</h2><p>原因是版本更新问题</p><pre><code>from wtforms import StringField</code></pre><p>使用StringField即可</p><h2 id="AttributeError-module-‘wtforms-validators’-has-no-attribute-‘Required’"><a href="#AttributeError-module-‘wtforms-validators’-has-no-attribute-‘Required’" class="headerlink" title="AttributeError: module ‘wtforms.validators’ has no attribute ‘Required’"></a>AttributeError: module ‘wtforms.validators’ has no attribute ‘Required’</h2><p>looks like wtforms.validators split the Required into DataRequired and InputRequired in version version 1.0.2</p><p>新版本将Required换成InputRequired</p><h2 id="Install-‘email-validator’-for-email-validation-support"><a href="#Install-‘email-validator’-for-email-validation-support" class="headerlink" title="Install ‘email_validator’ for email validation support."></a>Install ‘email_validator’ for email validation support.</h2><p>还是版本兼容问题</p><h2 id="TypeError-init-takes-1-positional-argument-but-5-were-given"><a href="#TypeError-init-takes-1-positional-argument-but-5-were-given" class="headerlink" title="TypeError: init() takes 1 positional argument but 5 were given"></a>TypeError: <strong>init</strong>() takes 1 positional argument but 5 were given</h2><p>在 Flask SQLAlchemy中 students 的class初始化函数如下：</p><pre><code>def __init__(self, name, city, addr,pin):</code></pre><p>调用的时候赋值：</p><pre><code> student = students(request.form[&#39;name&#39;], request.form[&#39;city&#39;],    request.form[&#39;addr&#39;], request.form[&#39;pin&#39;])</code></pre><p>报错：</p><p>改成下列调用方式即可</p><pre><code>student = students(name = request.form[&#39;name&#39;], city = request.form[&#39;city&#39;],                           addr = request.form[&#39;addr&#39;], pin = request.form[&#39;pin&#39;])</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flask学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="2022年6月" scheme="http://yoursite.com/categories/2022%E5%B9%B46%E6%9C%88/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>从文本中读取数据</title>
    <link href="http://yoursite.com/2022/05/22/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2022/05/22/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/</id>
    <published>2022-05-22T00:12:12.000Z</published>
    <updated>2022-08-08T02:17:07.249Z</updated>
    
    <content type="html"><![CDATA[<p>从文本中读取数据</p><span id="more"></span><p>[TOC]</p><p>一些比赛遇到需要从文本中读取输入数据,读取方式如下</p><h1 id="fstream读取"><a href="#fstream读取" class="headerlink" title="fstream读取"></a>fstream读取</h1><details>    <summary>从文本中读取文件</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    ifstream inFile(&quot;in.txt&quot;);</span><br><span class="line">    ofstream outFile(&quot;out.txt&quot;);</span><br><span class="line">    if (!inFile.is_open())&#123;</span><br><span class="line">       cerr &lt;&lt; &quot;open file failed!&quot; &lt;&lt; endl;</span><br><span class="line">       exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    int num=0;</span><br><span class="line">    string str;</span><br><span class="line">    inFile&gt;&gt;num;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    outFile&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    while(!inFile.eof())&#123;</span><br><span class="line">        getline(inFile, str);</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        outFile&lt;&lt;str;</span><br><span class="line">    &#125;</span><br><span class="line">    inFile.close();</span><br><span class="line">    outFile.close();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="修改配置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory"><a href="#修改配置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory" class="headerlink" title="修改配置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory"></a>修改配置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory</h1><p>但是在Xcode中一开始无法读入，发现问题是因为没有配置路径<a href="http://stackoverflow.com/questions/23438393/new-to-xcode-cant-open-files-in-c">^1</a></p><p>Put your .txt files in the same directory where your main.cpp file is (or anywhere you like).</p><p>In Xcode go to Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top) </p><p>Down under Options check “Use custom working directory” and set it to the directory where you .txt files are located. </p><p>To work with the files, you will have to specify just file names, e.g. in_file.open(“inputFile.txt”); no path is necessary.</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Scanner scanner = new Scanner(new File(System.getProperty(&quot;user.dir&quot;) + &quot;/src/in.txt&quot;));</span><br><span class="line">       while (scanner.hasNext()) &#123;</span><br><span class="line">           String number = scanner.nextLine();</span><br><span class="line">           Integer num = Integer.valueOf(number);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">with open(&#x27;number.txt&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        f.write(str(random.randint(1, 10))+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">L = []</span><br><span class="line">with open(&#x27;number.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    read_data = f.read()</span><br><span class="line">    strs = read_data.split();</span><br><span class="line">    for i in strs:</span><br><span class="line">        L.append(int(i))</span><br><span class="line">    L.sort()</span><br><span class="line">    print(L)</span><br><span class="line">     </span><br></pre></td></tr></table></figure></details><h1 id="Mac上无法读取data-in文件，而改成data-in就可以读取"><a href="#Mac上无法读取data-in文件，而改成data-in就可以读取" class="headerlink" title="Mac上无法读取data.in文件，而改成data.in就可以读取"></a>Mac上无法读取data.in文件，而改成data.in就可以读取</h1><p>首先需要确认data.in文件后缀是否为txt，打开文件简介，要在简介里才能看到真实的扩展名<br>看文件种类也可以区分，如果是txt后缀文件种类是纯文本文档，<br>如果后缀就是为.in或.out文件种类就是文本编辑文档</p><p>但修改后发现还是不行，同样的代码在windows下用VS可以读取，但在Mac下用Xcode无法读取.in文件</p><h2 id="最后发现如果先用代码创建data-in然后再读取就可以"><a href="#最后发现如果先用代码创建data-in然后再读取就可以" class="headerlink" title="最后发现如果先用代码创建data.in然后再读取就可以"></a>最后发现如果先用代码创建data.in然后再读取就可以</h2><p>手工创建就不行，可能还是手动创建的文本格式不对。用data.out复制改后缀为data.in一开始也不行，后来可以了。</p><h1 id="Visual-Studio设置文本输入输出"><a href="#Visual-Studio设置文本输入输出" class="headerlink" title="Visual Studio设置文本输入输出"></a>Visual Studio设置文本输入输出</h1><p>打开解决方案管理器然后在管理方案那里右键点击，选择属性<br>然后选择通配属性，里面的命令行设置为&lt;input.txt表示把文件input.txt作为我们运行程序的输入流。 </p><blockquote><p>output.txt表示把文件output.txt作为程序的输出流。</p></blockquote><h1 id="Visual-Studio一个项目下建立多个源代码"><a href="#Visual-Studio一个项目下建立多个源代码" class="headerlink" title="Visual Studio一个项目下建立多个源代码"></a>Visual Studio一个项目下建立多个源代码</h1><p>在不用包括main函数的代码，右键属性-》常规-》从生成中排除-》选择是<br>就不会报错了</p><h1 id="XCode一个项目下建立多个源代码"><a href="#XCode一个项目下建立多个源代码" class="headerlink" title="XCode一个项目下建立多个源代码"></a>XCode一个项目下建立多个源代码</h1><p>File-》New-》Target-》Command Line Tool</p><p>就可以新建，运行时选择中间上方选择当前的target目录就可以</p><h1 id="每次创建新的Target时都要设置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory，-不然无法读取新文件！！！"><a href="#每次创建新的Target时都要设置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory，-不然无法读取新文件！！！" class="headerlink" title="每次创建新的Target时都要设置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory， 不然无法读取新文件！！！"></a>每次创建新的Target时都要设置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory， 不然无法读取新文件！！！</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;从文本中读取数据&lt;/p&gt;</summary>
    
    
    
    <category term="2022年5月" scheme="http://yoursite.com/categories/2022%E5%B9%B45%E6%9C%88/"/>
    
    
    <category term="fstream" scheme="http://yoursite.com/tags/fstream/"/>
    
  </entry>
  
</feed>
