<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-28T12:05:13.304Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>739. 每日温度</title>
    <link href="http://yoursite.com/2021/11/26/739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>http://yoursite.com/2021/11/26/739. 每日温度/</id>
    <published>2021-11-26T11:12:12.000Z</published>
    <updated>2021-11-28T12:05:13.304Z</updated>
    
    <content type="html"><![CDATA[<p>请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: temperatures = [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0]</code></pre><p>示例 2:</p><pre><code>输入: temperatures = [30,40,50,60]输出: [1,1,1,0]</code></pre><p>示例 3:</p><pre><code>输入: temperatures = [30,60,90]输出: [1,1,0]</code></pre><p>提示：</p><pre><code>1 &lt;= temperatures.length &lt;= 10530 &lt;= temperatures[i] &lt;= 100</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h2><p>对于温度列表中的每个元素 <code>temperatures[i]</code>，需要找到最小的下标 <code>j</code>，使得 <code>i &lt; j</code> 且 <code>temperatures[i] &lt; temperatures[j]</code>。</p><p>由于温度范围在 <code>[30, 100]</code> 之内，因此可以维护一个数组 <code>next</code> 记录每个温度第一次出现的下标。数组 <code>next</code> 中的元素初始化为无穷大，在遍历温度列表的过程中更新 <code>next</code> 的值。</p><p>反向遍历温度列表。对于每个元素 <code>temperatures[i]</code>，在数组 <code>next</code> 中找到从 <code>temperatures[i] + 1</code> 到 <code>100</code> 中每个温度第一次出现的下标，将其中的最小下标记为 <code>warmerIndex</code>，则 <code>warmerIndex</code> 为下一次温度比当天高的下标。如果 <code>warmerIndex</code> 不为无穷大，则 <code>warmerIndex - i</code> 即为下一次温度比当天高的等待天数，最后令 <code>next[temperatures[i]] = i</code>。</p><p>为什么上述做法可以保证正确呢？因为遍历温度列表的方向是反向，当遍历到元素 <code>temperatures[i]</code> 时，只有 <code>temperatures[i]</code> 后面的元素被访问过，即对于任意 <code>t</code>，当 <code>next[t]</code> 不为无穷大时，一定存在 <code>j</code> 使得 <code>temperatures[j] == t</code> 且 <code>i &lt; j</code>。又由于遍历到温度列表中的每个元素时都会更新数组 <code>next</code> 中的对应温度的元素值，因此对于任意 <code>t</code>，当 <code>next[t]</code> 不为无穷大时，令 <code>j = next[t]</code>，则 <code>j</code> 是满足 <code>temperatures[j] == t</code> 且 <code>i &lt; j</code> 的最小下标。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        Arrays.fill(next, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> warmerIndex = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = temperatures[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; ++t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next[t] &lt; warmerIndex) &#123;</span><br><span class="line">                    warmerIndex = next[t];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (warmerIndex &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                ans[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            next[temperatures[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(temperatures)</span><br><span class="line">        ans, nxt, big = [<span class="number">0</span>] * n, dict(), <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            warmer_index = min(nxt.get(t, big) <span class="keyword">for</span> t <span class="keyword">in</span> range(temperatures[i] + <span class="number">1</span>, <span class="number">102</span>))</span><br><span class="line">            <span class="keyword">if</span> warmer_index != big:</span><br><span class="line">                ans[i] = warmer_index - i</span><br><span class="line">            nxt[temperatures[i]] = i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n), next(<span class="number">101</span>, INT_MAX);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> warmerIndex = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = temperatures[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; ++t) &#123;</span><br><span class="line">                warmerIndex = min(warmerIndex, next[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (warmerIndex != INT_MAX) &#123;</span><br><span class="line">                ans[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            next[temperatures[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(temperatures)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">101</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">101</span>; i++ &#123;</span><br><span class="line">        next[i] = math.MaxInt32</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        warmerIndex := math.MaxInt32</span><br><span class="line">        <span class="keyword">for</span> t := temperatures[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; t++ &#123;</span><br><span class="line">            <span class="keyword">if</span> next[t] &lt; warmerIndex &#123;</span><br><span class="line">                warmerIndex = next[t]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> warmerIndex &lt; math.MaxInt32 &#123;</span><br><span class="line">            ans[i] = warmerIndex - i</span><br><span class="line">        &#125;</span><br><span class="line">        next[temperatures[i]] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(nm)*，其中 *n</em> 是温度列表的长度，<em>m</em> 是数组 <code>next</code> 的长度，在本题中温度不超过 <em>100*，所以 *m</em> 的值为 <em>100</em>。反向遍历温度列表一遍，对于温度列表中的每个值，都要遍历数组 <code>next</code> 一遍。</p></li><li><p>空间复杂度：<em>O(m)*，其中 *m</em> 是数组 <code>next</code> 的长度。除了返回值以外，需要维护长度为 <em>m</em> 的数组 <code>next</code> 记录每个温度第一次出现的下标位置。</p></li></ul><h2 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h2><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表。对于温度列表中的每个元素 <code>temperatures[i]</code>，如果栈为空，则直接将 <code>i</code> 进栈，如果栈不为空，则比较栈顶元素 <code>prevIndex</code> 对应的温度 <code>temperatures[prevIndex]</code> 和当前温度 <code>temperatures[i]</code>，如果 <code>temperatures[i] &gt; temperatures[prevIndex]</code>，则将 <code>prevIndex</code> 移除，并将 <code>prevIndex</code> 对应的等待天数赋为 <code>i - prevIndex</code>，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 <code>i</code> 进栈。</p><p>为什么可以在弹栈的时候更新 <code>ans[prevIndex]</code> 呢？因为在这种情况下，即将进栈的 <code>i</code> 对应的 <code>temperatures[i]</code> 一定是 <code>temperatures[prevIndex]</code> 右边第一个比它大的元素，试想如果 <code>prevIndex</code> 和 <code>i</code> 有比它大的元素，假设下标为 <code>j</code>，那么 <code>prevIndex</code> 一定会在下标 <code>j</code> 的那一轮被弹掉。</p><p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p><p>以下用一个具体的例子帮助读者理解单调栈。对于温度列表 *[73,74,75,71,69,72,76,73]<em>，单调栈stack  的初始状态为空，答案 ans 的初始状态是 *[0,0,0,0,0,0,0,0]</em>，按照以下步骤更新单调栈和答案，其中单调栈内的元素都是下标，括号内的数字表示下标在温度列表中对应的温度。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temperature = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">                ans[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        length = len(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            temperature = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperature &gt; temperatures[stack[<span class="number">-1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                ans[prev_index] = i - prev_index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; temperatures[i] &gt; temperatures[s.top()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> previousIndex = s.top();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(temperatures)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">    stack := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        temperature := temperatures[i]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; temperature &gt; temperatures[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            prevIndex := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            ans[prevIndex] = i - prevIndex</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p></li><li><p>空间复杂度：<em>O(n)*，其中 *n</em> 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>396. 旋转函数</title>
    <link href="http://yoursite.com/2021/11/23/396.%20%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2021/11/23/396. 旋转函数/</id>
    <published>2021-11-23T14:12:12.000Z</published>
    <updated>2021-11-23T15:46:20.503Z</updated>
    
    <content type="html"><![CDATA[<p>计算F(0), F(1), …, F(n-1)中的最大值。</p><a id="more"></a><p>[TOC]</p><p>给定一个长度为 n 的整数数组 A 。</p><p>假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：</p><p>F(k) = 0 * Bk[0] + 1 * Bk[1] + … + (n-1) * Bk[n-1]。</p><p>计算F(0), F(1), …, F(n-1)中的最大值。</p><p>注意:<br>可以认为 n 的值小于 105。</p><p>示例:</p><pre><code>A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</code></pre><p>所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。</p><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>最先想到的自然是按个旋转求值，但超时了</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxRotateFunction(int[] A) &#123;</span><br><span class="line">        int len = A.length, max = Integer.MIN_VALUE;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int[] B = new int[len];</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                B[j] = A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, rotate(B, i));</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int rotate(int[] A, int k) &#123;</span><br><span class="line">        reverse(A, 0, A.length - 1 - k);</span><br><span class="line">        reverse(A, A.length - k, A.length - 1);</span><br><span class="line">        reverse(A, 0, A.length - 1);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">            sum += i * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reverse(int[] A, int start, int end) &#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while (start &lt;= end) &#123;</span><br><span class="line">            temp = A[start];</span><br><span class="line">            A[start] = A[end];</span><br><span class="line">            A[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>先计算出<code>f[0]</code>, 且状态转移方程为<code>f[i] = f[i - 1] + sum - n * nums[n - i]</code>，sum为nums的和</p><details>    <summary>Java动态规划</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            f[<span class="number">0</span>] += nums[i] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = f[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + sum - n * nums[n - i];</span><br><span class="line">            ans = Math.max(f[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>空间压缩</p><details>    <summary>Java空间压缩</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            f += nums[i] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = f; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f = f + sum - n * nums[n - i];</span><br><span class="line">            ans = Math.max(f, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算F(0), F(1), …, F(n-1)中的最大值。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>525. 连续数组</title>
    <link href="http://yoursite.com/2021/11/21/525.%20%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2021/11/21/525. 连续数组/</id>
    <published>2021-11-21T10:12:12.000Z</published>
    <updated>2021-11-23T14:22:16.698Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: nums = [0,1]输出: 2说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</code></pre><p>示例 2:</p><pre><code>输入: nums = [0,1,0]输出: 2说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 105nums[i] 不是 0 就是 1</code></pre><h1 id="方法一：前缀和-哈希表-1"><a href="#方法一：前缀和-哈希表-1" class="headerlink" title="方法一：前缀和 + 哈希表^1"></a>方法一：前缀和 + 哈希表<a href="https://leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode-solution-mvnm/" target="_blank" rel="noopener">^1</a></h1><p>由于「<em>0</em> 和 <em>1</em> 的数量相同」等价于「<em>1</em> 的数量减去 <em>0</em> 的数量等于 <em>0</em>」，我们可以将数组中的 <em>0</em> 视作 <em>-1</em>，则原问题转换成「求最长的连续子数组，其元素和为 <em>0</em>」。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        map.put(counter, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(counter)) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = map.get(counter);</span><br><span class="line">                maxLength = Math.max(maxLength, i - prevIndex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(counter, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindMaxLength(int[] nums) &#123;</span><br><span class="line">        int maxLength = 0;</span><br><span class="line">        Dictionary&lt;int, int&gt; dictionary = new Dictionary&lt;int, int&gt;();</span><br><span class="line">        int counter = 0;</span><br><span class="line">        dictionary.Add(counter, -1);</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            if (num == 1) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dictionary.ContainsKey(counter)) &#123;</span><br><span class="line">                int prevIndex = dictionary[counter];</span><br><span class="line">                maxLength = Math.Max(maxLength, i - prevIndex);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dictionary.Add(counter, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaxLength = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    map.set(counter, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> num = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.has(counter)) &#123;</span><br><span class="line">            <span class="keyword">const</span> prevIndex = map.get(counter);</span><br><span class="line">            maxLength = <span class="built_in">Math</span>.max(maxLength, i - prevIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(counter, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(maxLength <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mp := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">-1</span>&#125;</span><br><span class="line">    counter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">            counter++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> prevIndex, has := mp[counter]; has &#123;</span><br><span class="line">            maxLength = max(maxLength, i-prevIndex)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mp[counter] = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        mp[counter] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.count(counter)) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = mp[counter];</span><br><span class="line">                maxLength = max(maxLength, i - prevIndex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[counter] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">hashTable</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">HashTable</span>));</span></span><br><span class="line">    tmp-&gt;key = <span class="number">0</span>, tmp-&gt;val = <span class="number">-1</span>;</span><br><span class="line">    HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = numsSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        HASH_FIND_INT(hashTable, &amp;counter, tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> prevIndex = tmp-&gt;val;</span><br><span class="line">            maxLength = fmax(maxLength, i - prevIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">            tmp-&gt;key = counter, tmp-&gt;val = i;</span><br><span class="line">            HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Prefix Sum" scheme="http://yoursite.com/tags/Prefix-Sum/"/>
    
  </entry>
  
  <entry>
    <title>如何写出一份优秀的工作周报？</title>
    <link href="http://yoursite.com/2021/11/18/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%BB%BD%E4%BC%98%E7%A7%80%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%8A%A5/"/>
    <id>http://yoursite.com/2021/11/18/如何写出一份优秀的工作周报/</id>
    <published>2021-11-18T11:12:12.000Z</published>
    <updated>2021-11-18T10:43:31.063Z</updated>
    
    <content type="html"><![CDATA[<p>如何写出一份优秀的工作周报？(附90分周报模板)</p><a id="more"></a><p>[TOC]</p><p>来，先说说看周报的人看什么，然后再说说怎么写。<br>以下为目录： </p><h1 id="1-周报，最为基本的要求是什么？"><a href="#1-周报，最为基本的要求是什么？" class="headerlink" title="1 周报，最为基本的要求是什么？"></a>1 周报，最为基本的要求是什么？</h1><p>10 多年工作，自己也写周报，后来看别人写周报。先给大家评个分数，看看哪些肯定不合格： </p><h2 id="负分版本："><a href="#负分版本：" class="headerlink" title="- 负分版本："></a>- 负分版本：</h2><p>「本周完成既定工作，处理交办任务，下周按周五会议计划执行」<br>非要从理论上说，也没错。<br>但是手下的人多了，每个人啥叫既定任务、交办了什么任务、你的计划是啥<br>——我真不一定能记住。<br>这种表述，没有达到周报的基本要求:<br>——作为日常工作的备忘。<br>还花了我 20 秒时间打开邮箱，只能给负分。</p><h2 id="30-分版本："><a href="#30-分版本：" class="headerlink" title="- 30 分版本："></a>- 30 分版本：</h2><p>主线工作：完成 xxxxx、未完成 xxx；<br>临时性任务：完成 xxxxx、未完成 xxx；<br>事务性工作：完成 xxxxx；<br>培训：完成 xxxxx；<br>下周：xxxxxx<br>这个结构看得出提交者做了不错的分类，完成的工作和未完成的工作进行了梳理。<br>但是在工作中，可不是我们网上刷论坛，你说自己 985 或者年入百万别人就会信。<br>周报里你提到的所有成果，都必须有一个元素：<br> 证明。 </p><ul><li>如果你是做业务的，就把销售数据扔上去； </li><li>如果你是做开发的，就工作量证明扔上去； </li><li>……<br>如果没有数据或者可被验证的资料证明自己确实完成了这些工作，仍然是一份不及格的周报。<br>如果截图太大或者有专门的工作量统计表格，可以放在附件。 </li></ul><h2 id="60-分版本："><a href="#60-分版本：" class="headerlink" title="- 60 分版本："></a>- 60 分版本：</h2><p>主线工作：完成 xxxxx（详见 yyyy）、未完成 xxx；<br>临时性任务：完成 xxxxx（详见 yyyy）、未完成 xxx；<br>事务性工作：完成 xxxxx（详见 yyyy）；<br>培训：完成 xxxxx（详见 yyyy）；<br>下周：xxxxxx<br>很多朋友如果能够完成这类周报，就已经达到了及格线的标准。</p><p> 特别是对于实习生、刚毕业不到 1 年的职场新人。<br>能够对过去一周完成、未完成的工作进行一个有效的分类，上级在和你聊天的时候基本可以不用重复已经发生的事实。<br> 但是，我们可以做得更好。</p><h1 id="2-周报的核心作用，以及什么是更高级的信息传递"><a href="#2-周报的核心作用，以及什么是更高级的信息传递" class="headerlink" title="2 周报的核心作用，以及什么是更高级的信息传递"></a>2 周报的核心作用，以及什么是更高级的信息传递</h1><p>任何负责人阅读周报都有两个作用：查看事实、发现问题。<br>这里我想也不用多说了，大家肯定察觉到，让领导和同事发现问题才是周报的核心作用。<br>显然上面 60 分的周报，并没有很好地展示这个信息，我们下面来说一说。<br>什么是问题？<br>很多朋友想当然会认为问题就是困难，就是工作任务没完成<br>——对，但也不全面。<br>咱们就说周报里的这些内容，我来举几个例子：<br>本周完成 xxxxx（80% 进度）。<br>如果本周预计应该完成 60%，那么 80% 算是超预期；<br>如果本周预计应该完成 90%，那么 80% 算是落后进度。<br>本周规定的两篇报告，完成一篇；<br>如果是没有其他任务，那么显然没有达成 KPI，但是如果因为有突发任务比如组织大型会议，那么这就不算是 KPI 不达标。</p><p>所以在总结的时候，一定要把预期和实际做对比： </p><ul><li>本周完成 50%（原计划完成 40%）； </li><li>本周完成 xxxx 谈判（原计划成果 2 万/项目，实际 1.75 万/项目）； </li><li>本周完成 xxxx（原计划花费 20 工时，实际花费 30 工时）<br>当我们在周报中描述了预期和实际的偏差，领导和同事就会很明确地意识到问题。<br>实际工作中，有些领导会把你的各种工作目标和预期记得很清楚。<br>但是工作繁忙的人，带的人比较多，一般记不住。<br>为了高效传递信息，我还是建议大家把预期和实际工作成果列清楚。<br>列举问题的时候，领导和我们沟通就变得更有针对性。<br>一般来说，给出自己的分析和思考，可以节省同事复盘的时间，即使这些理由被领导都否掉，你的思考也能够为解决问题提供方向上的指引。</li></ul><h1 id="3-一个周报的模板"><a href="#3-一个周报的模板" class="headerlink" title="3 一个周报的模板"></a>3 一个周报的模板</h1><p>这里，还是要给到大家一个模板，满足 90 分要求。</p><h2 id="3-1-完成事项"><a href="#3-1-完成事项" class="headerlink" title="3-1 完成事项"></a>3-1 完成事项</h2><p>按照工作性质或者工作版块对一周的工作进行分类，然后分别描述进度，常见的分类手法如下： </p><ul><li>固定工作、临时工作； </li><li>主线工作、副线工作； </li><li>业务工作、事务工作； </li><li>自主工作、领导交办工作；<br>注意在描述工作时加入具体数据和证明工作完成的证据。</li></ul><h2 id="3-2-未完成事项-遇到问题的工作"><a href="#3-2-未完成事项-遇到问题的工作" class="headerlink" title="3-2 未完成事项/遇到问题的工作"></a>3-2 未完成事项/遇到问题的工作</h2><p>未按照预期完成的工作，或者未按照原定难度完成的工作我们通常认为是工作的问题，应当提醒领导注意。<br>在进行有效分类的基础上，建议添加如下细节： </p><ul><li>原工作预期（成果、难度、时间等）Vs 实际结果； </li><li>对产生这类偏差的原因进行可能的分析；</li><li></li></ul><h2 id="3-3-问题的解决方案"><a href="#3-3-问题的解决方案" class="headerlink" title="3-3 问题的解决方案"></a>3-3 问题的解决方案</h2><p>先自己想，如果没有答案可以在自己的笔记中寻找类似问题或者请求同事协助<br>我们工作中绝大多数工作解决方案其实比较单一。<br>没找到人下周补上、没写完程序加班写上、远程解决不了问题出差过去。<br>我要提醒的是比较复杂的问题，最好给出多个解决方案，让领导做选择题。</p><h2 id="3-4-待办工作"><a href="#3-4-待办工作" class="headerlink" title="3-4 待办工作"></a>3-4 待办工作</h2><p>待办工作包括两大类，第一类是按照工作计划本应该完成的工作；<br>第二类是本周遗留的问题在下周可以着手解决的工作。<br>第一类：<br> 很多公司的工作计划都是按照季度或者月度编制的，如果计划没有变更，用最简单的描述，说一下未来一周的工作内容就可以了。如果认为有必要可以用附件形式把计划贴上去。<br>第二类：<br>领导一般更关心遗留问题解决。<br>日常工作中很多工作肯定不是这周出问题、下周就能解决，在这里建议对这类型待办工作进行排序。 </p><ul><li>可以按照问题遗留时间排序，比如拖了 1 个月的工作放在上面，拖了 2 周地放在下面； </li><li>可以按照问题重要性排序，比如集团级&gt;公司级&gt;部门级&gt;小组级；<br>这说明你工作中知道找重点。</li></ul><p>说明：内容转自知乎，(答主：王家CFA)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何写出一份优秀的工作周报？(附90分周报模板)&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>1044. 最长重复子串</title>
    <link href="http://yoursite.com/2021/11/17/1044.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/17/1044. 最长重复子串/</id>
    <published>2021-11-17T07:12:12.000Z</published>
    <updated>2021-11-23T14:22:11.538Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个字符串S，考虑其所有重复子串（S 的连续子串，出现两次或多次，可能会有重叠）。</p><p>返回任何具有最长可能长度的重复子串。（如果 S不含重复子串，那么答案为””。）</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：&quot;banana&quot;输出：&quot;ana&quot;</code></pre><p>示例 2：</p><pre><code>输入：&quot;abcd&quot;输出：&quot;&quot;</code></pre><p>提示：</p><pre><code>2 &lt;= S.length &lt;= 10^5S 由小写英文字母组成。</code></pre><p>很多评论里有提到是字节一面的面试题，确实有难度</p><h1 id="方法一：二分查找-Rabin-Karp-字符串编码-1"><a href="#方法一：二分查找-Rabin-Karp-字符串编码-1" class="headerlink" title="方法一：二分查找 + Rabin-Karp 字符串编码^1"></a>方法一：二分查找 + Rabin-Karp 字符串编码<a href="https://leetcode-cn.com/problems/longest-duplicate-substring/solution/zui-chang-zhong-fu-zi-chuan-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p><strong>分析</strong></p><p>我们可以把这个问题分解成两个子问题：</p><ol><li><p>从 <code>1</code> 到 <code>N</code> 中选取子串的长度 <code>L</code>；</p></li><li><p>检查字符串中是否存在长度为 <code>L</code> 的重复子串。</p></li></ol><p><strong>子任务一：二分查找</strong></p><p>解决子问题一的最简单的方法是，我们从 <code>L = N - 1</code> 开始，依次递减选取子串的长度，并进行判断。如果发现存在长度为 <code>L</code> 的重复子串，就表示 <code>L</code> 是最长的可能长度。</p><p>但我们发现，如果字符串中存在长度为 <code>L</code> 的重复子串，那么一定存在长度为 <code>L0 &lt; L</code> 的重复子串（选取长度为 <code>L</code> 的重复子串的某个长度为 <code>L0</code> 的子串即可），因此我们可以使用二分查找的方法，找到最大的 <code>L</code>。</p><p><strong>子任务二：Rabin-Karp 字符串编码</strong></p><p>我们可以使用 <code>Rabin-Karp</code> 算法将字符串进行编码，这样只要有两个编码相同，就说明存在重复子串。对于选取的长度 <code>L</code>：</p><ul><li><p>使用长度为 <code>L</code> 的滑动窗口在长度为 <code>N</code> 的字符串上从左向右滑动；</p></li><li><p>检查当前处于滑动窗口中的子串的编码是否已经出现过（用一个集合存储已经出现过的编码）；</p><ul><li><p>若已经出现过，就说明找到了长度为 <code>L</code> 的重复子串；</p></li><li><p>若没有出现过，就把当前子串的编码加入到集合中。</p></li></ul></li></ul><p>可以看出，<code>Rabin-Karp</code> 字符串编码的本质是对字符串进行哈希，将字符串之间的比较转化为编码之间的比较。接下来的问题是，在滑动窗口从左向右滑动时，如何快速计算出当前子串的编码呢？如果需要在 <em>O(L)</em> 的时间内算出编码，这种方法就没有意义了，因为这个直接进行字符串比较需要的时间相同。</p><p>为了能够快速计算出字符串编码，我们可以将字符串看成一个 26 进制的数（因为字符串中仅包含小写字母），它对应的 10 进制的值就是字符串的编码值。首先将字符转换为 26 进制中的 0-25，即通过 <code>arr[i] = (int)S.charAt(i) - (int)&#39;a&#39;</code>，可以将字符串 <code>abcd</code> 转换为 <code>[0, 1, 2, 3]</code>，它对应的 10 进制值为：</p><p>我们将这个表达式写得更通用一些，设 <em>c_i</em> 为字符串中第 <code>i</code> 个字符对应的数字，<em>a = 26</em> 为字符串的进制，那么有：</p><p>当我们向右移动滑动窗口时，例如从 <code>abcd</code> 变成 <code>bcde</code>，此时字符串对应的值从 <code>[0, 1, 2, 3]</code> 变成 <code>[1, 2, 3, 4]</code>，移除了最高位的 <code>0</code>，并且在最低位添加了 <code>4</code>，那么我们可以快速地计算出新的字符串的编码：</p><p>更加通用的写法是：</p><p>*<br>h_1 = (h_0 a - c_0 a^L) + c_{L + 1}<br>*</p><p>这样，我们只需要 <em>O(L)</em> 的时间复杂度计算出最左侧子串的编码，这个 <em>O(L)</em> 和滑动窗口的循环是独立的。在滑动窗口向右滑动时，计算新的子串的编码的时间复杂度仅为 <em>O(1)</em>。</p><p>最后一个需要解决的问题是，在实际的编码计算中，<em>a^L</em> 的值可能会非常大，在 C++ 和 Java 语言中，会导致整数的上溢出。一般的解决方法时，对编码值进行取模，将编码控制在一定的范围内，防止溢出，即<code>h = h % modulus</code>。根据 <a href="https://baike.baidu.com/item/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA" target="_blank" rel="noopener">生日悖论</a>，模数一般需要和被编码的信息数量的平方根的数量级相同，在本题中，相同长度的子串的数量不会超过 <em>N</em> 个，因此选取模数是 <em>2^{32}</em>（无符号整型数的最大值）是足够的。在 Java 中可以用如下的代码实现取模：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = (h * a - nums[start - <span class="number">1</span>] * aL % modulus + modulus) % modulus;</span><br><span class="line">h = (h + nums[start + L - <span class="number">1</span>]) % modulus;</span><br></pre></td></tr></table></figure><p>而在 Python 中，整型数没有最大值，因此可以在运算的最后再取模：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = (h * a - nums[start - <span class="number">1</span>] * aL + nums[start + L - <span class="number">1</span>]) % modulus</span><br></pre></td></tr></table></figure><p>在解决算法题时，我们只要判断两个编码是否相同，就表示它们对应的字符串是否相同。但在实际的应用场景中，会出现字符串不同但编码相同的情况，因此在实际场景中使用 <code>Rabin-Karp</code> 字符串编码时，推荐在编码相同时再对字符串进行比较，防止出现错误。</p><details>    <summary>Python未检测碰撞（未通过）</summary><figure class="highlight python"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, L: int, a: int, modulus: int, n: int, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Rabin-Karp with polynomial rolling hash.</span></span><br><span class="line"><span class="string">        Search a substring of given length</span></span><br><span class="line"><span class="string">        that occurs at least 2 times.</span></span><br><span class="line"><span class="string">        @return start position if the substring exits and -1 otherwise.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># compute the hash of string S[:L]</span></span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">            h = (h * a + nums[i]) % modulus</span><br><span class="line">              </span><br><span class="line">        <span class="comment"># already seen hashes of strings of length L</span></span><br><span class="line">        seen = &#123;h&#125; </span><br><span class="line">        <span class="comment"># const value to be used often : a**L % modulus</span></span><br><span class="line">        aL = pow(a, L, modulus) </span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">1</span>, n - L + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># compute rolling hash in O(1) time</span></span><br><span class="line">            h = (h * a - nums[start - <span class="number">1</span>] * aL + nums[start + L - <span class="number">1</span>]) % modulus</span><br><span class="line">            <span class="keyword">if</span> h <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            seen.add(h)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDupSubstring</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        n = len(S)</span><br><span class="line">        <span class="comment"># convert string to array of integers</span></span><br><span class="line">        <span class="comment"># to implement constant time slice</span></span><br><span class="line">        nums = [ord(S[i]) - ord(<span class="string">'a'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># base value for the rolling hash function</span></span><br><span class="line">        a = <span class="number">26</span></span><br><span class="line">        <span class="comment"># modulus value for the rolling hash function to avoid overflow</span></span><br><span class="line">        modulus = <span class="number">2</span>**<span class="number">32</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># binary search, L = repeating string length</span></span><br><span class="line">        left, right = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">while</span> left != right:</span><br><span class="line">            L = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.search(L, a, modulus, n, nums) != <span class="number">-1</span>:</span><br><span class="line">                left = L + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = L </span><br><span class="line">               </span><br><span class="line">        start = self.search(left - <span class="number">1</span>, a, modulus, n, nums)</span><br><span class="line">        <span class="keyword">return</span> S[start: start + left - <span class="number">1</span>] <span class="keyword">if</span> start != <span class="number">-1</span> <span class="keyword">else</span> <span class="string">""</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Java未检测碰撞（未通过）</summary><figure class="highlight java"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Rabin-Karp with polynomial rolling hash.</span></span><br><span class="line"><span class="comment">        Search a substring of given length</span></span><br><span class="line"><span class="comment">        that occurs at least 2 times.</span></span><br><span class="line"><span class="comment">        Return start position if the substring exits and -1 otherwise.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> a, <span class="keyword">long</span> modulus, <span class="keyword">int</span> n, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute the hash of string S[:L]</span></span><br><span class="line">        <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) h = (h * a + nums[i]) % modulus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// already seen hashes of strings of length L</span></span><br><span class="line">        HashSet&lt;Long&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">        seen.add(h);</span><br><span class="line">        <span class="comment">// const value to be used often : a**L % modulus</span></span><br><span class="line">        <span class="keyword">long</span> aL = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++i) aL = (aL * a) % modulus;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">            <span class="comment">// compute rolling hash in O(1) time</span></span><br><span class="line">            h = (h * a - nums[start - <span class="number">1</span>] * aL % modulus + modulus) % modulus;</span><br><span class="line">            h = (h + nums[start + L - <span class="number">1</span>]) % modulus;</span><br><span class="line">            <span class="keyword">if</span> (seen.contains(h)) <span class="keyword">return</span> start;</span><br><span class="line">            seen.add(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDupSubstring</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="comment">// convert string to array of integers</span></span><br><span class="line">        <span class="comment">// to implement constant time slice</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) nums[i] = (<span class="keyword">int</span>)S.charAt(i) - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">// base value for the rolling hash function</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">26</span>;</span><br><span class="line">        <span class="comment">// modulus value for the rolling hash function to avoid overflow</span></span><br><span class="line">        <span class="keyword">long</span> modulus = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binary search, L = repeating string length</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">int</span> L;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            L = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (search(L, a, modulus, n, nums) != -<span class="number">1</span>) left = L + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = search(left - <span class="number">1</span>, a, modulus, n, nums);</span><br><span class="line">        <span class="keyword">return</span> start != -<span class="number">1</span> ? S.substring(start, start + left - <span class="number">1</span>) : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java检测碰撞</summary><figure class="highlight java"><figcaption><span>[sol2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDupSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = s.length();</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (last - first) / <span class="number">2</span> + first;</span><br><span class="line">            <span class="keyword">int</span> index = check(s, mid);</span><br><span class="line">            <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                first = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里就找出了重复的长度</span></span><br><span class="line">        <span class="keyword">int</span> index = check(s, first-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s.substring(index,index+first-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给一个字符串和一个长度，返回重复长度的下标index,没有返回-1</span></span><br><span class="line">    <span class="comment">//但是这种方式每次都要substring，但是hash碰撞太高，所以要进行改进</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check1</span><span class="params">(String s, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.length()-len;i++)&#123;</span><br><span class="line">            String str = s.substring(i,i+len);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(str))&#123;</span><br><span class="line">                <span class="keyword">int</span> index = map.get(str);</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(str,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要使用Rabin-Karp算法来解决len长度的字符串在s中是否重复，也就是使用hash的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> pow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            pow = (pow*<span class="number">31</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再来计算hash值</span></span><br><span class="line">        <span class="keyword">long</span> hash =<span class="number">0</span>;</span><br><span class="line">        Map&lt;Long,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            hash = (hash*<span class="number">31</span>+(s.charAt(i)-<span class="string">'a'</span>))%mod;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;len-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//这时候还不满足，继续</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=len)&#123;</span><br><span class="line">                <span class="comment">//这时候就要把前面的字符去掉</span></span><br><span class="line">                hash-=((s.charAt(i-len)-<span class="string">'a'</span>)*pow)%mod;</span><br><span class="line">                hash+=hash&lt;<span class="number">0</span>?mod:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(hash))&#123;</span><br><span class="line">                <span class="comment">//说明这个hash之前出现过</span></span><br><span class="line">                <span class="keyword">int</span> index = map.get(hash);</span><br><span class="line">                String str1 = s.substring(index,index+len);</span><br><span class="line">                String str2 = s.substring(i+<span class="number">1</span>-len,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(str1.equals(str2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(hash,i-len+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(NlogN) ，二分查找的时间复杂度为 O(logN) ，Rabin-Karp 字符串编码的时间复杂度为 <em>O(N)</em>。</p></li><li><p>空间复杂度：<em>O(N)</em>，用来存储字符串编码的集合。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个字符串S，考虑其所有重复子串（S 的连续子串，出现两次或多次，可能会有重叠）。&lt;/p&gt;
&lt;p&gt;返回任何具有最长可能长度的重复子串。（如果 S不含重复子串，那么答案为””。）&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Function" scheme="http://yoursite.com/tags/Hash-Function/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Suffix Array" scheme="http://yoursite.com/tags/Suffix-Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>1358. 包含所有三种字符的子字符串数目</title>
    <link href="http://yoursite.com/2021/11/16/1358.%20%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%89%E4%B8%89%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE/"/>
    <id>http://yoursite.com/2021/11/16/1358. 包含所有三种字符的子字符串数目/</id>
    <published>2021-11-16T14:12:12.000Z</published>
    <updated>2021-11-17T03:15:34.346Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 s ，它只包含三种字符 a, b 和 c 。</p><p>请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：s = &quot;abcabc&quot;输出：10解释：包含 a，b 和 c 各至少一次的子字符串为 &quot;abc&quot;, &quot;abca&quot;, &quot;abcab&quot;, &quot;abcabc&quot;, &quot;bca&quot;, &quot;bcab&quot;, &quot;bcabc&quot;, &quot;cab&quot;, &quot;cabc&quot; 和 &quot;abc&quot; (相同字符串算多次)。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;aaacb&quot;输出：3解释：包含 a，b 和 c 各至少一次的子字符串为 &quot;aaacb&quot;, &quot;aacb&quot; 和 &quot;acb&quot; 。</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;abc&quot;输出：1</code></pre><p>提示：</p><pre><code>3 &lt;= s.length &lt;= 5 x 10^4s 只包含字符 a，b 和 c 。</code></pre><h1 id="反向思考"><a href="#反向思考" class="headerlink" title="反向思考"></a>反向思考</h1><p>所求=总字符串数目-最多包含两个字符的子串数目<br>但是提交时遇到测试用例太长乘积超出整数范围，所以换成Long类型保存中间结果。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Long cal(Long n) &#123;</span><br><span class="line">        return (n * (n + 1)) &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public int numberOfSubstrings(String s) &#123;</span><br><span class="line">        //总字符串数目-最多包含两个字符的子串数目</span><br><span class="line">        int left=0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        Integer n = s.length();</span><br><span class="line">        CounterChar counterChar = new CounterChar();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (counterChar.size() &lt; 3) &#123;</span><br><span class="line">                counterChar.add(s.charAt(i), 1);</span><br><span class="line">            &#125;</span><br><span class="line">            while (counterChar.size() &gt; 2) &#123;</span><br><span class="line">                counterChar.add(s.charAt(left), -1);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += i - left + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return  (cal(n.longValue()).intValue() - ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CounterChar extends HashMap&lt;Character, Integer&gt; &#123;</span><br><span class="line">    public int get(Character character) &#123;</span><br><span class="line">        return containsKey(character) ? super.get(character) : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(Character c, int v) &#123;</span><br><span class="line">        put(c, get(c) + v);</span><br><span class="line">        if (get(c) == 0) &#123;</span><br><span class="line">            remove(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法一：枚举-二分"><a href="#方法一：枚举-二分" class="headerlink" title="方法一：枚举 + 二分"></a>方法一：枚举 + 二分</h1><p>我们定义 a，b，c 都至少出现过一次的字符串为合法的字符串，否则为非法的字符串。</p><p>可以观察到一个性质：<strong>从下标 i 开始的所有子串，我们按顺序从前到后考虑，一定是前部分均非法，后部分均合法</strong> ，简单来说，假设 <em>[i,j]</em> 的子串已经合法，那么 <em>[i,j+1]</em> 必然合法，如果 <em>[i,j]</em> 非法，那么 <em>[i,j-1]</em> 必然非法，这是很显然的。</p><p>通过这个性质我们知道对于下标 <em>i</em> 开始的所有子串，它的合法性是随下标具有单调性的（如果我们把非法字符串设为 0 ，合法字符串设为 1 ，那么从下标 <em>i</em> 开始的所有子串一定是 000011 这样的形式），所以我们就可以进行二分查找，找到第一个合法的子串的下标 <em>j</em> ，那么下标 <em>i</em> 开始的合法子串数就是 <em>len(s)-j+1</em> 了，最后的答案就是 </p><p><a href="./p__sum_{i=1}^{len_s_}len_s_-j+1_.png">\sum_{i=1}^{len(s)}len(s)-j+1 </a> </p><p>二分查找的时候需要判断子串是否合法，为了 <em>O(1)</em> 判断，我们需要预处理三个字符出现次数的前缀和数组，判断的时候直接 <em>O(1)</em> 差分查一下子串里 a，b，c 的个数即可判断。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line">    <span class="keyword">int</span> pre[<span class="number">3</span>][N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=(<span class="keyword">int</span>)s.length(),ans=<span class="number">0</span>;</span><br><span class="line">        pre[<span class="number">0</span>][<span class="number">0</span>]=pre[<span class="number">1</span>][<span class="number">0</span>]=pre[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)s.length();++i)&#123;<span class="comment">// 预处理前缀和数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j) pre[j][i+<span class="number">1</span>]=pre[j][i];</span><br><span class="line">            pre[s[i]-<span class="string">'a'</span>][i+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l=i+<span class="number">1</span>,r=len,pos=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (pre[<span class="number">0</span>][mid]-pre[<span class="number">0</span>][i]&gt;<span class="number">0</span> &amp;&amp; pre[<span class="number">1</span>][mid]-pre[<span class="number">1</span>][i]&gt;<span class="number">0</span> &amp;&amp; pre[<span class="number">2</span>][mid]-pre[<span class="number">2</span>][i]&gt;<span class="number">0</span>)&#123;<span class="comment">// 都大于0说明a,b,c至少出现过一次，子串合法</span></span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                    pos=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (~pos) ans+=len-pos+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：枚举每个下标需要 <em>O(n)</em> 的时间，<em>n=s.length</em> ，统计每个下标为起点里面套了一个二分需要 <em>O(logn)</em>   的时间，所以总时间复杂度为 <em>O(nlogn)</em> 。</li><li>空间复杂度：为了二分里面判断是不是合法子串，需要额外提供一个前缀和数组，所以空间复杂度为 <em>O(n)</em> 。</li></ul><h1 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h1><p>针对上面发现的性质还可以继续深挖， 我们假设下标 <em>i</em> 开始第一个合法的字符串的末尾下标为 <em>pos_i</em> ，则可以知道：</p><p><a href="./p__pos_1leq_pos_2_leq_cdots_leq_pos_{len_s_}_.png">pos_1\leqpos_2\leq\cdots\leqpos_{len(s)} </a> </p><p>这说明了 <em>pos_i</em> 是单调不降的，如果我们已经得出了下标 <em>i</em> 开始的第一个合法字符串末尾的下标 <em>pos_i</em> ，则计算下标 <em>i+1</em> 的 <em>pos_{i+1}</em> 的时候，我们就可以复用 <em>[i+1,pos_i]</em> 里的信息，即当前字符串里a，b，c出现的次数，再从 <em>pos_i+1</em> 开始往后延伸找到第一个符合条件的下标， 这就是我们常说的双指针算法。</p><p>维护两个指针 <em>l</em> 和 <em>r</em> ，以及 <em>[l,r]</em> 区间内 a，b，c 出现的次数。针对 <em>l</em> 找到第一个符合条件的 <em>r</em> 以后把答案加上 <em>len(s)-r</em> ，然后把 <em>l</em> 加一，减去 <em>s[l]</em> 字符的贡献，得出 <em>[l+1,r]</em> 里 a，b，c 出现的次数，然后再不断延伸 <em>r</em> 找第一个符合条件的合法字符串即可，这样我们就可以针对每一个下标找到对应的 <em>pos_i</em> ，最后的答案就是</p><p><a href="./p__sum_{i=0}^{len_s_-1}len_s_-pos_i_.png">\sum_{i=0}^{len(s)-1}len(s)-pos_i </a> </p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=(<span class="keyword">int</span>)s.length(),ans=<span class="number">0</span>;</span><br><span class="line">        cnt[<span class="number">0</span>]=cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">-1</span>;l&lt;len;)&#123;</span><br><span class="line">            <span class="keyword">while</span> (r&lt;len &amp;&amp; !(cnt[<span class="number">0</span>]&gt;=<span class="number">1</span> &amp;&amp; cnt[<span class="number">1</span>]&gt;=<span class="number">1</span> &amp;&amp; cnt[<span class="number">2</span>]&gt;=<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (++r==len) <span class="keyword">break</span>;</span><br><span class="line">                cnt[s[r]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=len-r;</span><br><span class="line">            cnt[s[l++]-<span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; s.length(); end++) &#123;</span><br><span class="line">            count[s.charAt(end) - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">while</span> (count[<span class="number">0</span>] &gt;= <span class="number">1</span> &amp;&amp; count[<span class="number">1</span>] &gt;= <span class="number">1</span> &amp;&amp; count[<span class="number">2</span>] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                answer += s.length() - end;</span><br><span class="line">                count[s.charAt(start) - <span class="string">'a'</span>]--;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：两个指针各移动了 <em>n</em> 次，所以时间复杂度为 <em>O(n)</em> ，<em>n=s.length</em> 。</li><li>空间复杂度：只需要常数的空间记录当前三个字符的出现次数，所以空间复杂度为 <em>O(1)</em> 。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串 s ，它只包含三种字符 a, b 和 c 。&lt;/p&gt;
&lt;p&gt;请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>1297. 子串的最大出现次数</title>
    <link href="http://yoursite.com/2021/11/16/1297.%20%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2021/11/16/1297. 子串的最大出现次数/</id>
    <published>2021-11-16T03:12:12.000Z</published>
    <updated>2021-11-16T10:51:37.414Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：</p><a id="more"></a><p>[TOC]</p><p>子串中不同字母的数目必须小于等于 maxLetters 。<br>子串的长度必须大于等于 minSize 且小于等于 maxSize 。</p><p>示例 1：</p><pre><code>输入：s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4输出：2解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3输出：2解释：子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3输出：3</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3输出：0</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 10^51 &lt;= maxLetters &lt;= 261 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)s 只包含小写英文字母。</code></pre><h1 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h1><p>由于 <code>minSize</code> 和 <code>maxSize</code> 都不超过 <code>26</code>，因此我们可以枚举所有长度在 <code>minSize</code> 与 <code>maxSize</code> 之间的字符串，选出其中字母数量小于等于的 <code>maxLetters</code> 的字符串并进行频数统计。</p><p>具体地，我们首先递增地枚举字符串的起始位置 <code>i</code> 以及结束位置 <code>j</code>。对于 <code>(i, j)</code> 对应的字符串，我们用一个集合 <code>exist</code> 存放其中出现的字母，并在递增地枚举 <code>j</code> 时，将对应位置的字母依次加入集合 <code>exist</code> 中。若集合中的字母数量不超过 <code>maxLetters</code>，并且字符串的长度在 <code>minSize</code> 与 <code>maxSize</code> 之间，那么我们就找到了一个满足条件的字符串。</p><p>我们使用一个无序映射（HashMap）存放所有满足条件的字符串。对于无序映射中的每个键值对，键表示字符串，值表示该字符串出现的次数。在枚举完所有的字符串后，无序映射中出现次数最多的那个字符串即为答案。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; exist;</span><br><span class="line">            <span class="built_in">string</span> cur;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; min(n, i + maxSize); ++j) &#123;</span><br><span class="line">                exist.insert(s[j]);</span><br><span class="line">                <span class="keyword">if</span> (exist.size() &gt; maxLetters) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += s[j];</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt;= minSize) &#123;</span><br><span class="line">                    ++occ[cur];</span><br><span class="line">                    ans = max(ans, occ[cur]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        occ = collections.defaultdict(int)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            exist = set()</span><br><span class="line">            cur = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, min(n, i + maxSize)):</span><br><span class="line">                exist.add(s[j])</span><br><span class="line">                <span class="keyword">if</span> len(exist) &gt; maxLetters:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur += s[j]</span><br><span class="line">                <span class="keyword">if</span> j - i + <span class="number">1</span> &gt;= minSize:</span><br><span class="line">                    occ[cur] += <span class="number">1</span></span><br><span class="line">                    ans = max(ans, occ[cur])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>我的Java(超出内存限制)</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(String s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        CounterChar counterChar = <span class="keyword">new</span> CounterChar();</span><br><span class="line">        CounterString counterString = <span class="keyword">new</span> CounterString();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counterChar.size() &lt;= maxLetters &amp;&amp; i - left + <span class="number">1</span> &lt;= maxSize) &#123;</span><br><span class="line">                counterChar.add(s.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (counterChar.size() &gt; maxLetters) &#123;</span><br><span class="line">                counterChar.add(s.charAt(left), -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (counterChar.get(s.charAt(left)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    counterChar.remove(s.charAt(left));</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= i - minSize + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                counterString.add(s.substring(j, i + <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counterString.maxFre();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterChar</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Character</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(Character c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(c) ? <span class="keyword">super</span>.get(c) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Character c,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(c, get(c) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterString</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(c) ? <span class="keyword">super</span>.get(c) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String c,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(c, get(c) + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxfre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s: keySet())&#123;</span><br><span class="line">            maxfre = Math.max(maxfre, <span class="keyword">super</span>.get(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxfre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMaxString</span><span class="params">(<span class="keyword">int</span> maxfre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.get(s) == maxfre) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java(通过)</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(String s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        CounterString counterString = <span class="keyword">new</span> CounterString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            CounterChar counterChar = <span class="keyword">new</span> CounterChar();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; Math.min(s.length(), i + maxSize); j++) &#123;</span><br><span class="line">                counterChar.add(s.charAt(j), <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (counterChar.size() &gt; maxLetters) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt;= minSize) &#123;</span><br><span class="line">                    counterString.add(s.substring(i, j + <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counterString.maxFre();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterChar</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Character</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(Character c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(c) ? <span class="keyword">super</span>.get(c) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Character c,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(c, get(c) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterString</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(c) ? <span class="keyword">super</span>.get(c) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String c,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(c, get(c) + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxfre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s: keySet())&#123;</span><br><span class="line">            maxfre = Math.max(maxfre, <span class="keyword">super</span>.get(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxfre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMaxString</span><span class="params">(<span class="keyword">int</span> maxfre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.get(s) == maxfre) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(NS^2)*，其中 *N</em> 是字符串的长度，<em>S</em> 是 <code>minSize</code> 和 <code>maxSize</code> 的数量级，在本题中为 <code>26</code>。枚举 <em>i</em> 的时间复杂度为 <em>O(N)*，枚举 *j</em> 的时间复杂度为 <em>O(S)</em>，在这之后的操作会有两种情况：</p><ul><li><p>该语言的字符串类型允许对字符串进行修改，例如 <code>C++</code>。那么当 <code>i</code> 固定时，随着 <code>j</code> 的增加，得到 <code>(i, j)</code> 对应字符串的时间复杂度为 <em>O(1)*，即只要在结束位置为 <code>j - 1</code> 的字符串结尾添加一个字母，但我们需要 *O(S)</em> 的时间将一个字符串无序映射中，这是因为无序映射中保存的是字符串的值；</p></li><li><p>该语言的字符串类型不允许对字符串进行修改，例如 <code>Java</code> 和 <code>Python</code>。那么当 <code>i</code> 固定时，随着 <code>j</code> 的增加，我们每次都需要 <em>O(S)</em> 的时间得到 <code>(i, j)</code> 对应的字符串，但只需要 <em>O(1)</em> 的时间将一个字符串加入无序映射中，这是因为无序映射中保存的是字符串的引用。</p></li></ul><p>同时，由于无序映射的底层实现本质上是哈希算法，因此无论是哪一种情况（保存字符串的值或引用），在将字符串加入无序映射时，都需要花费一定的时间计算字符串的哈希值。不同的语言计算字符串哈希值的方法不同，但时间复杂度均为 <em>O(S)*，与字符串的长度成正比。综上所述，对于每一组 <code>(i, j)</code> 对应的字符串，我们需要 *O(S)</em> 的时间进行相关的操作，总时间复杂度为 <em>O(NS^2)</em>。</p></li><li><p>空间复杂度：<em>O(NS^2)</em>。我们需要枚举所有长度在 <code>minSize</code> 与 <code>maxSize</code> 之间的字符串，在最坏情况下，这些字符串均满足条件且几乎不相同（即大部分字符串仅出现一次）。此时无序映射中需要存储所有字符串，数量为 <em>O(NS)</em>，而字符串的长度为 <em>O(S)</em>，因此总空间复杂度为 <em>O(NS^2)</em>。</p></li></ul><h1 id="方法二：可行性优化"><a href="#方法二：可行性优化" class="headerlink" title="方法二：可行性优化"></a>方法二：可行性优化</h1><p>方法一的时间复杂度较高，上文给出的代码刚好可以在规定时间内通过所有数据，那么我们是否可以进行一些优化呢？</p><p>假设字符串 <code>T</code> 在给定的字符串 <code>S</code> 中出现的次数为 <code>k</code>，那么 <code>T</code> 的任意一个子串出现的次数至少也为 <code>k</code>，即 <code>T</code> 的任意一个子串在 <code>S</code> 中出现的次数不会少于 <code>T</code> 本身。这样我们就可以断定，在所有满足条件且出现次数最多的的字符串中，一定有一个的长度恰好为 <code>minSize</code>。</p><p>我们可以使用反证法证明上述的结论：假设所有满足条件且出现次数最多的字符串中没有长度为 <code>minSize</code> 的，不妨任取其中的一个长度为 <code>l</code> 的字符串，根据假设，有 <code>l &gt; minSize</code>。此时我们再任取该字符串的一个长度为 <code>minSize</code> 的子串，子串出现的次数不会少于原字符串出现的次数，与假设相矛盾。</p><p>这样以来，我们只需要枚举所有长度为 <code>minSize</code> 的字符串即可，时空复杂度均减少了 <em>O(S)</em>。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - minSize + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> cur = s.substr(i, minSize);</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; exist(cur.begin(), cur.end());</span><br><span class="line">            <span class="keyword">if</span> (exist.size() &lt;= maxLetters) &#123;</span><br><span class="line">                <span class="built_in">string</span> cur = s.substr(i, minSize);</span><br><span class="line">                ++occ[cur];</span><br><span class="line">                ans = max(ans, occ[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        occ = collections.defaultdict(int)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - minSize + <span class="number">1</span>):</span><br><span class="line">            cur = s[i : i + minSize]</span><br><span class="line">            exist = set(cur)</span><br><span class="line">            <span class="keyword">if</span> len(exist) &lt;= maxLetters:</span><br><span class="line">                occ[cur] += <span class="number">1</span></span><br><span class="line">                ans = max(ans, occ[cur])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(String s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        CounterString counterString = <span class="keyword">new</span> CounterString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - minSize + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            CounterChar counterChar = <span class="keyword">new</span> CounterChar();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + minSize; j++) &#123;</span><br><span class="line">                counterChar.add(s.charAt(j), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (counterChar.size() &lt;= maxLetters) &#123;</span><br><span class="line">                counterString.add(s.substring(i, i + minSize), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counterString.maxFre();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterChar</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Character</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(Character c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(c) ? <span class="keyword">super</span>.get(c) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Character c,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(c, get(c) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterString</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(c) ? <span class="keyword">super</span>.get(c) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String c,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(c, get(c) + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxfre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s: keySet())&#123;</span><br><span class="line">            maxfre = Math.max(maxfre, <span class="keyword">super</span>.get(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxfre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMaxString</span><span class="params">(<span class="keyword">int</span> maxfre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.get(s) == maxfre) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(NS)*，其中 *N</em> 是字符串的长度，<em>S</em> 是 <code>minSize</code> 和 <code>maxSize</code> 的数量级。</p></li><li><p>空间复杂度：<em>O(NS)</em>。</p></li></ul><h1 id="方法三：滚动哈希"><a href="#方法三：滚动哈希" class="headerlink" title="方法三：滚动哈希"></a>方法三：滚动哈希</h1><p><strong>说明</strong></p><p>方法二的时空复杂度已经较为优秀，且无论在竞赛还是面试中，能够将方法二实现都是值得称赞的。而方法三可以忽略题目中 <code>1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)</code> 的条件，在 <code>minSize</code> 和 <code>maxSize</code> 为任意值的情况下，均可以在合理的时间得到答案。</p><p>方法三需要一些关于「滚动哈希」或「Rabin-Karp 算法」的预备知识，其核心是将字符串看成一个 <code>k</code> 进制的整数，其中 <code>k</code> 是字符串中可能出现的字符种类，本题中字符串只包含小写字母，即 <code>k = 26</code>。这样做的好处是绕开了字符串操作，将字符串看成整数进行比较，使得无论语言的字符串类型是否允许对字符串进行修改，都可以在常数时间内将字符串加入无序映射中。</p><p>关于「滚动哈希」或「Rabin-Karp 算法」的知识，可以参考 <a href="https://leetcode-cn.com/problems/longest-duplicate-substring/solution/zui-chang-zhong-fu-zi-chuan-by-leetcode/" target="_blank" rel="noopener">1044. 最长重复子串的官方题解</a> 或使用搜索引擎，这里对算法本身的流程不再赘述。</p><p><strong>使用滚动哈希</strong></p><p>我们在方法二的基础上进行优化，在枚举长度为 <code>minSize</code> 的子串时，使用一个长度为 <code>minSize</code> 的滑动窗口表示当前的子串。这样在窗口向右滑动时，我们可以使用 Rabin-Karp 算法在 <em>O(1)</em> 的时间计算出子串对应的整数值。</p><p>同时我们也需要优化维护 <code>exist</code> 的时间成本。在方法一和方法二中，由于得到一个子串需要 <em>O(S)</em> 的时间，而通过将子串中的字母依次加入 <code>exist</code> 中来判断不同字母数目的做法同样需要 <em>O(S)</em> 的时间，两者的时间复杂度相加，仍然为 <em>O(S)</em>。而在方法三中，由于得到一个子串需要的时间减少至 <em>O(1)</em>，因此我们需要借助滑动窗口，将维护 <code>exist</code> 需要的时间减少至 <em>O(1)</em>，才能降低总时间复杂度。</p><p>我们可以将 <code>exist</code> 从集合改为无序映射，对于其中的每个键值对，键表示字母，值表示字母出现的次数。当滑动窗口向右滑动一个字母时，头部的一个字母被移除窗口，尾部的一个字母被加入窗口，则：</p><ul><li><p>当一个字母 <code>c</code> 被移除窗口时，我们将 <code>c</code> 对应的值减 <code>1</code>，如果值变为 <code>0</code>，说明子串中不同字母的数量也减少 <code>1</code>；</p></li><li><p>当一个字母 <code>c</code> 被加入窗口时，我们将 <code>c</code> 对应的值加 <code>1</code>，如果值变为 <code>1</code>，说明子串中不同字母的数量也增加 <code>1</code>。</p></li></ul><p>这样我们就可以在滑动窗口向右滑动一个字母时，使用 <em>O(1)</em> 的时间同时得到子串对应的整数值以及其包含不同字符的数量。整个算法的时间复杂度与 <code>minSize</code> 无关。</p><p><strong>注意事项</strong></p><p>由于 Rabin-Karp 算法会将字符串对应的整数值进行取模，那么：</p><ul><li><p>如果字符串 <code>S1</code> 和 <code>S2</code> 对应的整数值 <code>I1</code> 和 <code>I2</code> 不相等，那么 <code>S1</code> 和 <code>S2</code> 一定不相等；</p></li><li><p>如果字符串 <code>S1</code> 和 <code>S2</code> 对应的整数值 <code>I1</code> 和 <code>I2</code> 相等，并不代表 <code>S1</code> 和 <code>S2</code> 一定相等；</p></li></ul><p>这与实际应用中使用的哈希算法也是一致的，即先判断两个实例的哈希值是否相等，再判断它们本质上是否相等。而在竞赛题目中，由于数据量较少，几乎不会产生哈希冲突，因此我们可以直接用 <code>I1</code> 和 <code>I2</code> 的相等代替 <code>S1</code> 和 <code>S2</code> 的相等，减少时间复杂度。但需要牢记在实际应用中，这样做是不严谨的。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; occ;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; exist;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, exist_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rabin = <span class="number">0</span>, base = <span class="number">26</span>, base_mul = base;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minSize - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            ++exist[s[i]];</span><br><span class="line">            <span class="keyword">if</span> (exist[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++exist_cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            rabin = ((LL)rabin * base + (s[i] - <span class="number">97</span>)) % mod;</span><br><span class="line">            base_mul = (LL)base_mul * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = minSize - <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++exist[s[i]];</span><br><span class="line">            <span class="keyword">if</span> (exist[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++exist_cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            rabin = ((LL)rabin * base + (s[i] - <span class="number">97</span>)) % mod;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= minSize) &#123;</span><br><span class="line">                --exist[s[i - minSize]];</span><br><span class="line">                <span class="keyword">if</span> (exist[s[i - minSize]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    --exist_cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                rabin = (rabin - (LL)base_mul * (s[i - minSize] - <span class="number">97</span>) % mod + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exist_cnt &lt;= maxLetters) &#123;</span><br><span class="line">                ++occ[rabin];</span><br><span class="line">                ans = max(ans, occ[rabin]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        occ = collections.defaultdict(int)</span><br><span class="line">        exist = collections.defaultdict(int)</span><br><span class="line">        mod = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line">        ans, exist_cnt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        rabin, base, base_mul = <span class="number">0</span>, <span class="number">26</span>, <span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(minSize - <span class="number">1</span>):</span><br><span class="line">            exist[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> exist[s[i]] == <span class="number">1</span>:</span><br><span class="line">                exist_cnt += <span class="number">1</span></span><br><span class="line">            rabin = (rabin * base + (ord(s[i]) - <span class="number">97</span>)) % mod</span><br><span class="line">            base_mul = base_mul * base % mod</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(minSize - <span class="number">1</span>, n):</span><br><span class="line">            exist[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> exist[s[i]] == <span class="number">1</span>:</span><br><span class="line">                exist_cnt += <span class="number">1</span></span><br><span class="line">            rabin = (rabin * base + (ord(s[i]) - <span class="number">97</span>)) % mod</span><br><span class="line">            <span class="keyword">if</span> i &gt;= minSize:</span><br><span class="line">                exist[s[i - minSize]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> exist[s[i - minSize]] == <span class="number">0</span>:</span><br><span class="line">                    exist_cnt -= <span class="number">1</span></span><br><span class="line">                rabin = (rabin - base_mul * (ord(s[i - minSize]) - <span class="number">97</span>) % mod + mod) % mod</span><br><span class="line">            <span class="keyword">if</span> exist_cnt &lt;= maxLetters:</span><br><span class="line">                occ[rabin] += <span class="number">1</span></span><br><span class="line">                ans = max(ans, occ[rabin])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是字符串的长度。</p></li><li><p>空间复杂度：<em>O(N)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>1109. 航班预订统计</title>
    <link href="http://yoursite.com/2021/11/15/1109.%20%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/"/>
    <id>http://yoursite.com/2021/11/15/1109. 航班预订统计/</id>
    <published>2021-11-15T09:12:12.000Z</published>
    <updated>2021-11-16T10:48:19.465Z</updated>
    
    <content type="html"><![CDATA[<p>请你返回一个长度为 n 的数组answer，里面的元素是每个航班预定的座位总数。</p><a id="more"></a><p>[TOC]</p><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组answer，里面的元素是每个航班预定的座位总数。</p><p>示例 1：</p><pre><code>输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5输出：[10,55,45,25,25]解释：航班编号        1   2   3   4   5预订记录 1 ：   10  10预订记录 2 ：       20  20预订记录 3 ：       25  25  25  25总座位数：      10  55  45  25  25因此，answer = [10,55,45,25,25]</code></pre><p>示例 2：</p><pre><code>输入：bookings = [[1,2,10],[2,2,15]], n = 2输出：[10,25]解释：航班编号        1   2预订记录 1 ：   10  10预订记录 2 ：       15总座位数：      10  25因此，answer = [10,25]</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 2 * 1041 &lt;= bookings.length &lt;= 2 * 104bookings[i].length == 31 &lt;= firsti &lt;= lasti &lt;= n1 &lt;= seatsi &lt;= 104</code></pre><h1 id="方法一：差分"><a href="#方法一：差分" class="headerlink" title="方法一：差分"></a>方法一：差分</h1><p>注意到一个预订记录实际上代表了一个区间的增量。我们的任务是将这些增量叠加得到答案。因此，我们可以使用差分解决本题。</p><p>差分数组对应的概念是前缀和数组，对于数组 <em>[1,2,2,4]<em>，其差分数组为 *[1,1,0,2]</em>，差分数组的第 *i</em> 个数即为原数组的第 <em>i-1</em> 个元素和第 <em>i</em> 个元素的差值，也就是说我们对差分数组求前缀和即可得到原数组。</p><p>差分数组的性质是，当我们希望对原数组的某一个区间 <em>[l,r]</em> 施加一个增量inc 时，差分数组 <em>d</em> 对应的改变是：<em>d[l]</em> 增加 inc ，<em>d[r+1]</em> 减少inc 。这样对于区间的修改就变为了对于两个位置的修改。并且这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。</p><p>在本题中，我们可以遍历给定的预定记录数组，每次 <em>O(1)</em> 地完成对差分数组的修改即可。当我们完成了差分数组的修改，只需要最后求出差分数组的前缀和即可得到目标数组。</p><p>注意本题中日期从 <em>1</em> 开始，因此我们需要相应的调整数组下标对应关系，对于预定记录booking=[l,r,inc] ，我们需要让 <em>d[l-1]</em> 增加 inc ，<em>d[r]</em> 减少inc 。特别地，当 <em>r</em> 为 <em>n</em> 时，我们无需修改 <em>d[r]</em>，因为这个位置溢出了下标范围。如果求前缀和时考虑该位置，那么该位置对应的前缀和值必定为 <em>0</em>。读者们可以自行思考原因，以加深对差分数组的理解。</p><p><strong>代码</strong></p><details>    <summary>cpp</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; corpFlightBookings(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; booking : bookings) &#123;</span><br><span class="line">            nums[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">                nums[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] booking : bookings) &#123;</span><br><span class="line">            nums[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">                nums[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] CorpFlightBookings(int[][] bookings, int n) &#123;</span><br><span class="line">        int[] nums = new int[n];</span><br><span class="line">        foreach (int[] booking in bookings) &#123;</span><br><span class="line">            nums[booking[0] - 1] += booking[2];</span><br><span class="line">            if (booking[1] &lt; n) &#123;</span><br><span class="line">                nums[booking[1]] -= booking[2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">corpFlightBookings</span><span class="params">(<span class="keyword">int</span>** bookings, <span class="keyword">int</span> bookingsSize, <span class="keyword">int</span>* bookingsColSize, <span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* nums = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookingsSize; i++) &#123;</span><br><span class="line">        nums[bookings[i][<span class="number">0</span>] - <span class="number">1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (bookings[i][<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">            nums[bookings[i][<span class="number">1</span>]] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> corpFlightBookings = <span class="function"><span class="keyword">function</span>(<span class="params">bookings, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> booking <span class="keyword">of</span> bookings) &#123;</span><br><span class="line">        nums[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (booking[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">            nums[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">corpFlightBookings</span><span class="params">(self, bookings: List[List[int]], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        nums = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> left, right, inc <span class="keyword">in</span> bookings:</span><br><span class="line">            nums[left - <span class="number">1</span>] += inc</span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                nums[right] -= inc</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">corpFlightBookings</span><span class="params">(bookings [][]<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> _, booking := <span class="keyword">range</span> bookings &#123;</span><br><span class="line">        nums[booking[<span class="number">0</span>]<span class="number">-1</span>] += booking[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> booking[<span class="number">1</span>] &lt; n &#123;</span><br><span class="line">            nums[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        nums[i] += nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n+m)*，其中 *n</em> 为要求的数组长度，<em>m</em> 为预定记录的数量。我们需要对于每一条预定记录处理一次差分数组，并最后对差分数组求前缀和。</p></li><li><p>空间复杂度：<em>O(1)</em>。我们只需要常数的空间保存若干变量，注意返回值不计入空间复杂度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你返回一个长度为 n 的数组answer，里面的元素是每个航班预定的座位总数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Prefix Sum" scheme="http://yoursite.com/tags/Prefix-Sum/"/>
    
  </entry>
  
  <entry>
    <title>904. 水果成篮</title>
    <link href="http://yoursite.com/2021/11/15/904.%20%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"/>
    <id>http://yoursite.com/2021/11/15/904. 水果成篮/</id>
    <published>2021-11-15T03:12:12.000Z</published>
    <updated>2021-11-15T08:32:57.800Z</updated>
    
    <content type="html"><![CDATA[<p>能收集的水果树的最大总量是多少</p><a id="more"></a><p>[TOC]</p><p>在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>你可以从你选择的任何树开始，然后重复执行以下步骤：</p><p>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。<br>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。<br>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p><p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p><p>用这个程序你能收集的水果树的最大总量是多少？</p><p>示例 1：</p><pre><code>输入：[1,2,1]输出：3解释：我们可以收集 [1,2,1]。</code></pre><p>示例 2：</p><pre><code>输入：[0,1,2,2]输出：3解释：我们可以收集 [1,2,2]如果我们从第一棵树开始，我们将只能收集到 [0, 1]。</code></pre><p>示例 3：</p><pre><code>输入：[1,2,3,2,2]输出：4解释：我们可以收集 [2,3,2,2]如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</code></pre><p>示例 4：</p><pre><code>输入：[3,3,3,1,2,1,1,2,3,3,4]输出：5解释：我们可以收集 [1,2,1,1,2]如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。</code></pre><p>提示：</p><pre><code>1 &lt;= tree.length &lt;= 400000 &lt;= tree[i] &lt; tree.length</code></pre><h1 id="方法-1：按块扫描"><a href="#方法-1：按块扫描" class="headerlink" title="方法 1：按块扫描"></a>方法 1：按块扫描</h1><p><strong>想法</strong></p><p>问题等价于，找到最长的子序列，最多含有两种“类型”（<code>tree[i]</code> 的值）。</p><p>不单独考虑每个元素，转而考虑相同类型的相连块。</p><p>比如说，<code>tree = [1, 1, 1, 1, 2, 2, 3, 3, 3]</code> 可以看成是 <code>blocks = [(1, weight = 4), (2, weight = 2), (3, weight = 3)]</code>。</p><p>现在可以使用暴力，从左往右扫描。我们会有类似于 <code>blocks = [1, _2_, 1, 2, 1, 2, _1_, 3, ...]</code> 以及对应权重。</p><p>处理的核心思想是，当我们考虑 <code>3</code> 的时候，我们不需要从第二个元素 <code>2</code> （也就是标记成 <code>_2_</code> 的数字）开始考虑，我们可以从 <code>3</code> 之前的第一个元素开始考虑（<code>_1_</code>）。这是因为如果我们从前两个或更多元素开始，这个序列一定包含类型 <code>1</code> 和 <code>2</code>，所以序列一定会在 <code>3</code> 处停止，这就比已经考虑的序列更短了。</p><p>从每个开始点（块的最左端点）开始考虑，这个结果一定是对的。</p><p><strong>算法</strong></p><p>Python 和 Java 的实现方法，符号和策略有所不同，可以查看代码内的注释。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// We'll make a list of indexes for which a block starts.</span></span><br><span class="line">        List&lt;Integer&gt; blockLefts = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the left boundary of each block</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.length; ++i)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || tree[i-<span class="number">1</span>] != tree[i])</span><br><span class="line">                blockLefts.add(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add tree.length as a sentinel for convenience</span></span><br><span class="line">        blockLefts.add(tree.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//跳转标识，里层循环 continue直接跳出外层循环，继续执行外层循环</span></span><br><span class="line">        search: <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// We'll start our scan at block[i].</span></span><br><span class="line">            <span class="comment">// types : the different values of tree[i] seen</span></span><br><span class="line">            <span class="comment">// weight : the total number of trees represented</span></span><br><span class="line">            <span class="comment">//          by blocks under consideration</span></span><br><span class="line">            Set&lt;Integer&gt; types = <span class="keyword">new</span> HashSet();</span><br><span class="line">            <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For each block from the i-th and going forward,</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; blockLefts.size() - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">// Add each block to consideration</span></span><br><span class="line">                types.add(tree[blockLefts.get(j)]);</span><br><span class="line">                weight += blockLefts.get(j+<span class="number">1</span>) - blockLefts.get(j);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If we have 3+ types, this is an illegal subarray</span></span><br><span class="line">                <span class="keyword">if</span> (types.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span> search;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If it is a legal subarray, record the answer</span></span><br><span class="line">                ans = Math.max(ans, weight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        blocks = [(k, len(list(v)))</span><br><span class="line">                  <span class="keyword">for</span> k, v <span class="keyword">in</span> itertools.groupby(tree)]</span><br><span class="line"></span><br><span class="line">        ans = i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(blocks):</span><br><span class="line">            <span class="comment"># We'll start our scan at block[i].</span></span><br><span class="line">            <span class="comment"># types : the different values of tree[i] seen</span></span><br><span class="line">            <span class="comment"># weight : the total number of trees represented</span></span><br><span class="line">            <span class="comment">#          by blocks under consideration</span></span><br><span class="line">            types, weight = set(), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># For each block from i and going forward,</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i, len(blocks)):</span><br><span class="line">                <span class="comment"># Add each block to consideration</span></span><br><span class="line">                types.add(blocks[j][<span class="number">0</span>])</span><br><span class="line">                weight += blocks[j][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If we have 3 types, this is not a legal subarray</span></span><br><span class="line">                <span class="keyword">if</span> len(types) &gt;= <span class="number">3</span>:</span><br><span class="line">                    i = j<span class="number">-1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                ans = max(ans, weight)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If we go to the last block, then stop</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 是 <code>tree</code> 的长度。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><h1 id="方法-2：滑动窗口"><a href="#方法-2：滑动窗口" class="headerlink" title="方法 2：滑动窗口"></a>方法 2：滑动窗口</h1><p><strong>想法</strong></p><p>在<em>方法 1</em>中，我们希望找到最长的包含两种不同“类型”的子序列，我们称这样的子序列为<em>合法的</em>。</p><p>假设我们考虑所有以下标 <code>j</code> 为结尾的合法子序列，那么一定有一个最小的开始下标 <code>i</code>：称之为 <code>opt(j) = i</code>。</p><p>我们会发现这个 <code>opt(j)</code> 是一个单调递增的函数，这是因为所有合法子序列的子序列一定也是合法的。</p><p><strong>算法</strong></p><p>模拟一个滑动窗口，维护变量 <code>i</code> 是最小的下标满足 <code>[i, j]</code> 是合法的子序列。</p><p>维护 <code>count</code> 是序列中各种类型的个数，这使得我们可以很快知道子序列中是否含有 3 中类型。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        Counter count = <span class="keyword">new</span> Counter();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tree.length; ++j) &#123;</span><br><span class="line">            count.add(tree[j], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                count.add(tree[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.get(tree[i]) == <span class="number">0</span>)</span><br><span class="line">                    count.remove(tree[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(k) ? <span class="keyword">super</span>.get(k) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        put(k, get(k) + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>我的滑动窗口写法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="keyword">int</span>[] fruits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找最多只含两种元素的最长连续子数组长度</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(fruits[i], map.getOrDefault(fruits[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(fruits[left], map.getOrDefault(fruits[left], <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.getOrDefault(fruits[left], <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxlen = Math.max(maxlen, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        ans = i = <span class="number">0</span></span><br><span class="line">        count = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> j, x <span class="keyword">in</span> enumerate(tree):</span><br><span class="line">            count[x] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> len(count) &gt;= <span class="number">3</span>:</span><br><span class="line">                count[tree[i]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count[tree[i]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> count[tree[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            ans = max(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 是 <code>tree</code> 的长度。</li><li>空间复杂度：<em>O(N)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能收集的水果树的最大总量是多少&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>《天龙八部》读书笔记</title>
    <link href="http://yoursite.com/2021/11/12/%E3%80%8A%E5%A4%A9%E9%BE%99%E5%85%AB%E9%83%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/11/12/《天龙八部》读书笔记/</id>
    <published>2021-11-12T15:12:12.000Z</published>
    <updated>2021-11-17T07:49:25.532Z</updated>
    
    <content type="html"><![CDATA[<p>重读有感</p><a id="more"></a><p>[TOC]</p><p>近来睡前听天龙八部有声小说，所谓重读大半是重听，耳中所闻尽可归为四字:众生皆苦。</p><p>整部书更像是一本大型的武侠版神话寓言故事集。写尽了人性中的贪嗔痴。正如希腊神话故事中诸神虽不食人间烟火却仍摆脱不了喜怒哀乐情妒贪嗔一样，天龙八部中众生无分国别门派，不论武功修为，人人都有解不脱的名利缰锁，断不去的痴心欲念。但有我执，有所求就免不了堕入娑婆世界中的三类苦中。</p><p>佛经中有苦苦、坏苦、行苦三类之说。</p><p>人生来即能感受到的痛苦为苦苦：即生、老、病、死、爱别离、求不得、怨憎会、五蕴炽盛。</p><p>书中大多数人物都溺于此八苦无法自拔，有萧峰阿朱塞上牛羊空许约的爱别离苦，有慕容氏执着复国却成空梦一场的求不得苦，有童姥李秋水七十余载情怨纠葛的怨憎会苦。世事无常，造化弄人。玲珑棋局非要无心方可解，名带坦之偏却一生坎坷难平。欲求情爱而不得的段誉最后出家为僧，只愿参诵经礼佛的虚竹却破戒终落尘网。只要未勘破我执的，任凭武功如何超凡入圣，得遇再多机缘巧合也难免五蕴炽盛，被人世间种种苦恼日日煎熬。</p><p>此一类苦苦，初读天龙八部便已有所感悟，然而对众生所历坏苦和行苦却是此次重读才初有理解。以下算是一些读书摘要。虽然是从佛家观点出发，但也足以从另一个角度开启心智。</p><p>何谓坏苦，是指我们通常快乐的感受。从佛家观点出发，我们所谓的快乐受并非真正的快乐，其实质也是痛苦的。饥饿时想吃，吃饱了感到快乐，但继续吃下去却还会觉得快乐吗？无聊了想刷手机觉得快乐，但没日没夜的看下去觉得快乐吗？由此可见我们的所谓快乐，是因为我们有了某种欲望之后，通过外境的刺激得到满足心理上出现暂时的平衡，于是我们觉得快乐，然而这种欲望满足后的实质并非快乐，倘若实质是快乐的话，无论外境刺激多少次都应该觉得快乐，然而事实不然，当我们带着强烈的欲望寻求满足时，初始感到快乐，但到后来会发现此时已由原来的快乐转变为痛苦了。就像自我刺激奖赏中枢实验中不休不止按动开关的小鼠一样沦为了多巴胺的奴隶，世间上一切通过欲望得到的快乐莫不如此，因为这种乐受能变坏，因此称为坏苦。</p><p>行苦：行，是迁流变化义。世间一切都是无常变化，这是宇宙人生之规律。但世人不识这种规律，追求永恒：希望身体永恒、家庭永恒、事业永恒、爱情永恒，然而世事无常，美好的事物往往是昙花一现，转瞬即逝。由于我们的认识与世间的事实——行，相违背，因而就有了行苦。</p><p>往昔身经求不得之苦时往往想象求得后心情该如何舒畅，人生自当圆满无憾矣，却不知月满则亏，水满则溢。求得之时即是坏苦之始，更引行苦而来。婆娑苦乐杂，若是身处苦苦之中便能以此自省，想必苦楚自能顿减三分。孔夫子七十而从心所欲不逾矩，并非圣人无欲无求或无所不能，而是能使一己所欲不超出人和社会的规则之外，如此自然少了诸多烦恼。这些道理知易行难，有时身在局中执迷难悟。而立之年将至，需时时以此自省。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重读有感&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>795. 区间子数组个数</title>
    <link href="http://yoursite.com/2021/11/12/795.%20%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2021/11/12/795. 区间子数组个数/</id>
    <published>2021-11-12T12:12:12.000Z</published>
    <updated>2021-11-14T01:16:35.388Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个元素都是正整数的数组A，正整数 L以及R(L&lt;= R)。</p><a id="more"></a><p>[TOC]</p><p>求连续、非空且其中最大元素满足大于等于L 小于等于R的子数组个数。</p><p>例如 :</p><pre><code>输入: A = [2, 1, 4, 3]L = 2R = 3输出: 3解释: 满足条件的子数组: [2], [2, 1], [3].注意:L, R  和 A[i] 都是整数，范围在 [0, 10^9]。数组 A 的长度范围在[1, 50000]。</code></pre><h1 id="方法一：计数"><a href="#方法一：计数" class="headerlink" title="方法一：计数"></a>方法一：计数</h1><p><strong>思想</strong></p><p>根据以下步骤推导出解决方案：</p><p>其实我们只关心数组中的元素是否小于 <code>L</code>，大于 <code>R</code>，或者位于 <code>[L, R]</code> 之间。假设一个元素小于 <code>L</code> 标记为 <code>0</code>，位于 <code>[L, R]</code> 之间标记为 <code>1</code>，大于 <code>R</code> 标记为 <code>2</code>。</p><p>我们希望找出不包含 <code>2</code> 且至少包含一个 <code>1</code> 的子数组数量。因此可以看作是所有的 <code>2</code> 将数组拆分为仅包含 <code>0</code> 或 <code>1</code> 的子数组。例如在数组 <code>[0, 0, 1, 2, 2, 1, 0, 2, 0]</code>，<code>2</code> 将数组拆分为 <code>[0, 0, 1]</code>、<code>[1, 0]</code> 和 <code>[0]</code> 三个子数组。 </p><p>接下来，需要计算每个只包含 <code>0</code> 或 <code>1</code> 的数组中，至少包含一个 <code>1</code> 的子数组数量。那么问题可以转换为先找出所有的子数组，再从中减去只包含 <code>0</code> 的子数组。</p><p>例如，<code>[0, 0, 1]</code> 有 6 个子数组，其中 3 个子数组只包含 <code>0</code>，3 个子数组至少包含一个 <code>1</code>；<code>[1, 0]</code> 有 3 个子数组，其中 1 个子数组只包含 <code>0</code>，2 个子数组至少包含一个 <code>1</code>；<code>[0]</code> 只有 1 个子数组，且这个子数组只包含 <code>0</code>。因此数组 <code>A = [0, 0, 1, 2, 2, 1, 0, 2, 0]</code> 中不包含 <code>2</code>，且至少包含一个 <code>1</code> 的子数组的数量是 <code>3 + 2 + 0 = 5</code>。</p><p><strong>算法</strong></p><p>假设 <code>count(B)</code> 用于计算所有元素都小于等于 <code>B</code> 的子数组数量。根据上面分析，本题答案为 <code>count(R) - count(L-1)</code>。</p><p>那么如何计算 <code>count(B)</code>？使用 <code>cur</code> 记录在 <code>B</code> 的左边，小于等于 <code>B</code> 的连续元素数量。当找到一个这样的元素时，在此位置上结束的有效子数组的数量为 <code>cur + 1</code>。当遇到一个元素大于 <code>B</code> 时，则在此位置结束的有效子数组的数量为 0。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count(A, R) - count(A, L-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) &#123;</span><br><span class="line">            cur = x &lt;= bound ? cur + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            ans += cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(self, A, L, R)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(bound)</span>:</span></span><br><span class="line">            ans = cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> A :</span><br><span class="line">                cur = cur + <span class="number">1</span> <span class="keyword">if</span> x &lt;= bound <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                ans += cur</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count(R) - count(L - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)</em>，其中 <code>N</code> 是 <code>A</code> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个元素都是正整数的数组A，正整数 L以及R(L&amp;lt;= R)。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>467. 环绕字符串中唯一的子字符串</title>
    <link href="http://yoursite.com/2021/11/10/467.%20%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/10/467. 环绕字符串中唯一的子字符串/</id>
    <published>2021-11-10T08:12:12.000Z</published>
    <updated>2021-11-12T10:05:45.222Z</updated>
    
    <content type="html"><![CDATA[<p>你需要输出字符串s 中 p 的不同的非空子串的数目。</p><a id="more"></a><p>[TOC]</p><p>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以s看起来是这样的：”…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p><p>现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串s 中 p 的不同的非空子串的数目。</p><p>注意: p仅由小写的英文字母组成，p 的大小可能超过 10000。</p><p>示例 1:</p><pre><code>输入: &quot;a&quot;输出: 1解释: 字符串 S 中只有一个&quot;a&quot;子字符。</code></pre><p>示例 2:</p><pre><code>输入: &quot;cac&quot;输出: 2解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.</code></pre><p>示例 3:</p><pre><code>输入: &quot;zab&quot;输出: 6解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.</code></pre><h1 id="方法一：统计所有以每个字符结尾的最长连续子串的长度"><a href="#方法一：统计所有以每个字符结尾的最长连续子串的长度" class="headerlink" title="方法一：统计所有以每个字符结尾的最长连续子串的长度"></a>方法一：统计所有以每个字符结尾的最长连续子串的长度</h1><p>题意，假设有一个 a-z 无限循环的字符串 s，计算它和字符串 p 中有多少个相等的非空子串。题目中唯一的意思是，假设 <code>p=aa</code>，字符串 p 中有两个 <code>a</code>，相等的子串记作一个，即 <code>a</code>。</p><p>当 <code>p=cac</code> 时，有 <code>a 和 c</code>，因为 <code>ac、ca、cac</code> 不是 s 的子串。当 <code>p=bcabc</code> 时，有 <code>a、b、ab、c、bc、abc</code>。</p><ul><li>连续子串<code>a</code> 中以字符<code>a</code> 结尾的连续子串有<code>a</code>。</li><li>连续子串<code>b</code> 中以字符<code>b</code> 结尾的连续子串有<code>b</code>；而连续子串<code>ab</code> 以字符<code>b</code> 结尾的连续子串有<code>b、ab</code>。</li><li>连续子串<code>c</code> 中以字符<code>c</code> 结尾的连续子串有<code>c</code>，连续子串<code>bc</code> 中以字符<code>c</code> 结尾的连续子串有<code>c、bc</code>；连续子串<code>abc</code> 中以字符<code>c</code> 结尾的连续子串有<code>c、bc、abc</code>。</li><li>不难发现以该字符结尾的连续子串的长度，就等于以该字符结尾的相等子串的个数。</li></ul><p>所以我们只需求出p中以每个字符结尾的最长连续子串的长度即可。统计所有以每个字符结尾的最长连续子串的长度，就是唯一相等子串的个数。注意：因为 s 是一个循环字符串，所以 <code>za</code> 也是连续子串。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findSubstringInWraproundString(String p) &#123;</span><br><span class="line">        // 记录 p 中以每个字符结尾的最长连续子串的长度</span><br><span class="line">        int[] dp = new int[26];</span><br><span class="line">        char[] array = p.toCharArray();</span><br><span class="line">        // 记录当前连续子串的长度</span><br><span class="line">        int count = 0;</span><br><span class="line">        // 遍历 p 中的所有字符</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            // 判断字符是否连续</span><br><span class="line">            if (i &gt; 0 &amp;&amp; (array[i] - array[i - 1] - 1) % 26 == 0) &#123;</span><br><span class="line">                // 连续则自加</span><br><span class="line">                count++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不连续则刷新</span><br><span class="line">                count = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 只存储最长的连续长度</span><br><span class="line">            dp[array[i] - &apos;a&apos;] = Math.max(dp[array[i] - &apos;a&apos;], count);</span><br><span class="line">        &#125;</span><br><span class="line">        int result = 0;</span><br><span class="line">        // 统计所有以每个字符结尾的最长连续子串的长度，就是唯一相等子串的个数</span><br><span class="line">        for (int i : dp) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>代码优化</strong></p><p>上面的代码中，对于每一个字符都进行了一次判断、赋值。我们可以先计算出当前最长的连续子串，然后再计算其中所有连续子串的长度。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findSubstringInWraproundString(String p) &#123;</span><br><span class="line">        // // 记录 p 中以每个字符结尾的最长连续子串的长度</span><br><span class="line">        int[] dp = new int[26];</span><br><span class="line">        char[] array = p.toCharArray();</span><br><span class="line">        // 连续子串的开始下标</span><br><span class="line">        int start = 0;</span><br><span class="line">        while (start &lt; array.length) &#123;</span><br><span class="line">            // 连续子串的结束下标</span><br><span class="line">            int end = start + 1;</span><br><span class="line">            // 结束下标向后移动，寻找当前最长的连续子串</span><br><span class="line">            while (end &lt; array.length &amp;&amp; (array[end] - array[end-1] - 1) % 26 == 0) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 计算连续子串的长度</span><br><span class="line">            int length = end - start;</span><br><span class="line">            // 遍历连续子串的所有字符</span><br><span class="line">            for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">                // 计算当前字符在数组的下标</span><br><span class="line">                int index = array[i] - &apos;a&apos;;</span><br><span class="line">                // 计算当前连续子串的长度</span><br><span class="line">                int l = length - (i - start);</span><br><span class="line">                dp[index] = Math.max(dp[index], l);</span><br><span class="line">            &#125;</span><br><span class="line">            start = end;</span><br><span class="line">        &#125;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int i : dp) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul><li><a href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/" target="_blank" rel="noopener">467. 环绕字符串中唯一的子字符串</a>(中等)</li><li><a href="https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/" target="_blank" rel="noopener">795. 区间子数组个数</a>(中等)</li><li><a href="https://leetcode-cn.com/problems/fruit-into-baskets/" target="_blank" rel="noopener">904. 水果成篮</a>(中等)</li><li><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. K 个不同整数的子数组</a>（困难）</li><li><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">1109. 航班预订统计</a>(中等)</li></ul><p>前四道题都是滑动窗口的子类型，我们知道滑动窗口适合在题目要求连续的情况下使用， 而<a href="https://oi-wiki.org/basic/prefix-sum/" target="_blank" rel="noopener">前缀和</a>也是如此。二者在连续问题中，对于<strong>优化时间复杂度</strong>有着很重要的意义。 因此如果一道题你可以用暴力解决出来，而且题目恰好有连续的限制， 那么滑动窗口和前缀和等技巧就应该被想到。</p><p>除了这几道题， 还有很多题目都是类似的套路， 大家可以在学习过程中进行体会。今天我们就来一起学习一下。</p><h2 id="前情摘要"><a href="#前情摘要" class="headerlink" title="前情摘要"></a>前情摘要</h2><p>我们从一个简单的问题入手，识别一下这种题的基本形式和套路，为之后的四道题打基础。当你了解了这个套路之后， 之后做这种题就可以直接套。</p><p>需要注意的是这四道题的前置知识都是 <code>滑动窗口</code>， 不熟悉的同学可以先看下之前写的 <a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md" target="_blank" rel="noopener">滑动窗口专题（思路 + 模板）</a></p><h3 id="母题-0"><a href="#母题-0" class="headerlink" title="母题 0"></a>母题 0</h3><p>有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。</p><p>这道题可以使用前缀和来解决。 前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。</p><p>对 [1,2,3,4,5,6] 来说，其前缀和可以是 pre=[1,3,6,10,15,21]。我们可以使用公式 pre[𝑖]=pre[𝑖−1]+nums[𝑖]得到每一位前缀和的值，从而通过前缀和进行相应的计算和解题。其实前缀和的概念很简单，但困难的是如何在题目中使用前缀和以及如何使用前缀和的关系来进行解题。</p><h3 id="母题-1"><a href="#母题-1" class="headerlink" title="母题 1"></a>母题 1</h3><p>如果让你求一个数组的连续子数组总个数，你会如何求？其中连续指的是数组的索引连续。 比如 [1,3,4]，其连续子数组有：<code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，你需要返回 6。</p><p>一种思路是总的连续子数组个数等于：<strong>以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数</strong>，这无疑是完备的。</p><p>同时<strong>利用母题 0 的前缀和思路， 边遍历边求和。</strong></p><p>参考代码(JS)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSubArray</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (_ <span class="keyword">in</span> nums) &#123;</span><br><span class="line">    pre += <span class="number">1</span>;</span><br><span class="line">    ans += pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em>，其中 N 为数组长度。</li><li>空间复杂度：<em>O(1)</em></li></ul><p>而由于以索引为 i 结尾的子数组个数就是 i + 1，因此这道题可以直接用等差数列求和公式 <code>(1 + n) * n / 2</code>，其中 n 数组长度。</p><h3 id="母题-2"><a href="#母题-2" class="headerlink" title="母题 2"></a>母题 2</h3><p>我继续修改下题目， 如果让你求一个数组相邻差为 1 连续子数组的总个数呢？其实就是<strong>索引差 1 的同时，值也差 1。</strong></p><p>和上面思路类似，无非就是增加差值的判断。</p><p>参考代码(JS)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSubArray</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] - nums[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">      pre += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans += pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em>，其中 N 为数组长度。</li><li>空间复杂度：<em>O(1)</em></li></ul><p>如果我值差只要大于 1 就行呢？其实改下符号就行了，这不就是求上升子序列个数么？这里不再继续赘述， 大家可以自己试试。</p><h3 id="母题-3"><a href="#母题-3" class="headerlink" title="母题 3"></a>母题 3</h3><p>我们继续扩展。</p><p>如果我让你求出不大于 k 的子数组的个数呢？不大于 k 指的是子数组的全部元素都不大于 k。 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，不大于 3 的子数组有 <code>[1], [3], [1,3]</code> ，那么 [1,3,4] 不大于 3 的子数组个数就是 3。 实现函数 atMostK(k, nums)。</p><p>参考代码（JS）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSubArray</span>(<span class="params">k, nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= k) &#123;</span><br><span class="line">      pre += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans += pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em>，其中 N 为数组长度。</li><li>空间复杂度：<em>O(1)</em></li></ul><h3 id="母题-4"><a href="#母题-4" class="headerlink" title="母题 4"></a>母题 4</h3><p>如果我让你求出子数组最大值刚好是 k 的子数组的个数呢？ 比如 [1,3,4] 子数组有 <code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，子数组最大值刚好是 3 的子数组有 <code>[3], [1,3]</code> ，那么 [1,3,4] 子数组最大值刚好是 3 的子数组个数就是 2。实现函数 exactK(k, nums)。</p><p>实际上是 exactK 可以直接利用 atMostK，即 atMostK(k) - atMostK(k - 1)，原因见下方母题 5 部分。</p><h3 id="母题-5"><a href="#母题-5" class="headerlink" title="母题 5"></a>母题 5</h3><p>如果我让你求出子数组最大值刚好是 介于 k1 和 k2 的子数组的个数呢？实现函数 betweenK(k1, k2, nums)。</p><p>实际上是 betweenK 可以直接利用 atMostK，即 atMostK(k1, nums) - atMostK(k2 - 1, nums)，其中 k1 &gt; k2。前提是值是离散的， 比如上面我出的题都是整数。 因此我可以直接 减 1，因为 <strong>1 是两个整数最小的间隔</strong>。</p><p>如上，<code>小于等于 10 的区域</code>减去 <code>小于 5 的区域</code>就是 <code>大于等于 5 且小于等于 10 的区域</code>。</p><p>注意我说的是小于 5， 不是小于等于 5。 由于整数是离散的，最小间隔是 1。因此小于 5 在这里就等价于 小于等于 4。这就是 betweenK(k1, k2, nums) = atMostK(k1) - atMostK(k2 - 1) 的原因。</p><p>因此不难看出 exactK 其实就是 betweenK 的特殊形式。 当 k1 == k2 的时候， betweenK 等价于 exactK。</p><p>因此 atMostK 就是灵魂方法，一定要掌握，不明白建议多看几遍。</p><p>有了上面的铺垫， 我们来看下第一道题。</p><h2 id="467-环绕字符串中唯一的子字符串（中等）"><a href="#467-环绕字符串中唯一的子字符串（中等）" class="headerlink" title="467. 环绕字符串中唯一的子字符串（中等）"></a>467. 环绕字符串中唯一的子字符串（中等）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><details>    <summary>题目描述</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的：&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;. </span><br><span class="line"></span><br><span class="line">现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 </span><br><span class="line"></span><br><span class="line">注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 S 中只有一个&quot;a&quot;子字符。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.</span><br></pre></td></tr></table></figure></details><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目是让我们找 p 在 s 中出现的非空子串数目，而 s 是固定的一个无限循环字符串。由于 p 的数据范围是 10^5 ，因此暴力找出所有子串就需要 10^10 次操作了，应该会超时。而且题目很多信息都没用到，肯定不对。</p><p>仔细看下题目发现，这不就是母题 2 的变种么？话不多说， 直接上代码，看看有多像。</p><blockquote><p>为了减少判断， 我这里用了一个黑科技， p 前面加了个 <code>^</code>。</p></blockquote><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstringInWraproundString</span><span class="params">(self, p: str)</span> -&gt; int:</span></span><br><span class="line">        p = <span class="string">'^'</span> + p</span><br><span class="line">        w = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)):</span><br><span class="line">            <span class="keyword">if</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">1</span> <span class="keyword">or</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">-25</span>:</span><br><span class="line">                w += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                w = <span class="number">1</span></span><br><span class="line">            ans += w</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p>如上代码是有问题。 比如 <code>cac</code>会被计算为 3，实际上应该是 2。根本原因在于 c 被错误地计算了两次。因此一个简单的思路就是用 set 记录一下访问过的子字符串即可。比如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c,</span><br><span class="line">    abc,</span><br><span class="line">    ab,</span><br><span class="line">    abcd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而由于 set 中的元素一定是连续的，因此上面的数据也可以用 hashmap 存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c: 3</span><br><span class="line">    d: 4</span><br><span class="line">    b: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>含义是：</p><ul><li>以 b 结尾的子串最大长度为 1，也就是 b。</li><li>以 c 结尾的子串最大长度为 3，也就是 abc。</li><li>以 d 结尾的子串最大长度为 4，也就是 abcd。</li></ul><p>至于 c ，是没有必要存的。我们可以通过母题 2 的方式算出来。</p><p>具体算法：</p><ul><li>定义一个 len_mapper。key 是 字母， value 是 长度。 含义是以 key 结尾的最长连续子串的长度。</li></ul><blockquote><p>关键字是：最长</p></blockquote><ul><li>用一个变量 w 记录连续子串的长度，遍历过程根据 w 的值更新 len_mapper</li><li>返回 len_mapper 中所有 value 的和。</li></ul><p>比如: abc，此时的 len_mapper 为:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如：abcab，此时的 len_mapper 依旧。</p><p>再比如: abcazabc，此时的 len_mapper：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c: <span class="number">4</span></span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">    z: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就得到了去重的目的。这种算法是不重不漏的，因为最长的连续子串一定是包含了比它短的连续子串，这个思想和 <a href="https://github.com/azl397985856/leetcode/issues/266" target="_blank" rel="noopener">1297. 子串的最大出现次数</a> 剪枝的方法有异曲同工之妙。</p><h3 id="代码（Python）"><a href="#代码（Python）" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstringInWraproundString</span><span class="params">(self, p: str)</span> -&gt; int:</span></span><br><span class="line">        p = <span class="string">'^'</span> + p</span><br><span class="line">        len_mapper = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)</span><br><span class="line">        w = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(p)):</span><br><span class="line">            <span class="keyword">if</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">1</span> <span class="keyword">or</span> ord(p[i])-ord(p[i<span class="number">-1</span>]) == <span class="number">-25</span>:</span><br><span class="line">                w += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                w = <span class="number">1</span></span><br><span class="line">            len_mapper[p[i]] = max(len_mapper[p[i]], w)</span><br><span class="line">        <span class="keyword">return</span> sum(len_mapper.values())</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 为字符串 p 的长度。</li><li>空间复杂度：由于最多存储 26 个字母， 因此空间实际上是常数，故空间复杂度为 <em>O(1)</em>。</li></ul><h2 id="795-区间子数组个数（中等）"><a href="#795-区间子数组个数（中等）" class="headerlink" title="795. 区间子数组个数（中等）"></a>795. 区间子数组个数（中等）</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给定一个元素都是正整数的数组 A ，正整数 L  以及  R (L &lt;= R)。</span><br><span class="line"></span><br><span class="line">求连续、非空且其中最大元素满足大于等于 L  小于等于 R 的子数组个数。</span><br><span class="line"></span><br><span class="line">例如 :</span><br><span class="line">输入:</span><br><span class="line">A = [2, 1, 4, 3]</span><br><span class="line">L = 2</span><br><span class="line">R = 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 满足条件的子数组: [2], [2, 1], [3].</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">L, R  和  A[i] 都是整数，范围在  [0, 10^9]。</span><br><span class="line">数组  A  的长度范围在[1, 50000]。</span><br></pre></td></tr></table></figure><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>由母题 5，我们知道 <strong>betweenK 可以直接利用 atMostK，即 atMostK(k1) - atMostK(k2 - 1)，其中 k1 &gt; k2</strong>。</p><p>由母题 2，我们知道如何求满足一定条件（这里是元素都小于等于 R）子数组的个数。</p><p>这两个结合一下， 就可以解决。</p><h3 id="代码（Python）-1"><a href="#代码（Python）-1" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><blockquote><p>代码是不是很像</p></blockquote><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(self, A: List[int], L: int, R: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">notGreater</span><span class="params">(R)</span>:</span></span><br><span class="line">            ans = cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> a &lt;= R: cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: cnt = <span class="number">0</span></span><br><span class="line">                ans += cnt</span><br><span class="line">            <span class="keyword">return</span>  ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> notGreater(R) - notGreater(L - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(1)</em>。</li></ul><h2 id="904-水果成篮（中等）"><a href="#904-水果成篮（中等）" class="headerlink" title="904. 水果成篮（中等）"></a>904. 水果成篮（中等）</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">在一排树中，第 i 棵树产生 tree[i] 型的水果。</span><br><span class="line">你可以从你选择的任何树开始，然后重复执行以下步骤：</span><br><span class="line"></span><br><span class="line">把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</span><br><span class="line">移动到当前树右侧的下一棵树。如果右边没有树，就停下来。</span><br><span class="line">请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</span><br><span class="line"></span><br><span class="line">你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</span><br><span class="line"></span><br><span class="line">用这个程序你能收集的水果树的最大总量是多少？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以收集 [1,2,1]。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以收集 [1,2,2]</span><br><span class="line">如果我们从第一棵树开始，我们将只能收集到 [0, 1]。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：我们可以收集 [2,3,2,2]</span><br><span class="line">如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：[3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：我们可以收集 [1,2,1,1,2]</span><br><span class="line">如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= tree.length &lt;= 40000</span><br><span class="line">0 &lt;= tree[i] &lt; tree.length</span><br></pre></td></tr></table></figure><h3 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目花里胡哨的。我们来抽象一下，就是给你一个数组， 让你<strong>选定一个子数组， 这个子数组最多只有两种数字</strong>，这个选定的子数组最大可以是多少。</p><p>这不就和母题 3 一样么？只不过 k 变成了固定值 2。另外由于题目要求整个窗口最多两种数字，我们用哈希表存一下不就好了吗？</p><blockquote><p>set 是不行了的。 因此我们不但需要知道几个数字在窗口， 我们还要知道每个数字出现的次数，这样才可以使用滑动窗口优化时间复杂度。</p></blockquote><h3 id="代码（Python）-2"><a href="#代码（Python）-2" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">atMostK</span><span class="params">(k, nums)</span>:</span></span><br><span class="line">            i = ans = <span class="number">0</span></span><br><span class="line">            win = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> win[nums[j]] == <span class="number">0</span>: k -= <span class="number">1</span></span><br><span class="line">                win[nums[j]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                    win[nums[i]] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> win[nums[i]] == <span class="number">0</span>: k += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                ans = max(ans, j - i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> atMostK(<span class="number">2</span>, tree)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(k)</em>。</li></ul><h2 id="992-K-个不同整数的子数组（困难）"><a href="#992-K-个不同整数的子数组（困难）" class="headerlink" title="992. K 个不同整数的子数组（困难）"></a>992. K 个不同整数的子数组（困难）</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。</span><br><span class="line"></span><br><span class="line">（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）</span><br><span class="line"></span><br><span class="line">返回 A 中好子数组的数目。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A = [1,2,1,2,3], K = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A = [1,2,1,3,4], K = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= A.length &lt;= 20000</span><br><span class="line">1 &lt;= A[i] &lt;= A.length</span><br><span class="line">1 &lt;= K &lt;= A.length</span><br></pre></td></tr></table></figure><h3 id="前置知识-3"><a href="#前置知识-3" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>滑动窗口</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>由母题 5，知：exactK = atMostK(k) - atMostK(k - 1)， 因此答案便呼之欲出了。其他部分和上面的题目 <code>904. 水果成篮</code> 一样。</p><blockquote><p>实际上和所有的滑动窗口题目都差不多。</p></blockquote><h3 id="代码（Python）-3"><a href="#代码（Python）-3" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.atMostK(A, K) - self.atMostK(A, K - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">atMostK</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        counter = collections.Counter()</span><br><span class="line">        res = i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> counter[A[j]] == <span class="number">0</span>:</span><br><span class="line">                K -= <span class="number">1</span></span><br><span class="line">            counter[A[j]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> K &lt; <span class="number">0</span>:</span><br><span class="line">                counter[A[i]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> counter[A[i]] == <span class="number">0</span>:</span><br><span class="line">                    K += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res += j - i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(k)</em>。</li></ul><h2 id="1109-航班预订统计（中等）"><a href="#1109-航班预订统计（中等）" class="headerlink" title="1109. 航班预订统计（中等）"></a>1109. 航班预订统计（中等）</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里有  n  个航班，它们分别从 1 到 n 进行编号。</span><br><span class="line"></span><br><span class="line">我们这儿有一份航班预订表，表中第  i  条预订记录  bookings[i] = [i, j, k]  意味着我们在从  i  到  j  的每个航班上预订了 k 个座位。</span><br><span class="line"></span><br><span class="line">请你返回一个长度为 n 的数组  answer，按航班编号顺序返回每个航班上预订的座位数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= bookings.length &lt;= 20000</span><br><span class="line">1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000</span><br><span class="line">1 &lt;= bookings[i][2] &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="前置知识-4"><a href="#前置知识-4" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>前缀和</li></ul><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这道题的题目描述不是很清楚。我简单分析一下题目：</p><p>[i, j, k] 其实代表的是 第 i 站上来了 k 个人， 一直到 第 j 站都在飞机上，到第 j + 1 就不在飞机上了。所以第 i 站到第 j 站的<strong>每一站</strong>都会因此多 k 个人。</p><p>理解了题目只会不难写出下面的代码。</p><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">corpFlightBookings</span><span class="params">(self, bookings: List[List[int]], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        counter = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j, k <span class="keyword">in</span> bookings:</span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                counter[i - <span class="number">1</span>] += k</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counter</span><br></pre></td></tr></table></figure></details><p>如上的代码复杂度太高，无法通过全部的测试用例。</p><p><strong>注意到里层的 while 循环是连续的数组全部加上一个数字，不难想到可以利用母题 0 的前缀和思路优化。</strong></p><p>一种思路就是在 i 的位置 + k， 然后利用前缀和的技巧给 i 到 n 的元素都加上 k。但是题目需要加的是一个区间， j + 1 及其之后的元素会被多加一个 k。一个简单的技巧就是给 j + 1 的元素减去 k，这样正负就可以抵消。</p><h3 id="代码（Python）-4"><a href="#代码（Python）-4" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><details>    <summary>Python</summary><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">corpFlightBookings</span><span class="params">(self, bookings: List[List[int]], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        counter = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j, k <span class="keyword">in</span> bookings:</span><br><span class="line">            counter[i - <span class="number">1</span>] += k</span><br><span class="line">            <span class="keyword">if</span> j &lt; n: counter[j] -= k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            counter[i] += counter[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> counter[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，中 *N</em> 为数组长度。</li><li>空间复杂度：<em>O(N)</em>。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这几道题都是滑动窗口和前缀和的思路。力扣类似的题目还真不少，大家只有多留心，就会发现这个套路。</p><p>前缀和的技巧以及滑动窗口的技巧都比较固定，且有模板可套。 难点就在于我怎么才能想到可以用这个技巧呢？</p><p>我这里总结了两点：</p><ol><li>找关键字。比如题目中有连续，就应该条件反射想到滑动窗口和前缀和。比如题目求最大最小就想到动态规划和贪心等等。想到之后，就可以和题目信息对比快速排除错误的算法，找到可行解。这个思考的时间会随着你的题感增加而降低。</li><li>先写出暴力解，然后找暴力解的瓶颈， 根据瓶颈就很容易知道应该用什么数据结构和算法去优化。</li></ol><p>最后推荐几道类似的题目， 供大家练习，一定要自己写出来才行哦。</p><ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></li><li><a href="https://lucifer.ren/blog/2019/12/11/leetcode-1186/" target="_blank" rel="noopener">1186.删除一次得到子数组最大和</a></li><li><a href="https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/" target="_blank" rel="noopener">1310. 子数组异或查询</a></li><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你需要输出字符串s 中 p 的不同的非空子串的数目。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>992. K 个不同整数的子数组</title>
    <link href="http://yoursite.com/2021/11/07/992.%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2021/11/07/992. K 个不同整数的子数组/</id>
    <published>2021-11-07T04:12:12.000Z</published>
    <updated>2021-11-08T06:37:41.364Z</updated>
    
    <content type="html"><![CDATA[<p>返回A中好子数组的数目。</p><a id="more"></a><p>[TOC]</p><p>给定一个正整数数组 A，如果 A的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定不同的子数组为好子数组。</p><p>（例如，[1,2,3,1,2] 中有3个不同的整数：1，2，以及3。）</p><p>返回A中好子数组的数目。</p><p>示例 1：</p><pre><code>输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</code></pre><p>示例 2：</p><pre><code>输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</code></pre><p>提示：</p><pre><code>1 &lt;= A.length &lt;= 200001 &lt;= A[i] &lt;= A.length1 &lt;= K &lt;= A.length</code></pre><h1 id="📺-视频讲解"><a href="#📺-视频讲解" class="headerlink" title="📺 视频讲解"></a>📺 视频讲解</h1><p><a href="21472c3c-27ea-4ecf-9093-862f9b2f8e8b">992. K 个不同整数的子数组.mp4</a></p><h1 id="最初直觉使用双指针算法遇到的问题"><a href="#最初直觉使用双指针算法遇到的问题" class="headerlink" title="最初直觉使用双指针算法遇到的问题"></a>最初直觉使用双指针算法遇到的问题</h1><p>对于一个固定的左边界来说，满足「恰好存在 <code>K</code> 个不同整数的子区间」的右边界 <strong>不唯一</strong>，且形成区间。</p><p>示例 1：左边界固定的时候，恰好存在 <em>2</em> 个不同整数的子区间为 <em>[1,2],[1,2,1],[1,2,1,2]</em> ，总数为 <em>3</em>。其值为下标 <em>3 - 1 + 1*，即区间 *[1..3]</em> 的长度。</p><p><a href="https://pic.leetcode-cn.com/1612775858-VWbhYR-image.png" target="_blank" rel="noopener">image.png</a></p><p>须要找到左边界固定的情况下，满足「恰好存在 <code>K</code> 个不同整数的子区间」最小右边界和最大右边界。对比以前我们做过的，使用双指针解决的问题的问法基本都会出现「最小」、「最大」这样的字眼。</p><ul><li><a href="/problems/minimum-window-substring/">76. 最小覆盖子串</a>；</li><li><a href="/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>；</li><li><a href="/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a>；</li><li><a href="/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a>。</li></ul><h1 id="把原问题转换成为容易求解的问题"><a href="#把原问题转换成为容易求解的问题" class="headerlink" title="把原问题转换成为容易求解的问题"></a>把原问题转换成为容易求解的问题</h1><blockquote><p>友情提示：这里把 「恰好」 转换成为 「最多」须要一点求解「双指针（滑动窗口）」问题的经验。建立在熟练掌握这一类问题求解思路的基础上。</p></blockquote><p>把「<strong>恰好</strong>」改成「<strong>最多</strong>」就可以使用双指针一前一后交替向右的方法完成，这是因为 <strong>对于每一个确定的左边界，最多包含 <em>K</em> 种不同整数的右边界是唯一确定的</strong>，并且在左边界向右移动的过程中，右边界或者在原来的地方，或者在原来地方的右边。</p><p>而「最多存在 <em>K</em> 个不同整数的子区间的个数」与「恰好存在 <code>K</code> 个不同整数的子区间的个数」的差恰好等于「最多存在 <em>K - 1</em> 个不同整数的子区间的个数」。</p><p><a href="https://pic.leetcode-cn.com/1612776085-sZFGqE-image.png" target="_blank" rel="noopener">image.png</a></p><p>因为原问题就转换成为求解「最多存在 <em>K</em> 个不同整数的子区间的个数」与 「最多存在 <em>K - 1</em> 个不同整数的子区间的个数」，它们其实是一个问题。</p><h1 id="方法：双指针（滑动窗口）"><a href="#方法：双指针（滑动窗口）" class="headerlink" title="方法：双指针（滑动窗口）"></a>方法：双指针（滑动窗口）</h1><p>实现函数 <code>atMostWithKDistinct(A, K)</code> ，表示「最多存在 <em>K</em> 个不同整数的子区间的个数」。于是 <code>atMostWithKDistinct(A, K) - atMostWithKDistinct(A, K - 1)</code> 即为所求。</p><p><strong>参考代码</strong>：</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最多包含 K 个不同整数的子区间的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">atMostKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [left, right) 里不同整数的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [left, right) 包含不同整数的个数小于等于 K</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[A[right]] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            freq[A[right]]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count &gt; K) &#123;</span><br><span class="line">                freq[A[left]]--;</span><br><span class="line">                <span class="keyword">if</span> (freq[A[left]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [left, right) 区间的长度就是对结果的贡献</span></span><br><span class="line">            res += right - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>说明</strong>： <code>res += right - left;</code> 这行代码的意思：</p><p>用具体的例子理解：最多包含 3 种不同整数的子区间  <code>[1, 3, 2, 3]</code> （双指针算法是在左边界固定的前提下，让右边界走到最右边），当前可以确定 <code>1</code> 开始的满足最多包含 3 种不同整数的子区间有 <code>[1]</code>、<code>[1, 3]</code>、<code>[1, 3, 2]</code>、<code>[1, 3, 2, 3]</code>。</p><p><strong>所有的</strong> 左边界固定前提下，根据右边界最右的下标，计算出来的子区间的个数就是整个函数要返回的值。用右边界固定的前提下，左边界最左边的下标去计算也是完全可以的。</p><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N)*，这里 *N</em> 是输入数组的长度；</li><li>空间复杂度：<em>O(N)</em>，使用了常数个变量、频数数组的长度为 <em>N + 1</em>。</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用双指针（滑动窗口、两个变量一前一后交替向后移动）解决的问题通常都和这个问题要问的结果有关。以我们在题解中给出的 5 道经典问题为例：</p><ul><li><a href="/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>：没有重复的子串，一定只会问「最长」，因为最短的没有重复字符的子串是只有一个字符的子串； </li><li><a href="/problems/minimum-window-substring/">76. 最小覆盖子串</a>：求一个字符串的子串覆盖另一个字符串的长度一定是问「最小」，而不会问「最大」，因为最大一定是整个字符串；</li><li><a href="/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>：所有元素都是正整数，且子区间里所有元素的和大于等于定值 <code>s</code> 的子区间一定是问长度「最小」，而不会问「最多」，因为最多也一定是整个数组的长度；</li><li><a href="/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a>：最多包含两个不同字符一定是问「最长」才有意义，因为长度更长的子串可能会包含更多的字符；</li><li><a href="/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a>：替换的次数 <code>k</code> 是定值，替换以后字符全部相等的子串也一定只会问「最长」。</li></ul><hr><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>提示</strong>：在做这些问题的时候，<strong>一定要思考清楚为什么可以采用双指针（滑动窗口）算法解决如上的问题</strong>，为什么 <strong>左、右指针向右移动的时候可以不回头</strong>。如果不太熟悉这一类问题思路的朋友，一定要想清楚算法为什么有效，比知道这些问题可以用双指针（滑动窗口）算法解决重要得多。</p><p>思路一般是这样：固定左边界的前提下，如果较短的区间性质是什么样的，较长的区间的性质其实我们也可以推测出来。在右边界固定的前提下，我们须要将左边界右移，如此反复。这样的算法只遍历了数组两次，不用枚举所有可能的区间，把 <em>O(N^2)</em> 的时间复杂度降到了 <em>O(N)</em>。</p><ul><li><a href="/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a>；</li><li><a href="/problems/fruit-into-baskets/">904. 水果成篮</a> ；</li><li><a href="/problems/number-of-subarrays-with-bounded-maximum/">795. 区间子数组个数</a>；</li><li><a href="/problems/number-of-substrings-containing-all-three-characters/">1358. 包含所有三种字符的子字符串数目</a>；</li><li><a href="/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a>；</li><li><a href="/problems/longest-substring-with-at-most-k-distinct-characters/">340. 至多包含 K 个不同字符的最长子串</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回A中好子数组的数目。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Counting" scheme="http://yoursite.com/tags/Counting/"/>
    
  </entry>
  
  <entry>
    <title>340. 至多包含 K 个不同字符的最长子串</title>
    <link href="http://yoursite.com/2021/11/07/340.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/07/340. 至多包含 K 个不同字符的最长子串/</id>
    <published>2021-11-07T03:12:12.000Z</published>
    <updated>2021-11-07T04:15:35.403Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串s，找出至多包含k个不同字符的最长子串 T。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: s = &quot;eceba&quot;, k = 2输出: 3解释: 则 T 为 &quot;ece&quot;，所以长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: s = &quot;aa&quot;, k = 1输出: 2解释: 则 T 为 &quot;aa&quot;，所以长度为 2。</code></pre><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstringTwoDistinct(String s,int k) &#123;</span><br><span class="line">       int i = 0, j = 0, n = s.length(), maxlen = 0;</span><br><span class="line">       Map&lt;Character,Integer&gt; map = new HashMap();</span><br><span class="line">       while (j &lt; n) &#123;</span><br><span class="line">           if (map.size() &lt;= k &amp;&amp; j &lt; n) &#123;</span><br><span class="line">               map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           while (map.size() &gt; k) &#123;</span><br><span class="line">               map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) - 1);</span><br><span class="line">               if (map.getOrDefault(s.charAt(i), 0) &lt;= 0) &#123;</span><br><span class="line">                   map.remove(s.charAt(i));</span><br><span class="line">               &#125;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           maxlen = Math.max(maxlen, j - i);</span><br><span class="line">       &#125;</span><br><span class="line">       return maxlen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstringTwoDistinct(string s,int k) &#123;</span><br><span class="line">    int i = 0, j = 0, maxlen = 0;</span><br><span class="line">    unordered_map&lt;char, int&gt; m;</span><br><span class="line">    while(j &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">    if(m.size() &lt;= k)</span><br><span class="line">                ++m[s[j++]];</span><br><span class="line">            while(m.size()&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                if(--m[s[i]] == 0)</span><br><span class="line">                    m.erase(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">    maxlen = max(maxlen, j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串s，找出至多包含k个不同字符的最长子串 T。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>159. 至多包含两个不同字符的最长子串</title>
    <link href="http://yoursite.com/2021/11/07/159.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/07/159. 至多包含两个不同字符的最长子串/</id>
    <published>2021-11-07T01:03:12.000Z</published>
    <updated>2021-11-07T03:49:25.926Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串s，找出至多包含两个不同字符的最长子串 t ，并返回该子串的长度。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;eceba&quot;输出: 3解释: t 是 &quot;ece&quot;，长度为3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;ccaabbb&quot;输出: 5解释: t 是 &quot;aabbb&quot;，长度为5。</code></pre><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstringTwoDistinct(String s) &#123;</span><br><span class="line">       int k = 2, i = 0, j = 0, n = s.length(), maxlen = 0;</span><br><span class="line">       Map&lt;Character,Integer&gt; map = new HashMap();</span><br><span class="line">       while (j &lt; n) &#123;</span><br><span class="line">           if (map.size() &lt;= k &amp;&amp; j &lt; n) &#123;</span><br><span class="line">               map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           while (map.size() &gt; k) &#123;</span><br><span class="line">               map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) - 1);</span><br><span class="line">               if (map.getOrDefault(s.charAt(i), 0) &lt;= 0) &#123;</span><br><span class="line">                   map.remove(s.charAt(i));</span><br><span class="line">               &#125;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           maxlen = Math.max(maxlen, j - i);</span><br><span class="line">       &#125;</span><br><span class="line">       return maxlen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstringTwoDistinct(string s) &#123;</span><br><span class="line">    int k = 2, i = 0, j = 0, maxlen = 0;</span><br><span class="line">    unordered_map&lt;char, int&gt; m;</span><br><span class="line">    while(j &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">    if(m.size() &lt;= k)</span><br><span class="line">                ++m[s[j++]];</span><br><span class="line">            while(m.size()&gt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                if(--m[s[i]] == 0)</span><br><span class="line">                    m.erase(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">    maxlen = max(maxlen, j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串s，找出至多包含两个不同字符的最长子串 t ，并返回该子串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="http://yoursite.com/2021/11/05/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2021/11/05/3. 无重复字符的最长子串/</id>
    <published>2021-11-05T04:03:12.000Z</published>
    <updated>2021-11-06T13:34:01.945Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="fc6033f3-e9c6-41d7-b660-328fc288d2e2">3. 无重复字符的最长子串_2.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h2><p>我一开始想到的是一个比较粗暴的方法，遍历字符串中的每一个位置，然后在该位置向两边扩展，直到遇到重复的字符，最后统计长度，但这种方法效率较低</p><details>    <summary>Java暴力解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            int j = i ;</span><br><span class="line">            int k = i ;</span><br><span class="line">            while (j &gt; 0) &#123;</span><br><span class="line">                if (s.substring(j, k + 1).contains(s.substring(j-1,j))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (k &lt; s.length()-1) &#123;</span><br><span class="line">                if (s.substring(j, k+1).contains(s.substring(k + 1,k+2))) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = Math.max(maxlen, k - j + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++暴力解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int lengthOfLongestSubstring(string s)&#123;</span><br><span class="line">        long len=s.size();</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">            int j=i, k=i;</span><br><span class="line">            //向左搜索</span><br><span class="line">            while (j&gt;0) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(j-1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //向右搜索</span><br><span class="line">            while (k&lt;len-1) &#123;</span><br><span class="line">                string subs=s.substr(j, k-j+1);</span><br><span class="line">                string curs=s.substr(k+1, 1);</span><br><span class="line">                if(subs.find(curs) == string::npos)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=max(maxlen, k-j+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>时间复杂度：O(N^2)</p><p>空间复杂度：O(1)</p><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><p><strong>思路和算法</strong></p><p>我们先用一个例子来想一想如何在较优的时间复杂度内通过本题。</p><p>我们不妨以示例一中的字符串 abcabcbb  为例，找出 <strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><ul><li>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</li><li>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb ；</li><li>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb ；</li><li>以 abc(a)bcbb  开始的最长字符串为 abc(abc)bb ；</li><li>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</li><li>以 abcab(c)bb  开始的最长字符串为abcab(cb)b ；</li><li>以 abcabc(b)b  开始的最长字符串为 abcabc(b)b ；</li><li>以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 。</li></ul><p>发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 <em>k</em> 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 <em>r_k*。那么当我们选择第 *k+1</em> 个字符作为起始位置时，首先从 <em>k+1</em> 到 <em>r_k</em> 的字符显然是不重复的，并且由于少了原本的第 <em>k</em> 个字符，我们可以尝试继续增大 <em>r_k</em>，直到右侧出现了重复字符为止。</p><p>这样以来，我们就可以使用「滑动窗口」来解决这个问题了：</p><ul><li><p>我们使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 <em>r_k</em>；</p></li><li><p>在每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p></li><li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p></li></ul><p><strong>判断重复字符</strong></p><p>在上面的流程中，我们还需要使用一种数据结构来判断 <strong>是否有重复的字符</strong>，常用的数据结构为哈希集合（即 <code>C++</code> 中的 <code>std::unordered_set</code>，<code>Java</code> 中的 <code>HashSet</code>，<code>Python</code> 中的 <code>set</code>, <code>JavaScript</code> 中的 <code>Set</code>）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><p>至此，我们就完美解决了本题。</p><details>    <summary>滑动窗口C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.erase(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.insert(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = set()</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    <span class="keyword">const</span> occ = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    <span class="keyword">let</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            occ.delete(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.has(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>滑动窗口Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">    rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">            <span class="built_in">delete</span>(m, s[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rk + <span class="number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 不断地移动右指针</span></span><br><span class="line">            m[s[rk+<span class="number">1</span>]]++</span><br><span class="line">            rk++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = max(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p></li><li><p>空间复杂度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure></li></ul><p>，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Sigma</span><br></pre></td></tr></table></figure><p> 表示字符集（即字符串中可以出现的字符），</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure><p> 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 <em>[0, 128)</em> 内的字符，即<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|\Sigma|=128</span><br><span class="line">``` </span><br><span class="line">。我们需要用到哈希集合来存储出现过的字符，而字符最多有 </span><br><span class="line">```math</span><br><span class="line">|\Sigma|</span><br></pre></td></tr></table></figure></p><p>个，因此空间复杂度为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(|\Sigma|)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>991. 坏了的计算器</title>
    <link href="http://yoursite.com/2021/11/03/991.%20%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://yoursite.com/2021/11/03/991. 坏了的计算器/</id>
    <published>2021-11-03T03:12:12.000Z</published>
    <updated>2021-11-03T03:45:01.565Z</updated>
    
    <content type="html"><![CDATA[<p>返回显示数字 Y 所需的最小操作数。</p><a id="more"></a><p>[TOC]</p><p>在显示着数字的坏计算器上，我们可以执行以下两种操作：</p><p>双倍（Double）：将显示屏上的数字乘 2；<br>递减（Decrement）：将显示屏上的数字减 1 。<br>最初，计算器显示数字 X。</p><p>返回显示数字 Y 所需的最小操作数。</p><p>示例 1：</p><pre><code>输入：X = 2, Y = 3输出：2解释：先进行双倍运算，然后再进行递减运算 {2 -&gt; 4 -&gt; 3}.</code></pre><p>示例 2：</p><pre><code>输入：X = 5, Y = 8输出：2解释：先递减，再双倍 {5 -&gt; 4 -&gt; 8}.</code></pre><p>示例 3：</p><pre><code>输入：X = 3, Y = 10输出：3解释：先双倍，然后递减，再双倍 {3 -&gt; 6 -&gt; 5 -&gt; 10}.</code></pre><p>示例 4：</p><pre><code>输入：X = 1024, Y = 1输出：1023解释：执行递减运算 1023 次</code></pre><p>提示：</p><pre><code>1 &lt;= X &lt;= 10^91 &lt;= Y &lt;= 10^9</code></pre><h1 id="方法一：逆向思维"><a href="#方法一：逆向思维" class="headerlink" title="方法一：逆向思维"></a>方法一：逆向思维</h1><p><strong>思路</strong></p><p>除了对 <code>X</code> 执行乘 2 或 减 1 操作之外，我们也可以对 <code>Y</code> 执行<code>除 2</code>（当 <code>Y</code> 是偶数时）或者<code>加 1</code>操作。</p><p>为什么这道题采用逆向思维更优？</p><p>正向思维：在X&lt;Y时要实现操作数最小，要将X逼近Y的1/2值或1/4值或1/8值或…再进行*2操作，难点在于要判断要逼近的是1/2值还是1/4值还是其他值，逻辑复杂 </p><p>逆向思维：在Y&gt;X时Y只管/2，到了Y&lt;X时在+1逼近 说白了就是，正向思维采用的是先小跨度的-1操作，再大跨度的*2操作；逆向思维采用的是先大跨度的/2操作，再小跨度的-1操作</p><p>然而事实上往往是先大后小的解决问题思维在实现起来会比较简单</p><p>下面的解释我没有太理解，但重点是要分奇数和偶数。奇数不能直接除2，可以先加1</p><p>这样做的动机是我们可以总是贪心地执行除 2 操作：</p><ul><li><p>当 <code>Y</code> 是偶数，如果先执行 2 次加法操作，再执行 1 次除法操作，我们可以通过先执行 1 次除法操作，再执行 1 次加法操作以使用更少的操作次数得到相同的结果 [<code>(Y+2) / 2</code> vs <code>Y/2 + 1</code>]。</p></li><li><p>当 <code>Y</code> 是奇数，如果先执行 3 次加法操作，再执行 1 次除法操作，我们可以将其替代为顺次执行加法、除法、加法操作以使用更少的操作次数得到相同的结果 [<code>(Y+3) / 2</code> vs <code>(Y+1) / 2 + 1</code>]。</p></li></ul><p><strong>算法</strong></p><p>当 <code>Y</code> 大于 <code>X</code> 时，如果它是奇数，我们执行加法操作，否则执行除法操作。之后，我们需要执行 <code>X - Y</code> 次加法操作以得到 <code>X</code>。</p><figure class="highlight java"><figcaption><span>[uRsowHNz-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> startValue, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (startValue &lt; target) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            target = ((target &amp; <span class="number">1</span>) == <span class="number">1</span>) ? target + <span class="number">1</span> : target / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + startValue - target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>[uRsowHNz-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brokenCalc</span><span class="params">(self, X, Y)</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Y &gt; X:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> Y%<span class="number">2</span>: Y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: Y /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans + X-Y</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：  O(logY)</p></li><li><p>空间复杂度：  <em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回显示数字 Y 所需的最小操作数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>224. 基本计算器</title>
    <link href="http://yoursite.com/2021/11/02/224.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://yoursite.com/2021/11/02/224. 基本计算器/</id>
    <published>2021-11-02T09:12:12.000Z</published>
    <updated>2021-11-03T03:11:38.688Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串表达式s，请你实现一个基本计算器来计算并返回它的值。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：s = &quot;1 + 1&quot;输出：2</code></pre><p>示例 2：</p><pre><code>输入：s = &quot; 2-1 + 2 &quot;输出：3</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 3 * 105s 由数字、&apos;+&apos;、&apos;-&apos;、&apos;(&apos;、&apos;)&apos;、和 &apos; &apos; 组成s 表示一个有效的表达式</code></pre><h1 id="方法一：括号展开-栈"><a href="#方法一：括号展开-栈" class="headerlink" title="方法一：括号展开 + 栈"></a>方法一：括号展开 + 栈</h1><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。<a href="https://leetcode-cn.com/problems/basic-calculator/solution/ji-ben-ji-suan-qi-by-leetcode-solution-jvir/" target="_blank" rel="noopener">^1</a></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ops;</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; ops = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ops = [<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">' '</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">'+'</span>) &#123;</span><br><span class="line">            sign = ops[ops.length - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = -ops[ops.length - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">'('</span>) &#123;</span><br><span class="line">            ops.push(sign);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">')'</span>) &#123;</span><br><span class="line">            ops.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; !(<span class="built_in">isNaN</span>(<span class="built_in">Number</span>(s[i]))) &amp;&amp; s[i] !== <span class="string">' '</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i].charCodeAt() - <span class="string">'0'</span>.charCodeAt();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += sign * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ops := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">    sign := <span class="number">1</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; &#123;</span><br><span class="line">        <span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            sign = ops[<span class="built_in">len</span>(ops)<span class="number">-1</span>]</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            sign = -ops[<span class="built_in">len</span>(ops)<span class="number">-1</span>]</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">            ops = <span class="built_in">append</span>(ops, sign)</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">            ops = ops[:<span class="built_in">len</span>(ops)<span class="number">-1</span>]</span><br><span class="line">            i++</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            num := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ; i &lt; n &amp;&amp; <span class="string">'0'</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">'9'</span>; i++ &#123;</span><br><span class="line">                num = num*<span class="number">10</span> + <span class="keyword">int</span>(s[i]-<span class="string">'0'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            ans += sign * num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> ops[n], top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    ops[top++] = sign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            sign = ops[top - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = -ops[top - <span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            ops[top++] = sign;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            top--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += sign * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ops = [<span class="number">1</span>]</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'+'</span>:</span><br><span class="line">                sign = ops[<span class="number">-1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'-'</span>:</span><br><span class="line">                sign = -ops[<span class="number">-1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                ops.append(sign)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                ops.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">                    num = num * <span class="number">10</span> + ord(s[i]) - ord(<span class="string">'0'</span>)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                ret += num * sign</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为字符串 <em>s</em> 的长度。需要遍历字符串 <em>s</em> 一次，计算表达式的值。</p></li><li><p>空间复杂度：<em>O(n)*，其中 *n</em> 为字符串 <em>s</em> 的长度。空间复杂度主要取决于栈的空间，栈中的元素数量不超过 <em>n</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串表达式s，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>772. 基本计算器III</title>
    <link href="http://yoursite.com/2021/11/02/772.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8III/"/>
    <id>http://yoursite.com/2021/11/02/772. 基本计算器III/</id>
    <published>2021-11-02T09:12:12.000Z</published>
    <updated>2021-11-06T13:32:42.408Z</updated>
    
    <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.</p><a id="more"></a><p>[TOC]</p><p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p><p>The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid. All intermediate results will be in the range of [-2147483648, 2147483647].</p><p>Some examples:</p><pre><code>&quot;1 + 1&quot; = 2&quot; 6-4 / 2 &quot; = 4&quot;2*(5+5*2)/3+(6/2+8)&quot; = 21&quot;(2+6* 3+5- (3*14/7+2)*5)+3&quot;=-12</code></pre><p>Note: Do not use the eval built-in library function.</p><h1 id="方法一：中缀转后缀（逆波兰）表达式"><a href="#方法一：中缀转后缀（逆波兰）表达式" class="headerlink" title="方法一：中缀转后缀（逆波兰）表达式"></a>方法一：中缀转后缀（逆波兰）表达式</h1><p>唯一需要注意的地方就是计算的中间结果范围可能出现超出 int 类型的情况。因此，在进行逆波兰计算的时候，使用 long 来计算。</p><p>逆波兰计算器的原理是使用逆波兰表达式来计算出表达式的值，我们人类能够熟练使用的是中缀表达式，比如2×(9+6/3-5)+4就是一个中缀表达式，但是看到上面的简单计算器就知道处理起来很麻烦。于是有一种逆波兰计算器，计算是在逆波兰表达式（也叫做后缀表达式）的基础上。</p><p>逆波兰计算器的计算过程为：从左到右扫描后缀表达式，遇到数字就入栈，遇到操作符就从栈弹出两个数字，然后计算得到的值继续入栈，继续扫描表达式，直到扫描完毕得到结果。</p><p>把中缀表达式转成后缀表达式？</p><p>转换规则</p><pre><code>　　1）我们使用一个stack栈结构存储操作符，用一个List结构存储后缀表达式结果　　2）首先读取到数字，直接存入list中　　3）当读取到左括号&quot;(&quot;时，直接压栈，当读取到运算符时，分两种情况讨论　　　　a.当运算符栈为空或者栈顶操作符的优先级小于当前运算符优先级时(如+和-的优先级低于 * 和 /)，直接入栈　　　　b.当运算符不为空时且栈顶操作符的优先级大于或等于当前运算符优先级时，循环执行出栈操作并加入list中，直到遇到优先级小于当前运算符的元素为止。循环执行完后再将当前运算符压栈。另外需要注意的是，只有遇到右括号时，左括号才出栈　　4) 当遇到右括号&quot;)&quot;时，循环执行出栈操作并加入到list中，直到遇到左括号为止。并将左括号弹出，但不加入list中　　5) 表达式的值读取完后，将操作符栈中的所有元素弹出并加入到list中　　执行完上面步骤后，list中存储的顺序即为我们转换后的后缀表达式的结果</code></pre><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String expression = s.replaceAll(<span class="string">" "</span>, <span class="string">""</span>); <span class="comment">//去空格</span></span><br><span class="line">        List&lt;String&gt; infix = expressionToList(expression); <span class="comment">//表达式转中缀</span></span><br><span class="line">        List&lt;String&gt; suffix = parseToSuffixExpression(infix); <span class="comment">//中缀转后缀</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 存储中间结果</span></span><br><span class="line">        <span class="comment">// 逆波兰计算器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suffix.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOper(suffix.get(i))) &#123;</span><br><span class="line">                String b = stack.pop();</span><br><span class="line">                String a = stack.pop();</span><br><span class="line">                String result = cal(a, suffix.get(i), b);</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(suffix.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * num1 和 num2 进行 oper 计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">cal</span><span class="params">(String num1, String oper, String num2)</span> </span>&#123;</span><br><span class="line">        Long result = <span class="number">0L</span>;</span><br><span class="line">        Long a = Long.parseLong(num1);</span><br><span class="line">        Long b = Long.parseLong(num2);</span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                result = a + b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                result = a - b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                result = a * b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                result = a / b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中缀转后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  List&lt;String&gt; <span class="title">parseToSuffixExpression</span><span class="params">(List&lt;String&gt; expressionList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈用于保存操作符</span></span><br><span class="line">        Stack&lt;String&gt; opStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个list用于保存后缀表达式</span></span><br><span class="line">        List&lt;String&gt; suffixList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String item : expressionList)&#123;</span><br><span class="line">            <span class="comment">//得到数或操作符</span></span><br><span class="line">            <span class="keyword">if</span>(isOper(item))&#123;</span><br><span class="line">                <span class="comment">//是操作符 判断操作符栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(opStack.isEmpty() || <span class="string">"("</span>.equals(opStack.peek()) || priority(item) &gt; priority(opStack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//为空或者栈顶元素为左括号或者当前操作符大于栈顶操作符直接压栈</span></span><br><span class="line">                    opStack.push(item);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则将栈中元素出栈如队，直到遇到大于当前操作符或者遇到左括号时</span></span><br><span class="line">                    <span class="keyword">while</span> (!opStack.isEmpty() &amp;&amp; !<span class="string">"("</span>.equals(opStack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(priority(item) &lt;= priority(opStack.peek()))&#123;</span><br><span class="line">                            suffixList.add(opStack.pop());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当前操作符压栈</span></span><br><span class="line">                    opStack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isNumber(item))&#123;</span><br><span class="line">                <span class="comment">//是数字则直接入队</span></span><br><span class="line">                suffixList.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"("</span>.equals(item))&#123;</span><br><span class="line">                <span class="comment">//是左括号，压栈</span></span><br><span class="line">                opStack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">")"</span>.equals(item))&#123;</span><br><span class="line">                <span class="comment">//是右括号 ，将栈中元素弹出入队，直到遇到左括号，左括号出栈，但不入队</span></span><br><span class="line">                <span class="keyword">while</span> (!opStack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"("</span>.equals(opStack.peek()))&#123;</span><br><span class="line">                        opStack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        suffixList.add(opStack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"有非法字符！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环完毕，如果操作符栈中元素不为空，将栈中元素出栈入队</span></span><br><span class="line">        <span class="keyword">while</span> (!opStack.isEmpty())&#123;</span><br><span class="line">            suffixList.add(opStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suffixList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"+"</span>.equals(string) || <span class="string">"-"</span>.equals(string) || <span class="string">"*"</span>.equals(string)</span><br><span class="line">                || <span class="string">"/"</span>.equals(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//匹配数字（非负数，整数和小数）和 负数</span></span><br><span class="line">        <span class="keyword">return</span> num.matches(<span class="string">"\\d+"</span>) || (num.charAt(<span class="number">0</span>)==<span class="string">'-'</span> &amp;&amp; num.substring(<span class="number">1</span>,num.length()).matches(<span class="string">"\\d+"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串转为中缀 List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">expressionToList</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = expression.length();</span><br><span class="line">        String num = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = expression.charAt(i);</span><br><span class="line">            <span class="comment">//直接用Character.isDigit判断会忽略负数和小数的情况</span></span><br><span class="line">            <span class="keyword">if</span> (isNumber(c+<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != len - <span class="number">1</span> &amp;&amp; Character.isDigit(expression.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                    num += c;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    num += c;</span><br><span class="line">                    list.add(num);</span><br><span class="line">                    num = <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//处理负数情况</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'-'</span> &amp;&amp; (i == <span class="number">0</span> || !Character.isDigit(expression.charAt(i - <span class="number">1</span>)))) &#123;</span><br><span class="line">                    num += c;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(c + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回操作符的优先级，+- 为 0，* / 为 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"+"</span>.equals(oper) || <span class="string">"-"</span>.equals(oper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"*"</span>.equals(oper) || <span class="string">"/"</span>.equals(oper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>227.基本计算器 II</title>
    <link href="http://yoursite.com/2021/11/02/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/"/>
    <id>http://yoursite.com/2021/11/02/227. 基本计算器 II/</id>
    <published>2021-11-02T03:12:12.000Z</published>
    <updated>2021-11-02T10:04:31.752Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p><p>字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;3+2*2&quot;输出: 7</code></pre><p>示例 2:</p><pre><code>输入: &quot; 3/2 &quot;输出: 1</code></pre><p>示例 3:</p><pre><code>输入: &quot; 3+5 / 2 &quot;输出: 5</code></pre><p>说明：</p><p>你可以假设所给定的表达式都是有效的。<br>请不要使用内置的库函数 eval。</p><h1 id="解法一：单栈的经典应用"><a href="#解法一：单栈的经典应用" class="headerlink" title="解法一：单栈的经典应用"></a>解法一：单栈的经典应用</h1><p>此算法的思路很简单，先把乘除法的值计算出来，最终将所有的运算简化成只有加法。</p><ol><li>先跳过空格</li><li>出现了数字则记录整个数字是多少，然后根据之前的运算符决定下一步：</li></ol><ul><li>如果是加号’+’，说明前面的运算独立于以后的运算，可以将结果暂时放入栈；</li><li>如果是减号’-‘，可以看成<code>-1 * tempNum</code>，然后将<code>-tempNum</code>入栈；</li><li>如果是乘号’*’或者除号’/‘，由于前面的运算独立于此，可以先计算<code>lastNum</code>和<code>tempNum</code>积，然后结果入栈。</li></ul><ol start="3"><li>最后将栈中的所有元素相加就是答案。</li></ol><p>注意的点，在写代码的时候注意到pop要和push成对使用，之前混用了offer和poll，但对其实际用法并没有详细了解。结果导致出现了意料之外的结果。</p><details>    <summary>栈的经典应用</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        char lastOp = &apos;+&apos;;</span><br><span class="line">        char[] arr = s.toCharArray();</span><br><span class="line">        for(int i = 0; i &lt; arr.length; i ++)&#123;</span><br><span class="line">            if(arr[i] == &apos; &apos;) continue;</span><br><span class="line"></span><br><span class="line">            if(Character.isDigit(arr[i]))&#123;</span><br><span class="line">                int tempNum = arr[i] - &apos;0&apos;;</span><br><span class="line">                while(++i &lt; arr.length &amp;&amp; Character.isDigit(arr[i]))&#123;</span><br><span class="line">                    tempNum = tempNum * 10 + (arr[i] - &apos;0&apos;);</span><br><span class="line">                &#125; i--;</span><br><span class="line"></span><br><span class="line">                if(lastOp == &apos;+&apos;) numStack.push(tempNum);</span><br><span class="line">                else if(lastOp == &apos;-&apos;) numStack.push(-tempNum);</span><br><span class="line">                else numStack.push(res(lastOp, numStack.pop(), tempNum));</span><br><span class="line">            &#125; else lastOp = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int num : numStack) ans += num;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int res(char op, int a, int b)&#123;</span><br><span class="line">        if(op == &apos;*&apos;) return a * b;</span><br><span class="line">        else if(op == &apos;/&apos;) return a / b;</span><br><span class="line">        else if(op == &apos;+&apos;) return a + b; //其实加减运算可以忽略</span><br><span class="line">        else return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <h1 id="解法二：双栈算法"><a href="#解法二：双栈算法" class="headerlink" title="解法二：双栈算法"></a>解法二：双栈算法</h1><p>这个算法有个专门的名称Shunting-yard algorithm</p><p>栈oprands存储表达式中的整数。<br>栈opors存储表达式中的运算符。</p><p>从左向右遍历字符串，</p><p>当s[i] 为空格时，过滤掉空格；</p><p>当s[i] 为数字数，提取连续的整数。存入oprands。</p><p>当s[i] 为运算符时，如果s[i]的优先级比opors栈顶运算符高，那么s[i]入opors栈。</p><p>如果不是，那么弹出opors栈顶运算符，和oprands栈顶的两个整数，计算，结果存入oprands栈。</p><p>最终的解在oprands中。</p><details>    <summary>双栈算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    static Stack&lt;Integer&gt; num = new Stack&lt;Integer&gt;();</span><br><span class="line">    static Stack&lt;Character&gt; op = new Stack&lt;Character&gt;();</span><br><span class="line">    static HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">    static void eval()</span><br><span class="line">    &#123;</span><br><span class="line">        int b = num.pop();</span><br><span class="line">        int a = num.pop();</span><br><span class="line">        char c = op.pop();</span><br><span class="line">        int r = 0;</span><br><span class="line">        if(c == &apos;+&apos;) r = a + b;</span><br><span class="line">        else if(c == &apos;-&apos;) r = a - b;</span><br><span class="line">        else if(c == &apos;*&apos;) r = a * b;</span><br><span class="line">        else r = a / b;</span><br><span class="line">        num.add(r); </span><br><span class="line">    &#125;</span><br><span class="line">    public int calculate(String s) &#123;</span><br><span class="line">        s = &apos;0&apos; + s; // 对开头是负数的处理 </span><br><span class="line">        map.put(&apos;+&apos;, 1);   //定义运算符的优先级</span><br><span class="line">        map.put(&apos;-&apos;, 1);</span><br><span class="line">        map.put(&apos;*&apos;, 2);</span><br><span class="line">        map.put(&apos;/&apos;, 2);</span><br><span class="line">        for(int i = 0; i &lt; s.length();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            char c = s.charAt(i);</span><br><span class="line">            if(c == &apos; &apos;) continue;  //跳过空格</span><br><span class="line">            if(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)  //c是数字,读取一个连续的数字</span><br><span class="line">            &#123;</span><br><span class="line">                int x = 0, j = i;</span><br><span class="line">                while(j &lt; s.length() &amp;&amp; s.charAt(j) &gt;= &apos;0&apos; &amp;&amp; s.charAt(j) &lt;= &apos;9&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = x * 10 + s.charAt(j) - &apos;0&apos;;</span><br><span class="line">                    j ++;</span><br><span class="line">                &#125;</span><br><span class="line">                i = j - 1;</span><br><span class="line">                num.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">            else  //c是操作符 </span><br><span class="line">            &#123;     //op栈非空并且栈顶操作符优先级大于等于当前操作符c的优先级，进行eval()计算</span><br><span class="line">                while(!op.isEmpty() &amp;&amp; map.get(op.peek()) &gt;= map.get(c)) eval();</span><br><span class="line">                op.add(c); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!op.isEmpty()) eval();</span><br><span class="line">        return num.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <h1 id="解法三：不用栈"><a href="#解法三：不用栈" class="headerlink" title="解法三：不用栈"></a>解法三：不用栈</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int calculate(String s) &#123;</span><br><span class="line">        int res = 0, tmp = 0, curNum = 0, n = s.length();</span><br><span class="line">        //res存结果，tmp存当前高优先级运算结果，curNum存当前字母段所代表的数值</span><br><span class="line">        char op = &apos;+&apos;;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char c = s.charAt(i);</span><br><span class="line">            if (Character.isDigit(c)) &#123;</span><br><span class="line">                curNum = curNum * 10 + c - &apos;0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            if (c == &apos;+&apos; || c == &apos;-&apos; || c == &apos;*&apos; || c == &apos;/&apos; || i == n - 1) &#123;</span><br><span class="line">                switch (op) &#123;</span><br><span class="line">                    case &apos;+&apos;:tmp+=curNum;break;</span><br><span class="line">                    case &apos;-&apos;:tmp-=curNum;break;</span><br><span class="line">                    case &apos;*&apos;:tmp*=curNum;break;</span><br><span class="line">                    case &apos;/&apos;:tmp/=curNum;break;</span><br><span class="line">                &#125;</span><br><span class="line">                //单独判断连乘、连除结束 或 达到最后一个字符，例如：3 + 2 * 2</span><br><span class="line">                //如果没有下面这个if则会出错</span><br><span class="line">                if (c == &apos;+&apos; || c == &apos;-&apos; || i == n - 1) &#123;</span><br><span class="line">                    res += tmp;</span><br><span class="line">                    tmp = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                op = c;//更新操作符</span><br><span class="line">                curNum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式的值。&lt;/p&gt;
&lt;p&gt;字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
</feed>
