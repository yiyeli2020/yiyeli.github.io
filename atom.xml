<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-16T09:39:28.211Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1936. 新增的最少台阶数</title>
    <link href="http://yoursite.com/2021/12/16/1936.%20%E6%96%B0%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%B0%E9%98%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/16/1936. 新增的最少台阶数/</id>
    <published>2021-12-16T08:28:12.000Z</published>
    <updated>2021-12-16T09:39:28.211Z</updated>
    
    <content type="html"><![CDATA[<p>返回爬到最后一阶时必须添加到梯子上的 最少台阶数。</p><a id="more"></a><p>[TOC]</p><p>给你一个 严格递增 的整数数组 rungs ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。</p><p>另给你一个整数 dist 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过dist高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。</p><p>返回爬到最后一阶时必须添加到梯子上的 最少台阶数。</p><p>示例 1：</p><pre><code>输入：rungs = [1,3,5,10], dist = 2输出：2解释：现在无法到达最后一阶。在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,5,7,8,10] 的位置上有台阶。</code></pre><p>示例 2：</p><pre><code>输入：rungs = [3,6,8,10], dist = 3输出：0解释：这个梯子无需增设新台阶也可以爬上去。</code></pre><p>示例 3：</p><pre><code>输入：rungs = [3,4,6,7], dist = 2输出：1解释：现在无法从地板到达梯子的第一阶。 在高度为 1 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,4,6,7] 的位置上有台阶。</code></pre><p>示例 4：</p><pre><code>输入：rungs = [5], dist = 10输出：0解释：这个梯子无需增设新台阶也可以爬上去。</code></pre><p>提示：</p><pre><code>1 &lt;= rungs.length &lt;= 1051 &lt;= rungs[i] &lt;= 1091 &lt;= dist &lt;= 109rungs 严格递增</code></pre><h1 id="方法一：模拟-贪心"><a href="#方法一：模拟-贪心" class="headerlink" title="方法一：模拟 + 贪心"></a>方法一：模拟 + 贪心</h1><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/add-minimum-number-of-rungs/solution/xin-zeng-de-zui-shao-tai-jie-shu-by-leet-y0de/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addRungs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rungs, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// 需要增设的梯子数目</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;   <span class="comment">// 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h: rungs)&#123;</span><br><span class="line">            <span class="comment">// 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            <span class="keyword">int</span> d = h - curr;</span><br><span class="line">            res += (d - <span class="number">1</span>) / dist;</span><br><span class="line">            curr = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addRungs</span><span class="params">(self, rungs: List[int], dist: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span>   <span class="comment"># 需要增设的梯子数目</span></span><br><span class="line">        curr = <span class="number">0</span>   <span class="comment"># 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> rungs:</span><br><span class="line">            <span class="comment"># 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            d = h - curr</span><br><span class="line">            res += (h - curr - <span class="number">1</span>) // dist</span><br><span class="line">            curr = h</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addRungs</span><span class="params">(<span class="keyword">int</span>[] rungs, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;    <span class="comment">// 需要增设的梯子数目</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;   <span class="comment">// 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h : rungs) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            <span class="keyword">int</span> d = h - curr;</span><br><span class="line">            res += (d - <span class="number">1</span>) / dist;</span><br><span class="line">            curr = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回爬到最后一阶时必须添加到梯子上的 最少台阶数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <link href="http://yoursite.com/2021/12/16/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2021/12/16/746. 使用最小花费爬楼梯/</id>
    <published>2021-12-16T08:12:12.000Z</published>
    <updated>2021-12-16T08:23:50.543Z</updated>
    
    <content type="html"><![CDATA[<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</code></pre><p> 示例 2：</p><pre><code>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</code></pre><p>提示：</p><pre><code>cost 的长度范围是 [2, 1000]。cost[i] 将会是一个整型数据，范围为 [0, 999] 。</code></pre><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.Min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[costSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        dp[i] = fmin(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述代码的时间复杂度和空间复杂度都是 <em>O(n)</em> 。可以使用滚动数组的思想，将空间复杂度优化到 <em>O(1)</em>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = Math.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="built_in">Math</span>.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int prev = 0, curr = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int next = Math.Min(curr + cost[i - 1], prev + cost[i - 2]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        pre, cur = cur, min(cur+cost[i<span class="number">-1</span>], pre+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        prev = curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>])</span><br><span class="line">            prev, curr = curr, nxt</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = fmin(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组cost 的长度。需要依次计算每个dp 值，每个值的计算需要常数时间，因此总时间复杂度是 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用滚动数组的思想，只需要使用有限的额外空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 088. 爬楼梯的最少成本</title>
    <link href="http://yoursite.com/2021/12/16/%E5%89%91%E6%8C%87%20Offer%20II%20088.%20%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%91%E6%88%90%E6%9C%AC/"/>
    <id>http://yoursite.com/2021/12/16/剑指 Offer II 088. 爬楼梯的最少成本/</id>
    <published>2021-12-16T08:12:12.000Z</published>
    <updated>2021-12-16T08:25:41.154Z</updated>
    
    <content type="html"><![CDATA[<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</code></pre><p> 示例 2：</p><pre><code>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</code></pre><p>提示：</p><pre><code>cost 的长度范围是 [2, 1000]。cost[i] 将会是一个整型数据，范围为 [0, 999] 。</code></pre><p>注意：本题与<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a>相同： </p><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.Min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[costSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        dp[i] = fmin(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述代码的时间复杂度和空间复杂度都是 <em>O(n)</em> 。可以使用滚动数组的思想，将空间复杂度优化到 <em>O(1)</em>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = Math.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="built_in">Math</span>.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int prev = 0, curr = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int next = Math.Min(curr + cost[i - 1], prev + cost[i - 2]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        pre, cur = cur, min(cur+cost[i<span class="number">-1</span>], pre+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        prev = curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>])</span><br><span class="line">            prev, curr = curr, nxt</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = fmin(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组cost 的长度。需要依次计算每个dp 值，每个值的计算需要常数时间，因此总时间复杂度是 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用滚动数组的思想，只需要使用有限的额外空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="http://yoursite.com/2021/12/16/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2021/12/16/70. 爬楼梯/</id>
    <published>2021-12-16T07:12:12.000Z</published>
    <updated>2021-12-16T07:30:09.737Z</updated>
    
    <content type="html"><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><a id="more"></a><p>[TOC]</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><p>示例 2：</p><pre><code>输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><p>具体解法和斐波那契数列一样，动态规划，矩阵快速幂和齐次线性递推方程取通解。本来已经这样就玩到极致了<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，没想到还有卷中卷，评论里有人提到字节面试还会修改条件，这样就又为之一变。</p><h1 id="加入新的限制条件：不能连续跳两个台阶。"><a href="#加入新的限制条件：不能连续跳两个台阶。" class="headerlink" title="加入新的限制条件：不能连续跳两个台阶。"></a>加入新的限制条件：不能连续跳两个台阶。</h1><p> 1、每次你可以爬 1 或 2 个台阶。</p><p> 2、不能连续跳两个台阶。（个人理解为这次跳了两个台阶，下次不能再跳两个台阶）</p><p> 假设：</p><pre><code>f(x) 表示爬到第 x 级台阶的方案数， g(x, 1) 表示爬到第 x 级台阶并且最后一步只跨越一个台阶的方案数， g(x, 2) 表示爬到第 x 级台阶并且最后一步跨越了两个台阶的方案数。由 ：f(x) = g(x, 1)+g(x,2)， g(x, 1) = f(x-1)， g(x, 2) = g(x-2, 1) // 最后一步跨越了两步，那么上一步只能跨越一步得：f(x) = g(x, 1) + g(x, 2)       = f(x-1) + g(x-2, 1)       = f(x-1) + f((x-2)-1)      = f(x-1) + f(x-3)</code></pre><p>题目里“不能连续跳两个台阶”，即一旦跳了两个台阶，则下一步只能跳一步（2-&gt;1），把它们连在一起就一共跳了三个台阶，所以问题可以转化为要么跳一个台阶，要么跳三个台阶（当然还是有点区别的，只不过因为结果是一样的，所以可以这么转化），于是就有了 f(x) = f(x-1) + f(x-3)</p><pre><code>public int climbStarts2(int n) {        if(n == 1) return 1; // 防止数组溢出（f[2]）        int[] f = new int[n+1];        f[0] = 1;        f[1] = 1;        f[2] = 2;        for(int i = 3; i &lt;= n; i++) {            f[i] = f[i-1] + f[i-3];        }        return f[n];    }</code></pre><p>结合执行树会更快理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                         6</span><br><span class="line">                   /            \</span><br><span class="line">                  5              4</span><br><span class="line">             /        \         /</span><br><span class="line">            4          3       3</span><br><span class="line">        /       \     /      /   \</span><br><span class="line">       3         2   2      2     1</span><br><span class="line">     /  \       /   / \    / \   /</span><br><span class="line">    2    1     1   1   0  1   0 0</span><br><span class="line">   / \   /    /   /      /</span><br><span class="line">  1   0 0    0   0      0</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这是一个 n = 6 时绘制的一个带权二叉树，其中左节点为权 1，右节点为权 2，很明显，问题的解为树的非空叶节点个数。</p><p>根节点为 f(x)<br>根节点的左节点为 g(x, 1)，又为 f(x - 1)，因为它是一个同类型的子问题<br>根节点的右节点为 g(x, 2)<br>而看节点 g(x, 2)，其不包含非空右节点，即它的解等同于它的左节点的解，再将其相对于根节点，可以明显看出其为 f(x - 3)</p><p>最终结果便为：f(x) = f(x - 1) + f(x - 3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="http://yoursite.com/2021/12/16/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/12/16/剑指 Offer 10- II. 青蛙跳台阶问题/</id>
    <published>2021-12-16T07:12:12.000Z</published>
    <updated>2021-12-16T07:30:03.599Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><a id="more"></a><p>[TOC]</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><pre><code>输入：n = 2输出：2</code></pre><p>示例 2：</p><pre><code>输入：n = 7输出：21</code></pre><p>示例 3：</p><pre><code>输入：n = 0输出：1</code></pre><p>提示：</p><p>0 &lt;= n &lt;= 100</p><p>注意：本题与<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a>相同</p><p>具体解法和斐波那契数列一样，动态规划，矩阵快速幂和齐次线性递推方程取通解。本来已经这样就玩到极致了<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，没想到还有卷中卷，评论里有人提到字节面试还会修改条件，这样就又为之一变。</p><h1 id="加入新的限制条件：不能连续跳两个台阶。"><a href="#加入新的限制条件：不能连续跳两个台阶。" class="headerlink" title="加入新的限制条件：不能连续跳两个台阶。"></a>加入新的限制条件：不能连续跳两个台阶。</h1><p> 1、每次你可以爬 1 或 2 个台阶。</p><p> 2、不能连续跳两个台阶。（个人理解为这次跳了两个台阶，下次不能再跳两个台阶）</p><p> 假设：</p><pre><code>f(x) 表示爬到第 x 级台阶的方案数， g(x, 1) 表示爬到第 x 级台阶并且最后一步只跨越一个台阶的方案数， g(x, 2) 表示爬到第 x 级台阶并且最后一步跨越了两个台阶的方案数。由 ：f(x) = g(x, 1)+g(x,2)， g(x, 1) = f(x-1)， g(x, 2) = g(x-2, 1) // 最后一步跨越了两步，那么上一步只能跨越一步得：f(x) = g(x, 1) + g(x, 2)       = f(x-1) + g(x-2, 1)       = f(x-1) + f((x-2)-1)      = f(x-1) + f(x-3)</code></pre><p>题目里“不能连续跳两个台阶”，即一旦跳了两个台阶，则下一步只能跳一步（2-&gt;1），把它们连在一起就一共跳了三个台阶，所以问题可以转化为要么跳一个台阶，要么跳三个台阶（当然还是有点区别的，只不过因为结果是一样的，所以可以这么转化），于是就有了 f(x) = f(x-1) + f(x-3)</p><pre><code>public int climbStarts2(int n) {        if(n == 1) return 1; // 防止数组溢出（f[2]）        int[] f = new int[n+1];        f[0] = 1;        f[1] = 1;        f[2] = 2;        for(int i = 3; i &lt;= n; i++) {            f[i] = f[i-1] + f[i-3];        }        return f[n];    }</code></pre><p>结合执行树会更快理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                         6</span><br><span class="line">                   /            \</span><br><span class="line">                  5              4</span><br><span class="line">             /        \         /</span><br><span class="line">            4          3       3</span><br><span class="line">        /       \     /      /   \</span><br><span class="line">       3         2   2      2     1</span><br><span class="line">     /  \       /   / \    / \   /</span><br><span class="line">    2    1     1   1   0  1   0 0</span><br><span class="line">   / \   /    /   /      /</span><br><span class="line">  1   0 0    0   0      0</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这是一个 n = 6 时绘制的一个带权二叉树，其中左节点为权 1，右节点为权 2，很明显，问题的解为树的非空叶节点个数。</p><p>根节点为 f(x)<br>根节点的左节点为 g(x, 1)，又为 f(x - 1)，因为它是一个同类型的子问题<br>根节点的右节点为 g(x, 2)<br>而看节点 g(x, 2)，其不包含非空右节点，即它的解等同于它的左节点的解，再将其相对于根节点，可以明显看出其为 f(x - 3)</p><p>最终结果便为：f(x) = f(x - 1) + f(x - 3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="http://yoursite.com/2021/12/15/842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2021/12/15/842. 将数组拆分成斐波那契序列/</id>
    <published>2021-12-15T13:30:12.000Z</published>
    <updated>2021-12-15T14:42:44.038Z</updated>
    
    <content type="html"><![CDATA[<p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><a id="more"></a><p>[TOC]</p><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p><p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p><p>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length &gt;= 3；<br>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p><p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><p>示例 1：</p><pre><code>输入：&quot;123456579&quot;输出：[123,456,579]</code></pre><p>示例 2：</p><pre><code>输入: &quot;11235813&quot;输出: [1,1,2,3,5,8,13]</code></pre><p>示例 3：</p><pre><code>输入: &quot;112358130&quot;输出: []解释: 这项任务无法完成。</code></pre><p>示例 4：</p><pre><code>输入：&quot;0123&quot;输出：[]解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。</code></pre><p>示例 5：</p><pre><code>输入: &quot;1101111&quot;输出: [110, 1, 111]解释: 输出 [11,0,11,11] 也同样被接受。</code></pre><p>提示：</p><pre><code>1 &lt;= S.length &lt;= 200字符串 S 中只含有数字。</code></pre><h1 id="回溯法模板-1"><a href="#回溯法模板-1" class="headerlink" title="回溯法模板^1"></a>回溯法模板<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>回溯法模板</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void backtrack(&quot;原始参数&quot;) &#123;</span><br><span class="line">    //终止条件(递归必须要有终止条件)</span><br><span class="line">    if (&quot;终止条件&quot;) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = &quot;for循环开始的参数&quot;; i &lt; &quot;for循环结束的参数&quot;; i++) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //做出选择</span><br><span class="line"></span><br><span class="line">        //递归</span><br><span class="line">        backtrack(&quot;新的参数&quot;);</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法一：回溯-剪枝-2"><a href="#方法一：回溯-剪枝-2" class="headerlink" title="方法一：回溯 + 剪枝^2"></a>方法一：回溯 + 剪枝<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/jiang-shu-zu-chai-fen-cheng-fei-bo-na-qi-ts6c/" target="_blank" rel="noopener">^2</a></h1><p>将给定的字符串拆分成斐波那契式序列，可以通过回溯的方法实现。</p><p>使用列表存储拆分出的数，回溯过程中维护该列表的元素，列表初始为空。遍历字符串的所有可能的前缀，作为当前被拆分出的数，然后对剩余部分继续拆分，直到整个字符串拆分完毕。</p><p>根据斐波那契式序列的要求，从第 <em>3</em> 个数开始，每个数都等于前 <em>2</em> 个数的和，因此从第 <em>3</em> 个数开始，需要判断拆分出的数是否等于前 <em>2</em> 个数的和，只有满足要求时才进行拆分，否则不进行拆分。</p><p>回溯过程中，还有三处可以进行剪枝操作。</p><ul><li><p>拆分出的数如果不是 <em>0</em>，则不能以 <em>0</em> 开头，因此如果字符串剩下的部分以 <em>0</em> 开头，就不需要考虑拆分出长度大于 <em>1</em> 的数，因为长度大于 <em>1</em> 的数以 <em>0</em> 开头是不符合要求的，不可能继续拆分得到斐波那契式序列；</p></li><li><p>拆分出的数必须符合 <em>32</em> 位有符号整数类型，即每个数必须在 <em>[0,2^{31}-1]</em> 的范围内，如果拆分出的数大于 <em>2^{31}-1</em>，则不符合要求，长度更大的数的数值也一定更大，一定也大于 <em>2^{31}-1</em>，因此不可能继续拆分得到斐波那契式序列；</p></li><li><p>如果列表中至少有 <em>2</em> 个数，并且拆分出的数已经大于最后 <em>2</em> 个数的和，就不需要继续尝试拆分了。</p></li></ul><p>当整个字符串拆分完毕时，如果列表中至少有 <em>3</em> 个数，则得到一个符合要求的斐波那契式序列，返回列表。如果没有找到符合要求的斐波那契式序列，则返回空列表。</p><p>实现方面，回溯需要带返回值，表示是否存在符合要求的斐波那契式序列。</p><p>但是代码部分实现的过于繁琐，简洁版可以参见<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">^1</a></p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(S.toCharArray(), res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[] digit, List&lt;Integer&gt; res, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件判断，如果截取完了，并且res长度大于等于3，表示找到了一个组合。</span></span><br><span class="line">    <span class="keyword">if</span> (index == digit.length &amp;&amp; res.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; digit.length; i++) &#123;</span><br><span class="line">        <span class="comment">//两位以上的数字不能以0开头</span></span><br><span class="line">        <span class="keyword">if</span> (digit[index] == <span class="string">'0'</span> &amp;&amp; i &gt; index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//截取字符串转化为数字</span></span><br><span class="line">        <span class="keyword">long</span> num = subDigit(digit, index, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果截取的数字大于int的最大值，则终止截取</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = res.size();</span><br><span class="line">        <span class="comment">//如果截取的数字大于res中前两个数字的和，说明这次截取的太大，直接终止，因为后面越截取越大</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= <span class="number">2</span> &amp;&amp; num &gt; res.get(size - <span class="number">1</span>) + res.get(size - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span> || num == res.get(size - <span class="number">1</span>) + res.get(size - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="comment">//把数字num添加到集合res中</span></span><br><span class="line">            res.add((<span class="keyword">int</span>) num);</span><br><span class="line">            <span class="comment">//如果找到了就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (backtrack(digit, res, i + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果没找到，就会走回溯这一步，然后把上一步添加到集合res中的数字给移除掉</span></span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于截取字符串S中的子串然后转换为十进制数字</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">subDigit</span><span class="params">(<span class="keyword">char</span>[] digit, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + digit[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; splitIntoFibonacci(<span class="built_in">string</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">        backtrack(<span class="built_in">list</span>, num, num.length(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">list</span>, <span class="built_in">string</span> num, <span class="keyword">int</span> length, <span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>.size() &gt;= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr * <span class="number">10</span> + num[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr &gt; INT_MAX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>.push_back(curr);</span><br><span class="line">            <span class="keyword">if</span> (backtrack(<span class="built_in">list</span>, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> splitIntoFibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">new</span> <span class="built_in">Array</span>().fill(<span class="number">0</span>);</span><br><span class="line">    backtrack(list, num, num.length, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> backtrack = <span class="function">(<span class="params">list, num, length, index, sum, prev</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === length) &#123;</span><br><span class="line">        <span class="keyword">return</span> list.length &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currLong = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] === <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currLong = currLong * <span class="number">10</span> + num[i].charCodeAt() - <span class="string">'0'</span>.charCodeAt();</span><br><span class="line">        <span class="keyword">if</span> (currLong &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> curr = currLong;</span><br><span class="line">        <span class="keyword">if</span> (list.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.push(curr);</span><br><span class="line">        <span class="keyword">if</span> (backtrack(list, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.splice(list.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, num: str)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = list()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index: int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == len(num):</span><br><span class="line">                <span class="keyword">return</span> len(ans) &gt;= <span class="number">3</span></span><br><span class="line">            </span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(num)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> num[index] == <span class="string">"0"</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                curr = curr * <span class="number">10</span> + ord(num[i]) - ord(<span class="string">"0"</span>)</span><br><span class="line">                <span class="keyword">if</span> curr &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> len(ans) &lt; <span class="number">2</span> <span class="keyword">or</span> curr == ans[<span class="number">-2</span>] + ans[<span class="number">-1</span>]:</span><br><span class="line">                    ans.append(curr)</span><br><span class="line">                    <span class="keyword">if</span> backtrack(i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    ans.pop()</span><br><span class="line">                <span class="keyword">elif</span> len(ans) &gt; <span class="number">2</span> <span class="keyword">and</span> curr &gt; ans[<span class="number">-2</span>] + ans[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">splitIntoFibonacci</span><span class="params">(num <span class="keyword">string</span>)</span> <span class="params">(F []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(num)</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(index, sum, prev <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">backtrack</span> = <span class="title">func</span><span class="params">(index, sum, prev <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == n &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(F) &gt;= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">// 每个块的数字一定不要以零开头，除非这个块是数字 0 本身</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur*<span class="number">10</span> + <span class="keyword">int</span>(num[i]-<span class="string">'0'</span>)</span><br><span class="line">            <span class="comment">// 拆出的整数要符合 32 位有符号整数类型</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; math.MaxInt32 &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// F[i] + F[i+1] = F[i+2]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(F) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> cur &lt; sum &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> cur &gt; sum &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 符合要求，加入序列 F</span></span><br><span class="line">            F = <span class="built_in">append</span>(F, cur)</span><br><span class="line">            <span class="keyword">if</span> backtrack(i+<span class="number">1</span>, prev+cur, cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            F = F[:<span class="built_in">len</span>(F)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">list</span>, <span class="keyword">int</span>* listSize, <span class="keyword">char</span>* num, <span class="keyword">int</span> length, <span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">        <span class="keyword">return</span> (*listSize) &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr * <span class="number">10</span> + num[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr &gt; INT_MAX) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((*listSize) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>[(*listSize)++] = curr;</span><br><span class="line">        <span class="keyword">if</span> (backtrack(<span class="built_in">list</span>, listSize, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (*listSize)--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">splitIntoFibonacci</span><span class="params">(<span class="keyword">char</span>* num, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(num);</span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">list</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    backtrack(<span class="built_in">list</span>, returnSize, num, <span class="built_in">strlen</span>(num), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="http://yoursite.com/2021/12/15/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <id>http://yoursite.com/2021/12/15/1414. 和为 K 的最少斐波那契数字数目/</id>
    <published>2021-12-15T12:02:12.000Z</published>
    <updated>2021-12-15T13:11:39.981Z</updated>
    
    <content type="html"><![CDATA[<p>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><a id="more"></a><p>[TOC]</p><p>斐波那契数字定义为：</p><pre><code>F1 = 1F2 = 1Fn = Fn-1 + Fn-2 ， 其中 n &gt; 2 。</code></pre><p>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：</p><pre><code>输入：k = 7输出：2 解释：斐波那契数字为：1，1，2，3，5，8，13，……对于 k = 7 ，我们可以得到 2 + 5 = 7 。</code></pre><p>示例 2：</p><pre><code>输入：k = 10输出：2 解释：对于 k = 10 ，我们可以得到 2 + 8 = 10 。</code></pre><p>示例 3：</p><pre><code>输入：k = 19输出：3 解释：对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。</code></pre><p>提示：</p><pre><code>1 &lt;= k &lt;= 10^9</code></pre><h1 id="贪心-栈"><a href="#贪心-栈" class="headerlink" title="贪心+栈"></a>贪心+栈</h1><p>证明参见<a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/he-wei-k-de-zui-shao-fei-bo-na-qi-shu-zi-shu-mu-by/" target="_blank" rel="noopener">^1</a>，自己觉得用栈的写法比官方题解更易于理解</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinFibonacciNumbers(int k) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int a = 1, b = 1;</span><br><span class="line">        stack.push(a);</span><br><span class="line">        stack.push(b);</span><br><span class="line">        while (stack.peek() &lt;= k) &#123;</span><br><span class="line">            int c = a + b;</span><br><span class="line">            stack.push(c);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = 0;</span><br><span class="line">        while (!stack.isEmpty() &amp;&amp; k &gt; 0) &#123;</span><br><span class="line">            int temp = stack.pop();</span><br><span class="line">            if (temp &lt;= k) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                k = k - temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>873. 最长的斐波那契子序列的长度</title>
    <link href="http://yoursite.com/2021/12/14/873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>http://yoursite.com/2021/12/14/873. 最长的斐波那契子序列的长度/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:34:37.497Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 093. 最长斐波那契数列</title>
    <link href="http://yoursite.com/2021/12/14/%E5%89%91%E6%8C%87%20Offer%20II%20093.%20%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2021/12/14/剑指 Offer II 093. 最长斐波那契数列/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:36:10.891Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><p>本题与<a href="https://leetcode-cn.com/problems/length-of-longest-fibonacc//i-subsequence/" target="_blank" rel="noopener">873. 最长的斐波那契子序列的长度</a>相同： </p><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>372. 超级次方</title>
    <link href="http://yoursite.com/2021/12/13/372.%20%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
    <id>http://yoursite.com/2021/12/13/372. 超级次方/</id>
    <published>2021-12-13T07:28:12.000Z</published>
    <updated>2021-12-13T10:23:30.426Z</updated>
    
    <content type="html"><![CDATA[<p>你的任务是计算ab对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：a = 2, b = [3]输出：8</code></pre><p>示例 2：</p><pre><code>输入：a = 2, b = [1,0]输出：1024</code></pre><p>示例 3：</p><pre><code>输入：a = 1, b = [4,3,3,8,5,2]输出：1</code></pre><p>示例 4：</p><pre><code>输入：a = 2147483647, b = [2,0,0]输出：1198</code></pre><p>提示：</p><pre><code>1 &lt;= a &lt;= 231 - 11 &lt;= b.length &lt;= 20000 &lt;= b[i] &lt;= 9b 不含前导 0</code></pre><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>在阅读本文前，读者需要掌握快速幂这一算法，具体可以见「<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">50. Pow(x, n) 的官方题解</a>」。</p><h1 id="方法一：倒序遍历-1"><a href="#方法一：倒序遍历-1" class="headerlink" title="方法一：倒序遍历^1"></a>方法一：倒序遍历<a href="https://leetcode-cn.com/problems/super-pow/solution/chao-ji-ci-fang-by-leetcode-solution-ow8j/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superPow</span><span class="params">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class="line">        MOD = <span class="number">1337</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> reversed(b):</span><br><span class="line">            ans = ans * pow(a, e, MOD) % MOD</span><br><span class="line">            a = pow(a, <span class="number">10</span>, MOD)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">long</span>) res * x % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">long</span>) x * x % MOD;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">long</span>) ans * <span class="built_in">pow</span>(a, b[i]) % MOD;</span><br><span class="line">            a = <span class="built_in">pow</span>(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    const int MOD = 1337;</span><br><span class="line"></span><br><span class="line">    public int SuperPow(int a, int[] b) &#123;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = b.Length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            ans = (int) ((long) ans * Pow(a, b[i]) % MOD);</span><br><span class="line">            a = Pow(a, 10);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pow(int x, int n) &#123;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            if (n % 2 != 0) &#123;</span><br><span class="line">                res = (int) ((long) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (int) ((long) x * x % MOD);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            res = res * x % mod</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superPow</span><span class="params">(a <span class="keyword">int</span>, b []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(b)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        ans = ans * pow(a, b[i]) % mod</span><br><span class="line">        a = pow(a, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD = BigInt(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superPow = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ans = ans * pow(BigInt(a), b[i]) % MOD;</span><br><span class="line">        a = pow(BigInt(a), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            res = res * BigInt(x) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：秦九韶算法（正序遍历）"><a href="#方法二：秦九韶算法（正序遍历）" class="headerlink" title="方法二：秦九韶算法（正序遍历）"></a>方法二：秦九韶算法（正序遍历）</h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superPow</span><span class="params">(self, a: int, b: List[int])</span> -&gt; int:</span></span><br><span class="line">        MOD = <span class="number">1337</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> b:</span><br><span class="line">            ans = pow(ans, <span class="number">10</span>, MOD) * pow(a, e, MOD) % MOD</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">long</span>) res * x % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">long</span>) x * x % MOD;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e: b) &#123;</span><br><span class="line">            ans = (<span class="keyword">long</span>) <span class="built_in">pow</span>(ans, <span class="number">10</span>) * <span class="built_in">pow</span>(a, e) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : b) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) pow(ans, <span class="number">10</span>) * pow(a, e) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    const int MOD = 1337;</span><br><span class="line"></span><br><span class="line">    public int SuperPow(int a, int[] b) &#123;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        foreach (int e in b) &#123;</span><br><span class="line">            ans = (int) ((long) Pow(ans, 10) * Pow(a, e) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Pow(int x, int n) &#123;</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (n != 0) &#123;</span><br><span class="line">            if (n % 2 != 0) &#123;</span><br><span class="line">                res = (int) ((long) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (int) ((long) x * x % MOD);</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            res = res * x % mod</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superPow</span><span class="params">(a <span class="keyword">int</span>, b []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> b &#123;</span><br><span class="line">        ans = pow(ans, <span class="number">10</span>) * pow(a, e) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD = BigInt(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> superPow = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> e <span class="keyword">of</span> b) &#123;</span><br><span class="line">        ans = pow(BigInt(ans), <span class="number">10</span>) * pow(BigInt(a), e) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">x, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = BigInt(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">            res = res * BigInt(x) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的任务是计算ab对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Division" scheme="http://yoursite.com/tags/Division/"/>
    
  </entry>
  
  <entry>
    <title>69. x 的平方根(二分法模板题及经典解释）</title>
    <link href="http://yoursite.com/2021/12/13/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/13/69. x 的平方根(二分法模板题及经典解释）/</id>
    <published>2021-12-13T07:23:12.000Z</published>
    <updated>2021-12-13T07:23:04.822Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道常见的面试题，面试官一般会要求面试者在不使用sqrt 函数的情况下，得到 <em>x</em> 的平方根的整数部分。一般的思路会有以下几种：</p><ul><li><p>通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；</p></li><li><p>通过数学方法得到近似结果，直接作为答案。</p></li></ul><h1 id="二分法典型解法-二分法模板题及经典解释）-1"><a href="#二分法典型解法-二分法模板题及经典解释）-1" class="headerlink" title="二分法典型解法(二分法模板题及经典解释）^1"></a>二分法典型解法(二分法模板题及经典解释）<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">^1</a></h1><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><ul><li>这道题要求我们实现平方根函数，输入是一个非负整数，输出也是一个整数；</li><li>但是题目当中说：结果只保留整数的部分，小数部分将被舍去。这是什么意思呢？我们分析一下示例。</li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这是显然的，<em>4</em> 本身是一个完全平方数，<em>2^2 = 4</em>。虽然在数学上一个数的平方根有正有负，但是这个题目只要求我们返回算术平方根。</p><p>示例 2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>因为 <em>8</em> 的平方根实际上是 <em>2.82842<em>，题目要求我们将小数部分舍去。因此输出 *2</em>。于是我们知道：由于输出结果的时候，需要将小数部分舍去，因此问题的答案，平方以后一定不会严格大于输入的整数。这里返回 *3</em> 就不对了，这是因为 <em>3^2 = 9 &gt; 8</em>。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>从题目的要求和示例我们可以看出，这其实是一个查找整数的问题，并且这个整数是有范围的。</p><ul><li>如果这个整数的平方 <strong>恰好等于</strong> 输入整数，那么我们就找到了这个整数；</li><li>如果这个整数的平方 <strong>严格大于</strong> 输入整数，那么这个整数肯定不是我们要找的那个数；</li><li>如果这个整数的平方 <strong>严格小于</strong> 输入整数，那么这个整数 <strong>可能</strong> 是我们要找的那个数（重点理解这句话）。</li></ul><p>因此我们可以使用「二分查找」来查找这个整数，不断缩小范围去猜。</p><ul><li>猜的数平方以后大了就往小了猜；</li><li>猜的数平方以后恰恰好等于输入的数就找到了；</li><li>猜的数平方以后小了，可能猜的数就是，也可能不是。</li></ul><p>很容易知道，题目要我们返回的整数是有范围的，直觉上一个整数的平方根肯定不会超过它自己的一半，但是 <em>0</em> 和 <em>1</em> 除外，因此我们可以在 <em>1</em> 到输入整数除以 <em>2</em> 这个范围里查找我们要找的平方根整数。<em>0</em> 单独判断一下就好。</p><p><strong>参考代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(logx) ，每一次搜索的区间大小约为原来的1/2 ，时间复杂度为 O(log_2x)=O(logx) ；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><p><strong>对代码编写逻辑的解释</strong>：</p><p>一、写 <code>if</code> 和 <code>else</code> 的原因：</p><ul><li>猜的数是 <code>mid</code> ，根据上面的分析，如果 <code>mid</code> 的平方 <strong>严格大于</strong> <code>x</code>，<code>mid</code> 肯定不是解，比 <code>mid</code> 大的整数也肯定不是解，因此问题的答案只可能存在区间 <code>[left..mid - 1]</code>，此时设置 <code>right = mid - 1</code>；</li><li><code>else</code> 的情况就是 <code>if</code> 的反面，只要 <code>if</code> 的分支和对应的区间分析对了，<code>else</code> 的区间是  <code>[left..mid - 1]</code> 的反面区间，即 <code>[mid..right]</code> ，此时设置 <code>left = mid</code>。</li></ul><p>二、为什么最后返回 <code>left</code>。</p><ul><li>退出 <code>while (left &lt; right)</code> 循环的时候，由于边界搜索是 <code>left = mid</code> 与 <code>right = mid - 1</code>，因此退出循环的时候一定有 <code>left</code> 与 <code>right</code> 重合，返回 <code>right</code> 也可以。</li></ul><hr><h2 id="问题：mid-为什么要加-1？"><a href="#问题：mid-为什么要加-1？" class="headerlink" title="问题：mid 为什么要加 1？"></a>问题：<code>mid</code> 为什么要加 <code>1</code>？</h2><p>对着错误的测试用例打印出变量 <code>left</code> 、<code>right</code> 和 <code>mid</code> 的值看一下就很清楚了。</p><p><strong><code>mid</code> 不加 <code>1</code> 会造成死循环的代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 取中间数 mid 下取整时</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调试语句开始</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"left = "</span> + left + <span class="string">", right = "</span> + right + <span class="string">", mid = "</span> + mid);</span><br><span class="line">            <span class="comment">// 调试语句结束</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> res = solution.mySqrt(x);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left = 1, right = 4, mid = 2</span><br><span class="line">left = 2, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br></pre></td></tr></table></figure><p><strong>在区间只有 <em>2</em> 个数的时候</strong>，本题 <code>if</code>、<code>else</code> 的逻辑区间的划分方式是：<code>[left..mid - 1]</code> 与 <code>[mid..right]</code>。如果 <code>mid</code> 下取整，在区间只有 <em>2</em> 个数的时候有 <code>mid</code> 的值等于 <code>left</code>，一旦进入分支 <code>[mid..right]</code> 区间不会再缩小，出现死循环。</p><p><a href="https://pic.leetcode-cn.com/1639366986-BFgeWx-image.png" target="_blank" rel="noopener">image.png</a></p><p><strong>解决办法</strong>：把取中间数的方式改成上取整。</p><h1 id="方法一：袖珍计算器算法"><a href="#方法一：袖珍计算器算法" class="headerlink" title="方法一：袖珍计算器算法"></a>方法一：袖珍计算器算法</h1><p>「袖珍计算器算法」是一种用指数函数 exp  和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p><p>我们将sqrt(x) 写成幂的形式 <em>x^{1/2}*，再使用自然对数 *e</em> 进行换底，即可得到</p><pre><code>sqrt(x)=x^{1/2} = (e^lnx)^{1/2}=e^{lnx/2}</code></pre><p>这样我们就可以得到sqrt(x)的值了。</p><p><strong>注意：</strong> 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 <a href="https://baike.baidu.com/item/IEEE%20754" target="_blank" rel="noopener">IEEE 754</a>，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。例如当 <em>x = 2147395600</em> 时，(e^lnx/2) 的计算结果与正确值 <em>46340</em> 相差 <em>10^{-11}*，这样在对结果取整数部分时，会得到 *46339</em> 这个错误的结果。</p><p>因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1  中哪一个是真正的答案。</p><details>    <summary>袖珍计算器算法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = int(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="keyword">int</span>(math.Exp(<span class="number">0.5</span> * math.Log(<span class="keyword">float64</span>(x))))</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x &#123;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em>，由于内置的 <code>exp</code> 函数与 <code>log</code> 函数一般都很快，我们在这里将其复杂度视为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>由于 <em>x</em> 平方根的整数部分 ans 是<strong>满足 k^2&lt;=x  的最大 <em>k</em> 值</strong>，因此我们可以对 <em>k</em> 进行二分查找，从而得到答案。</p><p>二分查找的下界为 <em>0</em>，上界可以粗略地设定为 <em>x</em>。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 <em>x</em> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, x</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt;= x &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logx)，即为二分查找需要的次数。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：牛顿迭代"><a href="#方法三：牛顿迭代" class="headerlink" title="方法三：牛顿迭代"></a>方法三：牛顿迭代</h1><p><strong>思路</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。参见<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">^2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II072</title>
    <link href="http://yoursite.com/2021/12/13/%E5%89%91%E6%8C%87%20Offer%20II%20072.%20%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9(%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98%E5%8F%8A%E7%BB%8F%E5%85%B8%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/13/剑指 Offer II 072. 求平方根(二分法模板题及经典解释）/</id>
    <published>2021-12-13T07:23:12.000Z</published>
    <updated>2021-12-13T10:26:04.755Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><p> 注意：本题与<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69.x的平方根</a>相同</p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道常见的面试题，面试官一般会要求面试者在不使用sqrt 函数的情况下，得到 <em>x</em> 的平方根的整数部分。一般的思路会有以下几种：</p><ul><li><p>通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；</p></li><li><p>通过数学方法得到近似结果，直接作为答案。</p></li></ul><h1 id="二分法典型解法-二分法模板题及经典解释）-1"><a href="#二分法典型解法-二分法模板题及经典解释）-1" class="headerlink" title="二分法典型解法(二分法模板题及经典解释）^1"></a>二分法典型解法(二分法模板题及经典解释）<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">^1</a></h1><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><ul><li>这道题要求我们实现平方根函数，输入是一个非负整数，输出也是一个整数；</li><li>但是题目当中说：结果只保留整数的部分，小数部分将被舍去。这是什么意思呢？我们分析一下示例。</li></ul><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这是显然的，<em>4</em> 本身是一个完全平方数，<em>2^2 = 4</em>。虽然在数学上一个数的平方根有正有负，但是这个题目只要求我们返回算术平方根。</p><p>示例 2 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>因为 <em>8</em> 的平方根实际上是 <em>2.82842<em>，题目要求我们将小数部分舍去。因此输出 *2</em>。于是我们知道：由于输出结果的时候，需要将小数部分舍去，因此问题的答案，平方以后一定不会严格大于输入的整数。这里返回 *3</em> 就不对了，这是因为 <em>3^2 = 9 &gt; 8</em>。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>从题目的要求和示例我们可以看出，这其实是一个查找整数的问题，并且这个整数是有范围的。</p><ul><li>如果这个整数的平方 <strong>恰好等于</strong> 输入整数，那么我们就找到了这个整数；</li><li>如果这个整数的平方 <strong>严格大于</strong> 输入整数，那么这个整数肯定不是我们要找的那个数；</li><li>如果这个整数的平方 <strong>严格小于</strong> 输入整数，那么这个整数 <strong>可能</strong> 是我们要找的那个数（重点理解这句话）。</li></ul><p>因此我们可以使用「二分查找」来查找这个整数，不断缩小范围去猜。</p><ul><li>猜的数平方以后大了就往小了猜；</li><li>猜的数平方以后恰恰好等于输入的数就找到了；</li><li>猜的数平方以后小了，可能猜的数就是，也可能不是。</li></ul><p>很容易知道，题目要我们返回的整数是有范围的，直觉上一个整数的平方根肯定不会超过它自己的一半，但是 <em>0</em> 和 <em>1</em> 除外，因此我们可以在 <em>1</em> 到输入整数除以 <em>2</em> 这个范围里查找我们要找的平方根整数。<em>0</em> 单独判断一下就好。</p><p><strong>参考代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(logx) ，每一次搜索的区间大小约为原来的1/2 ，时间复杂度为 O(log_2x)=O(logx) ；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><p><strong>对代码编写逻辑的解释</strong>：</p><p>一、写 <code>if</code> 和 <code>else</code> 的原因：</p><ul><li>猜的数是 <code>mid</code> ，根据上面的分析，如果 <code>mid</code> 的平方 <strong>严格大于</strong> <code>x</code>，<code>mid</code> 肯定不是解，比 <code>mid</code> 大的整数也肯定不是解，因此问题的答案只可能存在区间 <code>[left..mid - 1]</code>，此时设置 <code>right = mid - 1</code>；</li><li><code>else</code> 的情况就是 <code>if</code> 的反面，只要 <code>if</code> 的分支和对应的区间分析对了，<code>else</code> 的区间是  <code>[left..mid - 1]</code> 的反面区间，即 <code>[mid..right]</code> ，此时设置 <code>left = mid</code>。</li></ul><p>二、为什么最后返回 <code>left</code>。</p><ul><li>退出 <code>while (left &lt; right)</code> 循环的时候，由于边界搜索是 <code>left = mid</code> 与 <code>right = mid - 1</code>，因此退出循环的时候一定有 <code>left</code> 与 <code>right</code> 重合，返回 <code>right</code> 也可以。</li></ul><hr><h2 id="问题：mid-为什么要加-1？"><a href="#问题：mid-为什么要加-1？" class="headerlink" title="问题：mid 为什么要加 1？"></a>问题：<code>mid</code> 为什么要加 <code>1</code>？</h2><p>对着错误的测试用例打印出变量 <code>left</code> 、<code>right</code> 和 <code>mid</code> 的值看一下就很清楚了。</p><p><strong><code>mid</code> 不加 <code>1</code> 会造成死循环的代码</strong>：</p><details>    <summary>二分查找Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 取中间数 mid 下取整时</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调试语句开始</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"left = "</span> + left + <span class="string">", right = "</span> + right + <span class="string">", mid = "</span> + mid);</span><br><span class="line">            <span class="comment">// 调试语句结束</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> res = solution.mySqrt(x);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left = 1, right = 4, mid = 2</span><br><span class="line">left = 2, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br><span class="line">left = 3, right = 4, mid = 3</span><br></pre></td></tr></table></figure><p><strong>在区间只有 <em>2</em> 个数的时候</strong>，本题 <code>if</code>、<code>else</code> 的逻辑区间的划分方式是：<code>[left..mid - 1]</code> 与 <code>[mid..right]</code>。如果 <code>mid</code> 下取整，在区间只有 <em>2</em> 个数的时候有 <code>mid</code> 的值等于 <code>left</code>，一旦进入分支 <code>[mid..right]</code> 区间不会再缩小，出现死循环。</p><p><a href="https://pic.leetcode-cn.com/1639366986-BFgeWx-image.png" target="_blank" rel="noopener">image.png</a></p><p><strong>解决办法</strong>：把取中间数的方式改成上取整。</p><h1 id="方法一：袖珍计算器算法"><a href="#方法一：袖珍计算器算法" class="headerlink" title="方法一：袖珍计算器算法"></a>方法一：袖珍计算器算法</h1><p>「袖珍计算器算法」是一种用指数函数 exp  和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p><p>我们将sqrt(x) 写成幂的形式 <em>x^{1/2}*，再使用自然对数 *e</em> 进行换底，即可得到</p><pre><code>sqrt(x)=x^{1/2} = (e^lnx)^{1/2}=e^{lnx/2}</code></pre><p>这样我们就可以得到sqrt(x)的值了。</p><p><strong>注意：</strong> 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 <a href="https://baike.baidu.com/item/IEEE%20754" target="_blank" rel="noopener">IEEE 754</a>，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。例如当 <em>x = 2147395600</em> 时，(e^lnx/2) 的计算结果与正确值 <em>46340</em> 相差 <em>10^{-11}*，这样在对结果取整数部分时，会得到 *46339</em> 这个错误的结果。</p><p>因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1  中哪一个是真正的答案。</p><details>    <summary>袖珍计算器算法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = int(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="keyword">int</span>(math.Exp(<span class="number">0.5</span> * math.Log(<span class="keyword">float64</span>(x))))</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x &#123;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em>，由于内置的 <code>exp</code> 函数与 <code>log</code> 函数一般都很快，我们在这里将其复杂度视为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>由于 <em>x</em> 平方根的整数部分 ans 是<strong>满足 k^2&lt;=x  的最大 <em>k</em> 值</strong>，因此我们可以对 <em>k</em> 进行二分查找，从而得到答案。</p><p>二分查找的下界为 <em>0</em>，上界可以粗略地设定为 <em>x</em>。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 <em>x</em> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, x</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt;= x &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logx)，即为二分查找需要的次数。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：牛顿迭代"><a href="#方法三：牛顿迭代" class="headerlink" title="方法三：牛顿迭代"></a>方法三：牛顿迭代</h1><p><strong>思路</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。参见<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">^2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>50. Pow(x, n)快速幂算法</title>
    <link href="http://yoursite.com/2021/12/13/50.%20Pow(x,%20n)%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/12/13/50. Pow(x, n)快速幂算法/</id>
    <published>2021-12-13T03:12:12.000Z</published>
    <updated>2021-12-13T06:33:46.311Z</updated>
    
    <content type="html"><![CDATA[<p>在计算斐波那契数时遇到要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，需要用到快速幂算法。</p><p>实现 pow(x, n) ，即计算x的n次幂函数（即x^n）。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：x = 2.00000, n = 10输出：1024.00000</code></pre><p>示例 2：</p><pre><code>输入：x = 2.10000, n = 3输出：9.26100</code></pre><p>示例 3：</p><pre><code>输入：x = 2.00000, n = -2输出：0.25000解释：2^-2 = 1/2^2 = 1/4 = 0.25</code></pre><p>提示：</p><pre><code>-100.0 &lt; x &lt; 100.0-2^31 &lt;= n &lt;= 2^31-1-10^4 &lt;= x^n &lt;= 10^4</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题的方法被称为「快速幂算法」，有递归和迭代两个版本。这篇题解会从递归版本的开始讲起，再逐步引出迭代的版本。</p><p>当指数 <em>n</em> 为负数时，我们可以计算 <em>x^{-n}</em> 再取倒数得到结果，因此我们只需要考虑 <em>n</em> 为自然数的情况。</p><h1 id="方法一：快速幂-递归-1"><a href="#方法一：快速幂-递归-1" class="headerlink" title="方法一：快速幂 + 递归^1"></a>方法一：快速幂 + 递归<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></h1><p>「快速幂算法」的本质是分治算法。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">            y = quickMul(N // <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> y * y <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> y * y * x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickMul(x, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / quickMul(x, -n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickMul</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := quickMul(x, n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y * y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y * y * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：快速幂-迭代"><a href="#方法二：快速幂-迭代" class="headerlink" title="方法二：快速幂 + 迭代"></a>方法二：快速幂 + 迭代</h1><p>由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 <em>x</em>。但我们不妨找一找规律，看看哪些地方额外乘了 <em>x</em>，并且它们对答案产生了什么影响。</p><p>下面的代码给出了详细的注释。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(N)</span>:</span></span><br><span class="line">            ans = <span class="number">1.0</span></span><br><span class="line">            <span class="comment"># 贡献的初始值为 x</span></span><br><span class="line">            x_contribute = x</span><br><span class="line">            <span class="comment"># 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">            <span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                    ans *= x_contribute</span><br><span class="line">                <span class="comment"># 将贡献不断地平方</span></span><br><span class="line">                x_contribute *= x_contribute</span><br><span class="line">                <span class="comment"># 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">                N //= <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickMul(x, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / quickMul(x, -n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickMul</span><span class="params">(x <span class="keyword">float64</span>, N <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1.0</span></span><br><span class="line">    <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">    x_contribute := x</span><br><span class="line">    <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">    <span class="keyword">for</span> N &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">            ans *= x_contribute</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">        x_contribute *= x_contribute</span><br><span class="line">        <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">        N /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算斐波那契数时遇到要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，需要用到快速幂算法。&lt;/p&gt;
&lt;p&gt;实现 pow(x, n) ，即计算x的n次幂函数（即x^n）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>509. 斐波那契数</title>
    <link href="http://yoursite.com/2021/12/13/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/13/509. 斐波那契数/</id>
    <published>2021-12-13T02:12:12.000Z</published>
    <updated>2021-12-13T03:16:50.108Z</updated>
    
    <content type="html"><![CDATA[<p> 计算斐波那契数，虽然此题看起来简单，但面试中常要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，难度属实不低。</p><a id="more"></a><p>[TOC]</p><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p>示例 1：</p><pre><code>输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1</code></pre><p>示例 2：</p><pre><code>输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2</code></pre><p>示例 3：</p><pre><code>输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3</code></pre><p>提示：</p><pre><code>0 &lt;= n &lt;= 30</code></pre><p>与<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a>相同</p><p>参见<a href="https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/" target="_blank" rel="noopener">^1</a></p><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p>斐波那契数的边界条件是 <em>F(0)=0</em> 和 <em>F(1)=1*。当 *n&gt;1</em> 时，每一项的和都等于前两项的和，因此有如下递推关系：</p><p><em>F(n)=F(n-1)+F(n-2)</em></p><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 <em>F(0)</em> 和 <em>F(1)</em>。</p><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 <em>O(n)</em> 的实现。由于 <em>F(n)</em> 只和 <em>F(n-1)</em> 与 <em>F(n-2)</em> 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <em>O(1)</em>。<strong>如下的代码中给出的就是这种实现。</strong></p><p> <a href="https://assets.leetcode-cn.com/solution-static/509/509_fig1.gif" target="_blank" rel="noopener">fig1</a></p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        p, q, r = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            p, q = q, r</span><br><span class="line">            r = p + q</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：矩阵快速幂"><a href="#方法二：矩阵快速幂" class="headerlink" title="方法二：矩阵快速幂"></a>方法二：矩阵快速幂</h1><p>方法一的时间复杂度是 <em>O(n)</em>。使用矩阵快速幂的方法可以降低时间复杂度。</p><p>首先我们可以构建一个递推关系：</p><p>因此只要我们能快速计算矩阵 <em>M</em> 的 <em>n</em> 次幂，就可以得到 <em>F(n)</em> 的值。如果直接求取 <em>M^n<em>，时间复杂度是 *O(n)</em>，可以定义矩阵乘法，然后用快速幂算法来加速这里 *M^n</em> 的求取。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = matrix_pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix_pow(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret = matrix_multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = matrix_multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix_multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">const</span> res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">a, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">            ret = multiply(ret, a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = multiply(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> matrix [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(a, b matrix)</span> <span class="params">(c matrix)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>]*b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>]*b[<span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a matrix, n <span class="keyword">int</span>)</span> <span class="title">matrix</span></span> &#123;</span><br><span class="line">    ret := matrix&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ret = multiply(ret, a)</span><br><span class="line">        &#125;</span><br><span class="line">        a = multiply(a, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    res := pow(matrix&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Matrix <span class="title">matrixMultiply</span><span class="params">(struct Matrix* a, struct Matrix* b)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c.mat[i][j] = (*a).mat[i][<span class="number">0</span>] * (*b).mat[<span class="number">0</span>][j] + (*a).mat[i][<span class="number">1</span>] * (*b).mat[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Matrix <span class="title">matrixPow</span><span class="params">(struct Matrix a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">ret</span>;</span></span><br><span class="line">    ret.mat[<span class="number">0</span>][<span class="number">0</span>] = ret.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ret.mat[<span class="number">0</span>][<span class="number">1</span>] = ret.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = matrixMultiply(&amp;ret, &amp;a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = matrixMultiply(&amp;a, &amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">q</span>;</span></span><br><span class="line">    q.mat[<span class="number">0</span>][<span class="number">0</span>] = q.mat[<span class="number">0</span>][<span class="number">1</span>] = q.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">res</span> = <span class="title">matrixPow</span>(<span class="title">q</span>, <span class="title">n</span> - 1);</span></span><br><span class="line">    <span class="keyword">return</span> res.mat[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        res = self.matrix_pow(q, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrix_pow</span><span class="params">(self, a: List[List[int]], n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ret = self.matrix_multiply(ret, a)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            a = self.matrix_multiply(a, a)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrix_multiply</span><span class="params">(self, a: List[List[int]], b: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        c = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logn)  。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：通项公式"><a href="#方法三：通项公式" class="headerlink" title="方法三：通项公式"></a>方法三：通项公式</h1><p>斐波那契数 <em>F(n)</em> 是齐次线性递推，根据递推方程 <em>F(n)=F(n-1)+F(n-2)</em>，可以写出这样的特征方程：</p><p><em>x^2=x+1</em></p><p>得到通项公式之后，就可以通过公式直接求解第 <em>n</em> 项。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sqrt5 = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> fibN = <span class="built_in">Math</span>.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(fibN / sqrt5);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sqrt5 := math.Sqrt(<span class="number">5</span>)</span><br><span class="line">    p1 := math.Pow((<span class="number">1</span>+sqrt5)/<span class="number">2</span>, <span class="keyword">float64</span>(n))</span><br><span class="line">    p2 := math.Pow((<span class="number">1</span>-sqrt5)/<span class="number">2</span>, <span class="keyword">float64</span>(n))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(math.Round((p1 - p2) / sqrt5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        sqrt5 = <span class="number">5</span>**<span class="number">0.5</span></span><br><span class="line">        fibN = ((<span class="number">1</span> + sqrt5) / <span class="number">2</span>) ** n - ((<span class="number">1</span> - sqrt5) / <span class="number">2</span>) ** n</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>代码中使用的 pow 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 计算斐波那契数，虽然此题看起来简单，但面试中常要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，难度属实不低。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>面试题 08.06. 汉诺塔问题</title>
    <link href="http://yoursite.com/2021/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.06.%20%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/12/13/面试题 08.06. 汉诺塔问题/</id>
    <published>2021-12-13T02:12:12.000Z</published>
    <updated>2021-12-13T02:23:43.428Z</updated>
    
    <content type="html"><![CDATA[<p> 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><a id="more"></a><p>[TOC]</p><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p>示例1:</p><pre><code>输入：A = [2, 1, 0], B = [], C = []输出：C = [2, 1, 0]</code></pre><p>示例2:</p><pre><code>输入：A = [1, 0], B = [], C = []输出：C = [1, 0]</code></pre><p>提示:</p><pre><code>A中盘子的数目不大于14个。</code></pre><h2 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h2><blockquote><p>相传在很久以前，有个寺庙里的几个和尚整天不停地移动着 64 个盘子，日复一日，年复一年。据说，当 64 个盘子全部移完的那一天就是世界末日…</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有 A,B,C 三根柱子，A 上面有 n 个盘子，我们想把 A 上面的盘子移动到 C 上，但是要满足以下三个条件：</p><ol><li>每次只能移动一个盘子;</li><li>盘子只能从柱子顶端滑出移到下一根柱子;</li><li>盘子只能叠在比它大的盘子上。</li></ol><p><a href="https://pic.leetcode-cn.com/7043dec266338d396d186805072660d5f9517e2c1008af80d461b553c5b32470-p1.png" target="_blank" rel="noopener">p1.png</a></p><h3 id="解题思路：递归与分治"><a href="#解题思路：递归与分治" class="headerlink" title="解题思路：递归与分治"></a>解题思路：递归与分治</h3><p>这是一道递归方法的经典题目，乍一想还挺难理清头绪的，我们不妨先从简单的入手。</p><p>假设 <code>n = 1</code>,只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；</p><p>如果 <code>n = 2</code> 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 4 步。</p><p> <a href="https://pic.leetcode-cn.com/f6f3b97651247c9ff846f115e1866ab364b1c0e265fd51689ddd6a8ca1758482-0806.gif" target="_blank" rel="noopener">0806.gif</a></p><p>如果  <code>n &gt; 2</code> 呢？思路和上面是一样的，我们把 n 个盘子也看成两个部分，一部分有 1 个盘子，另一部分有 n - 1 个盘子。</p><p> <a href="https://pic.leetcode-cn.com/3bffd1a1faf4323a92b659e37d7e2cd6c79fe074602b2977f4a7931fe82bbb13-08061.gif" target="_blank" rel="noopener">08061.gif</a></p><p>观察上图，你可能会问：“那 n - 1 个盘子是怎么从 A 移到 C 的呢？”</p><p>注意，<strong>当你在思考这个问题的时候，就将最初的 n 个盘子从 A 移到 C 的问题，转化成了将 n - 1 个盘子从 A 移到 C 的问题，</strong> 依次类推，直至转化成 1 个盘子的问题时，问题也就解决了。这就是分治的思想。 </p><p>而实现分治思想的常用方法就是递归。不难发现，如果原问题可以分解成若干个与原问题结构相同但规模较小的子问题时，往往可以用递归的方法解决。具体解决办法如下：</p><ul><li><code>n = 1</code> 时，直接把盘子从 A 移到 C；</li><li><code>n &gt; 1</code> 时，<ul><li>先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；</li><li>再将最大的盘子从 A 移到 C；</li><li>再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hanota</span><span class="params">(self, A: List[int], B: List[int], C: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        self.move(n, A, B, C)</span><br><span class="line">    <span class="comment"># 定义move 函数移动汉诺塔</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,n, A, B, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            C.append(A[<span class="number">-1</span>])</span><br><span class="line">            A.pop()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.move(n<span class="number">-1</span>, A, C, B)  <span class="comment"># 将A上面n-1个通过C移到B</span></span><br><span class="line">            C.append(A[<span class="number">-1</span>])          <span class="comment"># 将A最后一个移到C</span></span><br><span class="line">            A.pop()                  <span class="comment"># 这时，A空了</span></span><br><span class="line">            self.move(n<span class="number">-1</span>,B, A, C)   <span class="comment"># 将B上面n-1个通过空的A移到C</span></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        move(n, A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.push_back(A.back());</span><br><span class="line">            A.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        move(n<span class="number">-1</span>, A, C, B);    <span class="comment">// 将A上面n-1个通过C移到B</span></span><br><span class="line">        C.push_back(A.back());  <span class="comment">// 将A最后一个移到C</span></span><br><span class="line">        A.pop_back();          <span class="comment">// 这时，A空了</span></span><br><span class="line">        move(n<span class="number">-1</span>, B, A, C);     <span class="comment">// 将B上面n-1个通过空的A移到C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            C.add(A.get(A.size() - <span class="number">1</span>));</span><br><span class="line">            A.remove(A.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move(n - <span class="number">1</span>, A, C, B);</span><br><span class="line">        C.add(A.get(A.size() - <span class="number">1</span>));</span><br><span class="line">        A.remove(A.size() - <span class="number">1</span>);</span><br><span class="line">        move(n - <span class="number">1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析：世界会毁灭吗"><a href="#复杂度分析：世界会毁灭吗" class="headerlink" title="复杂度分析：世界会毁灭吗"></a>复杂度分析：世界会毁灭吗</h2><ul><li>时间复杂度：<em>O(2^n-1)</em>。一共需要移动的次数。</li><li>空间复杂度：<em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ学习笔记（概念，架构和消息交换机类型）</title>
    <link href="http://yoursite.com/2021/12/12/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B6%88%E6%81%AF%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/12/RabbitMQ学习笔记（概念，架构和消息交换机类型）/</id>
    <published>2021-12-12T12:12:12.000Z</published>
    <updated>2021-12-13T01:56:48.612Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ是AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的技术实现，也是高性能消息服务组件的代表之作。由于其隶属于Pivotal公司，所以与Spring的整合效果是最完善的。在SpringCloud开发技术中大量使用了RabbitMQ消息组件。</p><a id="more"></a><p>[TOC]</p><h1 id="概念-1"><a href="#概念-1" class="headerlink" title="概念^1"></a>概念<a href="[名师讲坛：Java微服务架构实战（SpringBoot+SpringCloud+Docker+RabbitMQ](https://weread.qq.com/web/reader/0e03209071c96a420e02710ka0a32dd027aa0a080f42962)">^1</a></h1><p>RabbitMQ是一种消息队列服务，同样也是在进行系统整合时的一种通信手段，其运行模式遵循“生产者—消费者”模型，即会存在若干个消息生产者以及若干个消息消费者。与JavaEE提出的JMS标准不同之处在于：RabbitMQ是由ERLang开发的基于AMQP应用层协议标准的一种消息组件，所以其处理性能要比JMS组件更高。RabbitMQ官方网站的网址为<a href="http://www.rabbitmq.com" target="_blank" rel="noopener">http://www.rabbitmq.com</a></p><p>深入了解还可以参见<a href="[深入RabbitMQ](https://weread.qq.com/web/reader/80c32e0071dbdd9580c74f2k8f132430178f14e45fce0f7)">^2</a></p><h3 id="提示：常见消息组件。"><a href="#提示：常见消息组件。" class="headerlink" title="提示：常见消息组件。"></a>提示：常见消息组件。</h3><p>消息组件主要划分为JMS组件和AMQP组件两类。[插图] JMS（Java Message Service）组件：ActiveMQ性能较差。[插图] AMQP组件（协议）：性能是最高的，而AMQP有两个主要的开源。|- RabbitMQ：使用最为广泛，响应速度快。|- Kafka：是大数据时代作为数据采集的重要组件，处理速度更高。RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购，在2013年5月被并入Pivotal。</p><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p>AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放标准，为<br>面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言<br>等条件的限制。</p><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可<br>用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布<br>确认。</li><li>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对<br>于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路<br>由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节<br>点出问题的情况下队列仍然可用。</li><li>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT<br>等等。</li><li>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、<br>Ruby 等等。</li><li>管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控<br>和管理消息 Broker 的许多方面。</li><li>跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生<br>了什么。</li><li>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编<br>写自己的插件。</li></ol><h1 id="RabbitMQ-架构"><a href="#RabbitMQ-架构" class="headerlink" title="RabbitMQ 架构"></a>RabbitMQ 架构</h1><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h2 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h2><ol><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li></ol><h2 id="Exchange-消息交换机（将消息路由给队列-）"><a href="#Exchange-消息交换机（将消息路由给队列-）" class="headerlink" title="Exchange 消息交换机（将消息路由给队列 ）"></a>Exchange 消息交换机（将消息路由给队列 ）</h2><ol start="2"><li>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li></ol><h2 id="Binding（消息队列和交换器之间的关联）"><a href="#Binding（消息队列和交换器之间的关联）" class="headerlink" title="Binding（消息队列和交换器之间的关联）"></a>Binding（消息队列和交换器之间的关联）</h2><ol start="3"><li>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连<br>接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ol start="4"><li>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息<br>可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li></ol><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol start="5"><li>网络连接，比如一个 TCP 连接。</li></ol><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ol start="6"><li>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li></ol><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><ol start="7"><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li></ol><h2 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h2><ol start="8"><li>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</li></ol><h2 id="Broker-消息队列服务主机"><a href="#Broker-消息队列服务主机" class="headerlink" title="Broker 消息队列服务主机"></a>Broker 消息队列服务主机</h2><ol start="9"><li>表示消息队列服务器实体。</li></ol><h1 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h1><p>Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外headers交换器和direct交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：topic（主题订阅）、direct（直连）、fanout（广播）</p><h2 id="Direct-键（routing-key）分布："><a href="#Direct-键（routing-key）分布：" class="headerlink" title="Direct 键（routing key）分布："></a>Direct 键（routing key）分布：</h2><ol><li>Direct：消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。</li></ol><h2 id="Fanout（广播分发）"><a href="#Fanout（广播分发）" class="headerlink" title="Fanout（广播分发）"></a>Fanout（广播分发）</h2><ol start="2"><li>Fanout：每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout类型转发消息是最快的。</li></ol><h2 id="topic-交换器（模式匹配）"><a href="#topic-交换器（模式匹配）" class="headerlink" title="topic 交换器（模式匹配）"></a>topic 交换器（模式匹配）</h2><ol start="3"><li>topic 交换器：topic交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配 0 个或多个单词，匹配不多不少一个单词。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RabbitMQ是AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的技术实现，也是高性能消息服务组件的代表之作。由于其隶属于Pivotal公司，所以与Spring的整合效果是最完善的。在SpringCloud开发技术中大量使用了RabbitMQ消息组件。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.07. 最大数值</title>
    <link href="http://yoursite.com/2021/12/12/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.07.%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/"/>
    <id>http://yoursite.com/2021/12/12/面试题 16.07. 最大数值/</id>
    <published>2021-12-12T04:12:12.000Z</published>
    <updated>2021-12-12T04:20:48.078Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。</p><a id="more"></a><p>[TOC]</p><p>示例：</p><pre><code>输入： a = 1, b = 2输出： 2</code></pre><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><ol><li><p>首先 a - b 得到差值x</p></li><li><p>由于是long型，右移63位得到符号位，注意负号不变，那么正数右移63位就是0，负数右移63位就是-1</p></li><li><p>那么得出我们的计算公式  (1 + k) * a - b * k</p><p> 当 x &gt;= 0 的时候，k = 0, 即 a &gt; b<br> 那么我们的计算公式为  1 * a - b * 0 = a</p><p> 当 x &lt; 0的时候，k = -1, 即 b &gt; a<br> 那么我们的计算公式为  0 * a - b * ( -1 ) = b</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximum(int a, int b) &#123;</span><br><span class="line">        long x = (long) a - (long) b;</span><br><span class="line">        int k = (int) (x &gt;&gt; 63);</span><br><span class="line"></span><br><span class="line">        return (1 + k) * a - b * k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>关于这道题已有很多解法，大概有以下几种：</p><ol><li>使用 <code>max</code>，<code>abs</code> 之类的库函数。这种真的不要骗自己，就是作弊方法；</li><li>使用位运算，但申请了更大的类型避免溢出。这种没有作弊，但是我觉得还可以改进，因为如果入参就已经是系统支持的最大类型，那么这类解法就无效了；</li><li>使用位运算，同时没有申请更大的类型。这种已经很完美了，但是我没有看到 C/C++ 的 Solution，可能 C/C++ 面对溢出问题会报错（Java 不会），处理起来更困难一些。</li></ol><p>回到问题中，我们现在来一步一步思考。首先，如果没有限制条件，那么非常简单：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者使用三目运算符</span></span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>但是，我们不能使用 if-else 或者比较运算符，所以我们需要构思如何去返回结果，这里不妨构造一个计算公式：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>这里 k 的值应该为 1 或 0，且我们应使其：</p><ul><li>当 a &lt; b 时，k = 0，则 k ^ 1 = 1。此时计算结果等于 b；</li><li>当 a &gt; b 是，k = 1，则 k ^ 1 = 0。此时计算结果等于 a。</li></ul><p>那么如何让 k 满足我们的要求的呢？这里可以用算术运算+位运算操作：判断 a - b 的最高位（符号位），即：</p><ul><li>当 a - b &lt; 0 时，a - b 的最高位为 1，此时，k 应该为 0；</li><li>当 a - b &gt; 0 时，a - b 的最高位为 0，此时，k 应该为 1；</li></ul><p>发现了吗？k 的值和 a - b 的最高位恰好相反，这里很自然的再引入异或运算，可以得到代码：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// C/C++ 中负数右移最高位会补 1，因此需要转成无符号类型后再右移</span></span><br><span class="line">        <span class="comment">// 将 a-b 的符号位移动到最左边，再与 1 异或取反，得到 k 的值</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a - b) &gt;&gt; (bitlen - <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>这样我们就返回了正确结果。但是需要注意 a - b 可能会导致溢出问题，一种简单的解决方式是用更大的类型（例如 long long）保存中间结果，但如果入参已经是系统支持的最大类型，那这种解法就失效了，所以并不完美。因此，我们来思考一下如何在给定的类型范围内解决这个问题。这里，我们需要分情况考虑：</p><ul><li>当 a 和 b 同号时，a - b 不会溢出，使用上面的代码即可；</li><li>当 a 和 b 异号时，a - b 可能溢出，需要额外处理；</li></ul><p>第一种情况我们已经解决了，现在来考虑第二种情况。我们可以使用 a 的符号位异或 b 的符号位，当结果为 1 时，说明异号；结果为 0 时，说明同号。当异号时，我们应该直接返回正数，避免 a - b 的运算。那么当两数异号时，我们如何确定 k 的值呢？当 a 为负数时，a 的符号位为 1，此时 k 应该为 0；当 a 为正数时，a 的符号位为 0，k 应该为 1。总结规律可以发现，k 的值应该等于 a 的符号位异或 1。现在来实现第二种情况的代码：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> asign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> k = asign ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>现在我们已经实现了两种不同情况下的代码，针对两数同号或异号的场景分别处理，以避免溢出问题，最后我们只需要将其组合起来。由于不能使用 if-else 语句，需要我们用一点 trick，见下：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算 int 类型的位数，避免不同系统下长度不同</span></span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 a 的符号位，b 的符号位</span></span><br><span class="line">        <span class="comment">// C/C++ 中负数右移最高位会补 1，因此需要转成无符号类型后再右移</span></span><br><span class="line">        <span class="keyword">int</span> asign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bsign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(b) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 假设 a 与 b 异号，计算 k 的值</span></span><br><span class="line">        <span class="keyword">int</span> k = asign ^ <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 a 和 b 异号时，asign ^ bsign ^ 1 为 0，由于 逻辑与运算 的短路性，将不再计算后半行代码，避免溢出</span></span><br><span class="line">        <span class="comment">// 当 a 和 b 同号时，asign ^ bsign ^ 1 为 1，此时会执行后半行代码，重新对 k 赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp_cond = (asign ^ bsign ^ <span class="number">1</span>) &amp;&amp; (k = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a - b) &gt;&gt; (bitlen - <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>至此，我们就完成了这道题。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Brainteaser" scheme="http://yoursite.com/tags/Brainteaser/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 079. 所有子集</title>
    <link href="http://yoursite.com/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20079.%20%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2021/12/12/剑指 Offer II 079. 所有子集/</id>
    <published>2021-12-12T03:36:12.000Z</published>
    <updated>2021-12-12T03:45:52.725Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 10-10 &lt;= nums[i] &lt;= 10nums 中的所有元素 互不相同</code></pre><p>注意：本题与主站 <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78.子集</a>题相同。</p><h1 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int state = 0; state &lt; (1 &lt;&lt; n); state ++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (((state &gt;&gt; i) &amp; 1) == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int state = 0; state &lt; (1 &lt;&lt; n); state ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; cur;</span><br><span class="line">            for (int i = 0; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if ((state &gt;&gt; i) &amp; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur.push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        for state in range(0, 1 &lt;&lt; n):</span><br><span class="line">            cur = []</span><br><span class="line">            for i in range(n):</span><br><span class="line">                if (state &gt;&gt; i) &amp; 1:</span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">            res.append(cur)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details><h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">    int [] nums;</span><br><span class="line">    int n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, tmp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int idx, List&lt;Integer&gt; path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path1 = new ArrayList&lt;&gt;();     path1.addAll(path);</span><br><span class="line">        dfs(idx + 1, path1);</span><br><span class="line">        path.add(nums[idx]);</span><br><span class="line">        List&lt;Integer&gt; path2 = new ArrayList&lt;&gt;();     path2.addAll(path);</span><br><span class="line">        dfs(idx + 1, path2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        dfs(0, vector&lt;int&gt;&#123;&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int idx, vector&lt;int&gt; path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(idx + 1, path);</span><br><span class="line">        path.push_back(nums[idx]);</span><br><span class="line">        dfs(idx + 1, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        def dfs(idx: int, path: List[int]) -&gt; None:</span><br><span class="line">            nonlocal res</span><br><span class="line">            if idx == n:</span><br><span class="line">                res.append(path)</span><br><span class="line">                return </span><br><span class="line">            dfs(idx + 1, path + [nums[idx]])</span><br><span class="line">            dfs(idx + 1, path)</span><br><span class="line"></span><br><span class="line">        dfs(0, [])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">    int [] nums;</span><br><span class="line">    int n;</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        this.n = nums.length;</span><br><span class="line">        backtrace(0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtrace(int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line"></span><br><span class="line">        path.add(nums[idx]);</span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line">        path.remove(path.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        this-&gt;n = nums.size();</span><br><span class="line">        backtrace(0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backtrace(int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line"></span><br><span class="line">        path.push_back(nums[idx]);</span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        path = []</span><br><span class="line">        def backtrace(idx: int) -&gt; None:</span><br><span class="line">            nonlocal res</span><br><span class="line">            nonlocal path</span><br><span class="line">            if idx == n:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                return </span><br><span class="line">                </span><br><span class="line">            backtrace(idx + 1)</span><br><span class="line"></span><br><span class="line">            path.append(nums[idx])</span><br><span class="line">            backtrace(idx + 1)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        backtrace(0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 067. 最大的异或</title>
    <link href="http://yoursite.com/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20067.%20%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96/"/>
    <id>http://yoursite.com/2021/12/12/剑指 Offer II 067. 最大的异或/</id>
    <published>2021-12-12T02:12:12.000Z</published>
    <updated>2021-12-12T01:53:16.297Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p><p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p><p>注意：本题与主站 <a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. 数组中两个数的最大异或值</a>相同</p><p>示例 1：</p><pre><code>输入：nums = [3,10,5,25,2,8]输出：28解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [2,4]输出：6</code></pre><p>示例 4：</p><pre><code>输入：nums = [8,10,2]输出：10</code></pre><p>示例 5：</p><pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]输出：127</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2 * 1040 &lt;= nums[i] &lt;= 231 - 1</code></pre><h1 id="方法一：哈希表-1"><a href="#方法一：哈希表-1" class="headerlink" title="方法一：哈希表^1"></a>方法一：哈希表<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>假设我们已经确定了 <em>x</em> 最高的若干个二进制位，当前正在确定第 <em>k</em> 个二进制位。根据「前言」部分的分析，我们希望第 <em>k</em> 个二进制位能够取到 <em>1</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.insert(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.count(x_next ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = x_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = xNext - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            ISet&lt;int&gt; seen = new HashSet&lt;int&gt;();</span><br><span class="line">            // 将所有的 pre^k(a_j) 放入哈希表中</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                // 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br><span class="line">                // 只需将其右移 k 位</span><br><span class="line">                seen.Add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br><span class="line">            // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br><span class="line">            int xNext = x * 2 + 1;</span><br><span class="line">            bool found = false;</span><br><span class="line">            </span><br><span class="line">            // 枚举 i</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                if (seen.Contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br><span class="line">                // 即为 x = x*2</span><br><span class="line">                x = xNext - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            seen = set()</span><br><span class="line">            <span class="comment"># 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment"># 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment"># 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            x_next = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x_next ^ (num &gt;&gt; k) <span class="keyword">in</span> seen:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                x = x_next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment"># 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaximumXOR = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen.add(num &gt;&gt; k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">const</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.has(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = xNext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> highBit = <span class="number">30</span> <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">for</span> k := highBit; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        seen := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen[num&gt;&gt;k] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        xNext := x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found &#123;</span><br><span class="line">            x = xNext</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">hashTable</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            <span class="keyword">int</span> x = nums[i] &gt;&gt; k;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">                tmp-&gt;key = x;</span><br><span class="line">                HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x_next ^ (nums[i] &gt;&gt; k);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = x_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = x_next - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h1><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie* left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            Add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = Math.Max(x, Check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Add(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (cur.left == null) &#123;</span><br><span class="line">                    cur.left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (cur.right == null) &#123;</span><br><span class="line">                    cur.right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Check(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur.right != null) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur.left != null) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    public Trie left = null;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    public Trie right = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 左子树指向表示 0 的子节点</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 右子树指向表示 1 的子节点</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 字典树的根节点</span></span><br><span class="line">        root = Trie()</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num: int)</span>:</span></span><br><span class="line">            cur = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                        cur.left = Trie()</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                        cur.right = Trie()</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(num: int)</span> -&gt; int:</span></span><br><span class="line">            cur = root</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highBit = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.left == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.left = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.right == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.right = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">check</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    root := &amp;trie&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        root.add(nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = max(x, root.check(nums[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Trie* <span class="title">createTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">ret</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trie</span>));</span></span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                cur-&gt;left = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                cur-&gt;right = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">root</span> = <span class="title">createTrie</span>();</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        add(root, nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = fmax(x, check(root, nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>421. 数组中两个数的最大异或值</title>
    <link href="http://yoursite.com/2021/12/10/421.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/"/>
    <id>http://yoursite.com/2021/12/10/421. 数组中两个数的最大异或值/</id>
    <published>2021-12-10T10:12:12.000Z</published>
    <updated>2021-12-12T01:53:09.707Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p><p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p><p>示例 1：</p><pre><code>输入：nums = [3,10,5,25,2,8]输出：28解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [2,4]输出：6</code></pre><p>示例 4：</p><pre><code>输入：nums = [8,10,2]输出：10</code></pre><p>示例 5：</p><pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]输出：127</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2 * 1040 &lt;= nums[i] &lt;= 231 - 1</code></pre><h1 id="方法一：哈希表-1"><a href="#方法一：哈希表-1" class="headerlink" title="方法一：哈希表^1"></a>方法一：哈希表<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>假设我们已经确定了 <em>x</em> 最高的若干个二进制位，当前正在确定第 <em>k</em> 个二进制位。根据「前言」部分的分析，我们希望第 <em>k</em> 个二进制位能够取到 <em>1</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.insert(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.count(x_next ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = x_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = xNext - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            ISet&lt;int&gt; seen = new HashSet&lt;int&gt;();</span><br><span class="line">            // 将所有的 pre^k(a_j) 放入哈希表中</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                // 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br><span class="line">                // 只需将其右移 k 位</span><br><span class="line">                seen.Add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br><span class="line">            // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br><span class="line">            int xNext = x * 2 + 1;</span><br><span class="line">            bool found = false;</span><br><span class="line">            </span><br><span class="line">            // 枚举 i</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                if (seen.Contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br><span class="line">                // 即为 x = x*2</span><br><span class="line">                x = xNext - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            seen = set()</span><br><span class="line">            <span class="comment"># 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment"># 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment"># 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            x_next = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x_next ^ (num &gt;&gt; k) <span class="keyword">in</span> seen:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                x = x_next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment"># 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaximumXOR = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen.add(num &gt;&gt; k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">const</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.has(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = xNext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> highBit = <span class="number">30</span> <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">for</span> k := highBit; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        seen := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen[num&gt;&gt;k] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        xNext := x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found &#123;</span><br><span class="line">            x = xNext</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">hashTable</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            <span class="keyword">int</span> x = nums[i] &gt;&gt; k;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">                tmp-&gt;key = x;</span><br><span class="line">                HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x_next ^ (nums[i] &gt;&gt; k);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = x_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = x_next - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h1><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie* left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            Add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = Math.Max(x, Check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Add(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (cur.left == null) &#123;</span><br><span class="line">                    cur.left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (cur.right == null) &#123;</span><br><span class="line">                    cur.right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Check(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur.right != null) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur.left != null) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    public Trie left = null;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    public Trie right = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 左子树指向表示 0 的子节点</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 右子树指向表示 1 的子节点</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 字典树的根节点</span></span><br><span class="line">        root = Trie()</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num: int)</span>:</span></span><br><span class="line">            cur = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                        cur.left = Trie()</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                        cur.right = Trie()</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(num: int)</span> -&gt; int:</span></span><br><span class="line">            cur = root</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highBit = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.left == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.left = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.right == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.right = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">check</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    root := &amp;trie&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        root.add(nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = max(x, root.check(nums[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Trie* <span class="title">createTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">ret</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trie</span>));</span></span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                cur-&gt;left = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                cur-&gt;right = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">root</span> = <span class="title">createTrie</span>();</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        add(root, nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = fmax(x, check(root, nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
</feed>
