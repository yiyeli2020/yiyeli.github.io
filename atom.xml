<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-21T13:40:00.066Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>518. 零钱兑换 II</title>
    <link href="http://yoursite.com/2021/12/21/518.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II/"/>
    <id>http://yoursite.com/2021/12/21/518. 零钱兑换 II/</id>
    <published>2021-12-21T12:51:12.000Z</published>
    <updated>2021-12-21T13:40:00.066Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><a id="more"></a><p>[TOC]</p><p>假设每一种面额的硬币有无限个。<br>题目数据保证结果符合 32 位带符号整数。</p><p>示例 1：</p><pre><code>输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><p>示例 2：</p><pre><code>输入：amount = 3, coins = [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。</code></pre><p>示例 3：</p><pre><code>输入：amount = 10, coins = [10] 输出：1</code></pre><p>提示：</p><pre><code>1 &lt;= coins.length &lt;= 3001 &lt;= coins[i] &lt;= 5000coins 中的所有值 互不相同0 &lt;= amount &lt;= 5000</code></pre><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Change(int amount, int[] coins) &#123;</span><br><span class="line">        int[] dp = new int[amount + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        foreach (int coin in coins) &#123;</span><br><span class="line">            for (int i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> change = <span class="function"><span class="keyword">function</span>(<span class="params">amount, coins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] += dp[i - coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="keyword">int</span>, coins []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        <span class="keyword">for</span> i := coin; i &lt;= amount; i++ &#123;</span><br><span class="line">            dp[i] += dp[i-coin]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>* coins, <span class="keyword">int</span> coinsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coinsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。&lt;/p&gt;
&lt;p&gt;请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 17. 打印从1到最大的n位数</title>
    <link href="http://yoursite.com/2021/12/21/%E5%89%91%E6%8C%87%20Offer%2017.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/21/剑指 Offer 17. 打印从1到最大的n位数/</id>
    <published>2021-12-21T12:15:12.000Z</published>
    <updated>2021-12-22T06:53:17.531Z</updated>
    
    <content type="html"><![CDATA[<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: n = 1输出: [1,2,3,4,5,6,7,8,9]</code></pre><p>说明：</p><pre><code>用返回一个整数列表来代替打印n 为正整数</code></pre><h1 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路：^1"></a>解题思路：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/" target="_blank" rel="noopener">^1</a></h1><p>题目要求打印 “从 <em>1</em> 至最大的 <em>n</em> 位数的列表” ，因此需考虑以下两个问题：</p><ol><li><strong>最大的 <em>n</em> 位数（记为 <em>end</em> ）和位数 <em>n</em> 的关系：</strong> 例如最大的 <em>1</em> 位数是 <em>9</em> ，最大的 <em>2</em> 位数是 <em>99</em> ，最大的 <em>3</em> 位数是 <em>999</em> 。则可推出公式：</li></ol><pre><code>end = 10^n - 1</code></pre><ol start="2"><li><strong>大数越界问题：</strong> 当 <em>n</em> 较大时，<em>end</em> 会超出 <em>int32</em> 整型的取值范围，超出取值范围的数字无法正常存储。但由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，因此不考虑大数越界问题。</li></ol><p>因此，只需定义区间 <em>[1, 10^n - 1]</em> 和步长 <em>1</em> ，通过 <em>for</em> 循环生成结果列表 <em>res</em> 并返回即可。</p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(10^n)</em> ：</strong> 生成长度为 <em>10^n</em> 的列表需使用 <em>O(10^n)</em> 时间。</li><li><strong>空间复杂度 <em>O(1)</em> ：</strong> 建立列表需使用 <em>O(1)</em> 大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span> ** n):</span><br><span class="line">            res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> end = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[end];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">            res[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>利用 Python 的语言特性，可以简化代码：先使用 <code>range()</code> 方法生成可迭代对象，再使用 <code>list()</code> 方法转化为列表并返回即可。</p><details>    <summary>Python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> list(range(<span class="number">1</span>, <span class="number">10</span> ** n))</span><br></pre></td></tr></table></figure></details><h1 id="大数打印解法："><a href="#大数打印解法：" class="headerlink" title="大数打印解法："></a>大数打印解法：</h1><p>实际上，本题的主要考点是大数越界情况下的打印。需要解决以下三个问题：</p><h2 id="1-表示大数的变量类型："><a href="#1-表示大数的变量类型：" class="headerlink" title="1. 表示大数的变量类型："></a>1. 表示大数的变量类型：</h2><ul><li>无论是 short / int / long … 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</li></ul><h2 id="2-生成数字的字符串集："><a href="#2-生成数字的字符串集：" class="headerlink" title="2. 生成数字的字符串集："></a>2. 生成数字的字符串集：</h2><ul><li><p>使用 int 类型时，每轮可通过 <em>+1</em> 生成下个数字，而此方法无法应用至 String 类型。并且， String 类型的数字的进位操作效率较低，例如 <code>&quot;9999&quot;</code> 至 <code>&quot;10000&quot;</code> 需要从个位到千位循环判断，进位 4 次。</p></li><li><p>观察可知，生成的列表实际上是 <em>n</em> 位 <em>0</em> - <em>9</em> 的 <strong>全排列</strong> ，因此可避开进位操作，通过递归生成数字的 String 列表。</p></li></ul><h2 id="3-递归生成全排列："><a href="#3-递归生成全排列：" class="headerlink" title="3. 递归生成全排列："></a>3. 递归生成全排列：</h2><ul><li>基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。例如当 <em>n = 2</em> 时（数字范围 <em>1 - 99</em> ），固定十位为 <em>0</em> - <em>9</em> ，按顺序依次开启递归，固定个位 <em>0</em> - <em>9</em> ，终止递归并添加数字字符串。</li></ul><p><a href="https://pic.leetcode-cn.com/83f4b5930ddc1d42b05c724ea2950ee7f00427b11150c86b45bd88405f8c7c87-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><p>根据以上方法，可初步编写全排列代码：</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; [int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n: <span class="comment"># 终止条件：已固定完所有位</span></span><br><span class="line">                res.append(<span class="string">''</span>.join(num)) <span class="comment"># 拼接 num 并添加至 res 尾部</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># 遍历 0 - 9</span></span><br><span class="line">                num[x] = str(i) <span class="comment"># 固定第 x 位为 i</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位</span></span><br><span class="line">        </span><br><span class="line">        num = [<span class="string">'0'</span>] * n <span class="comment"># 起始数字定义为 n 个 0 组成的字符列表</span></span><br><span class="line">        res = [] <span class="comment"># 数字字符串列表</span></span><br><span class="line">        dfs(<span class="number">0</span>) <span class="comment"># 开启全排列递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join(res)  <span class="comment"># 拼接所有数字字符串，使用逗号隔开，并返回</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary> </details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    StringBuilder res;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, n;</span><br><span class="line">    <span class="keyword">char</span>[] num, loop = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 数字字符串集</span></span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">char</span>[n]; <span class="comment">// 定义长度为 n 的字符列表</span></span><br><span class="line">        dfs(<span class="number">0</span>); <span class="comment">// 开启全排列递归</span></span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>); <span class="comment">// 删除最后多余的逗号</span></span><br><span class="line">        <span class="keyword">return</span> res.toString(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123; <span class="comment">// 终止条件：已固定完所有位</span></span><br><span class="line">            res.append(String.valueOf(num) + <span class="string">","</span>); <span class="comment">// 拼接 num 并添加至 res 尾部，使用逗号隔开</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : loop) &#123; <span class="comment">// 遍历 ‘0‘ - ’9‘</span></span><br><span class="line">            num[x] = i; <span class="comment">// 固定第 x 位为 i</span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>在此方法下，各数字字符串被逗号隔开，共同组成长字符串。返回的数字集字符串如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入：n</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"><span class="string">输出："0,1,2,3,4,5,6,7,8,9"</span></span><br><span class="line"></span><br><span class="line"><span class="string">输入：n</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">输出："00,01,02,...,10,11,12,...,97,98,99"</span></span><br><span class="line"></span><br><span class="line"><span class="string">输入：n</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="string">输出："000,001,002,...,100,101,102,...,997,998,999"</span></span><br></pre></td></tr></table></figure><p>观察可知，当前的生成方法仍有以下问题：</p><ol><li>诸如00,01,02,…  应显示为0,1,2,… ，即应 <strong>删除高位多余的 <em>0</em></strong> ;</li><li>此方法从 <em>0</em> 开始生成，而题目要求 <strong>列表从 <em>1</em> 开始</strong> ；</li></ol><p>以上两个问题的解决方法如下：</p><h2 id="1-删除高位多余的-0-："><a href="#1-删除高位多余的-0-：" class="headerlink" title="1. 删除高位多余的 0 ："></a>1. 删除高位多余的 <em>0</em> ：</h2><ul><li><p><strong>字符串左边界定义：</strong> 声明变量 <em>start</em> 规定字符串的左边界，以保证添加的数字字符串 <code>num[start:]</code> 中无高位多余的 <em>0</em> 。例如当 <em>n = 2</em> 时， <em>1 - 9</em> 时 <em>start = 1</em> ， <em>10 - 99</em> 时 <em>start = 0</em> 。</p></li><li><p><strong>左边界 <em>start</em> 变化规律：</strong> 观察可知，当输出数字的所有位都是 <em>9</em> 时，则下个数字需要向更高位进 <em>1</em> ，此时左边界 <em>start</em> 需要减 <em>1</em> （即高位多余的 <em>0</em> 减少一个）。例如当 <em>n = 3</em> （数字范围 <em>1 - 999</em> ）时，左边界 <em>start</em> 需要减 <em>1</em> 的情况有： “009” 进位至 “010” ， “099” 进位至 “100” 。设数字各位中 <em>9</em> 的数量为 <em>nine</em> ，所有位都为 <em>9</em> 的判断条件可用以下公式表示：</p></li></ul><pre><code>n - start = nine</code></pre><ul><li><strong>统计 <em>nine</em> 的方法：</strong> 固定第 <em>x</em> 位时，当 <em>i = 9</em> 则执行 <em>nine = nine + 1</em> ，并在回溯前恢复 <em>nine = nine - 1</em> 。</li></ul><h2 id="2-列表从-1-开始："><a href="#2-列表从-1-开始：" class="headerlink" title="2. 列表从 1 开始："></a>2. 列表从 <em>1</em> 开始：</h2><ul><li>在以上方法的基础上，添加数字字符串前判断其是否为 <code>&quot;0&quot;</code> ，若为 <code>&quot;0&quot;</code> 则直接跳过。</li></ul><h2 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(10^n)</em> ：</strong> 递归的生成的排列的数量为 <em>10^n</em> 。</li><li><strong>空间复杂度 <em>O(10^n)</em> ：</strong> 结果列表 <em>res</em> 的长度为 <em>10^n - 1</em> ，各数字字符串的长度区间为 <em>1, 2, …, n</em> ，因此占用 <em>O(10^n)</em> 大小的额外空间。</li></ul><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><p>为 <strong>正确表示大数</strong> ，以下代码的返回值为数字字符串集拼接而成的长字符串。</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; [int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n:</span><br><span class="line">                s = <span class="string">''</span>.join(num[self.start:])</span><br><span class="line">                <span class="keyword">if</span> s != <span class="string">'0'</span>: res.append(s)</span><br><span class="line">                <span class="keyword">if</span> n - self.start == self.nine: self.start -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">9</span>: self.nine += <span class="number">1</span></span><br><span class="line">                num[x] = str(i)</span><br><span class="line">                dfs(x + <span class="number">1</span>)</span><br><span class="line">            self.nine -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        num, res = [<span class="string">'0'</span>] * n, []</span><br><span class="line">        self.nine = <span class="number">0</span></span><br><span class="line">        self.start = n - <span class="number">1</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join(res)</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    StringBuilder res;</span><br><span class="line">    <span class="keyword">int</span> nine = <span class="number">0</span>, count = <span class="number">0</span>, start, n;</span><br><span class="line">    <span class="keyword">char</span>[] num, loop = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123;</span><br><span class="line">            String s = String.valueOf(num).substring(start);</span><br><span class="line">            <span class="keyword">if</span>(!s.equals(<span class="string">"0"</span>)) res.append(s + <span class="string">","</span>);</span><br><span class="line">            <span class="keyword">if</span>(n - start == nine) start--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : loop) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">'9'</span>) nine++;</span><br><span class="line">            num[x] = i;</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nine--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>本题要求输出 int 类型数组。为 <strong>运行通过</strong> ，可在添加数字字符串 <em>s</em> 前，将其转化为 int 类型。代码如下所示：</p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; [int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n:</span><br><span class="line">                s = <span class="string">''</span>.join(num[self.start:])</span><br><span class="line">                <span class="keyword">if</span> s != <span class="string">'0'</span>: res.append(int(s))</span><br><span class="line">                <span class="keyword">if</span> n - self.start == self.nine: self.start -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">9</span>: self.nine += <span class="number">1</span></span><br><span class="line">                num[x] = str(i)</span><br><span class="line">                dfs(x + <span class="number">1</span>)</span><br><span class="line">            self.nine -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        num, res = [<span class="string">'0'</span>] * n, []</span><br><span class="line">        self.nine = <span class="number">0</span></span><br><span class="line">        self.start = n - <span class="number">1</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res;</span><br><span class="line">    <span class="keyword">int</span> nine = <span class="number">0</span>, count = <span class="number">0</span>, start, n;</span><br><span class="line">    <span class="keyword">char</span>[] num, loop = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123;</span><br><span class="line">            String s = String.valueOf(num).substring(start);</span><br><span class="line">            <span class="keyword">if</span>(!s.equals(<span class="string">"0"</span>)) res[count++] = Integer.parseInt(s);</span><br><span class="line">            <span class="keyword">if</span>(n - start == nine) start--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : loop) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">'9'</span>) nine++;</span><br><span class="line">            num[x] = i;</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nine--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>2104. 子数组范围和</title>
    <link href="http://yoursite.com/2021/12/19/2104.%20%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/"/>
    <id>http://yoursite.com/2021/12/19/2104. 子数组范围和/</id>
    <published>2021-12-19T02:30:12.000Z</published>
    <updated>2021-12-19T02:51:25.617Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。</p><p>返回 nums 中 所有 子数组范围的 和 。</p><a id="more"></a><p>[TOC]</p><p><strong>子数组是数组中一个连续 非空 的元素序列。</strong></p><p>示例 1：</p><pre><code>输入：nums = [1,2,3]输出：4解释：nums 的 6 个子数组如下所示：[1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0[3]，范围 = 3 - 3 = 0[1,2]，范围 = 2 - 1 = 1[2,3]，范围 = 3 - 2 = 1[1,2,3]，范围 = 3 - 1 = 2所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,3,3]输出：4解释：nums 的 6 个子数组如下所示：[1]，范围 = 最大 - 最小 = 1 - 1 = 0[3]，范围 = 3 - 3 = 0[3]，范围 = 3 - 3 = 0[1,3]，范围 = 3 - 1 = 2[3,3]，范围 = 3 - 3 = 0[1,3,3]，范围 = 3 - 1 = 2所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4</code></pre><p>示例 3：</p><pre><code>输入：nums = [4,-2,-3,4,1]输出：59解释：nums 中所有子数组范围的和是 59</code></pre><p>提示：</p><p>1 &lt;= nums.length &lt;= 1000<br>-109 &lt;= nums[i] &lt;= 109</p><p>进阶：你可以设计一种时间复杂度为 O(n) 的解决方案吗？</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1、一个很自然的思路就是枚举每一个子数组，找到子数组的最小值、最大值，然后求范围之和。这样做复杂度至少是O(n^2)。  </p><p>2、要找到一个O(n)复杂度的方法，只能依次考虑每一个数字。当出现数字nums[j]时，它对范围之和有什么影响呢？这样问题就变为了nums[j]可能是哪些子数组的最大值、最小值呢？沿着这个思路，我们发现，假设nums[i]…nums[j]…nums[k]，nums[i]是nums[j]左边第一个大于nums[j]的数，nums[k]是nums[j]右边第一个大于nums[j]的数，那么显然区间nums(i,k)之间的最大值是nums[j]，这就意味着该区间内所有包含nums[j]的子数组的最大值都是nums[j]；而任何一个包含nums[i]或者nums[k]的子数组的最大值都不可能是nums[j]。这样nums[j]作为最大值，贡献的范围之和就是区间nums(i,k)包含nums[j]的子数组个数 * nums[j]，而这个子数组个数 = (j - i) * (k - j)。  </p><p>3、同样的思路，我们可以找到nums[j]作为最小值，对范围之和的贡献。我们遍历所有的nums[j]，加上它作为最大值的贡献，减去它作为最小值的贡献，这样就可以求出范围之和了。  </p><p>4、那么如何求得nums[j]左右两边第一个大于它的数呢？这是一个典型的单调栈问题，我们正向遍历数组，维护一个单调递增栈和一个单调递减栈，单调递增栈的栈顶元素就是左边第一个小于nums[j]的元素，单调递减栈的栈顶元素就是左边第一个大于nums[j]的元素。同样的方法，反向遍历数组，即可求得nums[j]右边第一个大于、小于它的元素。  </p><p>5、注意一个细节问题，当有相同num出现时，如果是正向遍历，那么不应该继续弹出栈顶元素，因为在一个子数组中相同的两个数只有第一个会被认为是最大值、最小值，所以后来的第二个没有办法取代第一个。而反向遍历时恰恰相反，后来的第二个数在原数组的前面位置，它应该取代第一个数，所以需要继续弹出栈顶元素。  </p><h2 id="复杂度问题"><a href="#复杂度问题" class="headerlink" title="复杂度问题"></a>复杂度问题</h2><p>时间复杂度：O(n)，单调栈和后续的求范围之和，都只需要遍历一次数组。  </p><p>空间复杂度：O(n)，需要保存每个数左右两边第一个大于、小于自己的数的位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">subArrayRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, size = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftLess(size), leftGreater(size), rightLess(size), rightGreater(size);</span><br><span class="line"></span><br><span class="line">        getLeft(nums, leftLess, leftGreater);</span><br><span class="line">        getRight(nums, rightLess, rightGreater);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            sum += (nums[i] * ((<span class="keyword">long</span> <span class="keyword">long</span>)i - leftGreater[i]) * ((<span class="keyword">long</span> <span class="keyword">long</span>)rightGreater[i] - i));</span><br><span class="line">            sum -= (nums[i] * ((<span class="keyword">long</span> <span class="keyword">long</span>)i - leftLess[i]) * ((<span class="keyword">long</span> <span class="keyword">long</span>)rightLess[i] - i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getLeft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; leftLess, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; leftGreater)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, size = nums.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; increasing, decreasing;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!increasing.empty() &amp;&amp; nums[increasing.top()] &gt; nums[i]) &#123;</span><br><span class="line">                increasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftLess[i] = increasing.empty() ? <span class="number">-1</span> : increasing.top();</span><br><span class="line">            increasing.push(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!decreasing.empty() &amp;&amp; nums[decreasing.top()] &lt; nums[i]) &#123;</span><br><span class="line">                decreasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftGreater[i] = decreasing.empty() ? <span class="number">-1</span> : decreasing.top();</span><br><span class="line">            decreasing.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rightLess, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rightGreater)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, size = nums.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; increasing, decreasing;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!increasing.empty() &amp;&amp; nums[increasing.top()] &gt;= nums[i]) &#123;</span><br><span class="line">                increasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rightLess[i] = increasing.empty() ? size : increasing.top();</span><br><span class="line">            increasing.push(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!decreasing.empty() &amp;&amp; nums[decreasing.top()] &lt;= nums[i]) &#123;</span><br><span class="line">                decreasing.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rightGreater[i] = decreasing.empty() ? size : decreasing.top();</span><br><span class="line">            decreasing.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。&lt;/p&gt;
&lt;p&gt;返回 nums 中 所有 子数组范围的 和 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>2103. 环和杆</title>
    <link href="http://yoursite.com/2021/12/19/2103.%20%E7%8E%AF%E5%92%8C%E6%9D%86/"/>
    <id>http://yoursite.com/2021/12/19/2103. 环和杆/</id>
    <published>2021-12-19T02:30:12.000Z</published>
    <updated>2021-12-19T02:31:37.502Z</updated>
    
    <content type="html"><![CDATA[<p>找出所有集齐全部三种颜色环的杆，并返回这种杆的数量。</p><a id="more"></a><p>[TOC]</p><p>总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 0 到 9 的杆上。</p><p>给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：</p><p>第 i 对中的 第一个 字符表示第 i 个环的 颜色（’R’、’G’、’B’）。<br>第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（’0’ 到 ‘9’）。<br>例如，”R3G2B1” 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p><p>找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。</p><p>示例 1：</p><pre><code>输入：rings = &quot;B0B6G0R6R0R6G9&quot;输出：1解释：- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。- 编号 9 的杆上只有 1 个绿色环。因此，集齐全部三种颜色环的杆的数目为 1 。</code></pre><p>示例 2：</p><pre><code>输入：rings = &quot;B0R0G0R9R0B0G0&quot;输出：1解释：- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。- 编号 9 的杆上只有 1 个红色环。因此，集齐全部三种颜色环的杆的数目为 1 。</code></pre><p>示例 3：</p><pre><code>输入：rings = &quot;G4&quot;输出：0解释：只给了一个环，因此，不存在集齐全部三种颜色环的杆。</code></pre><p>提示：</p><pre><code>rings.length == 2 * n1 &lt;= n &lt;= 100如 i 是 偶数 ，则 rings[i] 的值可以取 &apos;R&apos;、&apos;G&apos; 或 &apos;B&apos;（下标从 0 开始计数）如 i 是 奇数 ，则 rings[i] 的值可以取 &apos;0&apos; 到 &apos;9&apos; 中的一个数字（下标从 0 开始计数）</code></pre><h1 id="方法一：维护每根杆的状态"><a href="#方法一：维护每根杆的状态" class="headerlink" title="方法一：维护每根杆的状态"></a>方法一：维护每根杆的状态</h1><p><strong>思路与算法</strong></p><p>我们可以遍历字符串的每个颜色位置对，来模拟套环的过程。</p><p>对于每一个环，由于我们只关心它上面有哪些颜色的环，而不在意具体的数量；同时是否有某一种颜色的环的状态相互独立，因此我们可以用一个 <em>3</em> 二进制位的整数来表示每个环的状态。具体地，<strong>从低到高</strong>第一位表示是否有红色的环，第二位表示是否有蓝色的环，第三位表示是否有绿色的环；每一位为 <em>1</em> 则代表当前杆上有对应颜色的环，为 <em>0</em> 则代表没有。当套上某种颜色的环后，无论该二进制位之前取值如何，新的取值一定为 <em>1</em>，这等价于对应二进制位<strong>对 <em>1</em> 取或</strong>的操作。</p><p>我们可以用一个长度为 <em>10</em> 的状态数组来表示每个环的状态，数组下标即为杆的编号。在模拟开始前，所有环的状态对应的整数均为 <em>0</em>。在遍历到每个颜色位置对时，我们首先看第二个字符寻找出对应的下标，同时根据环的颜色对状态值的对应二进制位<strong>对 <em>1</em> 取或</strong>。当遍历完成后，我们遍历状态数组，统计状态值为 <em>(111)_2 = 7</em> （代表对应杆上有三种颜色的环）的个数，并返回该个数作为答案。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPoints</span><span class="params">(<span class="built_in">string</span> rings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; status(<span class="number">10</span>);   <span class="comment">// 状态数组</span></span><br><span class="line">        <span class="comment">// 遍历颜色位置对维护状态数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = rings[i+<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (rings[i] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                status[idx] |= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rings[i] == <span class="string">'G'</span>) &#123;</span><br><span class="line">                status[idx] |= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                status[idx] |= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计集齐三色环的杆的数量</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status[i] == <span class="number">7</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPoints</span><span class="params">(self, rings: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(rings)</span><br><span class="line">        status = [<span class="number">0</span>] * <span class="number">10</span>   <span class="comment"># 状态数组</span></span><br><span class="line">        <span class="comment"># 遍历颜色位置对维护状态数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n, <span class="number">2</span>):</span><br><span class="line">            idx = int(rings[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> rings[i] == <span class="string">'R'</span>:</span><br><span class="line">                status[idx] |= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> rings[i] == <span class="string">'G'</span>:</span><br><span class="line">                status[idx] |= <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                status[idx] |= <span class="number">4</span></span><br><span class="line">        <span class="comment"># 统计集齐三色环的杆的数量</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> status[i] == <span class="number">7</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + k)*，其中 *n</em> 为rings 的长度，<em>k</em> 为杆的数量。初始化杆状态数组与统计数量的时间复杂度为 <em>O(k)</em>，遍历字符串的时间复杂度为 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(k)</em>，即为状态数组的空间开销。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找出所有集齐全部三种颜色环的杆，并返回这种杆的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习笔记（线程，JVM，垃圾回收，引用，IO，类加载）</title>
    <link href="http://yoursite.com/2021/12/17/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%8CJVM%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%BC%95%E7%94%A8%EF%BC%8CIO%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/17/JVM学习笔记（线程，JVM，垃圾回收，引用，IO，类加载）/</id>
    <published>2021-12-17T12:30:12.000Z</published>
    <updated>2021-12-19T13:14:00.787Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、<br>一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接<br>的交互。</p><a id="more"></a><p>[TOC]</p><h1 id="基本概念：-1"><a href="#基本概念：-1" class="headerlink" title="基本概念：^1"></a>基本概念：<a href="[深入理解Java虚拟机：JVM高级特性与最佳实践](https://weread.qq.com/web/reader/9b832f305933f09b86bd2a9kecc32f3013eccbc87e4b62e)">^1</a></h1><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、<br>一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接<br>的交互。</p><p>我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，<br>而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。<br>也就是如下：</p><p>① Java 源文件—-&gt;编译器—-&gt;字节码文件</p><p>② 字节码文件—-&gt;JVM—-&gt;机器码</p><p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够<br>跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会<br>存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不<br>能共享。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。<br>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓<br>冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。<br>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可<br>用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时会释放原生线程和 Java 线程的所有资源。</p><p>Hotspot JVM 后台运行的系统线程主要有下面几个：</p><table><thead><tr><th>线程</th><th>详情</th></tr></thead><tbody><tr><td>虚拟机线程（VM thread）</td><td>这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈dump、线程暂停、线程偏向锁（biased locking）解除。</td></tr><tr><td>周期性任务线程</td><td>这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</td></tr><tr><td>GC 线程</td><td>这些线程支持JVM中不同的垃圾回收活动</td></tr><tr><td>编译器线程</td><td>这些线程在运行时将字节码动态编译成本地平台相关的机器码。</td></tr><tr><td>信号分发线程</td><td>这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理</td></tr></tbody></table><h2 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h2><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。</p><p>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内,每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</p><p>线程共享区域随虚拟机的启动/关闭而创建/销毁。<br>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提<br>供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在Java堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p><h3 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h3><p>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的<br>程序计数器，这类内存也称为“线程私有”的内存。<br>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如<br>果还是 Native 方法，则为空。<br>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。</p><h3 id="虚拟机栈-线程私有"><a href="#虚拟机栈-线程私有" class="headerlink" title="虚拟机栈(线程私有)"></a>虚拟机栈(线程私有)</h3><p>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）<br>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成<br>的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接<br>(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异<br>常）都算作方法结束。</p><h3 id="本地方法区-线程私有"><a href="#本地方法区-线程私有" class="headerlink" title="本地方法区(线程私有)"></a>本地方法区(线程私有)</h3><p>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为<br>Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个<br>C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。</p><h3 id="堆（Heap-线程共享）-运行时数据区"><a href="#堆（Heap-线程共享）-运行时数据区" class="headerlink" title="堆（Heap-线程共享）-运行时数据区"></a>堆（Heap-线程共享）-运行时数据区</h3><p>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行<br>垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以<br>细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。</p><h3 id="方法区-永久代（线程共享）"><a href="#方法区-永久代（线程共享）" class="headerlink" title="方法区/永久代（线程共享）"></a>方法区/永久代（线程共享）</h3><p>即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静<br>态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java<br>堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,<br>而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型<br>的卸载, 因此收益一般很小)。<br>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版<br>本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加<br>载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量<br>池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会<br>被虚拟机认可、装载和执行。</p><h2 id="JVM-运行时内存"><a href="#JVM-运行时内存" class="headerlink" title="JVM 运行时内存"></a>JVM 运行时内存</h2><p>Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年<br>代。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发<br>MinorGC 进行垃圾回收。新生代又分为 Eden 区、SurvivorFrom、SurvivorTo 三个区。</p><h4 id="Eden-区"><a href="#Eden-区" class="headerlink" title="Eden 区"></a>Eden 区</h4><p>Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老<br>年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行<br>一次垃圾回收。</p><h4 id="From-Survivor"><a href="#From-Survivor" class="headerlink" title="From Survivor"></a>From Survivor</h4><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p><h4 id="To-Survivor"><a href="#To-Survivor" class="headerlink" title="To Survivor"></a>To Survivor</h4><p>保留了一次 MinorGC 过程中的幸存者。</p><h4 id="MinorGC-的过程（复制-gt-清空-gt-互换）"><a href="#MinorGC-的过程（复制-gt-清空-gt-互换）" class="headerlink" title="MinorGC 的过程（复制-&gt;清空-&gt;互换）"></a>MinorGC 的过程（复制-&gt;清空-&gt;互换）</h4><p>MinorGC 采用复制算法。</p><p>1：eden、From Survivor 复制到 To Survivor，年龄+1</p><p>首先，把 Eden 和 From Survivor 区域中存活的对象复制到 To Survivor 区域（如果有对象的年<br>龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 To Survivor 不<br>够位置了就放到老年区）；</p><p>2：清空 eden、From Survivor</p><p>然后，清空 Eden 和 From Survivor 中的对象；</p><p>3：To Survivor 和 From Survivor 互换</p><p>最后，To Survivor 和 From Survivor 互换，原 To Survivor 成为下一次 GC 时的 From Survivor<br>区。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>主要存放应用程序中生命周期长的内存对象。</p><p> 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行<br>了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足<br>够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p><p> MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没<br>有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减<br>少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的<br>时候，就会抛出 OOM（Out of Memory）异常。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被<br>放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这<br>也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p><h4 id="JAVA8-与元数据"><a href="#JAVA8-与元数据" class="headerlink" title="JAVA8 与元数据"></a>JAVA8 与元数据</h4><p>在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间<br>的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用<br>本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native<br>memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由<br>MaxPermSize 控制, 而由系统的实际可用空间来控制。</p><h2 id="垃圾回收与算法"><a href="#垃圾回收与算法" class="headerlink" title="垃圾回收与算法"></a>垃圾回收与算法</h2><h3 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单<br>的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都为0，则说明对象不太可能再被用到，那么这个对象就是可回收<br>对象。</p><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p><h3 id="标记清除算法（Mark-Sweep）"><a href="#标记清除算法（Mark-Sweep）" class="headerlink" title="标记清除算法（Mark-Sweep）"></a>标记清除算法（Mark-Sweep）</h3><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清<br>除阶段回收被标记的对象所占用的空间。如</p><p>该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</p><h3 id="复制算法（copying）"><a href="#复制算法（copying）" class="headerlink" title="复制算法（copying）"></a>复制算法（copying）</h3><p>为了解决 Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉<br>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原<br>本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。</p><h3 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark-Compact)"></a>标记整理算法(Mark-Compact)</h3><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清<br>理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><h4 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h4><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><h4 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h4><p>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p><ol><li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，<br>常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li><li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。</li><li>当新生代的 Eden Space 和 From Space空间不足时就会发生一次 GC，进行 GC 后，Eden<br>Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space进行清理。</li><li>如果 To Space无法足够存储某个对象，则将这个对象存储到老生代。</li><li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li><li>当对象在 Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</li><li></li></ol><h2 id="JAVA-四种引用类型"><a href="#JAVA-四种引用类型" class="headerlink" title="JAVA 四种引用类型"></a>JAVA 四种引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引<br>用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即<br>使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之<br>一。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用需要用 SoftReference类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用需要用 WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用需要 PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</p><h2 id="GC-分代收集算法-VS-分区收集算法"><a href="#GC-分代收集算法-VS-分区收集算法" class="headerlink" title="GC 分代收集算法 VS 分区收集算法"></a>GC 分代收集算法 VS 分区收集算法</h2><h3 id="分代收集算法-1"><a href="#分代收集算法-1" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法,这种算法会根据对象存活周期的不同将内存划分为几块,如JVM中的新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法</p><h4 id="在新生代-复制算法"><a href="#在新生代-复制算法" class="headerlink" title="在新生代-复制算法"></a>在新生代-复制算法</h4><p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法,只需要付出少量存活对象的复制成本就可以完成收集.</p><h4 id="在老年代-标记整理算法"><a href="#在老年代-标记整理算法" class="headerlink" title="在老年代-标记整理算法"></a>在老年代-标记整理算法</h4><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.</p><h3 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h3><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的<br>好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是<br>整个堆), 从而减少一次 GC 所产生的停顿。</p><h2 id="GC-垃圾收集器"><a href="#GC-垃圾收集器" class="headerlink" title="GC 垃圾收集器"></a>GC 垃圾收集器</h2><p>Java 堆内存被划分为新生代和老年代两部分，新生代主要使用复制和标记-清除垃圾回收算法；<br>老年代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和老年代分别提供了多种不<br>同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下</p><h3 id="Serial-垃圾收集器（单线程、复制算法）"><a href="#Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="Serial 垃圾收集器（单线程、复制算法）"></a>Serial 垃圾收集器（单线程、复制算法）</h3><p>Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾<br>收集器。Serial是一个单线程的收集器，它不但只会使用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。<br>Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限<br>定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial<br>垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。</p><h3 id="ParNew-垃圾收集器（Serial-多线程）"><a href="#ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="ParNew 垃圾收集器（Serial+多线程）"></a>ParNew 垃圾收集器（Serial+多线程）</h3><p>ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。ParNew收集器默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。【Parallel：平行的】ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p><h3 id="Parallel-Scavenge收集器（多线程复制算法、高效）"><a href="#Parallel-Scavenge收集器（多线程复制算法、高效）" class="headerlink" title="Parallel Scavenge收集器（多线程复制算法、高效）"></a>Parallel Scavenge收集器（多线程复制算法、高效）</h3><p>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃<br>圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码<br>的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），<br>高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而<br>不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个<br>重要区别。</p><h3 id="Serial-Old-收集器（单线程标记整理算法-）"><a href="#Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="Serial Old 收集器（单线程标记整理算法 ）"></a>Serial Old 收集器（单线程标记整理算法 ）</h3><p>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，<br>这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。<br>在 Server 模式下，主要有两个用途：</p><ol><li>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</li><li>作为年老代中使用 CMS 收集器的后备垃圾收集方案。<br>新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：</li></ol><p>新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使<br>用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel<br>Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图</p><h3 id="Parallel-Old-收集器（多线程标记整理算法）"><a href="#Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="Parallel Old 收集器（多线程标记整理算法）"></a>Parallel Old 收集器（多线程标记整理算法）</h3><p>Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6<br>才开始提供。<br>在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只<br>能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞<br>吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge<br>和年老代 Parallel Old 收集器的搭配策略。<br>新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：</p><h3 id="CMS-收集器（多线程标记清除算法）"><a href="#CMS-收集器（多线程标记清除算法）" class="headerlink" title="CMS 收集器（多线程标记清除算法）"></a>CMS 收集器（多线程标记清除算法）</h3><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾<br>回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。<br>最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。<br>CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p><h4 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h4><p>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p><h4 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h4><p>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p><h4 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h4><p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记<br>记录，仍然需要暂停所有的工作线程。</p><h4 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h4><p>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并<br>发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看<br>CMS 收集器的内存回收和用户线程是一起并发地执行。<br>CMS 收集器工作过程：</p><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收<br>集器两个最突出的改进是：</p><ol><li>基于标记-整理算法，不产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。<br>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域<br>的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾<br>最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收<br>集效率。</li></ol><h2 id="JAVA-IO-NIO"><a href="#JAVA-IO-NIO" class="headerlink" title="JAVA IO/NIO"></a>JAVA IO/NIO</h2><h3 id="阻塞-IO-模型"><a href="#阻塞-IO-模型" class="headerlink" title="阻塞 IO 模型"></a>阻塞 IO 模型</h3><p>最传统的一种 IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内<br>核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用<br>户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就<br>绪，就会一直阻塞在 read 方法。</p><h3 id="非阻塞-IO-模型"><a href="#非阻塞-IO-模型" class="headerlink" title="非阻塞 IO 模型"></a>非阻塞 IO 模型</h3><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个<br>error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备<br>好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO<br>不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：</p><pre><code>while(true){    data = socket.read();    if(data!= error){    处理数据    break;    }}</code></pre><p>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就<br>绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就<br>绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p><h3 id="多路复用-IO-模型"><a href="#多路复用-IO-模型" class="headerlink" title="多路复用 IO 模型"></a>多路复用 IO 模型</h3><p>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO<br>模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真<br>正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个<br>socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有<br>socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通<br>过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这<br>种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当<br>socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连<br>接数比较多的情况。</p><p>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态<br>时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效<br>率要比用户线程要高的多。</p><p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件<br>逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件<br>迟迟得不到处理，并且会影响新的事件轮询。</p><h3 id="信号驱动-IO-模型"><a href="#信号驱动-IO-模型" class="headerlink" title="信号驱动 IO 模型"></a>信号驱动 IO 模型</h3><p>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函<br>数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到<br>信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p><h3 id="异步-IO-模型"><a href="#异步-IO-模型" class="headerlink" title="异步 IO 模型"></a>异步 IO 模型</h3><p>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就<br>可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，<br>它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内<br>核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程<br>发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何<br>进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接<br>去使用数据了。<br>也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完<br>成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的<br>读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据<br>已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号<br>表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。<br>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。</p><h3 id="JAVA-IO-包"><a href="#JAVA-IO-包" class="headerlink" title="JAVA IO 包"></a>JAVA IO 包</h3><h3 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h3><p>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字<br>符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区<br>中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，<br>数据到达）。因此，单个线程可以监听多个数据通道。<br>NIO 和传统 IO之间第一个最大的区别是，IO是面向流的，NIO 是面向缓冲区的。</p><h4 id="NIO-的缓冲区"><a href="#NIO-的缓冲区" class="headerlink" title="NIO 的缓冲区"></a>NIO 的缓冲区</h4><p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><h4 id="NIO-的非阻塞"><a href="#NIO-的非阻塞" class="headerlink" title="NIO 的非阻塞"></a>NIO 的非阻塞</h4><p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有<br>一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，<br>使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可<br>用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个<br>等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向<br>的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有：</p><ol><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel<br>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。<br>下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。</li></ol><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p><p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送<br>数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必<br>须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。<br>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：<br>ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、<br>ShortBuffer</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事<br>件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可<br>以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用<br>函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护<br>多个线程，并且避免了多线程之间的上下文切换导致的开销。</p><h2 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h2><p>JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这<br>五个过程。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对<br>象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既<br>可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），<br>也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并<br>且不会危害虚拟机自身的安全。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使<br>用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br>public static int v = 8080;<br>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是<br>程序被编译后，存放于类构造器<client>方法之中。<br>但是注意如果声明为：</client></p><pre><code>public static final int v = 8080;</code></pre><p>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v<br>赋值为 8080。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：</p><ol><li>CONSTANT_Class_info</li><li>CONSTANT_Field_info</li><li>CONSTANT_Method_info</li></ol><p>等类型的常量。</p><h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p> 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟<br>机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引<br>用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</p><h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><p> 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有<br>了直接引用，那引用的目标必定已经在内存中存在。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载<br>器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p><h4 id="类构造器"><a href="#类构造器" class="headerlink" title="类构造器"></a>类构造器<client></client></h4><p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变<br>量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类<br>的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译<br>器可以不为这个类生成<client>()方法。<br>注意以下几种情况不会执行类初始化：</client></client></client></client></client></p><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触<br>发定义常量所在的类。</li><li>通过类名获取 Class 对象，不会触发类的初始化。</li><li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初<br>始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器：</p><h4 id="启动类加载器-Bootstrap-ClassLoader"><a href="#启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动类加载器(Bootstrap ClassLoader)"></a>启动类加载器(Bootstrap ClassLoader)</h4><ol><li>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被<br>虚拟机认可（按文件名识别，如 rt.jar）的类。</li></ol><h4 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h4><ol start="2"><li>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类<br>库。</li></ol><h4 id="应用程序类加载器-Application-ClassLoader-："><a href="#应用程序类加载器-Application-ClassLoader-：" class="headerlink" title="应用程序类加载器(Application ClassLoader)："></a>应用程序类加载器(Application ClassLoader)：</h4><ol start="3"><li>负责加载用户路径（classpath）上的类库。<br>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader<br>实现自定义的类加载器。</li></ol><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于rt.jar包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p><h3 id="OSGI（动态模型系统）"><a href="#OSGI（动态模型系统）" class="headerlink" title="OSGI（动态模型系统）"></a>OSGI（动态模型系统）</h3><p>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系<br>统的一系列规范。</p><h4 id="动态改变构造"><a href="#动态改变构造" class="headerlink" title="动态改变构造"></a>动态改变构造</h4><p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使<br>这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。</p><h4 id="模块化编程与热插拔"><a href="#模块化编程与热插拔" class="headerlink" title="模块化编程与热插拔"></a>模块化编程与热插拔</h4><p>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级<br>的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企<br>业级程序开发来说是非常具有诱惑力的特性。<br>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时<br>也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大<br>功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、&lt;br&gt;一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接&lt;br&gt;的交互。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>875. 爱吃香蕉的珂珂</title>
    <link href="http://yoursite.com/2021/12/17/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <id>http://yoursite.com/2021/12/17/875. 爱吃香蕉的珂珂/</id>
    <published>2021-12-17T11:30:12.000Z</published>
    <updated>2021-12-17T11:16:14.922Z</updated>
    
    <content type="html"><![CDATA[<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><a id="more"></a><p>[TOC]</p><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p>示例 1：</p><pre><code>输入: piles = [3,6,7,11], H = 8输出: 4</code></pre><p>示例 2：</p><pre><code>输入: piles = [30,11,23,4,20], H = 5输出: 30</code></pre><p>示例 3：</p><pre><code>输入: piles = [30,11,23,4,20], H = 6输出: 23</code></pre><p>提示：</p><pre><code>1 &lt;= piles.length &lt;= 10^4piles.length &lt;= H &lt;= 10^91 &lt;= piles[i] &lt;= 10^9</code></pre><h1 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找^1"></a>二分查找<a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/ai-chi-xiang-jiao-de-ke-ke-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路</strong></p><p>如果珂珂能以 <code>K</code> 的进食速度最终吃完所有的香蕉（在 <code>H</code> 小时内），那么她也可以用更快的速度吃完。</p><p>当珂珂能以 <code>K</code> 的进食速度吃完香蕉时，我们令 <code>possible(K)</code> 为 <code>true</code>，那么就存在 <code>X</code> 使得当 <code>K &gt;= X</code> 时， <code>possible(K) = True</code>。</p><p>举个例子，当初始条件为 <code>piles = [3, 6, 7, 11]</code> 和 <code>H = 8</code> 时，存在 <code>X = 4</code> 使得 <code>possible(1) = possible(2) = possible(3) = False</code>，且 <code>possible(4) = possible(5) = ... = True</code>。</p><p><strong>算法</strong></p><p>我们可以二分查找 <code>possible(K)</code> 的值来找到第一个使得 <code>possible(X)</code> 为 <code>True</code> 的 <code>X</code>：这将是我们的答案。我们的循环中，不变量 <code>possible(hi)</code> 总为 <code>True</code>， <code>lo</code> 总小于等于答案。有关二分查找的更多信息，请参阅<a href="https://leetcode-cn.com/explore/learn/card/binary-search/" target="_blank" rel="noopener">《力扣探索：二分查找》</a>。</p><p>为了找到 <code>possible(K)</code> 的值， (即<code>珂珂</code>是否能以 <code>K</code> 的进食速度在 <code>H</code> 小时内吃完所有的香蕉），我们模拟这一情景。对于每一堆（大小 <code>p &gt; 0</code>），我们可以推断出珂珂将在 <code>Math.ceil(p / K) = ((p-1) // K) + 1</code> 小时内吃完这一堆，我们将每一堆的完成时间加在一起并与 <code>H</code> 进行比较。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[2q2E5AzB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p - <span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[2q2E5AzB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">1_000_000_000</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p-<span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[2q2E5AzB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="comment"># Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">possible</span><span class="params">(K)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum((p<span class="number">-1</span>) / K + <span class="number">1</span> <span class="keyword">for</span> p <span class="keyword">in</span> piles) &lt;= H</span><br><span class="line"></span><br><span class="line">        lo, hi = <span class="number">1</span>, max(piles)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (lo + hi) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> possible(mi):</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 073. 狒狒吃香蕉</title>
    <link href="http://yoursite.com/2021/12/17/%E5%89%91%E6%8C%87%20Offer%20II%20073.%20%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89/"/>
    <id>http://yoursite.com/2021/12/17/剑指 Offer II 073. 狒狒吃香蕉/</id>
    <published>2021-12-17T11:30:12.000Z</published>
    <updated>2021-12-17T11:16:09.347Z</updated>
    
    <content type="html"><![CDATA[<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><a id="more"></a><p>[TOC]</p><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p>注意：本题与<a href="https://leetcode-cn.com/problems/nZZqjQ/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a>相同</p><p>示例 1：</p><pre><code>输入: piles = [3,6,7,11], H = 8输出: 4</code></pre><p>示例 2：</p><pre><code>输入: piles = [30,11,23,4,20], H = 5输出: 30</code></pre><p>示例 3：</p><pre><code>输入: piles = [30,11,23,4,20], H = 6输出: 23</code></pre><p>提示：</p><pre><code>1 &lt;= piles.length &lt;= 10^4piles.length &lt;= H &lt;= 10^91 &lt;= piles[i] &lt;= 10^9</code></pre><h1 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找^1"></a>二分查找<a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/ai-chi-xiang-jiao-de-ke-ke-by-leetcode/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路</strong></p><p>如果珂珂能以 <code>K</code> 的进食速度最终吃完所有的香蕉（在 <code>H</code> 小时内），那么她也可以用更快的速度吃完。</p><p>当珂珂能以 <code>K</code> 的进食速度吃完香蕉时，我们令 <code>possible(K)</code> 为 <code>true</code>，那么就存在 <code>X</code> 使得当 <code>K &gt;= X</code> 时， <code>possible(K) = True</code>。</p><p>举个例子，当初始条件为 <code>piles = [3, 6, 7, 11]</code> 和 <code>H = 8</code> 时，存在 <code>X = 4</code> 使得 <code>possible(1) = possible(2) = possible(3) = False</code>，且 <code>possible(4) = possible(5) = ... = True</code>。</p><p><strong>算法</strong></p><p>我们可以二分查找 <code>possible(K)</code> 的值来找到第一个使得 <code>possible(X)</code> 为 <code>True</code> 的 <code>X</code>：这将是我们的答案。我们的循环中，不变量 <code>possible(hi)</code> 总为 <code>True</code>， <code>lo</code> 总小于等于答案。有关二分查找的更多信息，请参阅<a href="https://leetcode-cn.com/explore/learn/card/binary-search/" target="_blank" rel="noopener">《力扣探索：二分查找》</a>。</p><p>为了找到 <code>possible(K)</code> 的值， (即<code>珂珂</code>是否能以 <code>K</code> 的进食速度在 <code>H</code> 小时内吃完所有的香蕉），我们模拟这一情景。对于每一堆（大小 <code>p &gt; 0</code>），我们可以推断出珂珂将在 <code>Math.ceil(p / K) = ((p-1) // K) + 1</code> 小时内吃完这一堆，我们将每一堆的完成时间加在一起并与 <code>H</code> 进行比较。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[2q2E5AzB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p - <span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[2q2E5AzB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">1_000_000_000</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!possible(piles, H, mi))</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: piles)</span><br><span class="line">            time += (p-<span class="number">1</span>) / K + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> time &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[2q2E5AzB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="comment"># Can Koko eat all bananas in H hours with eating speed K?</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">possible</span><span class="params">(K)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum((p<span class="number">-1</span>) / K + <span class="number">1</span> <span class="keyword">for</span> p <span class="keyword">in</span> piles) &lt;= H</span><br><span class="line"></span><br><span class="line">        lo, hi = <span class="number">1</span>, max(piles)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (lo + hi) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> possible(mi):</span><br><span class="line">                lo = mi + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi</span><br><span class="line">        <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>403. 青蛙过河</title>
    <link href="http://yoursite.com/2021/12/17/403.%20%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
    <id>http://yoursite.com/2021/12/17/403. 青蛙过河/</id>
    <published>2021-12-17T07:30:12.000Z</published>
    <updated>2021-12-17T10:33:56.730Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p><p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p><a id="more"></a><p>[TOC]</p><p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p><p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p>示例 1：</p><pre><code>输入：stones = [0,1,3,5,6,8,12,17]输出：true解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</code></pre><p>示例 2：</p><pre><code>输入：stones = [0,1,2,3,4,8,9,11]输出：false解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</code></pre><p>提示：</p><pre><code>2 &lt;= stones.length &lt;= 20000 &lt;= stones[i] &lt;= 231 - 1stones[0] == 0</code></pre><h1 id="方法一：记忆化搜索-二分查找-1"><a href="#方法一：记忆化搜索-二分查找-1" class="headerlink" title="方法一：记忆化搜索 + 二分查找^1"></a>方法一：记忆化搜索 + 二分查找<a href="https://leetcode-cn.com/problems/frog-jump/solution/qing-wa-guo-he-by-leetcode-solution-mbuo/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路及算法</strong></p><p>最直接的想法是使用深度优先搜索的方式尝试所有跳跃方案，直到我们找到一组可行解为止。但是不加优化的该算法的时间复杂度在最坏情况下是指数级的，因此考虑优化。</p><p>注意到当青蛙每次能够跳跃的距离仅取决于青蛙的「上一次跳跃距离」。而青蛙此后能否到达终点，只和它「现在所处的石子编号」以及「上一次跳跃距离」有关。因此我们可以将这两个维度综合记录为一个状态。使用记忆化搜索的方式优化时间复杂度。</p><p>具体地，当青蛙位于第 <em>i</em> 个石子，上次跳跃距离为 lastDis 时，它当前能够跳跃的距离范围为[lastDis-1,lastDis+1]。我们需要分别判断这三个距离对应的三个位置是否存在石子。注意到给定的石子列表为升序，所以我们可以利用二分查找来优化查找石子的时间复杂度。每次我们找到了符合要求的位置，我们就尝试进行一次递归搜索即可。</p><p>为了优化编码，我们可以认为青蛙的初始状态为：「现在所处的石子编号」为 <em>0</em>（石子从 <em>0</em> 开始编号），「上一次跳跃距离」为 <em>0</em>（这样可以保证青蛙的第一次跳跃距离为 <em>1</em>）。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; rec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> i, <span class="keyword">int</span> lastDis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == stones.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[i].count(lastDis)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[i][lastDis];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = lower_bound(stones.begin(), stones.end(), curDis + stones[i]) - stones.begin();</span><br><span class="line">                <span class="keyword">if</span> (j != stones.size() &amp;&amp; stones[j] == curDis + stones[i] &amp;&amp; dfs(stones, j, curDis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> rec[i][lastDis] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[i][lastDis] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        rec.resize(n);</span><br><span class="line">        <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean[][] rec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        rec = <span class="keyword">new</span> Boolean[n][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> i, <span class="keyword">int</span> lastDis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == stones.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[i][lastDis] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[i][lastDis];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = Arrays.binarySearch(stones, i + <span class="number">1</span>, stones.length, curDis + stones[i]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; dfs(stones, j, curDis)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> rec[i][lastDis] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[i][lastDis] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canCross = <span class="function"><span class="keyword">function</span>(<span class="params">stones</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stones.length;</span><br><span class="line">    rec = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">stones, i, lastDis</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === stones.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[i].has(lastDis)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[i].get(lastDis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> j = lower_bound(stones, curDis + stones[i]);</span><br><span class="line">                <span class="keyword">if</span> (j !== stones.length &amp;&amp; stones[j] === curDis + stones[i] &amp;&amp; dfs(stones, j, curDis)) &#123;</span><br><span class="line">                    rec[i].set(lastDis, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> rec[i].get(lastDis);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rec[i].set(lastDis, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> rec[i].get(lastDis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lower_bound</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>, hi = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="built_in">Math</span>.floor((hi - lo) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCross</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(stones)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">dfs</span> = <span class="title">func</span><span class="params">(i, lastDis <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> res, has := dp[i][lastDis]; has &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; dp[i][lastDis] = res &#125;()</span><br><span class="line">        <span class="keyword">for</span> curDis := lastDis - <span class="number">1</span>; curDis &lt;= lastDis+<span class="number">1</span>; curDis++ &#123;</span><br><span class="line">            <span class="keyword">if</span> curDis &gt; <span class="number">0</span> &#123;</span><br><span class="line">                j := sort.SearchInts(stones, curDis+stones[i])</span><br><span class="line">                <span class="keyword">if</span> j != n &amp;&amp; stones[j] == curDis+stones[i] &amp;&amp; dfs(j, curDis) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>** <span class="title">rec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count</span><span class="params">(struct HashTable** hashTable, <span class="keyword">int</span> ikey)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(*hashTable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(struct HashTable** hashTable, <span class="keyword">int</span> ikey, <span class="keyword">int</span> ival)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(*hashTable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(*hashTable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ival;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(struct HashTable** hashTable, <span class="keyword">int</span> ikey)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(*hashTable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = stonesSize;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (stones[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize, <span class="keyword">int</span> i, <span class="keyword">int</span> lastDis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == stonesSize - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count(&amp;rec[i], lastDis)) &#123;</span><br><span class="line">        <span class="keyword">return</span> query(&amp;rec[i], lastDis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curDis = lastDis - <span class="number">1</span>; curDis &lt;= lastDis + <span class="number">1</span>; curDis++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curDis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = lower_bound(stones, stonesSize, curDis + stones[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != stonesSize &amp;&amp; stones[j] == curDis + stones[i] &amp;&amp; dfs(stones, stonesSize, j, curDis)) &#123;</span><br><span class="line">                <span class="keyword">return</span> modify(&amp;rec[i], lastDis, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modify(&amp;rec[i], lastDis, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize)</span> </span>&#123;</span><br><span class="line">    rec = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable*) * stonesSize);</span><br><span class="line">    <span class="built_in">memset</span>(rec, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct HashTable*) * stonesSize);</span><br><span class="line">    <span class="keyword">return</span> dfs(stones, stonesSize, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路及算法</strong></p><p>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">                <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canCross = <span class="function"><span class="keyword">function</span>(<span class="params">stones</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stones.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">const</span> k = stones[i] - stones[j];</span><br><span class="line">            <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i === n - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCross</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(stones)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> stones[i]-stones[i<span class="number">-1</span>] &gt; i &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            k := stones[i] - stones[j]</span><br><span class="line">            <span class="keyword">if</span> k &gt; j+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k] = dp[j][k<span class="number">-1</span>] || dp[j][k] || dp[j][k+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i == n<span class="number">-1</span> &amp;&amp; dp[i][k] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>* stones, <span class="keyword">int</span> stonesSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[stonesSize][stonesSize];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stonesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stonesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">            <span class="keyword">if</span> (k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i == stonesSize - <span class="number">1</span> &amp;&amp; dp[i][k]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是石子的数量。因为青蛙仅能在石子间跳跃，且不能向后方（起点的方向）跳跃，而第 <em>i</em> 个石子后方只有 <em>i-1</em> 个石子，因此在任意位置，青蛙的「上一次跳跃距离」至多只有 <em>n</em> 种，状态总数为 <em>n^2*。最坏情况下我们要遍历每一个状态，每次我们只需要 *O(1)</em> 的时间计算当前状态是否可达，相乘即可得到最终时间复杂度。</p></li><li><p>空间复杂度：<em>O(n^2)*，其中 *n</em> 是石子的数量。我们需要记录全部 <em>n^2</em> 个状态。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。&lt;/p&gt;
&lt;p&gt;给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>1884. 鸡蛋掉落-两枚鸡蛋</title>
    <link href="http://yoursite.com/2021/12/16/1884.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-%E4%B8%A4%E6%9E%9A%E9%B8%A1%E8%9B%8B/"/>
    <id>http://yoursite.com/2021/12/16/1884. 鸡蛋掉落-两枚鸡蛋/</id>
    <published>2021-12-16T14:30:12.000Z</published>
    <updated>2021-12-17T07:31:29.457Z</updated>
    
    <content type="html"><![CDATA[<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p><a id="more"></a><p>[TOC]</p><p>给你 2 枚相同 的鸡蛋，和一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p><p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都 会碎 ，从 f 楼层或比它低 的楼层落下的鸡蛋都 不会碎 。</p><p>每次操作，你可以取一枚 没有碎 的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p><p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p><p>示例 1：</p><pre><code>输入：n = 2输出：2解释：我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。如果第一枚鸡蛋碎了，可知 f = 0；如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；否则，当两个鸡蛋都没碎时，可知 f = 2。</code></pre><p>示例 2：</p><pre><code>输入：n = 100输出：14解释：一种最优的策略是：- 将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。- 如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。- 如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。不管结果如何，最多需要扔 14 次来确定 f 。</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 1000</code></pre><p>此题可参见<a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/" target="_blank" rel="noopener">887. 鸡蛋掉落</a></p><h1 id="查表-动态规划"><a href="#查表-动态规划" class="headerlink" title="查表+动态规划"></a>查表+动态规划</h1><p><strong>函数定义：</strong><br><code>dp(n, k)</code>表示现在有<code>n</code>层楼需要验证，此时你手里有<code>k</code>个鸡蛋，返回此时的最小操作次数。</p><p><strong>base case：</strong></p><ul><li>如果没有楼层需要验证了(<code>n == 0</code>)，那你不管有几个鸡蛋都不用操作了。</li><li>如果你手里只有一个鸡蛋了(<code>k == 1</code>)，那你只能从1楼开始试：1楼、2楼、…、n楼，共需要<code>n</code>次操作。</li></ul><p><strong>状态转移：</strong><br>现在你手里有<code>k</code>个鸡蛋，接下来你要选一层楼扔鸡蛋，假设你选择了第<code>i</code>层楼，有两种情况：</p><ol><li><strong>鸡蛋碎了</strong>。你知道你要确定的<code>f</code>一定在[0, i-1]范围内了，也就是需要验证的楼层数变成了<code>i-1</code>，除此之外你还损失了一个鸡蛋，只剩下<code>k-1</code>个鸡蛋了。</li><li><strong>鸡蛋没碎</strong>。你知道你要确定的<code>f</code>一定在[i, n]范围内了，接下来需要验证的楼层数变成了<code>n-i</code>，并且你没有损失鸡蛋，你还有<code>k</code>个鸡蛋。</li></ol><p>题目的要求可以解释为：<strong>最坏情况下最少需要操作几次</strong>。<strong>最坏情况</strong>就是在这两种情况之间，选择那个需要<strong>操作次数最大</strong>的，再加上自己这一次扔鸡蛋的操作，也就是<code>Math.max(dp(i-1, k-1), dp(n-i, k)) + 1</code>，这个值就是你选择从第<code>i</code>层楼扔鸡蛋，最坏情况下需要的操作次数。</p><p><code>dp(n, k)</code>需要的操作次数，是你<strong>在所有楼层中选择一个最坏情况下需要的操作次数最小</strong>的楼层扔鸡蛋。所以需要遍历所有楼层，找到<code>Math.min(res, Math.max(dp(i-1, k-1), dp(n-i, k)) + 1)</code>。</p><p>为了避免重复计算，加上<strong>备忘录</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoEggDrop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(n, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查表</span></span><br><span class="line">        <span class="keyword">if</span>(memo[n][k] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[n][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 选一层楼扔鸡蛋</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res = Math.min(res, Math.max(dp(i-<span class="number">1</span>, k-<span class="number">1</span>), dp(n-i, k)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo[n][k] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>1377. T 秒后青蛙的位置</title>
    <link href="http://yoursite.com/2021/12/16/1377.%20T%20%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/12/16/1377. T 秒后青蛙的位置/</id>
    <published>2021-12-16T12:30:12.000Z</published>
    <updated>2021-12-16T14:29:09.224Z</updated>
    
    <content type="html"><![CDATA[<p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。</p><a id="more"></a><p>[TOC]</p><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：</p><p>在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。<br>青蛙无法跳回已经访问过的顶点。<br>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。<br>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。<br>无向树的边用数组 edges 描述，其中 edges[i] = [fromi, toi] 意味着存在一条直接连通 fromi 和 toi 两个顶点的边。</p><p>返回青蛙在 t 秒后位于目标顶点 target 上的概率。</p><p>示例 1：</p><pre><code>输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4输出：0.16666666666666666 解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 1 秒 有 1/3 的概率跳到顶点 2 ，然后第 2 秒 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 </code></pre><p>示例 2：</p><pre><code>输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7输出：0.3333333333333333解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 1 秒 后跳到顶点 7 。 </code></pre><p>示例 3：</p><pre><code>输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6输出：0.16666666666666666</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 100edges.length == n-1edges[i].length == 21 &lt;= edges[i][0], edges[i][1] &lt;= n1 &lt;= t &lt;= 501 &lt;= target &lt;= n与准确值误差在 10^-5 之内的结果将被判定为正确。</code></pre><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>朴素BFS搜素，中间需要注意已经访问过的点不能计算到概率当中，<br>这个青蛙就算是当前它已经到达target，只要还有其他没有访问过的点，他还是会继续跳，直到时间用完。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    class node &#123;</span><br><span class="line">        int id;</span><br><span class="line">        double p; //概率</span><br><span class="line">        int t; //时间</span><br><span class="line"></span><br><span class="line">        node(int i, double pp, int tt) &#123;</span><br><span class="line">            id = i;</span><br><span class="line">            p = pp;</span><br><span class="line">            t = tt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double frogPosition(int n, int[][] edges, int t, int target) &#123;</span><br><span class="line">        Set&lt;Integer&gt;[] sets = new Set[n + 1];</span><br><span class="line">        for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">            sets[i] = new HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] e : edges) &#123;</span><br><span class="line">            sets[e[0]].add(e[1]);</span><br><span class="line">            //因为是无向图，有的edges顺序可能从子节点指向父节点</span><br><span class="line">            sets[e[1]].add(e[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;node&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(new node(1, 1.0, 0));</span><br><span class="line">        boolean[] vis = new boolean[n + 1];</span><br><span class="line">        vis[1] = true;</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            node u = q.poll();</span><br><span class="line">            if (u.t == t &amp;&amp; u.id == target) &#123;</span><br><span class="line">                return u.p;</span><br><span class="line">            &#125;</span><br><span class="line">            //统计下一步可能的所有选择数</span><br><span class="line">            int sz = 0;</span><br><span class="line">            for (int nb : sets[u.id]) &#123;</span><br><span class="line">                if (!vis[nb]) &#123;</span><br><span class="line">                    sz++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (u.t &lt; t) &#123;</span><br><span class="line">                boolean find = false;</span><br><span class="line">                for (int nb : sets[u.id]) &#123;</span><br><span class="line">                    if (vis[nb]) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //下一层有未访问的节点即加入队列</span><br><span class="line">                    find = true;</span><br><span class="line">                    vis[nb] = true;</span><br><span class="line">                    q.add(new node(nb, u.p / sz, u.t + 1));</span><br><span class="line">                &#125;</span><br><span class="line">                //下一层无未访问的节点</span><br><span class="line">                if (find == false) &#123;</span><br><span class="line">                    q.add(new node(u.id, u.p, u.t + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0.0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回青蛙在 t 秒后位于目标顶点 target 上的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
      <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>1419. 数青蛙</title>
    <link href="http://yoursite.com/2021/12/16/1419.%20%E6%95%B0%E9%9D%92%E8%9B%99/"/>
    <id>http://yoursite.com/2021/12/16/1419. 数青蛙/</id>
    <published>2021-12-16T09:43:12.000Z</published>
    <updated>2021-12-16T10:34:52.080Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以croakOfFrogs 中会混合多个 “croak” 。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p><a id="more"></a><p>[TOC]</p><p>注意：要想发出蛙鸣 “croak”，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p><p>如果字符串 croakOfFrogs 不是由若干有效的 “croak” 字符混合而成，请返回 -1 。</p><p>示例 1：</p><pre><code>输入：croakOfFrogs = &quot;croakcroak&quot;输出：1 解释：一只青蛙 “呱呱” 两次</code></pre><p>示例 2：</p><pre><code>输入：croakOfFrogs = &quot;crcoakroak&quot;输出：2 解释：最少需要两只青蛙，“呱呱” 声用黑体标注第一只青蛙 &quot;crcoakroak&quot;第二只青蛙 &quot;crcoakroak&quot;</code></pre><p>示例 3：</p><pre><code>输入：croakOfFrogs = &quot;croakcrook&quot;输出：-1解释：给出的字符串不是 &quot;croak&quot; 的有效组合。</code></pre><p>示例 4：</p><pre><code>输入：croakOfFrogs = &quot;croakcroa&quot;输出：-1</code></pre><p>提示：</p><pre><code>1 &lt;= croakOfFrogs.length &lt;= 10^5字符串中的字符只有 &apos;c&apos;, &apos;r&apos;, &apos;o&apos;, &apos;a&apos; 或者 &apos;k&apos;</code></pre><p>思想就是维护croak的个数，如果遇到当前字母，则肯定是由前面字母过来，前面字母数-1。<br>如遇到r，则必是c-&gt;r，所以c–<br>k代表结尾，其实也是青蛙的起始（一次喊叫结束），所以遇到c的时候，先去消耗k，没有k了，需要新青蛙，答案+1</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int minNumberOfFrogs(String croakOfFrogs) &#123;</span><br><span class="line">        int c,r,o,a,k;</span><br><span class="line">        c = 0; r = 0; o = 0; a = 0;k = 0;</span><br><span class="line">        char []chars = croakOfFrogs.toCharArray();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0;i &lt; chars.length;i++)&#123;</span><br><span class="line">            if(chars[i] == &apos;c&apos;)&#123;</span><br><span class="line">                if(k &gt; 0)&#123;k--;&#125;else&#123;res++;&#125;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;r&apos;)&#123;</span><br><span class="line">                c--;r++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;o&apos;)&#123;</span><br><span class="line">                r--;o++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;a&apos;)&#123;</span><br><span class="line">                o--;a++;</span><br><span class="line">            &#125;else if(chars[i] == &apos;k&apos;)&#123;</span><br><span class="line">                a--;k++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(c &lt; 0 || r &lt; 0 || o &lt; 0 || a &lt; 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(c != 0 || r != 0 || o != 0 || a != 0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java switch case写法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minNumberOfFrogs(String croakOfFrogs) &#123;</span><br><span class="line">        int c = 0;</span><br><span class="line">        int r = 0;</span><br><span class="line">        int o = 0;</span><br><span class="line">        int a = 0;</span><br><span class="line">        int k = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        char[] chars = croakOfFrogs.toCharArray();</span><br><span class="line">        for (char character : chars) &#123;</span><br><span class="line">            switch (character) &#123;</span><br><span class="line">                case &apos;c&apos;:</span><br><span class="line">                    if (k &gt; 0) &#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;r&apos;:</span><br><span class="line">                    c--;</span><br><span class="line">                    r++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;o&apos;:</span><br><span class="line">                    r--;</span><br><span class="line">                    o++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;:</span><br><span class="line">                    o--;</span><br><span class="line">                    a++;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;k&apos;:</span><br><span class="line">                    a--;</span><br><span class="line">                    k++;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (c &lt; 0 || r &lt; 0 || o &lt; 0 || a &lt; 0 || k&lt;0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (c != 0 || r != 0 || o != 0 || a != 0) &#123;</span><br><span class="line">            res = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以croakOfFrogs 中会混合多个 “croak” 。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Counting" scheme="http://yoursite.com/tags/Counting/"/>
    
  </entry>
  
  <entry>
    <title>1936. 新增的最少台阶数</title>
    <link href="http://yoursite.com/2021/12/16/1936.%20%E6%96%B0%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%B0%E9%98%B6%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/16/1936. 新增的最少台阶数/</id>
    <published>2021-12-16T08:28:12.000Z</published>
    <updated>2021-12-16T09:39:28.211Z</updated>
    
    <content type="html"><![CDATA[<p>返回爬到最后一阶时必须添加到梯子上的 最少台阶数。</p><a id="more"></a><p>[TOC]</p><p>给你一个 严格递增 的整数数组 rungs ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。</p><p>另给你一个整数 dist 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过dist高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。</p><p>返回爬到最后一阶时必须添加到梯子上的 最少台阶数。</p><p>示例 1：</p><pre><code>输入：rungs = [1,3,5,10], dist = 2输出：2解释：现在无法到达最后一阶。在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,5,7,8,10] 的位置上有台阶。</code></pre><p>示例 2：</p><pre><code>输入：rungs = [3,6,8,10], dist = 3输出：0解释：这个梯子无需增设新台阶也可以爬上去。</code></pre><p>示例 3：</p><pre><code>输入：rungs = [3,4,6,7], dist = 2输出：1解释：现在无法从地板到达梯子的第一阶。 在高度为 1 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,4,6,7] 的位置上有台阶。</code></pre><p>示例 4：</p><pre><code>输入：rungs = [5], dist = 10输出：0解释：这个梯子无需增设新台阶也可以爬上去。</code></pre><p>提示：</p><pre><code>1 &lt;= rungs.length &lt;= 1051 &lt;= rungs[i] &lt;= 1091 &lt;= dist &lt;= 109rungs 严格递增</code></pre><h1 id="方法一：模拟-贪心"><a href="#方法一：模拟-贪心" class="headerlink" title="方法一：模拟 + 贪心"></a>方法一：模拟 + 贪心</h1><p><strong>思路与算法</strong><a href="https://leetcode-cn.com/problems/add-minimum-number-of-rungs/solution/xin-zeng-de-zui-shao-tai-jie-shu-by-leet-y0de/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addRungs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rungs, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// 需要增设的梯子数目</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;   <span class="comment">// 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h: rungs)&#123;</span><br><span class="line">            <span class="comment">// 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            <span class="keyword">int</span> d = h - curr;</span><br><span class="line">            res += (d - <span class="number">1</span>) / dist;</span><br><span class="line">            curr = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addRungs</span><span class="params">(self, rungs: List[int], dist: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span>   <span class="comment"># 需要增设的梯子数目</span></span><br><span class="line">        curr = <span class="number">0</span>   <span class="comment"># 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> rungs:</span><br><span class="line">            <span class="comment"># 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            d = h - curr</span><br><span class="line">            res += (h - curr - <span class="number">1</span>) // dist</span><br><span class="line">            curr = h</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addRungs</span><span class="params">(<span class="keyword">int</span>[] rungs, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;    <span class="comment">// 需要增设的梯子数目</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;   <span class="comment">// 当前高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h : rungs) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组计算高度差和最少添加数目，并更新当前高度</span></span><br><span class="line">            <span class="keyword">int</span> d = h - curr;</span><br><span class="line">            res += (d - <span class="number">1</span>) / dist;</span><br><span class="line">            curr = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回爬到最后一阶时必须添加到梯子上的 最少台阶数。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>746. 使用最小花费爬楼梯</title>
    <link href="http://yoursite.com/2021/12/16/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2021/12/16/746. 使用最小花费爬楼梯/</id>
    <published>2021-12-16T08:12:12.000Z</published>
    <updated>2021-12-16T08:23:50.543Z</updated>
    
    <content type="html"><![CDATA[<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</code></pre><p> 示例 2：</p><pre><code>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</code></pre><p>提示：</p><pre><code>cost 的长度范围是 [2, 1000]。cost[i] 将会是一个整型数据，范围为 [0, 999] 。</code></pre><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.Min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[costSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        dp[i] = fmin(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述代码的时间复杂度和空间复杂度都是 <em>O(n)</em> 。可以使用滚动数组的思想，将空间复杂度优化到 <em>O(1)</em>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = Math.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="built_in">Math</span>.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int prev = 0, curr = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int next = Math.Min(curr + cost[i - 1], prev + cost[i - 2]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        pre, cur = cur, min(cur+cost[i<span class="number">-1</span>], pre+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        prev = curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>])</span><br><span class="line">            prev, curr = curr, nxt</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = fmin(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组cost 的长度。需要依次计算每个dp 值，每个值的计算需要常数时间，因此总时间复杂度是 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用滚动数组的思想，只需要使用有限的额外空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 088. 爬楼梯的最少成本</title>
    <link href="http://yoursite.com/2021/12/16/%E5%89%91%E6%8C%87%20Offer%20II%20088.%20%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%91%E6%88%90%E6%9C%AC/"/>
    <id>http://yoursite.com/2021/12/16/剑指 Offer II 088. 爬楼梯的最少成本/</id>
    <published>2021-12-16T08:12:12.000Z</published>
    <updated>2021-12-16T08:25:41.154Z</updated>
    
    <content type="html"><![CDATA[<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</code></pre><p> 示例 2：</p><pre><code>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</code></pre><p>提示：</p><pre><code>cost 的长度范围是 [2, 1000]。cost[i] 将会是一个整型数据，范围为 [0, 999] 。</code></pre><p>注意：本题与<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a>相同： </p><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.Min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[costSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        dp[i] = fmin(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[costSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述代码的时间复杂度和空间复杂度都是 <em>O(n)</em> 。可以使用滚动数组的思想，将空间复杂度优化到 <em>O(1)</em>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.length;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = Math.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cost.length;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="built_in">Math</span>.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MinCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int n = cost.Length;</span><br><span class="line">        int prev = 0, curr = 0;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int next = Math.Min(curr + cost[i - 1], prev + cost[i - 2]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(cost)</span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        pre, cur = cur, min(cur+cost[i<span class="number">-1</span>], pre+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(cost)</span><br><span class="line">        prev = curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nxt = min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>])</span><br><span class="line">            prev, curr = curr, nxt</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>* cost, <span class="keyword">int</span> costSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= costSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = fmin(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组cost 的长度。需要依次计算每个dp 值，每个值的计算需要常数时间，因此总时间复杂度是 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用滚动数组的思想，只需要使用有限的额外空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="http://yoursite.com/2021/12/16/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2021/12/16/70. 爬楼梯/</id>
    <published>2021-12-16T07:12:12.000Z</published>
    <updated>2021-12-16T07:30:09.737Z</updated>
    
    <content type="html"><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><a id="more"></a><p>[TOC]</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><p>示例 2：</p><pre><code>输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><p>具体解法和斐波那契数列一样，动态规划，矩阵快速幂和齐次线性递推方程取通解。本来已经这样就玩到极致了<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，没想到还有卷中卷，评论里有人提到字节面试还会修改条件，这样就又为之一变。</p><h1 id="加入新的限制条件：不能连续跳两个台阶。"><a href="#加入新的限制条件：不能连续跳两个台阶。" class="headerlink" title="加入新的限制条件：不能连续跳两个台阶。"></a>加入新的限制条件：不能连续跳两个台阶。</h1><p> 1、每次你可以爬 1 或 2 个台阶。</p><p> 2、不能连续跳两个台阶。（个人理解为这次跳了两个台阶，下次不能再跳两个台阶）</p><p> 假设：</p><pre><code>f(x) 表示爬到第 x 级台阶的方案数， g(x, 1) 表示爬到第 x 级台阶并且最后一步只跨越一个台阶的方案数， g(x, 2) 表示爬到第 x 级台阶并且最后一步跨越了两个台阶的方案数。由 ：f(x) = g(x, 1)+g(x,2)， g(x, 1) = f(x-1)， g(x, 2) = g(x-2, 1) // 最后一步跨越了两步，那么上一步只能跨越一步得：f(x) = g(x, 1) + g(x, 2)       = f(x-1) + g(x-2, 1)       = f(x-1) + f((x-2)-1)      = f(x-1) + f(x-3)</code></pre><p>题目里“不能连续跳两个台阶”，即一旦跳了两个台阶，则下一步只能跳一步（2-&gt;1），把它们连在一起就一共跳了三个台阶，所以问题可以转化为要么跳一个台阶，要么跳三个台阶（当然还是有点区别的，只不过因为结果是一样的，所以可以这么转化），于是就有了 f(x) = f(x-1) + f(x-3)</p><pre><code>public int climbStarts2(int n) {        if(n == 1) return 1; // 防止数组溢出（f[2]）        int[] f = new int[n+1];        f[0] = 1;        f[1] = 1;        f[2] = 2;        for(int i = 3; i &lt;= n; i++) {            f[i] = f[i-1] + f[i-3];        }        return f[n];    }</code></pre><p>结合执行树会更快理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                         6</span><br><span class="line">                   /            \</span><br><span class="line">                  5              4</span><br><span class="line">             /        \         /</span><br><span class="line">            4          3       3</span><br><span class="line">        /       \     /      /   \</span><br><span class="line">       3         2   2      2     1</span><br><span class="line">     /  \       /   / \    / \   /</span><br><span class="line">    2    1     1   1   0  1   0 0</span><br><span class="line">   / \   /    /   /      /</span><br><span class="line">  1   0 0    0   0      0</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这是一个 n = 6 时绘制的一个带权二叉树，其中左节点为权 1，右节点为权 2，很明显，问题的解为树的非空叶节点个数。</p><p>根节点为 f(x)<br>根节点的左节点为 g(x, 1)，又为 f(x - 1)，因为它是一个同类型的子问题<br>根节点的右节点为 g(x, 2)<br>而看节点 g(x, 2)，其不包含非空右节点，即它的解等同于它的左节点的解，再将其相对于根节点，可以明显看出其为 f(x - 3)</p><p>最终结果便为：f(x) = f(x - 1) + f(x - 3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="http://yoursite.com/2021/12/16/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/12/16/剑指 Offer 10- II. 青蛙跳台阶问题/</id>
    <published>2021-12-16T07:12:12.000Z</published>
    <updated>2021-12-16T07:30:03.599Z</updated>
    
    <content type="html"><![CDATA[<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><a id="more"></a><p>[TOC]</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><pre><code>输入：n = 2输出：2</code></pre><p>示例 2：</p><pre><code>输入：n = 7输出：21</code></pre><p>示例 3：</p><pre><code>输入：n = 0输出：1</code></pre><p>提示：</p><p>0 &lt;= n &lt;= 100</p><p>注意：本题与<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a>相同</p><p>具体解法和斐波那契数列一样，动态规划，矩阵快速幂和齐次线性递推方程取通解。本来已经这样就玩到极致了<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，没想到还有卷中卷，评论里有人提到字节面试还会修改条件，这样就又为之一变。</p><h1 id="加入新的限制条件：不能连续跳两个台阶。"><a href="#加入新的限制条件：不能连续跳两个台阶。" class="headerlink" title="加入新的限制条件：不能连续跳两个台阶。"></a>加入新的限制条件：不能连续跳两个台阶。</h1><p> 1、每次你可以爬 1 或 2 个台阶。</p><p> 2、不能连续跳两个台阶。（个人理解为这次跳了两个台阶，下次不能再跳两个台阶）</p><p> 假设：</p><pre><code>f(x) 表示爬到第 x 级台阶的方案数， g(x, 1) 表示爬到第 x 级台阶并且最后一步只跨越一个台阶的方案数， g(x, 2) 表示爬到第 x 级台阶并且最后一步跨越了两个台阶的方案数。由 ：f(x) = g(x, 1)+g(x,2)， g(x, 1) = f(x-1)， g(x, 2) = g(x-2, 1) // 最后一步跨越了两步，那么上一步只能跨越一步得：f(x) = g(x, 1) + g(x, 2)       = f(x-1) + g(x-2, 1)       = f(x-1) + f((x-2)-1)      = f(x-1) + f(x-3)</code></pre><p>题目里“不能连续跳两个台阶”，即一旦跳了两个台阶，则下一步只能跳一步（2-&gt;1），把它们连在一起就一共跳了三个台阶，所以问题可以转化为要么跳一个台阶，要么跳三个台阶（当然还是有点区别的，只不过因为结果是一样的，所以可以这么转化），于是就有了 f(x) = f(x-1) + f(x-3)</p><pre><code>public int climbStarts2(int n) {        if(n == 1) return 1; // 防止数组溢出（f[2]）        int[] f = new int[n+1];        f[0] = 1;        f[1] = 1;        f[2] = 2;        for(int i = 3; i &lt;= n; i++) {            f[i] = f[i-1] + f[i-3];        }        return f[n];    }</code></pre><p>结合执行树会更快理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">                         6</span><br><span class="line">                   /            \</span><br><span class="line">                  5              4</span><br><span class="line">             /        \         /</span><br><span class="line">            4          3       3</span><br><span class="line">        /       \     /      /   \</span><br><span class="line">       3         2   2      2     1</span><br><span class="line">     /  \       /   / \    / \   /</span><br><span class="line">    2    1     1   1   0  1   0 0</span><br><span class="line">   / \   /    /   /      /</span><br><span class="line">  1   0 0    0   0      0</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>这是一个 n = 6 时绘制的一个带权二叉树，其中左节点为权 1，右节点为权 2，很明显，问题的解为树的非空叶节点个数。</p><p>根节点为 f(x)<br>根节点的左节点为 g(x, 1)，又为 f(x - 1)，因为它是一个同类型的子问题<br>根节点的右节点为 g(x, 2)<br>而看节点 g(x, 2)，其不包含非空右节点，即它的解等同于它的左节点的解，再将其相对于根节点，可以明显看出其为 f(x - 3)</p><p>最终结果便为：f(x) = f(x - 1) + f(x - 3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="http://yoursite.com/2021/12/15/842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2021/12/15/842. 将数组拆分成斐波那契序列/</id>
    <published>2021-12-15T13:30:12.000Z</published>
    <updated>2021-12-15T14:42:44.038Z</updated>
    
    <content type="html"><![CDATA[<p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><a id="more"></a><p>[TOC]</p><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p><p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p><p>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length &gt;= 3；<br>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p><p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><p>示例 1：</p><pre><code>输入：&quot;123456579&quot;输出：[123,456,579]</code></pre><p>示例 2：</p><pre><code>输入: &quot;11235813&quot;输出: [1,1,2,3,5,8,13]</code></pre><p>示例 3：</p><pre><code>输入: &quot;112358130&quot;输出: []解释: 这项任务无法完成。</code></pre><p>示例 4：</p><pre><code>输入：&quot;0123&quot;输出：[]解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。</code></pre><p>示例 5：</p><pre><code>输入: &quot;1101111&quot;输出: [110, 1, 111]解释: 输出 [11,0,11,11] 也同样被接受。</code></pre><p>提示：</p><pre><code>1 &lt;= S.length &lt;= 200字符串 S 中只含有数字。</code></pre><h1 id="回溯法模板-1"><a href="#回溯法模板-1" class="headerlink" title="回溯法模板^1"></a>回溯法模板<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">^1</a></h1><details>    <summary>回溯法模板</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void backtrack(&quot;原始参数&quot;) &#123;</span><br><span class="line">    //终止条件(递归必须要有终止条件)</span><br><span class="line">    if (&quot;终止条件&quot;) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = &quot;for循环开始的参数&quot;; i &lt; &quot;for循环结束的参数&quot;; i++) &#123;</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //做出选择</span><br><span class="line"></span><br><span class="line">        //递归</span><br><span class="line">        backtrack(&quot;新的参数&quot;);</span><br><span class="line">        //一些逻辑操作（可有可无，视情况而定）</span><br><span class="line"></span><br><span class="line">        //撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法一：回溯-剪枝-2"><a href="#方法一：回溯-剪枝-2" class="headerlink" title="方法一：回溯 + 剪枝^2"></a>方法一：回溯 + 剪枝<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/jiang-shu-zu-chai-fen-cheng-fei-bo-na-qi-ts6c/" target="_blank" rel="noopener">^2</a></h1><p>将给定的字符串拆分成斐波那契式序列，可以通过回溯的方法实现。</p><p>使用列表存储拆分出的数，回溯过程中维护该列表的元素，列表初始为空。遍历字符串的所有可能的前缀，作为当前被拆分出的数，然后对剩余部分继续拆分，直到整个字符串拆分完毕。</p><p>根据斐波那契式序列的要求，从第 <em>3</em> 个数开始，每个数都等于前 <em>2</em> 个数的和，因此从第 <em>3</em> 个数开始，需要判断拆分出的数是否等于前 <em>2</em> 个数的和，只有满足要求时才进行拆分，否则不进行拆分。</p><p>回溯过程中，还有三处可以进行剪枝操作。</p><ul><li><p>拆分出的数如果不是 <em>0</em>，则不能以 <em>0</em> 开头，因此如果字符串剩下的部分以 <em>0</em> 开头，就不需要考虑拆分出长度大于 <em>1</em> 的数，因为长度大于 <em>1</em> 的数以 <em>0</em> 开头是不符合要求的，不可能继续拆分得到斐波那契式序列；</p></li><li><p>拆分出的数必须符合 <em>32</em> 位有符号整数类型，即每个数必须在 <em>[0,2^{31}-1]</em> 的范围内，如果拆分出的数大于 <em>2^{31}-1</em>，则不符合要求，长度更大的数的数值也一定更大，一定也大于 <em>2^{31}-1</em>，因此不可能继续拆分得到斐波那契式序列；</p></li><li><p>如果列表中至少有 <em>2</em> 个数，并且拆分出的数已经大于最后 <em>2</em> 个数的和，就不需要继续尝试拆分了。</p></li></ul><p>当整个字符串拆分完毕时，如果列表中至少有 <em>3</em> 个数，则得到一个符合要求的斐波那契式序列，返回列表。如果没有找到符合要求的斐波那契式序列，则返回空列表。</p><p>实现方面，回溯需要带返回值，表示是否存在符合要求的斐波那契式序列。</p><p>但是代码部分实现的过于繁琐，简洁版可以参见<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">^1</a></p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(S.toCharArray(), res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[] digit, List&lt;Integer&gt; res, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件判断，如果截取完了，并且res长度大于等于3，表示找到了一个组合。</span></span><br><span class="line">    <span class="keyword">if</span> (index == digit.length &amp;&amp; res.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; digit.length; i++) &#123;</span><br><span class="line">        <span class="comment">//两位以上的数字不能以0开头</span></span><br><span class="line">        <span class="keyword">if</span> (digit[index] == <span class="string">'0'</span> &amp;&amp; i &gt; index) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//截取字符串转化为数字</span></span><br><span class="line">        <span class="keyword">long</span> num = subDigit(digit, index, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果截取的数字大于int的最大值，则终止截取</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = res.size();</span><br><span class="line">        <span class="comment">//如果截取的数字大于res中前两个数字的和，说明这次截取的太大，直接终止，因为后面越截取越大</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= <span class="number">2</span> &amp;&amp; num &gt; res.get(size - <span class="number">1</span>) + res.get(size - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span> || num == res.get(size - <span class="number">1</span>) + res.get(size - <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="comment">//把数字num添加到集合res中</span></span><br><span class="line">            res.add((<span class="keyword">int</span>) num);</span><br><span class="line">            <span class="comment">//如果找到了就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (backtrack(digit, res, i + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果没找到，就会走回溯这一步，然后把上一步添加到集合res中的数字给移除掉</span></span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于截取字符串S中的子串然后转换为十进制数字</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">subDigit</span><span class="params">(<span class="keyword">char</span>[] digit, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + digit[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; splitIntoFibonacci(<span class="built_in">string</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">        backtrack(<span class="built_in">list</span>, num, num.length(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">list</span>, <span class="built_in">string</span> num, <span class="keyword">int</span> length, <span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>.size() &gt;= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr * <span class="number">10</span> + num[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr &gt; INT_MAX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>.push_back(curr);</span><br><span class="line">            <span class="keyword">if</span> (backtrack(<span class="built_in">list</span>, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> splitIntoFibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">new</span> <span class="built_in">Array</span>().fill(<span class="number">0</span>);</span><br><span class="line">    backtrack(list, num, num.length, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> backtrack = <span class="function">(<span class="params">list, num, length, index, sum, prev</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === length) &#123;</span><br><span class="line">        <span class="keyword">return</span> list.length &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currLong = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] === <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currLong = currLong * <span class="number">10</span> + num[i].charCodeAt() - <span class="string">'0'</span>.charCodeAt();</span><br><span class="line">        <span class="keyword">if</span> (currLong &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> curr = currLong;</span><br><span class="line">        <span class="keyword">if</span> (list.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.push(curr);</span><br><span class="line">        <span class="keyword">if</span> (backtrack(list, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.splice(list.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, num: str)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = list()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index: int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == len(num):</span><br><span class="line">                <span class="keyword">return</span> len(ans) &gt;= <span class="number">3</span></span><br><span class="line">            </span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, len(num)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> num[index] == <span class="string">"0"</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                curr = curr * <span class="number">10</span> + ord(num[i]) - ord(<span class="string">"0"</span>)</span><br><span class="line">                <span class="keyword">if</span> curr &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> len(ans) &lt; <span class="number">2</span> <span class="keyword">or</span> curr == ans[<span class="number">-2</span>] + ans[<span class="number">-1</span>]:</span><br><span class="line">                    ans.append(curr)</span><br><span class="line">                    <span class="keyword">if</span> backtrack(i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    ans.pop()</span><br><span class="line">                <span class="keyword">elif</span> len(ans) &gt; <span class="number">2</span> <span class="keyword">and</span> curr &gt; ans[<span class="number">-2</span>] + ans[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">splitIntoFibonacci</span><span class="params">(num <span class="keyword">string</span>)</span> <span class="params">(F []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(num)</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(index, sum, prev <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">backtrack</span> = <span class="title">func</span><span class="params">(index, sum, prev <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == n &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(F) &gt;= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">// 每个块的数字一定不要以零开头，除非这个块是数字 0 本身</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur*<span class="number">10</span> + <span class="keyword">int</span>(num[i]-<span class="string">'0'</span>)</span><br><span class="line">            <span class="comment">// 拆出的整数要符合 32 位有符号整数类型</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; math.MaxInt32 &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// F[i] + F[i+1] = F[i+2]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(F) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> cur &lt; sum &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> cur &gt; sum &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 符合要求，加入序列 F</span></span><br><span class="line">            F = <span class="built_in">append</span>(F, cur)</span><br><span class="line">            <span class="keyword">if</span> backtrack(i+<span class="number">1</span>, prev+cur, cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            F = F[:<span class="built_in">len</span>(F)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">list</span>, <span class="keyword">int</span>* listSize, <span class="keyword">char</span>* num, <span class="keyword">int</span> length, <span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">        <span class="keyword">return</span> (*listSize) &gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; num[index] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr * <span class="number">10</span> + num[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr &gt; INT_MAX) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((*listSize) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>[(*listSize)++] = curr;</span><br><span class="line">        <span class="keyword">if</span> (backtrack(<span class="built_in">list</span>, listSize, num, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (*listSize)--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">splitIntoFibonacci</span><span class="params">(<span class="keyword">char</span>* num, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(num);</span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">list</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    backtrack(<span class="built_in">list</span>, returnSize, num, <span class="built_in">strlen</span>(num), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="http://yoursite.com/2021/12/15/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <id>http://yoursite.com/2021/12/15/1414. 和为 K 的最少斐波那契数字数目/</id>
    <published>2021-12-15T12:02:12.000Z</published>
    <updated>2021-12-15T13:11:39.981Z</updated>
    
    <content type="html"><![CDATA[<p>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><a id="more"></a><p>[TOC]</p><p>斐波那契数字定义为：</p><pre><code>F1 = 1F2 = 1Fn = Fn-1 + Fn-2 ， 其中 n &gt; 2 。</code></pre><p>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：</p><pre><code>输入：k = 7输出：2 解释：斐波那契数字为：1，1，2，3，5，8，13，……对于 k = 7 ，我们可以得到 2 + 5 = 7 。</code></pre><p>示例 2：</p><pre><code>输入：k = 10输出：2 解释：对于 k = 10 ，我们可以得到 2 + 8 = 10 。</code></pre><p>示例 3：</p><pre><code>输入：k = 19输出：3 解释：对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。</code></pre><p>提示：</p><pre><code>1 &lt;= k &lt;= 10^9</code></pre><h1 id="贪心-栈"><a href="#贪心-栈" class="headerlink" title="贪心+栈"></a>贪心+栈</h1><p>证明参见<a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/he-wei-k-de-zui-shao-fei-bo-na-qi-shu-zi-shu-mu-by/" target="_blank" rel="noopener">^1</a>，自己觉得用栈的写法比官方题解更易于理解</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinFibonacciNumbers(int k) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int a = 1, b = 1;</span><br><span class="line">        stack.push(a);</span><br><span class="line">        stack.push(b);</span><br><span class="line">        while (stack.peek() &lt;= k) &#123;</span><br><span class="line">            int c = a + b;</span><br><span class="line">            stack.push(c);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = 0;</span><br><span class="line">        while (!stack.isEmpty() &amp;&amp; k &gt; 0) &#123;</span><br><span class="line">            int temp = stack.pop();</span><br><span class="line">            if (temp &lt;= k) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                k = k - temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>873. 最长的斐波那契子序列的长度</title>
    <link href="http://yoursite.com/2021/12/14/873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>http://yoursite.com/2021/12/14/873. 最长的斐波那契子序列的长度/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:34:37.497Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 093. 最长斐波那契数列</title>
    <link href="http://yoursite.com/2021/12/14/%E5%89%91%E6%8C%87%20Offer%20II%20093.%20%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2021/12/14/剑指 Offer II 093. 最长斐波那契数列/</id>
    <published>2021-12-14T12:37:12.000Z</published>
    <updated>2021-12-14T15:36:10.891Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><a id="more"></a><p>[TOC]</p><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。</p><p>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p><p>示例 1：</p><pre><code>输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</code></pre><p>示例 2：</p><pre><code>输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre><p>提示：</p><pre><code>3 &lt;= arr.length &lt;= 10001 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></pre><p>本题与<a href="https://leetcode-cn.com/problems/length-of-longest-fibonacc//i-subsequence/" target="_blank" rel="noopener">873. 最长的斐波那契子序列的长度</a>相同： </p><h1 id="方法一：使用-Set-的暴力法"><a href="#方法一：使用-Set-的暴力法" class="headerlink" title="方法一：使用 Set 的暴力法"></a>方法一：使用 Set 的暴力法</h1><p><strong>思路</strong></p><p>每个斐波那契式的子序列都依靠两个相邻项来确定下一个预期项。例如，对于 <code>2, 5</code>，我们所期望的子序列必定以 <code>7, 12, 19, 31</code> 等继续。</p><p>我们可以使用 <code>Set</code> 结构来快速确定下一项是否在数组 <code>A</code> 中。由于这些项的值以指数形式增长，最大值 &lt;=10^9 的斐波那契式的子序列最多有 43 项。</p><p><strong>算法</strong></p><p>对于每个起始对 <code>A[i], A[j]</code>，我们保持下一个预期值 <code>y = A[i] + A[j]</code> 和此前看到的最大值 <code>x = A[j]</code>。如果 <code>y</code> 在数组中，我们可以更新这些值 <code>(x, y) -&gt; (y, x+y)</code>。</p><p>此外，由于子序列的长度大于等于 3 只能是斐波那契式的，所以我们必须在最后进行检查 <code>ans &gt;= 3 ? ans : 0</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[RGECz9nf-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S(A.begin(), A.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.find(y) != S.end()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> z = x + y;</span><br><span class="line">                    x = y;</span><br><span class="line">                    y = z;</span><br><span class="line">                    ans = max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[RGECz9nf-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Set&lt;Integer&gt; S = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) S.add(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="comment">/* With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="comment">                 * y represents the future expected value in</span></span><br><span class="line"><span class="comment">                 * the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="comment">                 * the most current value found. */</span></span><br><span class="line">                <span class="keyword">int</span> x = A[j], y = A[i] + A[j];</span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (S.contains(y)) &#123;</span><br><span class="line">                    <span class="comment">// x, y -&gt; y, x+y</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = y;</span><br><span class="line">                    y += x;</span><br><span class="line">                    x = tmp;</span><br><span class="line">                    ans = Math.max(ans, ++length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[RGECz9nf-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        S = set(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i+<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                With the starting pair (A[i], A[j]),</span></span><br><span class="line"><span class="string">                y represents the future expected value in</span></span><br><span class="line"><span class="string">                the fibonacci subsequence, and x represents</span></span><br><span class="line"><span class="string">                the most current value found.</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                x, y = A[j], A[i] + A[j]</span><br><span class="line">                length = <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> S:</span><br><span class="line">                    x, y = y, x + y</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">                ans = max(ans, length)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><hr><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p><strong>思路</strong></p><p>将斐波那契式的子序列中的两个连续项 <code>A[i], A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。</p><p>例如，对于斐波那契式的子序列 <code>(A[1] = 2, A[2] = 3, A[4] = 5, A[7] = 8, A[10] = 13)</code>，结点之间的路径为 <code>(1, 2) &lt;-&gt; (2, 4) &lt;-&gt; (4, 7) &lt;-&gt; (7, 10)</code>。</p><p>这样做的动机是，只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的，我们需要这些信息才能知道这一连通。现在我们得到一个类似于 <em>最长上升子序列</em> 的问题。</p><p><strong>算法</strong></p><p>设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p><p>由于 <code>i</code> 由 <code>A.index(A[k] - A[j])</code> 唯一确定，所以这是有效的：我们在 <code>i</code> 潜在时检查每组 <code>j &lt; k</code>，并相应地更新 <code>longest[j, k]</code>。</p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[UNSjQ9SB-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index[A[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; longest;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[k] - A[j] &lt; A[j] &amp;&amp; index.count(A[k] - A[j])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = index[A[k] - A[j]];</span><br><span class="line">                    longest[j * N + k] = longest[i * N + j] + <span class="number">1</span>;</span><br><span class="line">                    ans = max(ans, longest[j * N + k] + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[UNSjQ9SB-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                    <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                    <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                    longest.put(j * N + k, cand);</span><br><span class="line">                    ans = Math.max(ans, cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[UNSjQ9SB-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        index = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A)&#125;</span><br><span class="line">        longest = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, z <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k):</span><br><span class="line">                i = index.get(z - A[j], <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                    cand = longest[j, k] = longest[i, j] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, cand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt;= <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></details><h1 id="动态规划简明版"><a href="#动态规划简明版" class="headerlink" title="动态规划简明版"></a>动态规划简明版</h1><p>上面这个状态转移比较难以理解</p><p>以下是解释</p><p>下面是<code>Time Limit Error</code>代码</p><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[k] + A[i] == A[j]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; intMap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">intMap[A[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line"><span class="keyword">if</span> (intMap.count(diff)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = intMap[diff];</span><br><span class="line"><span class="keyword">if</span> (index &lt; i) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[index][i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MAX = max(MAX, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MAX &gt; <span class="number">2</span>? MAX : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]: 以A[i],A[j] 结尾的最长的长度-2</span></span><br><span class="line">        <span class="comment">//如果存在A[k]=A[j]-A[i] 且k&lt;i 则 dp[i][j]=dp[k][i]+1</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(arr[j]-arr[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = map.get(arr[j] - arr[i]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt; i) &#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[k][i] + <span class="number">1</span>);</span><br><span class="line">                            max = Math.max(max, dp[i][j] + <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>如果对 <code>max = Math.max(max, dp[i][j] + 2);</code>这一步理解有困难，也可以将dp初始化为全2的矩阵，然后<code>max = Math.max(max, dp[i][j]);</code>即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回0 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
