<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-01T00:00:20.757Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>294 · 简化链表</title>
    <link href="http://yoursite.com/2021/03/31/294%20%C2%B7%20%E7%AE%80%E5%8C%96%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/03/31/294 · 简化链表/</id>
    <published>2021-03-31T13:31:12.000Z</published>
    <updated>2021-04-01T00:00:20.757Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个字符链表，对其进行简化。<br>简化的过程为，保留链表的头尾节点，用数字代替掉中间的部分。数字也要用字符链表表示。</p><a id="more"></a><p>输入的字符链表用一个整型链表表示，链表的每个节点的值都是其对应的ASCII码。<br>输入的字符链表的节点数为 n，3≤n≤10^4</p><p>说明</p><pre><code>原链表是 &apos;h&apos;-&gt;&apos;e&apos;-&gt;&apos;l&apos;-&gt;&apos;l&apos;-&gt;&apos;o&apos;-&gt;null。简化后变为 &apos;h&apos;-&gt;&apos;3&apos;-&gt;&apos;o&apos;-&gt;null。第二组样例中：原链表是 &apos;a&apos;-&gt;&apos;b&apos;-&gt;...-&gt;&apos;z&apos;-&gt;null。简化后变为 &apos;a&apos;-&gt;&apos;2&apos;-&gt;&apos;4&apos;-&gt;&apos;z&apos;-&gt;null。</code></pre><p>样例</p><pre><code>输入1：    104-&gt;101-&gt;108-&gt;108-&gt;111-&gt;null输出1：    104-&gt;51-&gt;111-&gt;null输入2：    97-&gt;98-&gt;...-&gt;122-&gt;null输出2：    97-&gt;50-&gt;52-&gt;122-&gt;null</code></pre><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for ListNode</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param head: the linked list to be simplify.</span><br><span class="line">     * @return: return the linked list after simplifiction.</span><br><span class="line">     */</span><br><span class="line">    public ListNode simplify(ListNode head) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        ListNode cur=head.next;</span><br><span class="line">        if(head == null || cur == null || cur.next == null)&#123;</span><br><span class="line">          return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        while(cur.next!=null)&#123;</span><br><span class="line">          cur=cur.next;</span><br><span class="line">          cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        if(cnt!=0)&#123;</span><br><span class="line">            ListNode p = new ListNode(Integer.valueOf(&apos;0&apos;)+cnt%10);</span><br><span class="line">            cnt/=10;</span><br><span class="line">            p.next = cur;</span><br><span class="line">            while(cnt != 0)&#123;</span><br><span class="line">              ListNode temp=p;</span><br><span class="line">              p = new ListNode(Integer.valueOf(&apos;0&apos;)+cnt%10);</span><br><span class="line">              p.next=temp;</span><br><span class="line">              cnt/=10;</span><br><span class="line">          &#125;</span><br><span class="line">          head.next=p;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个字符链表，对其进行简化。&lt;br&gt;简化的过程为，保留链表的头尾节点，用数字代替掉中间的部分。数字也要用字符链表表示。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Simulation" scheme="http://yoursite.com/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>711. 不同岛屿的数量II</title>
    <link href="http://yoursite.com/2021/03/31/711.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8FII/"/>
    <id>http://yoursite.com/2021/03/31/711. 不同岛屿的数量II/</id>
    <published>2021-03-31T09:31:12.000Z</published>
    <updated>2021-03-31T10:24:31.270Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个0和1的非空的二维数组网格，一个岛是一个1(表示陆地)的组，4个方向(水平或垂直)连接。你可以假设网格的所有四条边都被水包围。</p><p>计算不同岛屿的数量。当一个岛被认为与另一个岛相同时，它们有相同的形状，或在旋转后的形状相同(90,180，或270度)或翻转(左/右方向或向上/向下方向)。</p><a id="more"></a><p>样例</p><p>Example 1:</p><pre><code>11000100000000100011</code></pre><p>给定上述网格，返回1。<br>注意:</p><pre><code>111</code></pre><p>和</p><pre><code> 111</code></pre><p>被认为是相同的岛屿形状。因为如果我们在第一个岛上顺时针旋转180度，那么两个岛就会有相同的形状。</p><p>Example 2:</p><pre><code>11100100010100101110</code></pre><p>给定上述网格，返回2。<br>以下是两个不同的岛屿:</p><pre><code>1111</code></pre><p>和</p><pre><code>11</code></pre><p>注意：</p><pre><code>1111</code></pre><p>和</p><pre><code>1111</code></pre><p>被认为是相同的岛屿形状。因为如果我们在向上/向下的方向上翻转第一个数组，那么它们的形状是相同的<br>参见Lintcode<a href="https://www.lintcode.com/problem/804/?utm_source=sc-qingbaozhan-sy" target="_blank" rel="noopener">^1</a></p><h2 id="题解BFS"><a href="#题解BFS" class="headerlink" title="题解BFS"></a>题解BFS</h2><p>先用dfs或者bfs把每个岛屿都找出来，然后进行旋转比较。1·</p><details>    <summary>BFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: the 2D grid</span><br><span class="line">     * @return: the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    private final int[] dir = &#123;-1, 0, 1, 0, -1&#125;;</span><br><span class="line">    private final int[][] ref1 = &#123;&#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;</span><br><span class="line">    public int numDistinctIslands2(int[][] grid) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Point&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    bfs(grid, i, j, list);</span><br><span class="line">                &#125;</span><br><span class="line">                if (list.size() &gt; 0) &#123;</span><br><span class="line">                    set.add(norm(list));</span><br><span class="line">                    list.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void bfs(int[][] grid, int row, int col, List&lt;Point&gt; list) &#123;</span><br><span class="line">        Queue&lt;Point&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">        Point start = new Point(row, col);</span><br><span class="line">        queue.add(start);</span><br><span class="line">        list.add(start);</span><br><span class="line">        grid[row][col] = 2;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int r = p.x + dir[i], c = p.y + dir[i + 1];</span><br><span class="line">                if (r &lt; 0 || r &gt;= grid.length || c &lt; 0 || c &gt;= grid[0].length || grid[r][c] != 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[r][c] = 2;</span><br><span class="line">                Point next = new Point(r, c);</span><br><span class="line">                list.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String norm(List&lt;Point&gt; list) &#123;</span><br><span class="line">        List&lt;Point&gt;[] comb = new List[8];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            comb[i] = new ArrayList&lt;Point&gt;();</span><br><span class="line">            comb[i + 4] = new ArrayList&lt;Point&gt;();</span><br><span class="line">            for (Point p : list) &#123;</span><br><span class="line">                comb[i].add(new Point(p.x * ref1[i][0], p.y * ref1[i][1]));</span><br><span class="line">                comb[i + 4].add(new Point(p.y * ref1[i][1], p.x * ref1[i][0]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            Collections.sort(comb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] s = new String[8];</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            int x0 = comb[i].get(0).x, y0 = comb[i].get(0).y;</span><br><span class="line">            for (Point p : comb[i]) &#123;</span><br><span class="line">                sb.append(p.x - x0).append(&apos;,&apos;).append(p.y - y0).append(&apos;!&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            s[i] = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        return s[0];</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Point implements Comparable&lt;Point&gt; &#123;</span><br><span class="line">        int x;</span><br><span class="line">        int y;</span><br><span class="line"></span><br><span class="line">        public Point(int x, int y) &#123;</span><br><span class="line">            this.x = x;</span><br><span class="line">            this.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int compareTo(Point p) &#123;</span><br><span class="line">            return this.x - p.x == 0 ? this.y - p.y : this.x - p.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="题解DFS"><a href="#题解DFS" class="headerlink" title="题解DFS"></a>题解DFS</h2><details>    <summary>DFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">    public int x, y;</span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: the 2D grid</span><br><span class="line">     * @return: the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    public int numDistinctIslands2(int[][] grid) &#123;</span><br><span class="line">        if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = grid.length, n = grid[0].length;</span><br><span class="line">        Set&lt;String&gt;  res = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    List&lt;Point&gt; island = new ArrayList&lt;&gt;();</span><br><span class="line">                    dfs(grid, i, j, island);</span><br><span class="line">                    res.add(getUnique(island));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[][]grid, int x, int y, List&lt;Point&gt; island) &#123;</span><br><span class="line">        int m = grid.length, n = grid[0].length;</span><br><span class="line"></span><br><span class="line">        island.add(new Point(x, y));</span><br><span class="line">        grid[x][y] = 0;</span><br><span class="line"></span><br><span class="line">        int[] dirs = &#123;-1, 0, 1, 0, -1&#125;;</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int _x = x + dirs[i], _y = y + dirs[i + 1];</span><br><span class="line">            if (_x &gt;= 0  &amp;&amp; _x &lt; m  &amp;&amp; _y &gt;= 0  &amp;&amp; _y &lt; n  &amp;&amp; grid[_x][_y] == 1) &#123;</span><br><span class="line">                dfs(grid, _x, _y, island);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getUnique(List&lt;Point&gt; island) &#123;</span><br><span class="line">        List&lt;String&gt; sameIslands = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int[][] trans=&#123;&#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            List&lt;Point&gt; l1 = new ArrayList&lt;&gt;(), l2 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for (Point point : island) &#123;</span><br><span class="line">                int x = point.x, y = point.y;</span><br><span class="line">                l1.add(new Point(x * trans[i][0], y * trans[i][1]));</span><br><span class="line">                l2.add(new Point(y * trans[i][0], x * trans[i][1]));</span><br><span class="line">            &#125;</span><br><span class="line">            sameIslands.add(getStr(l1));</span><br><span class="line">            sameIslands.add(getStr(l2));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(sameIslands);</span><br><span class="line">        return sameIslands.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getStr(List&lt;Point&gt; island) &#123;</span><br><span class="line"></span><br><span class="line">        Collections.sort(island, new Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            public int compare(Point a, Point b) &#123;</span><br><span class="line">                if (a.x != b.x) &#123;</span><br><span class="line">                    return a.x - b.x;</span><br><span class="line">                &#125;</span><br><span class="line">                return a.y - b.y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        int x = island.get(0).x, y = island.get(0).y;</span><br><span class="line"></span><br><span class="line">        for (Point point : island) &#123;</span><br><span class="line">            sb.append((point.x - x) + &quot; &quot; + (point.y - y) + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个0和1的非空的二维数组网格，一个岛是一个1(表示陆地)的组，4个方向(水平或垂直)连接。你可以假设网格的所有四条边都被水包围。&lt;/p&gt;
&lt;p&gt;计算不同岛屿的数量。当一个岛被认为与另一个岛相同时，它们有相同的形状，或在旋转后的形状相同(90,180，或270度)或翻转(左/右方向或向上/向下方向)。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bread-first Search" scheme="http://yoursite.com/tags/Bread-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>694. 不同岛屿的数量</title>
    <link href="http://yoursite.com/2021/03/31/694.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>http://yoursite.com/2021/03/31/694. 不同岛屿的数量/</id>
    <published>2021-03-31T03:31:12.000Z</published>
    <updated>2021-03-31T09:12:36.395Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。</p><p>请你计算这个网格中共有多少个形状不同的岛屿。<br>两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p><a id="more"></a><p>样例 1:</p><pre><code>11000110000001100011</code></pre><p>给定上图，返回结果 1。</p><p>样例 2:</p><pre><code>11011100000000111011</code></pre><p>给定上图，返回结果 3。</p><p>注意:</p><pre><code>111</code></pre><p>和</p><pre><code> 111</code></pre><p>是不同的岛屿，因为我们不考虑旋转、翻转操作。</p><p>注释 :  二维数组每维的大小都不会超过50。</p><p>参见Lintcode<a href="https://www.lintcode.com/problem/860/" target="_blank" rel="noopener">^1</a></p><h2 id="题解BFS"><a href="#题解BFS" class="headerlink" title="题解BFS"></a>题解BFS</h2><p>我们可以通过BFS/DFS得到每一个岛屿，然后把每个岛屿的形状放到set里，最后set的大小就是答案。</p><p>那么问题的关键在于如何描述一个岛屿的形状。</p><p>有以下两个基本思路：</p><ol><li>记录一个岛屿所有点相对于左上角的点的相对位置。</li><li>记录一个岛屿的bfs/dfs轨迹</li></ol><p>方法1涉及细节较少，但是可能复杂度相对较高，不过50*50的数据范围不会超时。</p><p>方法1也有多种实现方法，比如一个岛屿形状可以用set记录，也可以将所有点的相对坐标排序后转换成字符串。</p><p>方法2需要注意一个细节：不能仅仅存储下来dfs/bfs移动的方向，因为涉及到回溯等问题，可以加上一定的间隔符，或者除方向之外额外记录一个位置信息。</p><details>    <summary>BFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if(grid.empty() || grid[0].empty()) return 0;</span><br><span class="line">        int m = grid.size(), n = grid[0].size(), i, j, k, x, y, x0, y0, nx, ny;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">        set&lt;vector&lt;vector&lt;int&gt;&gt;&gt; s;</span><br><span class="line">        for(i = 0; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        for(j = 0; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">        if(grid[i][j] == 0)</span><br><span class="line">        continue;</span><br><span class="line">        x0 = i, y0 = j;</span><br><span class="line">        queue&lt;vector&lt;int&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; path;</span><br><span class="line">        q.push(&#123;x0, y0&#125;);</span><br><span class="line">        grid[x0][y0] = 0;//访问过</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        x = q.front()[0];</span><br><span class="line">        y = q.front()[1];</span><br><span class="line">        path.push_back(&#123;x-x0, y-y0&#125;);//路径记录相对坐标</span><br><span class="line">        q.pop();</span><br><span class="line">        for(k = 0; k &lt; 4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">        nx = x + dir[k][0];</span><br><span class="line">        ny = y + dir[k][1];</span><br><span class="line">        if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny])</span><br><span class="line">        &#123;</span><br><span class="line">        q.push(&#123;nx, ny&#125;);</span><br><span class="line">        grid[nx][ny] = 0;//访问过</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(path);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="题解DFS"><a href="#题解DFS" class="headerlink" title="题解DFS"></a>题解DFS</h2><details>    <summary>DFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    int m, n;</span><br><span class="line">    set&lt;vector&lt;vector&lt;int&gt;&gt;&gt; s;</span><br><span class="line">public:</span><br><span class="line">    int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if(grid.empty() || grid[0].empty()) return 0;</span><br><span class="line">        m = grid.size(), n = grid[0].size();</span><br><span class="line">        for(int i = 0, j; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(j = 0; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 0)</span><br><span class="line">                    continue;</span><br><span class="line">                vector&lt;vector&lt;int&gt;&gt; path;</span><br><span class="line">                grid[i][j] = 0;//访问过</span><br><span class="line">                DFS(grid,i,j,i,j,path);</span><br><span class="line">                s.insert(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x0, int y0, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; path)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(&#123;x-x0, y-y0&#125;);//路径记录相对坐标</span><br><span class="line">        int k, nx, ny;</span><br><span class="line">        for(k = 0; k &lt; 4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            nx = x + dir[k][0];</span><br><span class="line">            ny = y + dir[k][1];</span><br><span class="line">            if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny])</span><br><span class="line">            &#123;</span><br><span class="line">                grid[nx][ny] = 0;//访问过</span><br><span class="line">                DFS(grid, x0, y0, nx, ny, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>DFS II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: a list of lists of integers</span><br><span class="line">     * @return: return an integer, denote the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    int n, m, ix, iy;</span><br><span class="line">    set&lt;string&gt; S;</span><br><span class="line">    string temp;</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; vis;</span><br><span class="line">    int fx[4]=&#123;</span><br><span class="line">        1, -1, 0, 0</span><br><span class="line">    &#125;;</span><br><span class="line">    int fy[4]=&#123;</span><br><span class="line">        0, 0, 1, -1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int numberofDistinctIslands(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        n = grid.size();</span><br><span class="line">        m = grid[0].size();</span><br><span class="line">        vector&lt;bool&gt; p;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            p.push_back(false);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            vis.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1 &amp;&amp; !vis[i][j]) &#123;</span><br><span class="line">                    ix = i;</span><br><span class="line">                    iy = j;</span><br><span class="line">                    temp = &quot;&quot;;</span><br><span class="line">                    dfs(i, j, grid);</span><br><span class="line">                    S.insert(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return S.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        vis[x][y] = true;</span><br><span class="line">        temp += to_string(x - ix) + &quot;&quot; + to_string(y - iy);</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int nx = x + fx[i], ny = y + fy[i];</span><br><span class="line">            if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || grid[nx][ny] == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(nx, ny, grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。&lt;/p&gt;
&lt;p&gt;请你计算这个网格中共有多少个形状不同的岛屿。&lt;br&gt;两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bread-first Search" scheme="http://yoursite.com/tags/Bread-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>305. 岛屿数量 II</title>
    <link href="http://yoursite.com/2021/03/30/305.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%20II/"/>
    <id>http://yoursite.com/2021/03/30/305. 岛屿数量 II/</id>
    <published>2021-03-30T09:47:12.000Z</published>
    <updated>2021-03-31T03:29:02.064Z</updated>
    
    <content type="html"><![CDATA[<p>假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。</p><p>起始的时候，每个格子的地形都被默认标记为「水」。<br>我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。</p><p>你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。</p><a id="more"></a><p>注意：一个岛的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。<br>你可以假设地图网格的四边均被无边无际的「水」所包围。</p><p>请仔细阅读下方示例与解析，更加深入了解岛屿的判定。</p><p>示例:</p><pre><code>输入: m = 3, n = 3,     positions = [[0,0], [0,1], [1,2], [2,1]]输出: [1,1,2,3]解析:起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）0 0 00 0 00 0 0操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。1 0 00 0 0   Number of islands = 10 0 0操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。1 1 00 0 0   岛屿的数量为 10 0 0操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。1 1 00 0 1   岛屿的数量为 20 0 0操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。1 1 00 0 1   岛屿的数量为 30 1 0拓展：你是否能在 O(k log mn) 的时间复杂度程度内完成每次的计算？（k 表示 positions 的长度）</code></pre><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>题目在Lintcode上也有，参见<a href="https://www.lintcode.com/problem/434/" target="_blank" rel="noopener">^1</a></p><h1 id="题解（超时）"><a href="#题解（超时）" class="headerlink" title="题解（超时）"></a>题解（超时）</h1><p>将矩阵的每个位置看成并查集中的一个点，每次加入一个岛屿，把四周是1的点合并掉</p><p>计算集团个数</p><details>    <summary>题解（超时）</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class dsu</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; f;</span><br><span class="line"></span><br><span class="line">    dsu(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)</span><br><span class="line">            f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        int fa = find(a);</span><br><span class="line">        int fb = find(b);</span><br><span class="line">        f[fa] = fb;</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        int origin = a;</span><br><span class="line">        while(a != f[a])</span><br><span class="line">            a = f[a];</span><br><span class="line">        return f[origin] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    int countUni(vector&lt;vector&lt;int&gt;&gt; &amp;grid)</span><br><span class="line">    &#123;</span><br><span class="line">        int count = 0, x, y, n = grid[0].size();</span><br><span class="line">        for(int i = 0; i &lt; f.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = i/n, y = i-x*n;</span><br><span class="line">            if(i == find(i) &amp;&amp; grid[x][y]==1)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    int N = m*n, pos, x, y;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(m,vector&lt;int&gt;(n,0));</span><br><span class="line">    dsu u(N);</span><br><span class="line">    vector&lt;int&gt; ans(positions.size());</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    for(int i = 0, k; i &lt; positions.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            grid[positions[i][0]][positions[i][1]] = 1;//标记为岛屿</span><br><span class="line">            pos = positions[i][0]*n+positions[i][1];//对应并查集中的位置</span><br><span class="line">    for(k = 0; k &lt; 4; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">    x = positions[i][0] + dir[k][0];</span><br><span class="line">                y = positions[i][1] + dir[k][1];//周围坐标x,y</span><br><span class="line">    if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; grid[x][y]==1)</span><br><span class="line">    u.merge(pos, x*n+y);//合并</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = u.countUni(grid);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h1 id="题解（改进仍不能通过）"><a href="#题解（改进仍不能通过）" class="headerlink" title="题解（改进仍不能通过）"></a>题解（改进仍不能通过）</h1><p>并查集merge 函数返回是否被合并了，合并了数量就减1</p><p>注意有重复岛屿，不能算</p><p>这种算法改进后在lintcode上运行了一次还是超时，只能通过30%的样例</p><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class dsu</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; f;</span><br><span class="line">    dsu(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)</span><br><span class="line">            f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    bool merge(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        int fa = find(a);</span><br><span class="line">        int fb = find(b);</span><br><span class="line">        if(fa != fb)</span><br><span class="line">        &#123;</span><br><span class="line">            f[fa] = fb;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//返回是否被合并了</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        int origin = a;</span><br><span class="line">        while(a != f[a])</span><br><span class="line">            a = f[a];</span><br><span class="line">        return f[origin] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    int N = m*n, pos, x, y;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(m,vector&lt;int&gt;(n,0));</span><br><span class="line">    dsu u(N);</span><br><span class="line">    vector&lt;int&gt; ans(positions.size());</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">        unordered_set&lt;int&gt; s;//有重复的岛屿！！！</span><br><span class="line">    for(int i = 0, k; i &lt; positions.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            ans[i] = (i&gt;0 ? ans[i-1] : 0 )+1;//先把这个岛屿算作孤立+1</span><br><span class="line">            grid[positions[i][0]][positions[i][1]] = 1;//标记为岛屿</span><br><span class="line">            pos = positions[i][0]*n+positions[i][1];//对应并查集中的位置</span><br><span class="line">            if(s.count(pos))//有该岛屿了，重复添加</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i]--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(pos);</span><br><span class="line">    for(k = 0; k &lt; 4; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">    x = positions[i][0] + dir[k][0];</span><br><span class="line">                y = positions[i][1] + dir[k][1];//周围坐标x,y</span><br><span class="line">    if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; grid[x][y]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(u.merge(pos, x*n+y))//合并了</span><br><span class="line">                        ans[i]--;//减1</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h1 id="题解（通过）"><a href="#题解（通过）" class="headerlink" title="题解（通过）"></a>题解（通过）</h1><p>构建数组nums表示所有位置对应岛屿的数字，初始化为0。遍历数组并将岛屿的值初始化为位置的值，此时岛屿数目+1，之后遍历此位置的邻接位置，若已经编号的岛屿，则将改岛屿的编号改为邻接岛屿编号，由于岛屿融合，岛屿的总数目-1。</p><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#ifndef C434_H</span><br><span class="line">#define C434_H</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">* 岛屿的个数II</span><br><span class="line">*</span><br><span class="line">* 给定 n，m，分别代表一个2D矩阵的行数和列数，同时，给定一个大小为 k 的二元数组A。起初，2D矩阵的行数和列数均为 0，即该矩阵中只有海洋。二元数组有 k 个运算符，每个运算符有 2 个整数 A[i].x, A[i].y，你可通过改变矩阵网格中的A[i].x]，[A[i].y] 来将其由海洋改为岛屿。请在每次运算后，返回矩阵中岛屿的数量。</span><br><span class="line">* 注意事项</span><br><span class="line">* 0 代表海，1 代表岛。如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</span><br><span class="line">* 样例</span><br><span class="line">* 给定 n = 3, m = 3， 二元数组 A = [(0,0),(0,1),(2,2),(2,1)].</span><br><span class="line">* 返回 [1,1,2,2].</span><br><span class="line">*/</span><br><span class="line">struct Point&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    Point() :x(0), y(0)&#123;&#125;</span><br><span class="line">    Point(int a, int b) :x(a), y(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">    * @param n: An integer</span><br><span class="line">    * @param m: An integer</span><br><span class="line">    * @param operators: an array of point</span><br><span class="line">    * @return: an integer array</span><br><span class="line">    */</span><br><span class="line">    vector&lt;int&gt; numIslands2(int n, int m, vector&lt;Point&gt; &amp;operators) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (n &lt;= 0 || m &lt;= 0 || operators.empty())</span><br><span class="line">            return res;</span><br><span class="line">        vector&lt;int&gt; nums(n*m + 1, 0);//下标表示岛屿位置</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dic&#123; &#123; 1, 0 &#125;, &#123; -1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 0, -1 &#125; &#125;;//方便遍历上下左右四个位置</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (auto c : operators)</span><br><span class="line">        &#123;</span><br><span class="line">            int pos = c.x*m + c.y + 1;</span><br><span class="line">            //若nums[pos]不为0,则岛屿已经出现过,直接返回现有的岛屿数目</span><br><span class="line">            if (nums[pos] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //初始化nums[pos]为pos,表示pos最高层的岛屿是本身,此时岛屿数+1</span><br><span class="line">            nums[pos] = pos;</span><br><span class="line">            count++;</span><br><span class="line">            for (auto t : dic)</span><br><span class="line">            &#123;</span><br><span class="line">                int a = c.x + t[0];</span><br><span class="line">                int b = c.y + t[1];</span><br><span class="line">                int tmp = a*m + b + 1;</span><br><span class="line">                if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || nums[tmp] == 0)</span><br><span class="line">                    continue;</span><br><span class="line">                //tmp表示pos的相邻位置,root为tmp的最高层岛屿</span><br><span class="line">                //root!=pos表示pos与root并不属于同一个大岛屿,把pos并入root所在的大岛,</span><br><span class="line">                //nums[pos]=root,并将pos置为root避免重复计算,此时岛屿数目-1</span><br><span class="line">                int root = unionSearch(tmp, nums);</span><br><span class="line">                if (root != pos)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[pos] = root;</span><br><span class="line">                    pos = root;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(count);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //寻找root的最高层岛屿</span><br><span class="line">    int unionSearch(int root, vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        while (root != nums[root])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[root] = nums[nums[root]];</span><br><span class="line">            root = nums[root];</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。&lt;/p&gt;
&lt;p&gt;起始的时候，每个格子的地形都被默认标记为「水」。&lt;br&gt;我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。&lt;/p&gt;
&lt;p&gt;你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>572. 另一个树的子树</title>
    <link href="http://yoursite.com/2021/03/29/572.%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>http://yoursite.com/2021/03/29/572. 另一个树的子树/</id>
    <published>2021-03-29T12:55:12.000Z</published>
    <updated>2021-03-29T13:17:08.112Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><a id="more"></a><p>示例 1:</p><p>给定的树 s:</p><pre><code>    3   / \  4   5 / \1   2</code></pre><p>给定的树 t：</p><pre><code>   4   / \ 1   2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</code></pre><p>示例 2:</p><p>给定的树 s：</p><pre><code>    3   / \  4   5 / \1   2   /  0</code></pre><p>给定的树 t：</p><pre><code>   4  / \ 1   2返回 false。</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：深度优先搜索暴力匹配"><a href="#方法一：深度优先搜索暴力匹配" class="headerlink" title="方法一：深度优先搜索暴力匹配"></a>方法一：深度优先搜索暴力匹配</h2><p><strong>思路和算法</strong></p><p>这是一种最朴素的方法——深度优先搜索枚举 <em>s</em> 中的每一个节点，判断这个点的子树是否和 <em>t</em> 相等。如何判断一个节点的子树是否和 <em>t</em> 相等呢，我们又需要做一次深度优先搜索来检查，即让两个指针一开始先指向该节点和 <em>t</em> 的根，然后「同步移动」两根指针来「同步遍历」这两棵树，判断对应位置是否相等。</p><details>    <summary>深度优先搜索暴力匹配C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o &amp;&amp; !t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((o &amp;&amp; !t) || (!o &amp;&amp; t) || (o-&gt;val != t-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(o-&gt;left, t-&gt;left) &amp;&amp; check(o-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(o, t) || dfs(o-&gt;left, t) || dfs(o-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索暴力匹配Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s, t) || dfs(s.left, t) || dfs(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.val != t.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s.left, t.left) &amp;&amp; check(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索暴力匹配Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(a, b *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> || b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a.Val == b.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> check(a.Left, b.Left) &amp;&amp; check(a.Right, b.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法二：深度优先搜索序列上做串匹配"><a href="#方法二：深度优先搜索序列上做串匹配" class="headerlink" title="方法二：深度优先搜索序列上做串匹配"></a>方法二：深度优先搜索序列上做串匹配</h2><p><strong>思路和算法</strong></p><p>这个方法需要我们先了解一个「小套路」：一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的。了解了这个「小套路」之后，我们可以确定解决这个问题的方向就是：把 <em>s</em> 和 <em>t</em> 先转换成深度优先搜索序列，然后看 <em>t</em> 的深度优先搜索序列是否是 <em>s</em> 的深度优先搜索序列的「子串」。</p><p><strong>这样做正确吗？</strong> 假设 <em>s</em> 由两个点组成，<em>1</em> 是根，<em>2</em> 是 <em>1</em> 的左孩子；<em>t</em> 也由两个点组成，<em>1</em> 是根，<em>2</em> 是 <em>1</em> 的右孩子。这样一来 <em>s</em> 和 <em>t</em> 的深度优先搜索序列相同，可是 <em>t</em> 并不是 <em>s</em> 的某一棵子树。由此可见「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」是「<em>t</em> 是 <em>s</em> 子树」的<strong>必要不充分条件</strong>，所以单纯这样做是不正确的。</p><p>为了解决这个问题，我们可以引入两个空值 <code>lNull</code> 和 <code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样深度优先搜索序列就唯一对应一棵树。处理完之后，就可以通过判断「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」来判断答案。</p><p><a href="https://assets.leetcode-cn.com/solution-static/572/572_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>在判断「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法，在使用Rabin-Karp算法的时候，要注意串中可能有负值。</p><p>这里给出用KMP判断的代码实现。</p><details><summary>深度优先搜索序列上做串匹配C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sOrder, tOrder;</span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode *o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxElement = max(maxElement, o-&gt;val);</span><br><span class="line">        getMaxElement(o-&gt;left);</span><br><span class="line">        getMaxElement(o-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode *o, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar.push_back(o-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            getDfsOrder(o-&gt;left, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.push_back(lNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            getDfsOrder(o-&gt;right, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.push_back(rNull);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fail(tOrder.size(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; tOrder[i] != tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tOrder[i] == tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sOrder[i] != tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sOrder[i] == tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        maxElement = INT_MIN;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>深度优先搜索序列上做串匹配Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;Integer&gt; tOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        maxElement = Integer.MIN_VALUE;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxElement = Math.max(maxElement, t.val);</span><br><span class="line">        getMaxElement(t.left);</span><br><span class="line">        getMaxElement(t.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode t, List&lt;Integer&gt; tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar.add(t.val);</span><br><span class="line">        <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getDfsOrder(t.left, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.add(lNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getDfsOrder(t.right, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.add(rNull);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[tOrder.size()];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = -<span class="number">1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>深度优先搜索序列上做串匹配Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    maxEle := math.MinInt32</span><br><span class="line">    getMaxElement(s, &amp;maxEle)</span><br><span class="line">    getMaxElement(t, &amp;maxEle)</span><br><span class="line">    lNull := maxEle + <span class="number">1</span>;</span><br><span class="line">    rNull := maxEle + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sl, tl := getDfsOrder(s, []<span class="keyword">int</span>&#123;&#125;, lNull, rNull), getDfsOrder(t, []<span class="keyword">int</span>&#123;&#125;, lNull, rNull)</span><br><span class="line">    <span class="keyword">return</span> kmp(sl, tl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(s, t []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sLen, tLen := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">    fail := <span class="built_in">make</span>([]<span class="keyword">int</span>, sLen)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sLen; i++ &#123;</span><br><span class="line">        fail[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">-1</span>; i &lt; tLen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; t[i] != t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> t[i] == t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        fail[i] = j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">-1</span>; i &lt; sLen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == tLen - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDfsOrder</span><span class="params">(t *TreeNode, list []<span class="keyword">int</span>, lNull, rNull <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">    list = <span class="built_in">append</span>(list, t.Val)</span><br><span class="line">    <span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        list = getDfsOrder(t.Left, list, lNull, rNull)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, lNull)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        list = getDfsOrder(t.Right, list, lNull, rNull)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, rNull)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxElement</span><span class="params">(t *TreeNode, maxEle *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.Val &gt; *maxEle &#123;</span><br><span class="line">        *maxEle = t.Val</span><br><span class="line">    &#125;</span><br><span class="line">    getMaxElement(t.Left, maxEle)</span><br><span class="line">    getMaxElement(t.Right, maxEle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法三：树哈希"><a href="#方法三：树哈希" class="headerlink" title="方法三：树哈希"></a>方法三：树哈希</h2><p><strong>思路和算法</strong></p><p>考虑把每个子树都映射成一个唯一的数，如果 <em>t</em> 对应的数字和 <em>s</em> 中任意一个子树映射的数字相等，则 <em>t</em> 是 <em>s</em> 的某一棵子树。如何映射呢？我们可以定义这样的哈希函数：</p><details><summary>树哈希C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1E9</span>) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> p[MAX_N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> f, s; <span class="comment">// f 为哈希值 | s 为子树大小</span></span><br><span class="line">        Status(<span class="keyword">int</span> f_ = <span class="number">0</span>, <span class="keyword">int</span> s_ = <span class="number">0</span>) </span><br><span class="line">            : f(f_), s(s_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; hS, hT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *o, <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">        h[o] = Status(o-&gt;val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!o-&gt;left &amp;&amp; !o-&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            dfs(o-&gt;left, h);</span><br><span class="line">            h[o].s += h[o-&gt;left].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">31L</span>L * h[o-&gt;left].f * p[h[o-&gt;left].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            dfs(o-&gt;right, h);</span><br><span class="line">            h[o].s += h[o-&gt;right].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">179L</span>L * h[o-&gt;right].f * p[h[o-&gt;right].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT[t].f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: hS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.f == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>树哈希Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_N = <span class="number">1005</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_N];</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; hS = <span class="keyword">new</span> HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt;();</span><br><span class="line">    Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; hT = <span class="keyword">new</span> HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT.get(t)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;TreeNode, <span class="keyword">int</span>[]&gt; entry : hS.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()[<span class="number">0</span>] == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                p[++tot] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode o, Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; h)</span> </span>&#123;</span><br><span class="line">        h.put(o, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;o.val, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span> (o.left == <span class="keyword">null</span> &amp;&amp; o.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(o.left, h);</span><br><span class="line">            <span class="keyword">int</span>[] val = h.get(o);</span><br><span class="line">            val[<span class="number">1</span>] += h.get(o.left)[<span class="number">1</span>];</span><br><span class="line">            val[<span class="number">0</span>] = (<span class="keyword">int</span>) ((val[<span class="number">0</span>] + (<span class="number">31L</span> * h.get(o.left)[<span class="number">0</span>] * p[h.get(o.left)[<span class="number">1</span>]]) % MOD) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(o.right, h);</span><br><span class="line">            <span class="keyword">int</span>[] val = h.get(o);</span><br><span class="line">            val[<span class="number">1</span>] += h.get(o.right)[<span class="number">1</span>];</span><br><span class="line">            val[<span class="number">0</span>] = (<span class="keyword">int</span>) ((val[<span class="number">0</span>] + (<span class="number">179L</span> * h.get(o.right)[<span class="number">0</span>] * p[h.get(o.right)[<span class="number">1</span>]]) % MOD) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="http://yoursite.com/2021/03/27/491.%20%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/27/491. 递增子序列/</id>
    <published>2021-03-27T13:17:12.000Z</published>
    <updated>2021-03-28T01:00:59.596Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。</p><a id="more"></a><p>示例：</p><pre><code>输入：[4, 6, 7, 7]输出：[[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</code></pre><p>提示：</p><pre><code>给定数组的长度不会超过15。数组中的整数范围是 [-100,100]。给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</code></pre><h1 id="方法一：二进制枚举-哈希"><a href="#方法一：二进制枚举-哈希" class="headerlink" title="方法一：二进制枚举 + 哈希"></a>方法一：二进制枚举 + 哈希</h1><p>这个方法比较难理解，可以参见<a href="https://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，</p><h1 id="方法二：递归枚举-减枝"><a href="#方法二：递归枚举-减枝" class="headerlink" title="方法二：递归枚举 + 减枝"></a>方法二：递归枚举 + 减枝</h1><p><strong>思路与算法</strong></p><p>我们也可以用递归的方法实现二进制枚举，像「方法一」那样枚举出所有的子序列，然后判断是否合法。直接把方法一变成递归形式，我们可以得到这样的代码：</p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.size()) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.push_back(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.add(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这是一个递归枚举子序列的通用模板.</p><p>当然，如果我们简单地这样枚举，对于每一个子序列，我们还需要做一次 <em>O(n)</em> 的合法性检查和哈希判重复，在执行整个程序的过程中，我们还需要使用一个空间代价 <em>O(2^n)</em> 的哈希表来维护已经出现的子序列的哈希值。我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的都是合法的并且不重复：</p><ul><li><p>使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的</p></li><li><p>那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：</p><ol><li><p>前者被选择，后者被选择</p></li><li><p>前者被选择，后者不被选择</p></li><li><p>前者不被选择，后者被选择</p></li><li><p>前者不被选择，后者不被选择</p><p>其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。</p></li></ol></li></ul><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">            temp.push_back(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, INT_MIN, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, Integer.MIN_VALUE, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">            temp.add(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** ans;</span><br><span class="line"><span class="keyword">int</span> ansSize;</span><br><span class="line"><span class="keyword">int</span>* temp;</span><br><span class="line"><span class="keyword">int</span> tempSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempSize &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ans[ansSize] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * tempSize);</span><br><span class="line">            <span class="built_in">memcpy</span>(ans[ansSize], temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * tempSize);</span><br><span class="line">            (*returnColumnSizes)[ansSize++] = tempSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">        temp[tempSize++] = nums[cur];</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums[cur], nums, numsSize, returnColumnSizes);</span><br><span class="line">        tempSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">        dfs(cur + <span class="number">1</span>, last, nums, numsSize, returnColumnSizes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">findSubsequences</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">32768</span>);</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">32768</span>);</span><br><span class="line">    temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    ansSize = tempSize = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, INT_MIN, nums, numsSize, returnColumnSizes);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    temp []<span class="keyword">int</span></span><br><span class="line">    ans [][]<span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubsequences</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans = [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, math.MinInt32, nums)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(cur, last <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> cur == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            t := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(temp))</span><br><span class="line">            <span class="built_in">copy</span>(t, temp)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, t)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[cur] &gt;= last &#123;</span><br><span class="line">        temp = <span class="built_in">append</span>(temp, nums[cur])</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums[cur], nums)</span><br><span class="line">        temp = temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[cur] != last &#123;</span><br><span class="line">        dfs(cur + <span class="number">1</span>, last, nums)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(2^n * n)  。仍然需要对子序列做二进制枚举，枚举出的序列虽然省去了判断合法性和哈希的过程，但是仍然需要 <em>O(n)</em> 的时间添加到答案中。</li><li>空间复杂度：<em>O(n)</em>。这里临时数组的空间代价是 <em>O(n)</em>，递归使用的栈空间的空间代价也是 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="http://yoursite.com/2021/03/27/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://yoursite.com/2021/03/27/304. 二维区域和检索 - 矩阵不可变/</id>
    <published>2021-03-27T01:17:12.000Z</published>
    <updated>2021-03-27T02:09:08.055Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。</p><a id="more"></a><p>上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。</p><p>示例：</p><pre><code>给定 matrix = [  [3, 0, 1, 4, 2],  [5, 6, 3, 2, 1],  [1, 2, 0, 1, 5],  [4, 1, 0, 1, 7],  [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12</code></pre><p>提示：</p><pre><code>你可以假设矩阵不可变。会多次调用 sumRegion 方法。你可以假设 row1 ≤ row2 且 col1 ≤ col2 。</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看完题目要求先想到的当然就是双重循环直接求和了，而且还能通过。再一细想，其实可以直接计算每个点上以其作为左上角的到大矩阵右下角的矩形面积，保存起来后每次要求给定坐标的矩形面积时只需要把上下左右四个角的点保存的面积做个加减就可以了,但这样写完却在调用sumRegion方法很多的用例那里超时了。</p><details>    <summary>预处理左上角面积（超时）</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix &#123;</span><br><span class="line"></span><br><span class="line">    public int[][] sum;</span><br><span class="line">    public NumMatrix(int[][] matrix) &#123;</span><br><span class="line">        sum = new int[matrix.length][matrix[0].length];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; matrix[0].length; j++) &#123;</span><br><span class="line">                for (int k = i; k &lt; matrix.length; k++) &#123;</span><br><span class="line">                    for (int l = j; l &lt; matrix[0].length; l++) &#123;</span><br><span class="line">                        sum[i][j] += matrix[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">//                System.out.printf(&quot;%d &quot;, sum[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">//            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumRegion(int row1, int col1, int row2, int col2) &#123;</span><br><span class="line"></span><br><span class="line">        int leftBottom,rightTop,rightBottom;</span><br><span class="line">        leftBottom = (row2 + 1 &lt; sum.length) ? sum[row2 + 1][col1] : 0;</span><br><span class="line">        rightTop = (col2 + 1 &lt; sum[0].length) ? sum[row1][col2 + 1] : 0;</span><br><span class="line">        rightBottom = ((row2 + 1 &lt; sum.length) &amp;&amp; (col2 + 1 &lt; sum[0].length)) ? sum[row2 + 1][col2 + 1] : 0;</span><br><span class="line">        return sum[row1][col1] - leftBottom - rightTop + rightBottom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>考虑一下更好的方法可以保存一维前缀和或者二维前缀和<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/" target="_blank" rel="noopener">^1</a></p><p>这里的核心思想是保存以每个点作为右下角的位置，这样初识构造时循环时避免了四重循环，其实我上面的做法逆向循环也可以避免四重循环。更为重要的是，我上面的算法里之所以超时是因为在sumRegion里每次都要判断是否越界，所以可以定义一个大一号的数组来保存，这样就把判断的操作挪到读数组元素里了，用空间换时间。</p><details>    <summary>二维前缀和(预处理左上角面积)</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix &#123;</span><br><span class="line">    public int[][] sum;</span><br><span class="line">    public NumMatrix(int[][] matrix) &#123;</span><br><span class="line">        sum = new int[matrix.length+1][matrix[0].length+1];</span><br><span class="line">        for (int i = matrix.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = matrix[0].length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                sum[i][j] = matrix[i][j] + sum[i + 1][j] + sum[i][j + 1] - sum[i + 1][j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sumRegion(int row1, int col1, int row2, int col2) &#123;</span><br><span class="line">        return sum[row1][col1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row2 + 1][col2 + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>456. 132 模式</title>
    <link href="http://yoursite.com/2021/03/25/456.%20132%20%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/03/25/456. 132 模式/</id>
    <published>2021-03-25T07:29:12.000Z</published>
    <updated>2021-03-25T10:23:58.543Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</p><p>如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</p><a id="more"></a><p>进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？</p><p>示例 1：</p><pre><code>输入：nums = [1,2,3,4]输出：false解释：序列中不存在 132 模式的子序列。</code></pre><p>示例 2：</p><pre><code>输入：nums = [3,1,4,2]输出：true解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</code></pre><p>示例 3：</p><pre><code>输入：nums = [-1,3,2,0]输出：true解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</code></pre><p>提示：</p><pre><code>n == nums.length1 &lt;= n &lt;= 104-10^9 &lt;= nums[i] &lt;= 10^9</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于本题中 <em>n</em> 的最大值可以到 <em>15000*，因此对于一个满足 *132</em> 模式的三元组下标 <em>(i, j, k)*，枚举其中的 *2</em> 个下标时间复杂度为 <em>O(n^2)</em>，很容易超出时间限制。</p><p>因此我们可以考虑枚举其中的 <em>1</em> 个下标，并使用合适的数据结构维护另外的 <em>2</em> 个下标的可能值。</p><h1 id="方法一：枚举-3"><a href="#方法一：枚举-3" class="headerlink" title="方法一：枚举 3"></a>方法一：枚举 <em>3</em></h1><p><strong>思路与算法</strong></p><p>枚举 <em>3</em> 是容易想到并且也是最容易实现的。由于 <em>3</em> 是模式中的最大值，并且其出现在 <em>1</em> 和 <em>2</em> 的中间，因此我们只需要从左到右枚举 <em>3</em> 的下标 <em>j</em>，那么：</p><ul><li><p>由于 <em>1</em> 是模式中的最小值，因此我们在枚举 <em>j</em> 的同时，维护数组 <em>a</em> 中左侧元素 <em>a[0..j-1]</em> 的最小值，即为 <em>1</em> 对应的元素 <em>a[i]*。需要注意的是，只有 *a[i] &lt; a[j]</em> 时，<em>a[i]</em> 才能作为 <em>1</em> 对应的元素；</p></li><li><p>由于 <em>2</em> 是模式中的次小值，因此我们可以使用一个有序集合（例如平衡树）维护数组 <em>a</em> 中右侧元素 <em>a[j+1..n-1]</em> 中的所有值。当我们确定了 <em>a[i]</em> 和 <em>a[j]</em> 之后，只需要在有序集合中查询严格比 <em>a[i]</em> 大的那个最小的元素，即为 <em>a[k]*。需要注意的是，只有 *a[k] &lt; a[j]</em> 时，<em>a[k]</em> 才能作为 <em>3</em> 对应的元素。</p></li></ul><p><strong>代码</strong></p><p>下面的 Python 代码需要手动导入 sortedcontainers  库。</p><details>    <summary>枚举3 C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左侧最小值</span></span><br><span class="line">        <span class="keyword">int</span> left_min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 右侧所有元素</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; right_all;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            right_all.insert(nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left_min &lt; nums[j]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = right_all.upper_bound(left_min);</span><br><span class="line">                <span class="keyword">if</span> (it != right_all.end() &amp;&amp; *it &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left_min = min(left_min, nums[j]);</span><br><span class="line">            right_all.erase(right_all.find(nums[j + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举3 Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左侧最小值</span></span><br><span class="line">        <span class="keyword">int</span> leftMin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 右侧所有元素</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; rightAll = <span class="keyword">new</span> TreeMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            rightAll.put(nums[k], rightAll.getOrDefault(nums[k], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMin &lt; nums[j]) &#123;</span><br><span class="line">                Integer next = rightAll.ceilingKey(leftMin + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            leftMin = Math.min(leftMin, nums[j]);</span><br><span class="line">            rightAll.put(nums[j + <span class="number">1</span>], rightAll.get(nums[j + <span class="number">1</span>]) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (rightAll.get(nums[j + <span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">                rightAll.remove(nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举3 Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左侧最小值</span></span><br><span class="line">        left_min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 右侧所有元素</span></span><br><span class="line">        right_all = SortedList(nums[<span class="number">2</span>:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> left_min &lt; nums[j]:</span><br><span class="line">                index = right_all.bisect_right(left_min)</span><br><span class="line">                <span class="keyword">if</span> index &lt; len(right_all) <span class="keyword">and</span> right_all[index] &lt; nums[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            left_min = min(left_min, nums[j])</span><br><span class="line">            right_all.remove(nums[j + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>枚举3 Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    ch       [<span class="number">2</span>]*node</span><br><span class="line">    priority <span class="keyword">int</span></span><br><span class="line">    val      <span class="keyword">int</span></span><br><span class="line">    cnt      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *node)</span> <span class="title">cmp</span><span class="params">(b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b &lt; o.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> b &gt; o.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *node)</span> <span class="title">rotate</span><span class="params">(d <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    x := o.ch[d^<span class="number">1</span>]</span><br><span class="line">    o.ch[d^<span class="number">1</span>] = x.ch[d]</span><br><span class="line">    x.ch[d] = o</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> treap <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> _<span class="title">put</span><span class="params">(o *node, val <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;node&#123;priority: rand.Int(), val: val, cnt: <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d := o.cmp(val); d &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        o.ch[d] = t._put(o.ch[d], val)</span><br><span class="line">        <span class="keyword">if</span> o.ch[d].priority &gt; o.priority &#123;</span><br><span class="line">            o = o.rotate(d ^ <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o.cnt++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> <span class="title">put</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t.root = t._put(t.root, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> _<span class="title">delete</span><span class="params">(o *node, val <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d := o.cmp(val); d &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        o.ch[d] = t._delete(o.ch[d], val)</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> o.cnt &gt; <span class="number">1</span> &#123;</span><br><span class="line">        o.cnt--</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> o.ch[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.ch[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> o.ch[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.ch[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    d := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> o.ch[<span class="number">0</span>].priority &gt; o.ch[<span class="number">1</span>].priority &#123;</span><br><span class="line">        d = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    o = o.rotate(d)</span><br><span class="line">    o.ch[d] = t._delete(o.ch[d], val)</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> <span class="title">delete</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t.root = t._delete(t.root, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> <span class="title">upperBound</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(ub *node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> o := t.root; o != <span class="literal">nil</span>; &#123;</span><br><span class="line">        <span class="keyword">if</span> o.cmp(val) == <span class="number">0</span> &#123;</span><br><span class="line">            ub = o</span><br><span class="line">            o = o.ch[<span class="number">0</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = o.ch[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find132pattern</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftMin := nums[<span class="number">0</span>]</span><br><span class="line">    rights := &amp;treap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums[<span class="number">2</span>:] &#123;</span><br><span class="line">        rights.put(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; leftMin &#123;</span><br><span class="line">            ub := rights.upperBound(leftMin)</span><br><span class="line">            <span class="keyword">if</span> ub != <span class="literal">nil</span> &amp;&amp; ub.val &lt; nums[j] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftMin = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">        rights.<span class="built_in">delete</span>(nums[j+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogn)  。在初始化时，我们需要 O(nlogn)  的时间将数组元素 <em>a[2..n-1]</em> 加入有序集合中。在枚举 <em>j</em> 时，维护左侧元素最小值的时间复杂度为 <em>O(1)*，将 *a[j+1]</em> 从有序集合中删除的时间复杂度为 O(logn)，总共需要枚举的次数为 <em>O(n)</em>，因此总时间复杂度为 O(nlogn) 。</p></li><li><p>空间复杂度：<em>O(n)</em>，即为有序集合存储右侧所有元素需要使用的空间。</p></li></ul><h1 id="方法二：枚举-1"><a href="#方法二：枚举-1" class="headerlink" title="方法二：枚举 1"></a>方法二：枚举 <em>1</em></h1><p><strong>思路与算法</strong></p><p>如果我们从左到右枚举 <em>1</em> 的下标 <em>i</em>，那么 <em>j, k</em> 的下标范围都是减少的，这样就不利于对它们进行维护。因此我们可以考虑从右到左枚举 <em>i</em>。</p><p>那么我们应该如何维护 <em>j, k</em> 呢？在 <em>132</em> 模式中，如果 <em>1&lt;2</em> 并且 <em>2&lt;3<em>，那么根据传递性，</em>1&lt;3</em> 也是成立的，那么我们可以使用下面的方法进行维护：</p><ul><li><p>我们使用一种数据结构维护所有遍历过的元素，它们作为 <em>2</em> 的候选元素。每当我们遍历到一个新的元素时，就将其加入数据结构中；</p></li><li><p>在遍历到一个新的元素的同时，我们可以考虑其是否可以作为 <em>3</em>。如果它作为 <em>3</em>，那么<strong>数据结构中所有严格小于它的元素都可以作为 <em>2</em></strong>，我们将这些元素全部从数据结构中移除，并且使用一个变量维护<strong>所有被移除的元素的最大值</strong>。这些被移除的元素都是可以真正作为 <em>2</em> 的，并且元素的值越大，那么我们之后找到 <em>1</em> 的机会也就越大。</p></li></ul><p>那么这个「数据结构」是什么样的数据结构呢？我们尝试提取出它进行的操作：</p><ul><li><p>它需要支持添加一个元素；</p></li><li><p>它需要支持移除所有严格小于给定阈值的所有元素；</p></li><li><p>上面两步操作是「依次进行」的，即我们先用给定的阈值移除元素，再将该阈值加入数据结构中。</p></li></ul><p>这就是「单调栈」。在单调栈中，从栈底到栈顶的元素是严格单调递减的。当给定阈值 <em>x</em> 时，我们只需要不断地弹出栈顶的元素，直到栈为空或者 <em>x</em> 严格小于栈顶元素。此时我们再将 <em>x</em> 入栈，这样就维护了栈的单调性。</p><p>因此，我们可以使用单调栈作为维护 <em>2</em> 的数据结构，并给出下面的算法：</p><ul><li><p>我们用单调栈维护所有可以作为 <em>2</em> 的候选元素。初始时，单调栈中只有唯一的元素a[n-1] 。我们还需要使用一个变量 max_k 记录所有可以真正作为 <em>2</em> 的元素的最大值；</p></li><li><p>随后我们从 <em>n-2</em> 开始从右到左枚举元素 <em>a[i]</em>：</p><ul><li><p>首先我们判断 <em>a[i]</em> 是否可以作为 <em>1</em>。如果 [a[i]&lt;max_k ，那么它就可以作为 <em>1</em>，我们就找到了一组满足 <em>132</em> 模式的三元组；</p></li><li><p>随后我们判断 <em>a[i]</em> 是否可以作为 <em>3</em>，以此找出哪些可以真正作为 <em>2</em> 的元素。我们将 <em>a[i]</em> 不断地与单调栈栈顶的元素进行比较，如果 <em>a[i]</em> 较大，那么栈顶元素可以真正作为 <em>2</em>，将其弹出并更新 max_k；</p></li><li><p>最后我们将 <em>a[i]</em> 作为 <em>2</em> 的候选元素放入单调栈中。这里可以进行一个优化，即如果a[i] &lt;= max_k ，那么我们也没有必要将 <em>a[i]</em> 放入栈中，因为即使它在未来被弹出，也不会将 max_k  更新为更大的值。</p></li></ul></li><li><p>在枚举完所有的元素后，如果仍未找到满足 <em>132</em> 模式的三元组，那就说明其不存在。</p></li></ul><h2 id="我的思路总结"><a href="#我的思路总结" class="headerlink" title="我的思路总结"></a>我的思路总结</h2><p>这个解法我看了几遍还是感觉很抽象，用自己的话总结一下就是用maxK来保存作为2的元素，单调栈里从栈顶到栈底是越来越大的，在while循环中的主要目的是找到一个nums[i]右侧比它小的最大元素，用它来作为2的元素maxK。这样后面的遍历中只要遇到一个比maxK小的元素就说明有了一个132的序列，while循环后把nums[i]放进单调栈，因为之前的while循环中已经把比maxK小的数都弹出栈了，所以这里放进单调栈就可以保证栈的顺序是单调的。后面的优化判断增大了阅读难度，一开始可以略去这个判断。</p><p><strong>代码</strong></p><details>    <summary>枚举1 C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; candidate_k;</span><br><span class="line">        candidate_k.push(nums[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> max_k = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; max_k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!candidate_k.empty() &amp;&amp; nums[i] &gt; candidate_k.top()) &#123;</span><br><span class="line">                max_k = candidate_k.top();</span><br><span class="line">                candidate_k.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max_k) &#123;</span><br><span class="line">                candidate_k.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; candidateK = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        candidateK.push(nums[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> maxK = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; maxK) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!candidateK.isEmpty() &amp;&amp; nums[i] &gt; candidateK.peek()) &#123;</span><br><span class="line">                maxK = candidateK.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxK) &#123;</span><br><span class="line">                candidateK.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        candidate_k = [nums[n - <span class="number">1</span>]]</span><br><span class="line">        max_k = float(<span class="string">"-inf"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; max_k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">while</span> candidate_k <span class="keyword">and</span> nums[i] &gt; candidate_k[<span class="number">-1</span>]:</span><br><span class="line">                max_k = candidate_k[<span class="number">-1</span>]</span><br><span class="line">                candidate_k.pop()</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; max_k:</span><br><span class="line">                candidate_k.append(nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find132pattern = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> candidate_k = [nums[n - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">let</span> max_k = -<span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; max_k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (candidate_k.length &amp;&amp; nums[i] &gt; candidate_k[candidate_k.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            max_k = candidate_k[candidate_k.length - <span class="number">1</span>];</span><br><span class="line">            candidate_k.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max_k) &#123;</span><br><span class="line">            candidate_k.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find132pattern</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    candidateK := []<span class="keyword">int</span>&#123;nums[n<span class="number">-1</span>]&#125;</span><br><span class="line">    maxK := math.MinInt64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; maxK &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(candidateK) &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; candidateK[<span class="built_in">len</span>(candidateK)<span class="number">-1</span>] &#123;</span><br><span class="line">            maxK = candidateK[<span class="built_in">len</span>(candidateK)<span class="number">-1</span>]</span><br><span class="line">            candidateK = candidateK[:<span class="built_in">len</span>(candidateK)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; maxK &#123;</span><br><span class="line">            candidateK = <span class="built_in">append</span>(candidateK, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numsSize;</span><br><span class="line">    <span class="keyword">int</span> candidate_k[n], top = <span class="number">0</span>;</span><br><span class="line">    candidate_k[top++] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max_k = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; max_k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; nums[i] &gt; candidate_k[top - <span class="number">1</span>]) &#123;</span><br><span class="line">            max_k = candidate_k[--top];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max_k) &#123;</span><br><span class="line">            candidate_k[top++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，枚举 *i</em> 的次数为 <em>O(n)</em>，由于每一个元素最多被加入和弹出单调栈各一次，因此操作单调栈的时间复杂度一共为 <em>O(n)</em>，总时间复杂度为 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(n)</em>，即为单调栈需要使用的空间。</p></li></ul><h1 id="方法三：枚举-2"><a href="#方法三：枚举-2" class="headerlink" title="方法三：枚举 2"></a>方法三：枚举 <em>2</em></h1><p><strong>说明</strong></p><p>方法三思路难度较大，需要在单调栈上进行二分查找。建议读者在完全理解方法二之后，再尝试阅读该方法。</p><p><strong>思路与算法</strong></p><p>当我们枚举 <em>2</em> 的下标 <em>k</em> 时，与方法二相反，从左到右进行枚举的方法是十分合理的：在枚举的过程中，<em>i, j</em> 的下标范围都是增加的。</p><p>由于我们需要保证 <em>1&lt;2</em> 并且 <em>2&lt;3*，那么我们需要维护一系列尽可能小的元素作为 *1</em> 的候选元素，并且维护一系列尽可能大的元素作为 <em>3</em> 的候选元素。</p><p>我们可以分情况进行讨论，假设当前有一个小元素 <em>x_i</em> 以及一个大元素 <em>x_j</em> 表示一个二元组，而我们当前遍历到了一个新的元素 <em>x=a[k]</em>，那么：</p><ul><li><p>如果 <em>x &gt; x_j*，那么让 *x</em> 作为 <em>3</em> 显然是比 <em>x_j</em> 作为 <em>3</em> 更优，因此我们可以用 <em>x</em> 替代 <em>x_j</em>；</p></li><li><p>如果 <em>x &lt; x_i*，那么让 *x</em> 作为 <em>1</em> 显然是比 <em>x_i</em> 作为 <em>3</em> 更优，然而我们必须要满足 <em>132</em> 模式中的顺序，即 <em>1</em> 出现在 <em>3</em> 之前，这里如果我们简单地用 <em>x</em> 替代 <em>x_i*，那么 *x_i=x</em> 作为 <em>1</em> 是出现在 <em>x_j</em> 作为 <em>3</em> 之后的，这并不满足要求。因此我们需要为 <em>x</em> 找一个新的元素作为 <em>3</em>。由于我们还没有遍历到后面的元素，因此可以简单地将 <em>x</em> 同时看作一个二元组的 <em>x_i</em> 和 <em>x_j</em>；</p></li><li><p>对于其它的情况，xi&lt;=x&lt;=xj ，<em>x</em> 无论作为 <em>1</em> 还是 <em>3</em> 都没有当前二元组对应的要优，因此我们可以不用考虑 <em>x</em> 作为 <em>1</em> 或者 <em>3</em> 的情况。</p></li></ul><p>这样一来，与方法二类似，我们使用两个单调递减的单调栈维护一系列二元组 <em>(x_i, x_j)*，表示一个可以选择的 *1-3</em> 区间，并且从栈底到栈顶 <em>x_i</em> 和 <em>x_j</em> 分别严格单调递减，因为根据上面的讨论，我们只有在 <em>x &lt; x_i</em> 时才会增加一个新的二元组。</p><p>然而与方法二不同的是，如果我们想让 <em>x</em> 作为 <em>2</em>，那么我们并不知道到底应该选择单调栈中的哪个 <em>1-3</em> 区间，因此我们只能根据单调性进行二分查找：</p><ul><li><p>对于单调栈中的 <em>x_i*，我们需要找出第一个满足 *x_i &lt; x</em> 的位置 idx_i ，这样从该位置到栈顶的所有二元组都满足 <em>x_i &lt; x</em>；</p></li><li><p>对于单调栈中的 <em>x_j*，我们需要找出最后一个满足 *x_j &gt; x</em> 的位置 idx_j ，这样从栈底到该位置的所有二元组都满足 <em>x_j &gt; x</em>；</p></li><li><p>如果 idx_i  和 idx_j  都存在，并且idx_i&lt;idx_j ，那么就存在至少一个二元组 <em>(x_i, x_j)</em> 满足 <em>x_i &lt; x &lt; x_j<em>，</em>x</em> 就可以作为 <em>2</em>，我们就找到了一组满足 <em>132</em> 模式的三元组。</p></li></ul><p>在枚举完所有的元素后，如果仍未找到满足 <em>132</em> 模式的三元组，那就说明其不存在。</p><p><strong>代码</strong></p><p>需要注意的是，我们是在<strong>单调递减的栈上进行二分查找</strong>，因此大部分语言都需要实现一个自定义比较函数，或者将栈中的元素取相反数后再使用默认的比较函数。</p><details>    <summary>枚举2 C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidate_i = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidate_j = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it_i = upper_bound(candidate_i.begin(), candidate_i.end(), nums[k], greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">auto</span> it_j = lower_bound(candidate_j.begin(), candidate_j.end(), nums[k], greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">if</span> (it_i != candidate_i.end() &amp;&amp; it_j != candidate_j.begin()) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx_i = it_i - candidate_i.begin();</span><br><span class="line">                <span class="keyword">int</span> idx_j = it_j - candidate_j.begin() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (idx_i &lt;= idx_j) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; candidate_i.back()) &#123;</span><br><span class="line">                candidate_i.push_back(nums[k]);</span><br><span class="line">                candidate_j.push_back(nums[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidate_j.back()) &#123;</span><br><span class="line">                <span class="keyword">int</span> last_i = candidate_i.back();</span><br><span class="line">                <span class="keyword">while</span> (!candidate_j.empty() &amp;&amp; nums[k] &gt; candidate_j.back()) &#123;</span><br><span class="line">                    candidate_i.pop_back();</span><br><span class="line">                    candidate_j.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                candidate_i.push_back(last_i);</span><br><span class="line">                candidate_j.push_back(nums[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; candidateI = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        candidateI.add(nums[<span class="number">0</span>]);</span><br><span class="line">        List&lt;Integer&gt; candidateJ = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        candidateJ.add(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> idxI = binarySearchFirst(candidateI, nums[k]);</span><br><span class="line">            <span class="keyword">int</span> idxJ = binarySearchLast(candidateJ, nums[k]);</span><br><span class="line">            <span class="keyword">if</span> (idxI &gt;= <span class="number">0</span> &amp;&amp; idxJ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (idxI &lt;= idxJ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; candidateI.get(candidateI.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                candidateI.add(nums[k]);</span><br><span class="line">                candidateJ.add(nums[k]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidateJ.get(candidateJ.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastI = candidateI.get(candidateI.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (!candidateJ.isEmpty() &amp;&amp; nums[k] &gt; candidateJ.get(candidateJ.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                    candidateI.remove(candidateI.size() - <span class="number">1</span>);</span><br><span class="line">                    candidateJ.remove(candidateJ.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                candidateI.add(lastI);</span><br><span class="line">                candidateJ.add(nums[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(List&lt;Integer&gt; candidate, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = candidate.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (candidate.get(high) &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">int</span> num = candidate.get(mid);</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(List&lt;Integer&gt; candidate, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = candidate.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (candidate.get(low) &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">int</span> num = candidate.get(mid);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 Python</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        candidate_i, candidate_j = [-nums[<span class="number">0</span>]], [-nums[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            idx_i = bisect.bisect_right(candidate_i, -v)</span><br><span class="line">            idx_j = bisect.bisect_left(candidate_j, -v)</span><br><span class="line">            <span class="keyword">if</span> idx_i &lt; idx_j:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> v &lt; -candidate_i[<span class="number">-1</span>]:</span><br><span class="line">                candidate_i.append(-v)</span><br><span class="line">                candidate_j.append(-v)</span><br><span class="line">            <span class="keyword">elif</span> v &gt; -candidate_j[<span class="number">-1</span>]:</span><br><span class="line">                last_i = -candidate_i[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">while</span> candidate_j <span class="keyword">and</span> v &gt; -candidate_j[<span class="number">-1</span>]:</span><br><span class="line">                    candidate_i.pop()</span><br><span class="line">                    candidate_j.pop()</span><br><span class="line">                candidate_i.append(-last_i)</span><br><span class="line">                candidate_j.append(-v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find132pattern = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> candidateI = [nums[<span class="number">0</span>]], candidateJ = [nums[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">const</span> idxI = binarySearchFirst(candidateI, nums[k]);</span><br><span class="line">        <span class="keyword">const</span> idxJ = binarySearchLast(candidateJ, nums[k]);</span><br><span class="line">        <span class="keyword">if</span> (idxI &gt;= <span class="number">0</span> &amp;&amp; idxJ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idxI &lt;= idxJ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[k] &lt; candidateI[candidateI.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            candidateI.push(nums[k]);</span><br><span class="line">            candidateJ.push(nums[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidateJ[candidateJ.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> lastI = candidateI[candidateI.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (candidateJ.length &amp;&amp; nums[k] &gt; candidateJ[candidateJ.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                candidateI.pop();</span><br><span class="line">                candidateJ.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            candidateI.push(lastI);</span><br><span class="line">            candidateJ.push(nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> binarySearchFirst = <span class="function">(<span class="params">candidate, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>, high = candidate.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (candidate[high] &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((high - low) / <span class="number">2</span>) + low;</span><br><span class="line">        <span class="keyword">const</span> num = candidate[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> binarySearchLast = <span class="function">(<span class="params">candidate, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>, high = candidate.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (candidate[low] &lt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((high - low + <span class="number">1</span>) / <span class="number">2</span>) + low;</span><br><span class="line">        <span class="keyword">const</span> num = candidate[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 Golang</summary><figure class="highlight go"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find132pattern</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    candidateI, candidateJ := []<span class="keyword">int</span>&#123;-nums[<span class="number">0</span>]&#125;, []<span class="keyword">int</span>&#123;-nums[<span class="number">0</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        idxI := sort.SearchInts(candidateI, <span class="number">1</span>-v)</span><br><span class="line">        idxJ := sort.SearchInts(candidateJ, -v)</span><br><span class="line">        <span class="keyword">if</span> idxI &lt; idxJ &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v &lt; -candidateI[<span class="built_in">len</span>(candidateI)<span class="number">-1</span>] &#123;</span><br><span class="line">            candidateI = <span class="built_in">append</span>(candidateI, -v)</span><br><span class="line">            candidateJ = <span class="built_in">append</span>(candidateJ, -v)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> v &gt; -candidateJ[<span class="built_in">len</span>(candidateJ)<span class="number">-1</span>] &#123;</span><br><span class="line">            lastI := -candidateI[<span class="built_in">len</span>(candidateI)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">len</span>(candidateJ) &gt; <span class="number">0</span> &amp;&amp; v &gt; -candidateJ[<span class="built_in">len</span>(candidateJ)<span class="number">-1</span>] &#123;</span><br><span class="line">                candidateI = candidateI[:<span class="built_in">len</span>(candidateI)<span class="number">-1</span>]</span><br><span class="line">                candidateJ = candidateJ[:<span class="built_in">len</span>(candidateJ)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            candidateI = <span class="built_in">append</span>(candidateI, -lastI)</span><br><span class="line">            candidateJ = <span class="built_in">append</span>(candidateJ, -v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span>* vec, <span class="keyword">int</span> vecSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = vecSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (vec[high] &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">int</span> num = vec[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>* vec, <span class="keyword">int</span> vecSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = vecSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (vec[low] &lt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">int</span> num = vec[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numsSize;</span><br><span class="line">    <span class="keyword">int</span> candidate_i[n], top_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> candidate_j[n], top_j = <span class="number">0</span>;</span><br><span class="line">    candidate_i[top_i++] = nums[<span class="number">0</span>];</span><br><span class="line">    candidate_j[top_j++] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> it_i = upper_bound(candidate_i, top_i, nums[k]);</span><br><span class="line">        <span class="keyword">int</span> it_j = lower_bound(candidate_j, top_j, nums[k]);</span><br><span class="line">        <span class="keyword">if</span> (it_i != <span class="number">-1</span> &amp;&amp; it_j != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it_i &lt;= it_j) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[k] &lt; candidate_i[top_i - <span class="number">1</span>]) &#123;</span><br><span class="line">            candidate_i[top_i++] = nums[k];</span><br><span class="line">            candidate_j[top_j++] = nums[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidate_j[top_j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> last_i = candidate_i[top_i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (top_j &amp;&amp; nums[k] &gt; candidate_j[top_j - <span class="number">1</span>]) &#123;</span><br><span class="line">                top_j--, top_i--;</span><br><span class="line">            &#125;</span><br><span class="line">            candidate_i[top_i++] = last_i;</span><br><span class="line">            candidate_j[top_j++] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogn) ，枚举 <em>i</em> 的次数为 <em>O(n)</em>，由于每一个元素最多被加入和弹出单调栈各一次，因此操作单调栈的时间复杂度一共为 <em>O(n)</em>。二分查找的单次时间为 O(logn)  ，一共为 O(nlogn)，总时间复杂度为O(nlogn) 。</p></li><li><p>空间复杂度：<em>O(n)</em>，即为单调栈需要使用的空间。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在上面的三种方法中，方法二的时间复杂度为 <em>O(n)</em>，最优秀。而剩余的两种时间复杂度为O(nlogn)  的方法中，方法一相较于方法三，无论从理解还是代码编写层面来说都更容易一些。那么为什么还要介绍方法三呢？这里我们可以发现方法一和方法二的不足：</p><ul><li><p>方法一需要提前知道整个数组，否则就无法使用有序集合维护右侧元素了；</p></li><li><p>方法二是从后向前遍历的，本质上也同样需要提前知道整个数组。</p></li></ul><p>而方法三是从前向后遍历的，并且维护的数据结构不依赖于后续未知的元素，因此如果数组是以「数据流」的形式给出的，那么方法三是唯一可以继续使用的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &amp;lt; j &amp;lt; k 和 nums[i] &amp;lt; nums[k] &amp;lt; nums[j] 。&lt;/p&gt;
&lt;p&gt;如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>1188 设计有限阻塞队列</title>
    <link href="http://yoursite.com/2021/03/18/1188%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/18/1188 设计有限阻塞队列/</id>
    <published>2021-03-18T08:52:12.000Z</published>
    <updated>2021-03-25T07:30:56.051Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个拥有如下方法的线程安全有限阻塞队列：</p><a id="more"></a><ul><li>BoundedBlockingQueue(int capacity) 构造方法初始化队列，其中capacity代表队列长度上限。</li><li>void enqueue(int element) 在队首增加一个element. 如果队列满，调用线程被阻塞直到队列非满。</li><li>int dequeue() 返回队尾元素并从队列中将其删除. 如果队列为空，调用线程被阻塞直到队列非空。</li><li>int size() 返回当前队列元素个数。</li></ul><p>你的实现将会被多线程同时访问进行测试。每一个线程要么是一个只调用enqueue方法的生产者线程，要么是一个只调用dequeue方法的消费者线程。size方法将会在每一个测试用例之后进行调用。<br>请不要使用内置的有限阻塞队列实现，否则面试将不会通过。</p><p>示例 1:</p><p>输入:</p><pre><code>11[“BoundedBlockingQueue”,“enqueue”,“dequeue”,“dequeue”,“enqueue”,“enqueue”,“enqueue”,“enqueue”,“dequeue”][[2],[1],[],[],[0],[2],[3],[4],[]]</code></pre><p>输出:</p><pre><code>[1,0,2,2]</code></pre><p>解释:</p><pre><code>生产者线程数目 = 1消费者线程数目 = 1BoundedBlockingQueue queue = new BoundedBlockingQueue(2); // 使用capacity = 2初始化队列。queue.enqueue(1); // 生产者线程将1插入队列。queue.dequeue(); // 消费者线程调用dequeue并返回1。queue.dequeue(); // 由于队列为空，消费者线程被阻塞。queue.enqueue(0); // 生产者线程将0插入队列。消费者线程被解除阻塞同时将0弹出队列并返回。queue.enqueue(2); // 生产者线程将2插入队列。queue.enqueue(3); // 生产者线程将3插入队列。queue.enqueue(4); // 生产者线程由于队列长度已达到上限2而被阻塞。queue.dequeue(); // 消费者线程将2从队列弹出并返回。生产者线程解除阻塞同时将4插入队列。queue.size(); // 队列中还有2个元素。size()方法在每组测试用例最后调用。</code></pre><p>示例 2:<br>输入:</p><pre><code>34[“BoundedBlockingQueue”,“enqueue”,“enqueue”,“enqueue”,“dequeue”,“dequeue”,“dequeue”,“enqueue”][[3],[1],[0],[2],[],[],[],[3]]</code></pre><p>输出:</p><pre><code>[1,0,2,1]</code></pre><p>解释:</p><pre><code>生产者线程数目 = 3消费者线程数目 = 4BoundedBlockingQueue queue = new BoundedBlockingQueue(3); // 使用capacity = 3初始化队列。queue.enqueue(1); // 生产者线程P1将1插入队列。queue.enqueue(0); // 生产者线程P2将0插入队列。queue.enqueue(2); // 生产者线程P3将2插入队列。queue.dequeue(); // 消费者线程C1调用dequeue。queue.dequeue(); // 消费者线程C2调用dequeue。queue.dequeue(); // 消费者线程C3调用dequeue。queue.enqueue(3); // 其中一个生产者线程将3插入队列。queue.size(); // 队列中还有1个元素。由于生产者/消费者线程的数目可能大于1，我们并不知道线程如何被操作系统调度，即使输入看上去隐含了顺序。因此任意一种输出[1,0,2]或[1,2,0]或[0,1,2]或[0,2,1]或[2,0,1]或[2,1,0]都可被接受。</code></pre><details><summary>示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBlockingQueue &#123;</span><br><span class="line"></span><br><span class="line">    public BoundedBlockingQueue(int capacity) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void enqueue(int element) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int dequeue() throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int size() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><details><summary>题解</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBlockingQueue &#123;</span><br><span class="line">    </span><br><span class="line">    private final LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 队列是否为空的条件</span><br><span class="line">    private final Condition notEmpty = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    // 队列是否已满的条件</span><br><span class="line">    private final Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedBlockingQueue(int capacity) &#123;</span><br><span class="line">        queue = new LinkedList&lt;&gt;();</span><br><span class="line">        this.count = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      public int size() &#123;</span><br><span class="line">        return queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enqueue(Integer e) throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == queue.size())</span><br><span class="line">                notFull.await();</span><br><span class="line">            queue.addFirst(e);</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dequeue() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (queue.size() == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Integer e = queue.removeLast();</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个拥有如下方法的线程安全有限阻塞队列：&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1242.多线程网页爬虫</title>
    <link href="http://yoursite.com/2021/03/18/1242.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2021/03/18/1242.多线程网页爬虫/</id>
    <published>2021-03-18T06:52:12.000Z</published>
    <updated>2021-03-19T08:26:46.154Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个初始地址 startUrl 和一个 HTML 解析器接口 HtmlParser，请你实现一个 多线程的网页爬虫，用于获取与 startUrl 有 相同主机名 的所有链接。 </p><p>以 任意 顺序返回爬虫获取的路径。</p><p>爬虫应该遵循：</p><p>从 startUrl 开始<br>调用 HtmlParser.getUrls(url) 从指定网页路径获得的所有路径。<br>不要抓取相同的链接两次。<br>仅浏览与 startUrl 相同主机名 的链接。</p><a id="more"></a><p>如上图所示，主机名是 example.org 。简单起见，你可以假设所有链接都采用 http 协议，并且没有指定 端口号。举个例子，链接 <a href="http://leetcode.com/problems" target="_blank" rel="noopener">http://leetcode.com/problems</a> 和链接 <a href="http://leetcode.com/contest" target="_blank" rel="noopener">http://leetcode.com/contest</a> 属于同一个 主机名， 而 <a href="http://example.org/test" target="_blank" rel="noopener">http://example.org/test</a> 与 <a href="http://example.com/abc" target="_blank" rel="noopener">http://example.com/abc</a> 并不属于同一个 主机名。</p><p>HtmlParser 的接口定义如下：</p><pre><code>interface HtmlParser {  // Return a list of all urls from a webpage of given url.  // This is a blocking call, that means it will do HTTP request and return when this request is finished.  public List&lt;String&gt; getUrls(String url);}</code></pre><p>注意一点，getUrls(String url) 模拟执行一个HTTP的请求。 你可以将它当做一个阻塞式的方法，直到请求结束。 getUrls(String url) 保证会在 15ms 内返回所有的路径。 单线程的方案会超过时间限制，你能用多线程方案做的更好吗？</p><p>对于问题所需的功能，下面提供了两个例子。为了方便自定义测试，你可以声明三个变量 urls，edges 和 startUrl。但要注意你只能在代码中访问 startUrl，并不能直接访问 urls 和 edges。</p><p>拓展问题：</p><p>假设我们要要抓取 10000 个节点和 10 亿个路径。并且在每个节点部署相同的的软件。软件可以发现所有的节点。我们必须尽可能减少机器之间的通讯，并确保每个节点负载均衡。你将如何设计这个网页爬虫？<br>如果有一个节点发生故障不工作该怎么办？<br>如何确认爬虫任务已经完成？</p><p>示例 1：</p><pre><code>输入：urls = [  &quot;http://news.yahoo.com&quot;,  &quot;http://news.yahoo.com/news&quot;,  &quot;http://news.yahoo.com/news/topics/&quot;,  &quot;http://news.google.com&quot;,  &quot;http://news.yahoo.com/us&quot;]edges = [[2,0],[2,1],[3,2],[3,1],[0,4]]startUrl = &quot;http://news.yahoo.com/news/topics/&quot;输出：[  &quot;http://news.yahoo.com&quot;,  &quot;http://news.yahoo.com/news&quot;,  &quot;http://news.yahoo.com/news/topics/&quot;,  &quot;http://news.yahoo.com/us&quot;]</code></pre><p>示例 2：</p><pre><code>输入：urls = [  &quot;http://news.yahoo.com&quot;,  &quot;http://news.yahoo.com/news&quot;,  &quot;http://news.yahoo.com/news/topics/&quot;,  &quot;http://news.google.com&quot;]edges = [[0,2],[2,1],[3,2],[3,1],[3,0]]startUrl = &quot;http://news.google.com&quot;输出：[&quot;http://news.google.com&quot;]解释：startUrl 链接与其他页面不共享一个主机名。</code></pre><p>提示：</p><p>1 &lt;= urls.length &lt;= 1000<br>1 &lt;= urls[i].length &lt;= 300</p><p>startUrl 是 urls 中的一个。<br>主机名的长度必须为 1 到 63 个字符（包括点 . 在内），只能包含从 “a” 到 “z” 的 ASCII 字母和 “0” 到 “9” 的数字，以及中划线 “-”。<br>主机名开头和结尾不能是中划线 “-”。</p><p>参考资料：<a href="https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames</a><br>你可以假设路径都是不重复的。</p><details><summary>示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the HtmlParser&apos;s API interface.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * interface HtmlParser &#123;</span><br><span class="line"> *     public List&lt;String&gt; getUrls(String url) &#123;&#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; crawl(String startUrl, HtmlParser htmlParser) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    private final Set&lt;String&gt; set = Collections.newSetFromMap(new ConcurrentHashMap&lt;String, Boolean&gt;());</span><br><span class="line">    private final List&lt;String&gt; result = Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br><span class="line">    private String HOSTNAME = null;</span><br><span class="line"></span><br><span class="line">    public boolean judgeHostname(String url) &#123;</span><br><span class="line">        int idx = url.indexOf(&apos;/&apos;, 7);</span><br><span class="line">        String hostName = (idx != -1) ? url.substring(0, idx) : url;</span><br><span class="line">        return hostName.equals(HOSTNAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initHostName(String url) &#123;</span><br><span class="line">        int idx = url.indexOf(&apos;/&apos;, 7);</span><br><span class="line">        HOSTNAME = (idx != -1) ? url.substring(0, idx) : url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getUrl(String startUrl, HtmlParser htmlParser) &#123;</span><br><span class="line">        result.add(startUrl);</span><br><span class="line">        List&lt;String&gt; res = htmlParser.getUrls(startUrl);</span><br><span class="line">        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();</span><br><span class="line">        for (String url : res) &#123;</span><br><span class="line">            if (judgeHostname(url) &amp;&amp; !set.contains(url)) &#123;</span><br><span class="line">                set.add(url);</span><br><span class="line">                threads.add(new Thread(() -&gt; &#123;</span><br><span class="line">                    getUrl(url, htmlParser);</span><br><span class="line">                &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Thread thread : threads) &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; crawl(String startUrl, HtmlParser htmlParser) &#123;</span><br><span class="line">        initHostName(startUrl);</span><br><span class="line">        set.add(startUrl);</span><br><span class="line">        getUrl(startUrl, htmlParser);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Thread-join-详解"><a href="#Thread-join-详解" class="headerlink" title="Thread.join()详解"></a>Thread.join()详解</h2><p>上面的代码里用到了join方法，join是Thread类的一个方法，启动线程后直接调用。</p><h3 id="为什么要用join-方法"><a href="#为什么要用join-方法" class="headerlink" title="为什么要用join()方法"></a>为什么要用join()方法</h3><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><h3 id="join方法的作用"><a href="#join方法的作用" class="headerlink" title="join方法的作用"></a>join方法的作用</h3><p>在JDk的API里对于join()方法是：</p><pre><code>joinpublic final void join() throws InterruptedException Waits for this thread to die. Throws: InterruptedException  - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.</code></pre><p>即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p><details>    <summary>join方法示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class BThread extends Thread &#123;</span><br><span class="line">    public BThread() &#123;</span><br><span class="line">        super(&quot;[BThread] Thread&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                System.out.println(threadName + &quot; loop at &quot; + i);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadName + &quot; end.&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from &quot; + threadName + &quot;.run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AThread extends Thread &#123;</span><br><span class="line">    BThread bt;</span><br><span class="line">    public AThread(BThread bt) &#123;</span><br><span class="line">        super(&quot;[AThread] Thread&quot;);</span><br><span class="line">        this.bt = bt;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            bt.join();</span><br><span class="line">            System.out.println(threadName + &quot; end.&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from &quot; + threadName + &quot;.run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        BThread bt = new BThread();</span><br><span class="line">        AThread at = new AThread(bt);</span><br><span class="line">        try &#123;</span><br><span class="line">            bt.start();</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            at.start();</span><br><span class="line">            at.join();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from main&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName + &quot; end!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main start.    //主线程起动，因为调用了at.join()，要等到at结束了，此线程才能向下执行。 </span><br><span class="line">[BThread] Thread start. </span><br><span class="line">[BThread] Thread loop at 0 </span><br><span class="line">[BThread] Thread loop at 1 </span><br><span class="line">[AThread] Thread start.    //线程at启动，因为调用bt.join()，等到bt结束了才向下执行。 </span><br><span class="line">[BThread] Thread loop at 2 </span><br><span class="line">[BThread] Thread loop at 3 </span><br><span class="line">[BThread] Thread loop at 4 </span><br><span class="line">[BThread] Thread end. </span><br><span class="line">[AThread] Thread end.    // 线程AThread在bt.join();阻塞处起动，向下继续执行的结果 </span><br><span class="line">main end!      //线程AThread结束，此线程在at.join();阻塞处起动，向下继续执行的结果。</span><br></pre></td></tr></table></figure><p>修改一下代码:</p><details>    <summary>join方法示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        BThread bt = new BThread();</span><br><span class="line">        AThread at = new AThread(bt);</span><br><span class="line">        try &#123;</span><br><span class="line">            bt.start();</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            at.start();</span><br><span class="line">            //at.join(); //在此处注释掉对join()的调用</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from main&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName + &quot; end!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main start.    // 主线程起动，因为Thread.sleep(2000)，主线程没有马上结束;</span><br><span class="line"></span><br><span class="line">[BThread] Thread start.    //线程BThread起动</span><br><span class="line">[BThread] Thread loop at 0</span><br><span class="line">[BThread] Thread loop at 1</span><br><span class="line">main end!   // 在sleep两秒后主线程结束，AThread执行的bt.join();并不会影响到主线程。</span><br><span class="line">[AThread] Thread start.    //线程at起动，因为调用了bt.join()，等到bt结束了，此线程才向下执行。</span><br><span class="line">[BThread] Thread loop at 2</span><br><span class="line">[BThread] Thread loop at 3</span><br><span class="line">[BThread] Thread loop at 4</span><br><span class="line">[BThread] Thread end.    //线程BThread结束了</span><br><span class="line">[AThread] Thread end.    // 线程AThread在bt.join();阻塞处起动，向下继续执行的结果</span><br></pre></td></tr></table></figure><h3 id="从源码看join-方法"><a href="#从源码看join-方法" class="headerlink" title="从源码看join()方法"></a>从源码看join()方法</h3><details>    <summary>从源码看join()方法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Waits at most &#123;@code millis&#125; milliseconds for this thread to</span><br><span class="line">     * die. A timeout of &#123;@code 0&#125; means to wait forever.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; This implementation uses a loop of &#123;@code this.wait&#125; calls</span><br><span class="line">     * conditioned on &#123;@code this.isAlive&#125;. As a thread terminates the</span><br><span class="line">     * &#123;@code this.notifyAll&#125; method is invoked. It is recommended that</span><br><span class="line">     * applications not use &#123;@code wait&#125;, &#123;@code notify&#125;, or</span><br><span class="line">     * &#123;@code notifyAll&#125; on &#123;@code Thread&#125; instances.</span><br><span class="line">     *</span><br><span class="line">     * @param  millis</span><br><span class="line">     *         the time to wait in milliseconds</span><br><span class="line">     *</span><br><span class="line">     * @throws  IllegalArgumentException</span><br><span class="line">     *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line">     *</span><br><span class="line">     * @throws  InterruptedException</span><br><span class="line">     *          if any thread has interrupted the current thread. The</span><br><span class="line">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line">     *          cleared when this exception is thrown.</span><br><span class="line">     */</span><br><span class="line">    public final synchronized void join(long millis)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        long base = System.currentTimeMillis();</span><br><span class="line">        long now = 0;</span><br><span class="line"></span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (millis == 0) &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay = millis - now;</span><br><span class="line">                if (delay &lt;= 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><p>单纯从代码上看： * 如果线程被生成了，但还未被起动，isAlive()将返回false，调用它的join()方法是没有作用的。将直接继续向下执行。 * 在AThread类中的run方法中，bt.join()是判断bt的active状态，如果bt的isActive()方法返回false，在bt.join(),这一点就不用阻塞了，可以继续向下进行了。从源码里看，wait方法中有参数，也就是不用唤醒谁，只是不再执行wait，向下继续执行而已。 * 在join()方法中，对于isAlive()和wait()方法的作用对象是个比较让人困惑的问题：</p><p>isAlive()方法的签名是：public final native boolean isAlive()，也就是说isAlive()是判断当前线程的状态，也就是bt的状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个初始地址 startUrl 和一个 HTML 解析器接口 HtmlParser，请你实现一个 多线程的网页爬虫，用于获取与 startUrl 有 相同主机名 的所有链接。 &lt;/p&gt;
&lt;p&gt;以 任意 顺序返回爬虫获取的路径。&lt;/p&gt;
&lt;p&gt;爬虫应该遵循：&lt;/p&gt;
&lt;p&gt;从 startUrl 开始&lt;br&gt;调用 HtmlParser.getUrls(url) 从指定网页路径获得的所有路径。&lt;br&gt;不要抓取相同的链接两次。&lt;br&gt;仅浏览与 startUrl 相同主机名 的链接。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1279. 红绿灯路口</title>
    <link href="http://yoursite.com/2021/03/17/1279.%20%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%B7%AF%E5%8F%A3/"/>
    <id>http://yoursite.com/2021/03/17/1279. 红绿灯路口/</id>
    <published>2021-03-17T08:52:12.000Z</published>
    <updated>2021-03-19T01:55:59.435Z</updated>
    
    <content type="html"><![CDATA[<p>给这个路口设计一个没有死锁的红绿灯控制系统。</p><a id="more"></a><p>这是两条路的交叉路口。第一条路是 A 路，车辆可沿 1 号方向由北向南行驶，也可沿 2 号方向由南向北行驶。第二条路是 B 路，车辆可沿 3 号方向由西向东行驶，也可沿 4 号方向由东向西行驶。</p><p>每条路在路口前都有一个红绿灯。红绿灯可以亮起红灯或绿灯。</p><p>绿灯表示两个方向的车辆都可通过路口。<br>红灯表示两个方向的车辆都不可以通过路口，必须等待绿灯亮起。<br>两条路上的红绿灯不可以同时为绿灯。这意味着，当 A 路上的绿灯亮起时，B 路上的红灯会亮起；当 B 路上的绿灯亮起时，A 路上的红灯会亮起.</p><p>开始时，A 路上的绿灯亮起，B 路上的红灯亮起。当一条路上的绿灯亮起时，所有车辆都可以从任意两个方向通过路口，直到另一条路上的绿灯亮起。不同路上的车辆不可以同时通过路口。</p><p>给这个路口设计一个没有死锁的红绿灯控制系统。</p><p>实现函数 void carArrived(carId, roadId, direction, turnGreen, crossCar) :</p><ul><li>carId 为到达车辆的编号。</li><li>roadId 为车辆所在道路的编号。</li><li>direction 为车辆的行进方向。</li><li>turnGreen 是一个函数，调用此函数会使当前道路上的绿灯亮起。</li><li>crossCar 是一个函数，调用此函数会允许车辆通过路口。</li></ul><p>当你的答案避免了车辆在路口出现死锁，此答案会被认定为正确的。当路口已经亮起绿灯时仍打开绿灯，此答案会被认定为错误的。</p><p>示例 1:</p><pre><code>输入: cars = [1,3,5,2,4], directions = [2,1,2,4,3], arrivalTimes = [10,20,30,40,50]输出: [&quot;Car 1 Has Passed Road A In Direction 2&quot;,    // A 路上的红绿灯为绿色，1 号车可通过路口。&quot;Car 3 Has Passed Road A In Direction 1&quot;,    // 红绿灯仍为绿色，3 号车通过路口。&quot;Car 5 Has Passed Road A In Direction 2&quot;,    // 红绿灯仍为绿色，5 号车通过路口。&quot;Traffic Light On Road B Is Green&quot;,          // 2 号车在 B 路请求绿灯。&quot;Car 2 Has Passed Road B In Direction 4&quot;,    // B 路上的绿灯现已亮起，2 号车通过路口。&quot;Car 4 Has Passed Road B In Direction 3&quot;     // 红绿灯仍为绿色，4 号车通过路口。]</code></pre><p>示例 2:</p><pre><code>输入: cars = [1,2,3,4,5], directions = [2,4,3,3,1], arrivalTimes = [10,20,30,40,40]输出: [&quot;Car 1 Has Passed Road A In Direction 2&quot;,    // A 路上的红绿灯为绿色，1 号车可通过路口。&quot;Traffic Light On Road B Is Green&quot;,          // 2 号车在 B 路请求绿灯。&quot;Car 2 Has Passed Road B In Direction 4&quot;,    // B 路上的绿灯现已亮起，2 号车通过路口。&quot;Car 3 Has Passed Road B In Direction 3&quot;,    // B 路上的绿灯现已亮起，3 号车通过路口。&quot;Traffic Light On Road A Is Green&quot;,          // 5 号车在 A 路请求绿灯。&quot;Car 5 Has Passed Road A In Direction 1&quot;,    // A 路上的绿灯现已亮起，5 号车通过路口。&quot;Traffic Light On Road B Is Green&quot;,          // 4 号车在 B 路请求绿灯。4 号车在路口等灯，直到 5 号车通过路口，B 路的绿灯亮起。&quot;Car 4 Has Passed Road B In Direction 3&quot;     // B 路上的绿灯现已亮起，4 号车通过路口。]解释: 这是一个无死锁的方案。注意，在 A 路上的绿灯亮起、5 号车通过前让 4 号车通过，也是一个正确且可被接受的方案。</code></pre><p>提示：</p><pre><code>1 &lt;= cars.length &lt;= 20cars.length = directions.lengthcars.length = arrivalTimes.lengthcars 中的所有值都是唯一的。1 &lt;= directions[i] &lt;= 4arrivalTimes 是非递减的。</code></pre><details><summary>题目要求</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TrafficLight &#123;</span><br><span class="line"></span><br><span class="line">    public TrafficLight() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void carArrived(</span><br><span class="line">        int carId,           // ID of the car</span><br><span class="line">        int roadId,          // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)</span><br><span class="line">        int direction,       // Direction of the car</span><br><span class="line">        Runnable turnGreen,  // Use turnGreen.run() to turn light to green on current road</span><br><span class="line">        Runnable crossCar    // Use crossCar.run() to make car cross the intersection </span><br><span class="line">    ) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题解说实在没太理解，这题又是道收费题目，下面道题解是否能跑通有待验证。</p><details><summary>题解</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class TrafficLight &#123;</span><br><span class="line">    public TrafficLight() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean lightA = true;</span><br><span class="line">    public void carArrived(</span><br><span class="line">        int carId,           // ID of the car</span><br><span class="line">        int roadId,          // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)</span><br><span class="line">        int direction,       // Direction of the car</span><br><span class="line">        Runnable turnGreen,  // Use turnGreen.run() to turn light to green on current road</span><br><span class="line">        Runnable crossCar    // Use crossCar.run() to make car cross the intersection </span><br><span class="line">    ) &#123;</span><br><span class="line">        synchronized (this) </span><br><span class="line">        &#123;</span><br><span class="line">            if( roadId == 1) </span><br><span class="line">            &#123;</span><br><span class="line">                if( !lightA) &#123;</span><br><span class="line">                    turnGreen.run();</span><br><span class="line">                    lightA = true;</span><br><span class="line">                &#125;</span><br><span class="line">                crossCar.run();</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                if( lightA) &#123;</span><br><span class="line">                    turnGreen.run();</span><br><span class="line">                    lightA = false;</span><br><span class="line">                &#125;</span><br><span class="line">                crossCar.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给这个路口设计一个没有死锁的红绿灯控制系统。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>953. 验证外星语词典</title>
    <link href="http://yoursite.com/2021/03/04/953.%20%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/"/>
    <id>http://yoursite.com/2021/03/04/953. 验证外星语词典/</id>
    <published>2021-03-04T10:12:12.000Z</published>
    <updated>2021-03-04T10:30:25.352Z</updated>
    
    <content type="html"><![CDATA[<p>某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。</p><p>给定一组用外星语书写的单词words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;输出：true解释：在该语言的字母表中，&apos;h&apos; 位于 &apos;l&apos; 之前，所以单词序列是按字典序排列的。</code></pre><p>示例 2：</p><pre><code>输入：words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;输出：false解释：在该语言的字母表中，&apos;d&apos; 位于 &apos;l&apos; 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</code></pre><p>示例 3：</p><pre><code>输入：words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;输出：false解释：当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 &apos;l&apos; &gt; &apos;∅&apos;，其中 &apos;∅&apos; 是空白字符，定义为比任何其他字符都小（更多信息）。</code></pre><p>提示：</p><pre><code>1 &lt;= words.length &lt;= 1001 &lt;= words[i].length &lt;= 20order.length == 26在 words[i] 和 order 中的所有字符都是英文小写字母。</code></pre><h4 id="方法一：-检查相邻单词"><a href="#方法一：-检查相邻单词" class="headerlink" title="方法一： 检查相邻单词"></a>方法一： 检查相邻单词</h4><p><strong>思路</strong></p><p>只有每对相邻单词都是有序的，那么整个 <code>words</code> 才是有序的。因为有序性是可以传递的，例如，<code>a &lt;= b</code> 和 <code>b &lt;= c</code> 可以推出 <code>a &lt;= c</code>。</p><p><strong>算法</strong></p><p>检查相邻单词 <code>a</code> 和 <code>b</code> 是否满足 <code>a &lt;= b</code>。</p><p>为了检查相邻单词 <code>a</code>，<code>b</code> 是否满足 <code>a &lt;= b</code>，只需要检查它们第一个不同的字母就可以了。例如，对于<code>&quot;applying&quot;</code> 和 <code>&quot;apples&quot;</code>，第一个不同的字母是 <code>y</code> 和 <code>e</code>。之后只需要比较这两个字母在 <code>order</code> 中的下标就可以了。 </p><p>还需要考虑两个单词长度不等的情况。例如，当比较 <code>&quot;app&quot;</code> 和 <code>&quot;apply&quot;</code> 的时候，前三个字母都是相等的，但 <code>&quot;app&quot;</code> 比 <code>&quot;apply&quot;</code> 更短，所以满足 <code>a &lt;= b</code>。</p><details>    <summary>检查相邻单词Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); ++i)</span><br><span class="line">            index[order.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line"></span><br><span class="line">        search: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            String word1 = words[i];</span><br><span class="line">            String word2 = words[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the first difference word1[k] != word2[k].</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Math.min(word1.length(), word2.length()); ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(k) != word2.charAt(k)) &#123;</span><br><span class="line">                    <span class="comment">// If they compare badly, it's not sorted.</span></span><br><span class="line">                    <span class="keyword">if</span> (index[word1.charAt(k) - <span class="string">'a'</span>] &gt; index[word2.charAt(k) - <span class="string">'a'</span>])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span> search;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn't find a first difference, the</span></span><br><span class="line">            <span class="comment">// words are like ("app", "apple").</span></span><br><span class="line">            <span class="keyword">if</span> (word1.length() &gt; word2.length())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>检查相邻单词Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span><span class="params">(self, words, order)</span>:</span></span><br><span class="line">        order_index = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(order)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(words) - <span class="number">1</span>):</span><br><span class="line">            word1 = words[i]</span><br><span class="line">            word2 = words[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Find the first difference word1[k] != word2[k].</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(min(len(word1), len(word2))):</span><br><span class="line">                <span class="comment"># If they compare badly, it's not sorted.</span></span><br><span class="line">                <span class="keyword">if</span> word1[k] != word2[k]:</span><br><span class="line">                    <span class="keyword">if</span> order_index[word1[k]] &gt; order_index[word2[k]]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># If we didn't find a first difference, the</span></span><br><span class="line">                <span class="comment"># words are like ("app", "apple").</span></span><br><span class="line">                <span class="keyword">if</span> len(word1) &gt; len(word2):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(C)*，其中 *C</em> 是 <code>words</code> 中单词总长度和。</p></li><li><p>空间复杂度： <em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。&lt;/p&gt;
&lt;p&gt;给定一组用外星语书写的单词words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>269.火星词典</title>
    <link href="http://yoursite.com/2021/02/27/269.%E7%81%AB%E6%98%9F%E8%AF%8D%E5%85%B8/"/>
    <id>http://yoursite.com/2021/02/27/269.火星词典/</id>
    <published>2021-02-27T06:12:12.000Z</published>
    <updated>2021-03-04T08:47:03.890Z</updated>
    
    <content type="html"><![CDATA[<p>有一种新的使用拉丁字母的外来语言。但是，你不知道字母之间的顺序。你会从词典中收到一个非空的单词列表，其中的单词在这种新语言的规则下按字典顺序排序。请推导出这种语言的字母顺序</p><a id="more"></a><p>此题也是LintCode上的 892. 外星人字典，可以直接在官网链接<a href="https://www.lintcode.com/problem/alien-dictionary?utm_source=sc-zhihuzl-sy" target="_blank" rel="noopener">^1</a>提交代码测试。也曾经是抖音的一道面试题。</p><ol><li>你可以假设所有的字母都是小写。</li><li>如果a是b的前缀且b出现在a之前，那么这个顺序是无效的。</li><li>如果顺序是无效的，则返回空字符串。</li><li>这里可能有多个有效的字母顺序，返回以正常字典顺序看来最小的。</li></ol><p>样例 1:</p><pre><code>输入：[&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]输出：&quot;wertf&quot;解释：从 &quot;wrt&quot;和&quot;wrf&quot; ,我们可以得到 &apos;t&apos;&lt;&apos;f&apos;从 &quot;wrt&quot;和&quot;er&quot; ,我们可以得到&apos;w&apos;&lt;&apos;e&apos;从 &quot;er&quot;和&quot;ett&quot; ,我们可以得到 get &apos;r&apos;&lt;&apos;t&apos;从 &quot;ett&quot;和&quot;rftt&quot; ,我们可以得到 &apos;e&apos;&lt;&apos;r&apos;所以返回 &quot;wertf&quot;</code></pre><p>样例 2:</p><pre><code>输入：[&quot;z&quot;,&quot;x&quot;]输出：&quot;zx&quot;解释：从 &quot;z&quot; 和 &quot;x&quot;，我们可以得到 &apos;z&apos; &lt; &apos;x&apos;所以返回&quot;zx&quot;</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这是很明显的拓扑排序，可以参考210.课程表II的代码。区别在于那个拓扑排序是对整数而且输入样例是给好的。这道题里要自己整理好要拓扑排序的数据，而且将拓扑排序的代码更改为对字符串排序，在改动的过程中踩了一些坑。</p><p>网上很多博客的代码也踩了这些坑，比如如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[“abc”,”ab”]，所以是没法通过的。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><details>    <summary>宽度优先搜索-拓扑排序</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public static String findOrder(Set&lt;Character&gt; set,Character[][] prerequisites) &#123;</span><br><span class="line">        Map&lt;Character, List&lt;Character&gt;&gt; edges;</span><br><span class="line">        Map&lt;Character,Integer&gt; indeg;</span><br><span class="line">        String res=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        edges=new HashMap&lt;&gt;();</span><br><span class="line">        indeg=new HashMap&lt;&gt;();</span><br><span class="line">        for(Character[] info: prerequisites)&#123;</span><br><span class="line">            List&lt;Character&gt; list = edges.get(info[1]);</span><br><span class="line">            if (Objects.isNull(list)) &#123;</span><br><span class="line">                list = new ArrayList&lt;Character&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(info[0]);</span><br><span class="line">            edges.put(info[1], list);</span><br><span class="line">            indeg.put(info[0], indeg.getOrDefault(info[0],0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里可能有多个有效的字母顺序，返回以正常字典顺序看来最小的，[&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">        //所以使用优先队列</span><br><span class="line">        PriorityQueue&lt;Character&gt; queue=new PriorityQueue&lt;Character&gt;();</span><br><span class="line">        for (Character c: set) &#123;</span><br><span class="line">            if (indeg.getOrDefault(c,0) == 0) &#123;</span><br><span class="line">                queue.offer(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            Character u=queue.poll();</span><br><span class="line">            res+=u;</span><br><span class="line">            if (!Objects.isNull(edges.get(u))) &#123;</span><br><span class="line">                for (Character v : edges.get(u)) &#123;</span><br><span class="line">                    indeg.put(v, indeg.getOrDefault(v, 0) - 1);</span><br><span class="line">                    if (indeg.getOrDefault(v, 0) == 0) &#123;</span><br><span class="line">                        queue.offer(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (set.size() != res.length()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @param words: a list of words</span><br><span class="line">     * @return: a string which is correct order</span><br><span class="line">     */</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        // Write your code here</span><br><span class="line">        Set&lt;Character&gt; set=new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Character[]&gt; lists=new HashSet&lt;&gt;();</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for (String s : words) &#123;</span><br><span class="line">            maxlen = Math.max(s.length(), maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; maxlen; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words.length; j++) &#123;</span><br><span class="line">                Character c;</span><br><span class="line">                if (words[j].length() &gt; i) &#123;</span><br><span class="line">                    c = words[j].charAt(i);</span><br><span class="line">                    set.add(c);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int k = j + 1; k &lt; words.length; k++) &#123;</span><br><span class="line">                    Character d;</span><br><span class="line">                    if (words[k].length() &gt; i) &#123;</span><br><span class="line">                        d = words[k].charAt(i);</span><br><span class="line">                        set.add(d);</span><br><span class="line">                        if (d != c &amp;&amp; words[j].substring(0,i).equals(words[k].substring(0,i))) &#123;</span><br><span class="line">                            lists.add(new Character[]&#123;d,c&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[&quot;abc&quot;,&quot;ab&quot;]</span><br><span class="line">                        if (words[j].startsWith(words[k])) &#123;</span><br><span class="line">                            return &quot;&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Character[][] character = new Character[lists.size()][];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (Character[] c : lists) &#123;</span><br><span class="line">            character[index] = c;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return findOrder(set,character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="解法II"><a href="#解法II" class="headerlink" title="解法II"></a>解法II</h2><details>    <summary>宽度优先搜索-拓扑排序</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = constructGraph(words);</span><br><span class="line">        if (graph == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return topologicalSorting(graph);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    private Map&lt;Character, Set&lt;Character&gt;&gt; constructGraph(String[] words) &#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // create nodes</span><br><span class="line">        for (int i = 0; i &lt; words.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                char c = words[i].charAt(j);</span><br><span class="line">                if (!graph.containsKey(c)) &#123;</span><br><span class="line">                    graph.put(c, new HashSet&lt;Character&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // create edges</span><br><span class="line">        for (int i = 0; i &lt; words.length - 1; i++) &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            while (index &lt; words[i].length() &amp;&amp; index &lt; words[i + 1].length()) &#123;</span><br><span class="line">                if (words[i].charAt(index) != words[i + 1].charAt(index)) &#123;</span><br><span class="line">                    graph.get(words[i].charAt(index)).add(words[i + 1].charAt(index));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[&quot;abc&quot;,&quot;ab&quot;]</span><br><span class="line">            if (index == Math.min(words[i].length(), words[i + 1].length())) &#123;</span><br><span class="line">                if (words[i].length() &gt; words[i + 1].length()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return graph;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Map&lt;Character, Integer&gt; getIndegree(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; indegree = new HashMap&lt;&gt;();</span><br><span class="line">        for (Character u : graph.keySet()) &#123;</span><br><span class="line">            indegree.put(u, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (Character u : graph.keySet()) &#123;</span><br><span class="line">            for (Character v : graph.get(u)) &#123;</span><br><span class="line">                indegree.put(v, indegree.get(v) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">        </span><br><span class="line">        return indegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String topologicalSorting(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123;</span><br><span class="line">        // as we should return the topo order with lexicographical order</span><br><span class="line">        // we should use PriorityQueue instead of a FIFO Queue</span><br><span class="line">        Map&lt;Character, Integer&gt; indegree = getIndegree(graph);</span><br><span class="line">        Queue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for (Character u : indegree.keySet()) &#123;</span><br><span class="line">            if (indegree.get(u) == 0) &#123;</span><br><span class="line">                queue.offer(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Character head = queue.poll();</span><br><span class="line">            sb.append(head);</span><br><span class="line">            for (Character neighbor : graph.get(head)) &#123;</span><br><span class="line">                indegree.put(neighbor, indegree.get(neighbor) - 1);</span><br><span class="line">                if (indegree.get(neighbor) == 0) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sb.length() != indegree.size()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>官网的题解<a href="https://www.jiuzhang.com/solutions/alien-dictionary/" target="_blank" rel="noopener">^2</a>和我自己魔改的版本其实没有太大区别，主要的不同之处在于使用了Map&lt;Character, Set<character>&gt;来存储拓扑图，StringBuilder来保存最终结果，以及判断如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[“abc”,”ab”]，如果使用Strings自带的startsWith方法效率会比改题解中的利用下标判断低。</character></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一种新的使用拉丁字母的外来语言。但是，你不知道字母之间的顺序。你会从词典中收到一个非空的单词列表，其中的单词在这种新语言的规则下按字典顺序排序。请推导出这种语言的字母顺序&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Topological sort" scheme="http://yoursite.com/tags/Topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识-装箱和拆箱</title>
    <link href="http://yoursite.com/2021/02/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2021/02/22/Java基础知识-装箱和拆箱/</id>
    <published>2021-02-22T03:25:12.000Z</published>
    <updated>2021-02-22T07:24:00.286Z</updated>
    
    <content type="html"><![CDATA[<p>装箱和拆箱</p><a id="more"></a><h1 id="什么是装箱？什么是拆箱？"><a href="#什么是装箱？什么是拆箱？" class="headerlink" title="什么是装箱？什么是拆箱？"></a>什么是装箱？什么是拆箱？</h1><p>在java中有八种基本数据类型对应每种基本类型又有八种包装类型：<a href="https://zhuanlan.zhihu.com/p/78590948" target="_blank" rel="noopener">^1</a></p><p>基本类型：boolean， char， int， byte，short，long， float，double</p><p>包装器类型：Boolean，Character，Integer，Byte，Short，Long，Float，Double</p><p>从上面我们可以看到除了 char和int其它的包装类型名称和对应的基本类型一样只是首字母大写了。</p><p>既然有了基本类型为什么还要有包装类呢？我们在使用的过程中究竟用基本类型还是包装类呢？</p><p>在某些场合不能使用基本类型必须使用包装类，比如集合能接收的类型为Object,基本类型是无法添加进去的，还有范型也必须使用包装类。</p><p>另外假设我们要定义一个变量表示分数 如果用基本类型表示的话：int score;</p><p>默认值为零，如果我想表示分数为空也就是没有参加考试就没法表现了因为值类型是无法赋空值的，如果使用包装类型Integer score,就可以表示这种情况，因为Integer的默认值为空。</p><p>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p><pre><code>Integer i = new Integer(10);</code></pre><p>　　而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p><pre><code>Integer i = 10;</code></pre><p>　　这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。</p><p>　　那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p><pre><code>Integer i = 10;  //装箱int n = i;   //拆箱</code></pre><p>　　<br>　　简单一点说，装箱就是  自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。</p><h1 id="装箱和拆箱是如何实现的"><a href="#装箱和拆箱是如何实现的" class="headerlink" title="装箱和拆箱是如何实现的"></a>装箱和拆箱是如何实现的</h1><p>这部分主要内容来自于<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">^2</a>，作者是Matrix海子，写的很清楚，这里为了阅读方便转载一下，内容如下：</p><details>    <summary>装箱和拆箱是如何实现的</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer i = 10;</span><br><span class="line">        int n = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>先编译<code>javac Main.java</code>，然后反编译class文件 <code>javap -c Main</code>后</p><p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。</p><p>　　其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。</p><p>　　因此可以用一句话总结装箱和拆箱的实现过程：</p><p>　　装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p><h1 id="面试中相关的问题"><a href="#面试中相关的问题" class="headerlink" title="面试中相关的问题"></a>面试中相关的问题</h1><ol><li>代码的输出结果是什么<details> <summary>代码的输出结果是什么</summary></details></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = 100;</span><br><span class="line">        Integer i2 = 100;</span><br><span class="line">        Integer i3 = 200;</span><br><span class="line">        Integer i4 = 200;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟,Integer的valueOf方法的具体实现和IntegerCache类的实现，通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p><p>　　上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p><ol start="2"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Double i1 = 100.0;</span><br><span class="line">        Double i2 = 100.0;</span><br><span class="line">        Double i3 = 200.0;</span><br><span class="line">        Double i4 = 200.0;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>具体为什么，可以去看Double类的valueOf的实现。</p><p>　　在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><p>　　注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</p><p>　　　　　Double、Float的valueOf方法的实现是类似的。　</p><ol start="3"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean i1 = false;</span><br><span class="line">        Boolean i2 = false;</span><br><span class="line">        Boolean i3 = true;</span><br><span class="line">        Boolean i4 = true;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>输出结果都是true,至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然</p><ol start="4"><li>谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。</li></ol><p>　　当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</p><p>　　1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；</p><p>　　2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</p><ol start="5"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        Integer c = 3;</span><br><span class="line">        Integer d = 3;</span><br><span class="line">        Integer e = 321;</span><br><span class="line">        Integer f = 321;</span><br><span class="line">        Long g = 3L;</span><br><span class="line">        Long h = 2L;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);</span><br><span class="line">        System.out.println(e==f);</span><br><span class="line">        System.out.println(c==(a+b));</span><br><span class="line">        System.out.println(c.equals(a+b));</span><br><span class="line">        System.out.println(g==(a+b));</span><br><span class="line">        System.out.println(g.equals(a+b));</span><br><span class="line">        System.out.println(g.equals(a+h));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>当 “==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然：</p><pre><code>truefalsetruetruetruefalsetrue</code></pre><p>第一个和第二个输出结果没有什么疑问。第三句由于  a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p><p>如果对上面的具体执行过程有疑问，可以尝试获取反编译的字节码内容进行查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装箱和拆箱&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识-重写 `equals` 时为何必须重写 `hashCode` 方法</title>
    <link href="http://yoursite.com/2021/02/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%87%8D%E5%86%99%20%60equals%60%20%E6%97%B6%E4%B8%BA%E4%BD%95%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99%20%60hashCode%60%20%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/22/Java基础知识-重写 `equals` 时为何必须重写 `hashCode` 方法/</id>
    <published>2021-02-22T02:00:12.000Z</published>
    <updated>2021-02-22T02:58:44.532Z</updated>
    
    <content type="html"><![CDATA[<p>重写 <code>equals</code> 时为何必须重写 <code>hashCode</code> 方法</p><a id="more"></a><h1 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h1><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p><p><strong>1)hashCode()介绍:</strong></p><p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>2)为什么要有 hashCode？</strong></p><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p><blockquote><p> <code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p><p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p><p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p><p>上面的解释我读起来还是有点儿懵，从链接里我才真正明白了。</p><p>我们以“类的用途”来将“hashCode() 和 equals()的关系”分2种情况来说明。</p><ol><li><p>第一种 不会创建“类对应的散列表”</p><p>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p></li></ol><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！<br>这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。</p><p>下面，我们通过示例查看类的两个对象相等 以及 不等时hashCode()的取值。</p><p>源码如下 (NormalHashCodeTest.java)：</p><details>    <summary>NormalHashCodeTest</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class NormalHashCodeTest&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建2个相同内容的Person对象，</span><br><span class="line">        // 再用equals比较它们是否相等</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        System.out.printf(&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;, p1.equals(p3), p1.hashCode(), p3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name + &quot; - &quot; +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc 覆盖equals方法</span><br><span class="line">         */</span><br><span class="line">        public boolean equals(Object obj)&#123;</span><br><span class="line">            if(obj == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果是同一个对象返回true，反之返回false</span><br><span class="line">            if(this == obj)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断是否类型相同</span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Person person = (Person)obj;</span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>运行结果：</p><pre><code>p1.equals(p2) : true; p1(1169863946) p2(1901116749)p1.equals(p3) : false; p1(1169863946) p3(2131949076)</code></pre><p>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><ol start="2"><li>第二种 会创建“类对应的散列表”</li></ol><p>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：</p><p>1)、如果两个对象相等，那么它们的hashCode()值一定相同。<br>      这里的相等是指，通过equals()比较两个对象时返回true。</p><p>2)、如果两个对象hashCode()相等，它们并不一定相等。<br>       因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。</p><p>此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。<br>例如，创建Person类的HashSet集合，必须同时覆盖Person类的equals() 和 hashCode()方法。<br>        如果单单只是覆盖equals()方法。我们会发现，equals()方法没有达到我们想要的效果。</p><p>参考代码 (ConflictHashCodeTest1.java)：</p><details>    <summary>ConflictHashCodeTest1</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class ConflictHashCodeTest1&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建Person对象，</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line"></span><br><span class="line">        // 新建HashSet对象</span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        // 比较p1 和 p2， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        // 打印set</span><br><span class="line">        System.out.printf(&quot;set:%s\n&quot;, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;(&quot;+name + &quot;, &quot; +age+&quot;)&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc 覆盖equals方法</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj)&#123;</span><br><span class="line">            if(obj == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果是同一个对象返回true，反之返回false</span><br><span class="line">            if(this == obj)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断是否类型相同</span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Person person = (Person)obj;</span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>运行结果：<pre><code>p1.equals(p2) : true; p1(1169863946) p2(1690552137)set:[(eee, 100), (eee, 100), (aaa, 200)]</code></pre><p>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p><p>下面，我们同时覆盖equals() 和 hashCode()方法。</p><p>参考代码 (ConflictHashCodeTest2.java)：</p><details>    <summary>ConflictHashCodeTest2</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.Comparable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 比较equals() 返回true 以及 返回false时， hashCode()的值。</span><br><span class="line"> *</span><br><span class="line"> * @author skywang</span><br><span class="line"> * @emai kuiwu-wang@163.com</span><br><span class="line"> */</span><br><span class="line">public class ConflictHashCodeTest2&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 新建Person对象，</span><br><span class="line">        Person p1 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p2 = new Person(&quot;eee&quot;, 100);</span><br><span class="line">        Person p3 = new Person(&quot;aaa&quot;, 200);</span><br><span class="line">        Person p4 = new Person(&quot;EEE&quot;, 100);</span><br><span class="line"></span><br><span class="line">        // 新建HashSet对象</span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        // 比较p1 和 p2， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        // 比较p1 和 p4， 并打印它们的hashCode()</span><br><span class="line">        System.out.printf(&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;, p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">        // 打印set</span><br><span class="line">        System.out.printf(&quot;set:%s\n&quot;, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc Person类。</span><br><span class="line">     */</span><br><span class="line">    private static class Person &#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name, int age) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return name + &quot; - &quot; +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc重写hashCode</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode()&#123;</span><br><span class="line">            int nameHash =  name.toUpperCase().hashCode();</span><br><span class="line">            return nameHash ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @desc 覆盖equals方法</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object obj)&#123;</span><br><span class="line">            if(obj == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果是同一个对象返回true，反之返回false</span><br><span class="line">            if(this == obj)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断是否类型相同</span><br><span class="line">            if(this.getClass() != obj.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Person person = (Person)obj;</span><br><span class="line">            return name.equals(person.name) &amp;&amp; age==person.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>运行结果：</p><pre><code>p1.equals(p2) : true; p1(68545) p2(68545)p1.equals(p4) : false; p1(68545) p4(68545)set:[aaa - 200, eee - 100]</code></pre><p>结果分析：</p><p>这下，equals()生效了，HashSet中没有重复元素。<br>比较p1和p2，我们发现：它们的hashCode()相等，通过equals()比较它们也返回true。所以，p1和p2被视为相等。<br>比较p1和p4，我们发现：虽然它们的hashCode()相等；但是，通过equals()比较它们返回false。所以，p1和p4被视为不相等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重写 &lt;code&gt;equals&lt;/code&gt; 时为何必须重写 &lt;code&gt;hashCode&lt;/code&gt; 方法&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>77. 组合</title>
    <link href="http://yoursite.com/2021/02/03/77.%20%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2021/02/03/77. 组合/</id>
    <published>2021-02-03T02:12:12.000Z</published>
    <updated>2021-02-19T08:30:24.077Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><a id="more"></a><p>示例:</p><pre><code>输入: n = 4, k = 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><h1 id="方法一：递归实现组合型枚举"><a href="#方法一：递归实现组合型枚举" class="headerlink" title="方法一：递归实现组合型枚举"></a>方法一：递归实现组合型枚举</h1><p><strong>思路与算法</strong></p><p>从 <em>n</em> 个当中选 <em>k</em> 个的所有方案对应的枚举是组合型枚举。在「方法一」中我们用递归来实现组合型枚举。</p><p>首先我们先回忆一下如何用递归实现二进制枚举（子集枚举），假设我们需要找到一个长度为 <em>n</em> 的序列 <em>a</em> 的所有子序列，代码框架是这样的：</p><details>    <summary>二进制枚举</summary><figure class="highlight cpp"><figcaption><span>[demo1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录答案</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><details>    <summary>二进制枚举</summary><figure class="highlight cpp"><figcaption><span>[demo2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录合法的答案</span></span><br><span class="line">    <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur == n + 1 的时候结束递归</span></span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这个时候我们可以做一个剪枝，如果当前 temp 的大小为 <em>s</em>，未确定状态的区间cur的长度为 <em>t</em>，如果 <em>s + t &lt; k*，那么即使 *t</em> 个都被选中，也不可能构造出一个长度为 <em>k</em> 的序列，故这种情况就没有必要继续向下递归，即我们可以在每次递归开始的时候做一次这样的判断：</p><figure class="highlight cpp"><figcaption><span>[demo3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就变成了这样：</p><details>    <summary>二进制枚举</summary><figure class="highlight cpp"><figcaption><span>[demo4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">    <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录合法的答案</span></span><br><span class="line">    <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur == n + 1 的时候结束递归</span></span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp.push_back(cur);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>剪枝方法见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>二进制枚举C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.push_back(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        temp.add(cur);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">cur, n, k, temp</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">        <span class="keyword">if</span> (temp.length + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录合法的答案</span></span><br><span class="line">        <span class="keyword">if</span> (temp.length == k) &#123;</span><br><span class="line">            ans.push(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k, [...temp, cur]);</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        dfs(cur + <span class="number">1</span>, n, k, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, n, k, []);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="params">(ans [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">dfs</span> = <span class="title">func</span><span class="params">(cur <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(temp) + (n - cur + <span class="number">1</span>) &lt; k &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录合法的答案</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(temp) == k &#123;</span><br><span class="line">comb := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(comb, temp)</span><br><span class="line">ans = <span class="built_in">append</span>(ans, comb)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 考虑选择当前位置</span></span><br><span class="line">temp = <span class="built_in">append</span>(temp, cur)</span><br><span class="line">dfs(cur + <span class="number">1</span>)</span><br><span class="line">temp = temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">dfs(cur + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二进制枚举C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* temp;</span><br><span class="line"><span class="keyword">int</span> tempSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>** ans;</span><br><span class="line"><span class="keyword">int</span> ansSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span></span><br><span class="line">    <span class="keyword">if</span> (tempSize + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录合法的答案</span></span><br><span class="line">    <span class="keyword">if</span> (tempSize == k) &#123;</span><br><span class="line">        <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tmp[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ansSize++] = tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">    temp[tempSize++] = cur;</span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    tempSize--;</span><br><span class="line">    <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * k);</span><br><span class="line">    ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">10001</span>);</span><br><span class="line">    tempSize = ansSize = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, n, k);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ansSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><h1 id="方法二：非递归（字典序法）实现组合型枚举"><a href="#方法二：非递归（字典序法）实现组合型枚举" class="headerlink" title="方法二：非递归（字典序法）实现组合型枚举"></a>方法二：非递归（字典序法）实现组合型枚举</h1><p><strong>思路与算法</strong></p><p><strong>小贴士：这个方法理解起来比「方法一」复杂，建议读者遇到不理解的地方可以在草稿纸上举例模拟这个过程。</strong></p><p>这里的非递归版不是简单的用栈模拟递归转化为非递归：我们希望通过合适的手段，消除递归栈带来的额外空间代价。</p><p>假设我们把原序列中被选中的位置记为 <em>1</em>，不被选中的位置记为 <em>0</em>，对于每个方案都可以构造出一个二进制数。我们让原序列从大到小排列。我们先看一看 <em>n = 4<em>，</em>k = 2</em> 的例子：</p><table><thead><tr><th>原序列中被选中的数</th><th>对应的二进制数</th><th>方案</th></tr></thead><tbody><tr><td><em>43[2][1]</em></td><td><em>0011</em></td><td><em>2, 1</em></td></tr><tr><td><em>4[3]2[1]</em></td><td><em>0101</em></td><td><em>3, 1</em></td></tr><tr><td><em>4[3][2]1</em></td><td><em>0110</em></td><td><em>3, 2</em></td></tr><tr><td><em>[4]32[1]</em></td><td><em>1001</em></td><td><em>4, 1</em></td></tr><tr><td><em>[4]3[2]1</em></td><td><em>1010</em></td><td><em>4, 2</em></td></tr><tr><td><em>[4][3]21</em></td><td><em>1100</em></td><td><em>4, 3</em></td></tr></tbody></table><p>我们可以看出「对应的二进制数」一列包含了由 <em>k</em> 个 <em>1</em> 和 <em>n - k</em> 个 <em>0</em> 组成的所有二进制数，并且按照字典序排列。这给了我们一些启发，我们可以通过某种方法枚举，使得生成的序列是根据字典序递增的。我们可以考虑我们一个二进制数数字 <em>x</em>，它由 <em>k</em> 个 <em>1</em> 和 <em>n - k</em> 个 <em>0</em> 组成，见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>非递归（字典序法）实现组合型枚举C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">        <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push_back(n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            ans.emplace_back(temp.begin(), temp.begin() + k);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">            <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k &amp;&amp; temp[j] + <span class="number">1</span> == temp[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp[j] = j + <span class="number">1</span>;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">            ++temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">        <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp.subList(<span class="number">0</span>, k)));</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">            <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k &amp;&amp; temp.get(j) + <span class="number">1</span> == temp.get(j + <span class="number">1</span>)) &#123;</span><br><span class="line">                temp.set(j, j + <span class="number">1</span>);</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">            temp.set(j, temp.get(j) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">    <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        temp.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    temp.push(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        ans.push(temp.slice(<span class="number">0</span>, k));</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">        <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; k &amp;&amp; temp[j] + <span class="number">1</span> == temp[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp[j] = j + <span class="number">1</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">        ++temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="params">(ans [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line"><span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= k; i++ &#123;</span><br><span class="line">temp = <span class="built_in">append</span>(temp, i)</span><br><span class="line">&#125;</span><br><span class="line">temp = <span class="built_in">append</span>(temp, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; k; &#123;</span><br><span class="line">comb := <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line"><span class="built_in">copy</span>(comb, temp[:k])</span><br><span class="line">ans = <span class="built_in">append</span>(ans, comb)</span><br><span class="line"><span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line"><span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line"><span class="keyword">for</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; temp[j]+<span class="number">1</span> == temp[j+<span class="number">1</span>]; j++ &#123;</span><br><span class="line">temp[j] = j + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">temp[j]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>非递归（字典序法）实现组合型枚举C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (k + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> tempSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">10001</span>);</span><br><span class="line">    <span class="keyword">int</span> ansSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]</span></span><br><span class="line">    <span class="comment">// 末尾加一位 n + 1 作为哨兵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        temp[i - <span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[k] = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tmp[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ansSize++] = tmp;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t</span></span><br><span class="line">        <span class="comment">// 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; k &amp;&amp; temp[j] + <span class="number">1</span> == temp[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp[j] = j + <span class="number">1</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// j 是第一个 temp[j] + 1 != temp[j + 1] 的位置</span></span><br><span class="line">        ++temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ansSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>见<a href="https://leetcode-cn.com/problems/combinations/solution/zu-he-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>57. 插入区间</title>
    <link href="http://yoursite.com/2021/02/02/57.%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2021/02/02/57. 插入区间/</id>
    <published>2021-02-02T09:12:12.000Z</published>
    <updated>2021-02-03T01:37:17.352Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]]</code></pre><p>示例 2：</p><pre><code>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</code></pre><p>示例 3：</p><pre><code>输入：intervals = [], newInterval = [5,7]输出：[[5,7]]</code></pre><p>示例 4：</p><pre><code>输入：intervals = [[1,5]], newInterval = [2,3]输出：[[1,5]]</code></pre><p>示例 5：</p><pre><code>输入：intervals = [[1,5]], newInterval = [2,7]输出：[[1,7]]</code></pre><p>提示：</p><pre><code>0 &lt;= intervals.length &lt;= 104intervals[i].length == 20 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 105intervals 根据 intervals[i][0] 按 升序 排列newInterval.length == 20 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 105</code></pre><h1 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h1><p><strong>思路与算法</strong></p><p>见<a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p><p><strong>代码</strong></p><details>    <summary>模拟C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">bool</span> placed = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ans.push_back(&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="literal">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ans.push_back(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ans.push_back(&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> placed = <span class="keyword">false</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="keyword">true</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansList.size(); ++i) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        left, right = newInterval</span><br><span class="line">        placed = <span class="keyword">False</span></span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> li, ri <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> li &gt; right:</span><br><span class="line">                <span class="comment"># 在插入区间的右侧且无交集</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">                    ans.append([left, right])</span><br><span class="line">                    placed = <span class="keyword">True</span></span><br><span class="line">                ans.append([li, ri])</span><br><span class="line">            <span class="keyword">elif</span> ri &lt; left:</span><br><span class="line">                <span class="comment"># 在插入区间的左侧且无交集</span></span><br><span class="line">                ans.append([li, ri])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = min(left, li)</span><br><span class="line">                right = max(right, ri)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">            ans.append([left, right])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(intervals [][]<span class="keyword">int</span>, newInterval []<span class="keyword">int</span>)</span> <span class="params">(ans [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    left, right := newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]</span><br><span class="line">    merged := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">        <span class="keyword">if</span> interval[<span class="number">0</span>] &gt; right &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">            <span class="keyword">if</span> !merged &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="keyword">int</span>&#123;left, right&#125;)</span><br><span class="line">                merged = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, interval)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> interval[<span class="number">1</span>] &lt; left &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, interval)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">            left = min(left, interval[<span class="number">0</span>])</span><br><span class="line">            right = max(right, interval[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !merged &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, []<span class="keyword">int</span>&#123;left, right&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">insert</span><span class="params">(<span class="keyword">int</span>** intervals, <span class="keyword">int</span> intervalsSize, <span class="keyword">int</span>* intervalsColSize, <span class="keyword">int</span>* newInterval, <span class="keyword">int</span> newIntervalSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> placed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span>** ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (intervalsSize + <span class="number">1</span>));</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (intervalsSize + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervalsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span>* interval = intervals[i];</span><br><span class="line">        <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的右侧且无交集</span></span><br><span class="line">            <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">                tmp[<span class="number">0</span>] = left, tmp[<span class="number">1</span>] = right;</span><br><span class="line">                (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">                ans[(*returnSize)++] = tmp;</span><br><span class="line">                placed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(tmp, interval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">            ans[(*returnSize)++] = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">            <span class="comment">// 在插入区间的左侧且无交集</span></span><br><span class="line">            <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(tmp, interval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">            ans[(*returnSize)++] = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与插入区间有交集，计算它们的并集</span></span><br><span class="line">            left = fmin(left, interval[<span class="number">0</span>]);</span><br><span class="line">            right = fmax(right, interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">        <span class="keyword">int</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">        tmp[<span class="number">0</span>] = left, tmp[<span class="number">1</span>] = right;</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">        ans[(*returnSize)++] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是数组 intervals 的长度，即给定的区间个数。</p></li><li><p>空间复杂度：<em>O(1)</em>。除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个 无重叠的 ，按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>17. 电话号码的字母组合</title>
    <link href="http://yoursite.com/2021/02/02/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2021/02/02/17. 电话号码的字母组合/</id>
    <published>2021-02-02T07:12:12.000Z</published>
    <updated>2021-02-02T08:10:39.889Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</code></pre><p>示例 2：</p><pre><code>输入：digits = &quot;&quot;输出：[]</code></pre><p>示例 3：</p><pre><code>输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre><p>提示：</p><pre><code>0 &lt;= digits.length &lt;= 4digits[i] 是范围 [&apos;2&apos;, &apos;9&apos;] 的一个数字。</code></pre><h1 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h1><p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><p>回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p><details>    <summary>回溯Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">            put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">            put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">            put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">            put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">            put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">            put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">            put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="keyword">int</span> index, StringBuffer combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> digit = digits.charAt(index);</span><br><span class="line">            String letters = phoneMap.get(digit);</span><br><span class="line">            <span class="keyword">int</span> lettersCount = letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; combinations;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; phoneMap&#123;</span><br><span class="line">            &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">string</span> combination;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, combination);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; combinations, <span class="keyword">const</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&amp; phoneMap, <span class="keyword">const</span> <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> index, <span class="built_in">string</span>&amp; combination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.push_back(combination);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> digit = digits[index];</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span>&amp; letters = phoneMap.at(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>&amp; letter: letters) &#123;</span><br><span class="line">                combination.push_back(letter);</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phoneMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">"abc"</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">"def"</span>,</span><br><span class="line">    <span class="string">"4"</span>: <span class="string">"ghi"</span>,</span><br><span class="line">    <span class="string">"5"</span>: <span class="string">"jkl"</span>,</span><br><span class="line">    <span class="string">"6"</span>: <span class="string">"mno"</span>,</span><br><span class="line">    <span class="string">"7"</span>: <span class="string">"pqrs"</span>,</span><br><span class="line">    <span class="string">"8"</span>: <span class="string">"tuv"</span>,</span><br><span class="line">    <span class="string">"9"</span>: <span class="string">"wxyz"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> combinations []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    combinations = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    backtrack(digits, <span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> combinations</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(digits <span class="keyword">string</span>, index <span class="keyword">int</span>, combination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">        combinations = <span class="built_in">append</span>(combinations, combination)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        digit := <span class="keyword">string</span>(digits[index])</span><br><span class="line">        letters := phoneMap[digit]</span><br><span class="line">        lettersCount := <span class="built_in">len</span>(letters)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lettersCount; i++ &#123;</span><br><span class="line">            backtrack(digits, index + <span class="number">1</span>, combination + <span class="keyword">string</span>(letters[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> phoneMap[<span class="number">11</span>][<span class="number">5</span>] = &#123;<span class="string">"\0"</span>, <span class="string">"\0"</span>, <span class="string">"abc\0"</span>, <span class="string">"def\0"</span>, <span class="string">"ghi\0"</span>, <span class="string">"jkl\0"</span>, <span class="string">"mno\0"</span>, <span class="string">"pqrs\0"</span>, <span class="string">"tuv\0"</span>, <span class="string">"wxyz\0"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* digits_tmp;</span><br><span class="line"><span class="keyword">int</span> digits_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>** combinations;</span><br><span class="line"><span class="keyword">int</span> combinations_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* combination;</span><br><span class="line"><span class="keyword">int</span> combination_size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits_size) &#123;</span><br><span class="line">        <span class="keyword">char</span>* tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (combination_size + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, combination, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (combination_size + <span class="number">1</span>));</span><br><span class="line">        combinations[combinations_size++] = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> digit = digits_tmp[index];</span><br><span class="line">        <span class="keyword">char</span>* letters = phoneMap[digit - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(letters);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            combination[combination_size++] = letters[i];</span><br><span class="line">            combination[combination_size] = <span class="number">0</span>;</span><br><span class="line">            backtrack(index + <span class="number">1</span>);</span><br><span class="line">            combination[--combination_size] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">letterCombinations</span><span class="params">(<span class="keyword">char</span>* digits, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    combinations_size = combination_size = <span class="number">0</span>;</span><br><span class="line">    digits_tmp = digits;</span><br><span class="line">    digits_size = <span class="built_in">strlen</span>(digits);</span><br><span class="line">    <span class="keyword">if</span> (digits_size == <span class="number">0</span>) &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits_size; i++) num *= <span class="number">4</span>;</span><br><span class="line">    combinations = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * num);</span><br><span class="line">    combination = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * digits_size);</span><br><span class="line">    backtrack(<span class="number">0</span>);</span><br><span class="line">    *returnSize = combinations_size;</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line">        </span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">"2"</span>: <span class="string">"abc"</span>,</span><br><span class="line">            <span class="string">"3"</span>: <span class="string">"def"</span>,</span><br><span class="line">            <span class="string">"4"</span>: <span class="string">"ghi"</span>,</span><br><span class="line">            <span class="string">"5"</span>: <span class="string">"jkl"</span>,</span><br><span class="line">            <span class="string">"6"</span>: <span class="string">"mno"</span>,</span><br><span class="line">            <span class="string">"7"</span>: <span class="string">"pqrs"</span>,</span><br><span class="line">            <span class="string">"8"</span>: <span class="string">"tuv"</span>,</span><br><span class="line">            <span class="string">"9"</span>: <span class="string">"wxyz"</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index: int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == len(digits):</span><br><span class="line">                combinations.append(<span class="string">""</span>.join(combination))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digit = digits[index]</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phoneMap[digit]:</span><br><span class="line">                    combination.append(letter)</span><br><span class="line">                    backtrack(index + <span class="number">1</span>)</span><br><span class="line">                    combination.pop()</span><br><span class="line"></span><br><span class="line">        combination = list()</span><br><span class="line">        combinations = list()</span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3_oneliner]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line">        </span><br><span class="line">        phoneMap = &#123;</span><br><span class="line">            <span class="string">"2"</span>: <span class="string">"abc"</span>,</span><br><span class="line">            <span class="string">"3"</span>: <span class="string">"def"</span>,</span><br><span class="line">            <span class="string">"4"</span>: <span class="string">"ghi"</span>,</span><br><span class="line">            <span class="string">"5"</span>: <span class="string">"jkl"</span>,</span><br><span class="line">            <span class="string">"6"</span>: <span class="string">"mno"</span>,</span><br><span class="line">            <span class="string">"7"</span>: <span class="string">"pqrs"</span>,</span><br><span class="line">            <span class="string">"8"</span>: <span class="string">"tuv"</span>,</span><br><span class="line">            <span class="string">"9"</span>: <span class="string">"wxyz"</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        groups = (phoneMap[digit] <span class="keyword">for</span> digit <span class="keyword">in</span> digits)</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>.join(combination) <span class="keyword">for</span> combination <span class="keyword">in</span> itertools.product(*groups)]</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(3^m * 4^n)，其中 <em>m</em> 是输入中对应 <em>3</em> 个字母的数字个数（包括数字 <em>2</em>、<em>3</em>、<em>4</em>、<em>5</em>、<em>6</em>、<em>8</em>），<em>n</em> 是输入中对应 <em>4</em> 个字母的数字个数（包括数字 <em>7</em>、<em>9</em>），<em>m+n</em> 是输入数字的总个数。当输入包含 <em>m</em> 个对应 <em>3</em> 个字母的数字和 <em>n</em> 个对应 <em>4</em> 个字母的数字时，不同的字母组合一共有3^m * 4^n 种，需要遍历每一种字母组合。</p></li><li><p>空间复杂度：<em>O(m+n)</em>，其中 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>909. 蛇梯棋</title>
    <link href="http://yoursite.com/2021/01/28/909.%20%E8%9B%87%E6%A2%AF%E6%A3%8B/"/>
    <id>http://yoursite.com/2021/01/28/909. 蛇梯棋/</id>
    <published>2021-01-28T06:23:12.000Z</published>
    <updated>2021-01-28T09:28:27.707Z</updated>
    
    <content type="html"><![CDATA[<p>N x N 的棋盘 board 上，按从 1 到 N<em>N 的数字给方格编号，编号 从左下角开始，每一行交替方向。返回达到方格 N</em>N 所需的最少移动次数，如果不可能，则返回 -1。</p><a id="more"></a><p>例如，一块 6 x 6 大小的棋盘，编号如下：</p><p>r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。</p><p>玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进：</p><p>选定目标方格：选择从编号 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个目标方格 s ，目标方格的编号 &lt;= N*N。<br>该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。<br>传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S。<br>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p><p>返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。</p><p>示例：</p><pre><code>输入：[[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]输出：4解释：首先，从方格 1 [第 5 行，第 0 列] 开始。你决定移动到方格 2，并必须爬过梯子移动到到方格 15。然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。然后你决定移动到方格 14，且必须通过梯子移动到方格 35。然后你决定移动到方格 36, 游戏结束。可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</code></pre><p>提示：</p><pre><code>2 &lt;= board.length = board[0].length &lt;= 20board[i][j] 介于 1 和 N*N 之间或者等于 -1。编号为 1 的方格上没有蛇或梯子。编号为 N*N 的方格上没有蛇或梯子。</code></pre><h1 id="方法-1：广度优先搜索"><a href="#方法-1：广度优先搜索" class="headerlink" title="方法 1：广度优先搜索"></a>方法 1：广度优先搜索</h1><p><strong>想法</strong></p><p>由于我们需要找到一条最短路径，广度优先搜索是一种理想的方法。难点在于如何对每个方格枚举所有可能的移动。</p><p><strong>算法</strong></p><p>假设我们在方格 <code>s</code> 上，我们想知道一次移动之后所有可能的终点 <code>s2</code>。</p><p>这需要知道方格 <code>s2</code> 的坐标 <code>get(s2)</code>，这有一个小技巧：我们知道行号每 <code>N</code> 个方格改变一次，所以只依赖于 <code>quot = (s2-1) / N</code>；同样列号依赖于 <code>rem = (s2-1) % N</code>。</p><p>由此，我们可以实现一个根据方格 <code>s</code>  的信息进行广度优先搜索。</p><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = board.length;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; dist = <span class="keyword">new</span> HashMap();</span><br><span class="line">        dist.put(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (s == N*N) <span class="keyword">return</span> dist.get(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s2 = s+<span class="number">1</span>; s2 &lt;= Math.min(s+<span class="number">6</span>, N*N); ++s2) &#123;</span><br><span class="line">                <span class="keyword">int</span> rc = get(s2, N);</span><br><span class="line">                <span class="keyword">int</span> r = rc / N, c = rc % N;</span><br><span class="line">                <span class="keyword">int</span> s2Final = board[r][c] == -<span class="number">1</span> ? s2 : board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (!dist.containsKey(s2Final)) &#123;</span><br><span class="line">                    dist.put(s2Final, dist.get(s) + <span class="number">1</span>);</span><br><span class="line">                    queue.add(s2Final);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Given a square num s, return board coordinates (r, c) as r*N + c</span></span><br><span class="line">        <span class="keyword">int</span> quot = (s-<span class="number">1</span>) / N;</span><br><span class="line">        <span class="keyword">int</span> rem = (s-<span class="number">1</span>) % N;</span><br><span class="line">        <span class="keyword">int</span> row = N - <span class="number">1</span> - quot;</span><br><span class="line">        <span class="keyword">int</span> col = row % <span class="number">2</span> != N % <span class="number">2</span> ? rem : N - <span class="number">1</span> - rem;</span><br><span class="line">        <span class="keyword">return</span> row * N + col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        N = len(board)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="comment"># Given a square num s, return board coordinates (r, c)</span></span><br><span class="line">            quot, rem = divmod(s<span class="number">-1</span>, N)</span><br><span class="line">            row = N - <span class="number">1</span> - quot</span><br><span class="line">            col = rem <span class="keyword">if</span> row%<span class="number">2</span> != N%<span class="number">2</span> <span class="keyword">else</span> N - <span class="number">1</span> - rem</span><br><span class="line">            <span class="keyword">return</span> row, col</span><br><span class="line"></span><br><span class="line">        dist = &#123;<span class="number">1</span>: <span class="number">0</span>&#125;</span><br><span class="line">        queue = collections.deque([<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            s = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> s == N*N: <span class="keyword">return</span> dist[s]</span><br><span class="line">            <span class="keyword">for</span> s2 <span class="keyword">in</span> xrange(s+<span class="number">1</span>, min(s+<span class="number">6</span>, N*N) + <span class="number">1</span>):</span><br><span class="line">                r, c = get(s2)</span><br><span class="line">                <span class="keyword">if</span> board[r][c] != <span class="number">-1</span>:</span><br><span class="line">                    s2 = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> s2 <span class="keyword">not</span> <span class="keyword">in</span> dist:</span><br><span class="line">                    dist[s2] = dist[s] + <span class="number">1</span></span><br><span class="line">                    queue.append(s2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2)*，其中 *N</em> 是 <code>board</code> 的长度。</li><li>空间复杂度：<em>O(N^2)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N x N 的棋盘 board 上，按从 1 到 N&lt;em&gt;N 的数字给方格编号，编号 从左下角开始，每一行交替方向。返回达到方格 N&lt;/em&gt;N 所需的最少移动次数，如果不可能，则返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年1月" scheme="http://yoursite.com/categories/2021%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>688. “马”在棋盘上的概率</title>
    <link href="http://yoursite.com/2021/01/27/688.%20%E2%80%9C%E9%A9%AC%E2%80%9D%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/"/>
    <id>http://yoursite.com/2021/01/27/688. “马”在棋盘上的概率/</id>
    <published>2021-01-27T09:23:12.000Z</published>
    <updated>2021-01-28T06:16:05.034Z</updated>
    
    <content type="html"><![CDATA[<p>已知一个 NxN 的国际象棋棋盘，求移动结束后，“马” 仍留在棋盘上的概率。</p><a id="more"></a><p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 </p><p>现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 </p><p>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。</p><p>现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。</p><p>求移动结束后，“马” 仍留在棋盘上的概率。</p><p>示例：</p><pre><code>输入: 3, 2, 0, 0输出: 0.0625解释: 输入的数据依次为 N, K, r, c第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。所以 “马” 在结束后仍在棋盘上的概率为 0.0625。</code></pre><p>注意：</p><pre><code>N 的取值范围为 [1, 25]K 的取值范围为 [0, 100]开始时，“马” 总是位于棋盘上</code></pre><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p><strong>算法：</strong></p><ul><li>令 <code>f[r][c][steps]</code> 代表马在位置 <code>(r, c)</code> 移动了 <code>steps</code> 次以后还留在棋盘上的概率，根据马的移动方式，我们有以下递归：<br>  <code>f[r][c][steps]=sum(f[r+dr][c+dc][steps-1])/8.0</code></li><li>根据题目我们可以知道 <em>(dr, dc)</em> 的可能数据对是 <em>(2, 1),</em> <em>(2, -1),</em> <em>(-2, 1),</em> <em>(-2, -1),</em> <em>(1, 2),</em> <em>(1, -2),</em> <em>(-1, 2),</em> <em>(-1, -2)</em>。</li><li>我们将使用二维的 <code>dp</code> 和 <code>dp2</code> 来存储我们的数据，而不是使用三维数组 <code>f</code>。<code>dp2</code> 代表 <code>f[][][steps]</code>，<code>dp</code> 代表 <code>f[][][steps-1]</code>。 </li></ul><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">        <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dp[sr][sc] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; K &gt; <span class="number">0</span>; K--) &#123;</span><br><span class="line">            <span class="keyword">double</span>[][] dp2 = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; c++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> cr = r + dr[k];</span><br><span class="line">                        <span class="keyword">int</span> cc = c + dc[k];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; N &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; N) &#123;</span><br><span class="line">                            dp2[cr][cc] += dp[r][c] / <span class="number">8.0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span>[] row: dp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> x: row) ans += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;动态规划Python&lt;/summary&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">```python [solution1-Python]</span><br><span class="line">class Solution(object):</span><br><span class="line">    <span class="function">def <span class="title">knightProbability</span><span class="params">(self, N, K, r, c)</span>:</span></span><br><span class="line"><span class="function">        dp </span>= [[<span class="number">0</span>] * <span class="function">N <span class="keyword">for</span> _ in <span class="title">xrange</span><span class="params">(N)</span>]</span></span><br><span class="line"><span class="function">        dp[r][c] </span>= <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">for</span> _ in <span class="title">xrange</span><span class="params">(K)</span>:</span></span><br><span class="line"><span class="function">            dp2 </span>= [[<span class="number">0</span>] * <span class="function">N <span class="keyword">for</span> _ in <span class="title">xrange</span><span class="params">(N)</span>]</span></span><br><span class="line"><span class="function">            <span class="keyword">for</span> r, row in <span class="title">enumerate</span><span class="params">(dp)</span>:</span></span><br><span class="line"><span class="function">                <span class="keyword">for</span> c, val in <span class="title">enumerate</span><span class="params">(row)</span>:</span></span><br><span class="line"><span class="function">                    <span class="keyword">for</span> dr, dc <span class="title">in</span> <span class="params">((<span class="number">2</span>,<span class="number">1</span>)</span>,<span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span>,<span class="params">(<span class="number">-2</span>,<span class="number">1</span>)</span>,<span class="params">(<span class="number">-2</span>,<span class="number">-1</span>)</span>,</span></span><br><span class="line"><span class="function">                                   <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="params">(<span class="number">1</span>,<span class="number">-2</span>)</span>,<span class="params">(<span class="number">-1</span>,<span class="number">2</span>)</span>,<span class="params">(<span class="number">-1</span>,<span class="number">-2</span>)</span>):</span></span><br><span class="line"><span class="function">                        <span class="keyword">if</span> 0 &lt;</span>= r + dr &lt; N and <span class="number">0</span> &lt;= c + dc &lt; N:</span><br><span class="line">                            dp2[r+dr][c+dc] += val / <span class="number">8.0</span></span><br><span class="line">            dp = dp2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(map(sum, dp))</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N^2 K)*。其中 *N, K</em> 为题目中的定义。我们对 <em>N^2</em> 元素的每一层 <code>dp</code> 进行 <em>O(1)</em> 工作，并且考虑了 <em>K</em> 层。 </li><li>空间复杂度：<em>O(N^2)</em>，<code>dp</code> 和 <code>dp2</code> 的大小。 </li></ul><h1 id="方法二：矩阵求幂"><a href="#方法二：矩阵求幂" class="headerlink" title="方法二：矩阵求幂"></a>方法二：矩阵求幂</h1><p>方法 1 中表示的状态重复表达了过渡到其他的线性组合的状态。 任何情况下，我们都可以将整个转换表示为这些线性组合的矩阵。然后，这个矩阵的第 <em>n</em> 次方代表了 <em>n</em> 移动的转换，因此我们可以将问题简化为矩阵求幂问题。 </p><p><strong>算法：</strong></p><p>见<a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/solution/ma-zai-qi-pan-shang-de-gai-lu-by-leetcode/" target="_blank" rel="noopener">^1</a></p><details>    <summary>矩阵求幂Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[N * N];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r * N + c == canonical(r, c, N)) &#123;</span><br><span class="line">                    index[r * N + c] = t;</span><br><span class="line">                    t++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index[r * N + c] = index[canonical(r, c, N)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[][] T = <span class="keyword">new</span> <span class="keyword">double</span>[t][t];</span><br><span class="line">        <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r * N + c == canonical(r, c, N)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> cr = r + dr[k], cc = c + dc[k];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; N &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; N) &#123;</span><br><span class="line">                            T[curRow][index[canonical(cr, cc, N)]] += <span class="number">0.125</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curRow++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] row = matrixExpo(T, K)[index[sr*N + sc]];</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> x: row) ans += x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canonical</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*r &gt; N) r = N-<span class="number">1</span>-r;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*c &gt; N) c = N-<span class="number">1</span>-c;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; c) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = r;</span><br><span class="line">            r = c;</span><br><span class="line">            c = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r * N + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] matrixMult(<span class="keyword">double</span>[][] A, <span class="keyword">double</span>[][] B) &#123;</span><br><span class="line">        <span class="keyword">double</span>[][] ans = <span class="keyword">new</span> <span class="keyword">double</span>[A.length][A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B.length; k++) &#123;</span><br><span class="line">                    ans[i][j] += A[i][k] * B[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] matrixExpo(<span class="keyword">double</span>[][] A, <span class="keyword">int</span> pow) &#123;</span><br><span class="line">        <span class="keyword">double</span>[][] ans = <span class="keyword">new</span> <span class="keyword">double</span>[A.length][A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) ans[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pow == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (pow == <span class="number">1</span>) <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">if</span> (pow % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> matrixMult(matrixExpo(A, pow-<span class="number">1</span>), A);</span><br><span class="line">        <span class="keyword">double</span>[][] B = matrixExpo(A, pow / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMult(B, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>矩阵求幂Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">knightProbability</span><span class="params">(self, N, K, sr, sc)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canonical</span><span class="params">(r, c)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * r &gt; N: r = N - <span class="number">1</span> - r</span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * c &gt; N: c = N - <span class="number">1</span> - c</span><br><span class="line">            <span class="keyword">if</span> r &gt; c: r, c = c, r</span><br><span class="line">            <span class="keyword">return</span> r*N + c</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">matrix_mult</span><span class="params">(A, B)</span>:</span></span><br><span class="line">            ZB = zip(*B)</span><br><span class="line">            <span class="keyword">return</span> [[sum(a * b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(row, col))</span><br><span class="line">                     <span class="keyword">for</span> col <span class="keyword">in</span> ZB] <span class="keyword">for</span> row <span class="keyword">in</span> A]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">matrix_expo</span><span class="params">(A, K)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [[+(i==j) <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(A))]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A))]</span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> A</span><br><span class="line">            <span class="keyword">elif</span> K % <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> matrix_mult(matrix_expo(A, K<span class="number">-1</span>), A)</span><br><span class="line">            B = matrix_expo(A, K/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> matrix_mult(B, B)</span><br><span class="line"></span><br><span class="line">        index = [<span class="number">0</span>] * (N*N)</span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> xrange(N):</span><br><span class="line">                <span class="keyword">if</span> r*N + c == canonical(r, c):</span><br><span class="line">                    index[r*N + c] = t</span><br><span class="line">                    t += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index[r*N + c] = index[canonical(r, c)]</span><br><span class="line"></span><br><span class="line">        T = []</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> xrange(N):</span><br><span class="line">                <span class="keyword">if</span> r*N + c == canonical(r, c):</span><br><span class="line">                    row = [<span class="number">0</span>] * t</span><br><span class="line">                    <span class="keyword">for</span> dr, dc <span class="keyword">in</span> ((<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">-1</span>),(<span class="number">-2</span>,<span class="number">1</span>),(<span class="number">-2</span>,<span class="number">-1</span>),</span><br><span class="line">                                    (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">-2</span>),(<span class="number">-1</span>,<span class="number">2</span>),(<span class="number">-1</span>,<span class="number">-2</span>)):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= r+dr &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= c+dc &lt; N:</span><br><span class="line">                            row[index[(r+dr)*N + c+dc]] += <span class="number">0.125</span></span><br><span class="line">                    T.append(row)</span><br><span class="line"></span><br><span class="line">        Tk = matrix_expo(T, K)</span><br><span class="line">        i = index[sr * N + sc]</span><br><span class="line">        <span class="keyword">return</span> sum(Tk[i])</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已知一个 NxN 的国际象棋棋盘，求移动结束后，“马” 仍留在棋盘上的概率。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年1月" scheme="http://yoursite.com/categories/2021%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
  </entry>
  
</feed>
