<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-25T08:00:48.057Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>162. 寻找峰值</title>
    <link href="http://yoursite.com/2020/08/24/162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>http://yoursite.com/2020/08/24/162. 寻找峰值/</id>
    <published>2020-08-24T09:55:12.000Z</published>
    <updated>2020-08-25T08:00:48.057Z</updated>
    
    <content type="html"><![CDATA[<p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p><a id="more"></a><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞。</p><p>示例 1:</p><pre><code>输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。</code></pre><p>示例 2:</p><pre><code>输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。</code></pre><p>说明:</p><p>你的解法应该是 O(logN) 时间复杂度的。</p><h1 id="方法一-线性扫描"><a href="#方法一-线性扫描" class="headerlink" title="方法一: 线性扫描"></a>方法一: 线性扫描</h1><p>本方法利用了连续的两个元素 <em>nums[j]</em> 和 <em>nums[j + 1]</em> 不会相等这一事实。于是，我们可以从头开始遍历 <em>nums</em> 数组。每当我们遇到数字 <em>nums[i]*，只需要检查它是否大于下一个元素 *nums[i+1]</em> 即可判断 <em>nums[i]</em> 是否是峰值。可以通过分别讨论问题的全部三种可能情况来理解本方法的思路。</p><p>情况 1. </p><p>所有的数字以降序排列。这种情况下，第一个元素即为峰值。我们首先检查当前元素是否大于下个元素。第一个元素满足这一条件，因此被正确判断为峰值。此时，我们不需要继续向下判断，也就不会有需要判断 <em>nums[i]</em> 和上一个元素 <em>nums[i-1]</em> 的大小的情况。</p><p><a href="https://pic.leetcode-cn.com/fafef6e2070c9c444541d03e5d24c6c06f2f50f94026a22a9a86903e9d5ffcb1-image.png" target="_blank" rel="noopener">image.png</a></p><p>情况 2. </p><p>所有的数字以升序排列。这种情况下，我们会一直比较 <em>nums[i]</em> 与 <em>nums[i+1]</em> 以判断 <em>nums[i]</em> 是否是峰值元素。没有元素符合这一条件，说明处于上坡而非峰值。于是，在结尾，我们返回末尾元素作为峰值元素，得到正确结果。在这种情况下，我们同样不需要比较 <em>nums[i]</em> 和上一个元素 <em>nums[i-1]*，因为处于上坡是 *nums[i]</em> 不是峰值的充分条件。</p><p><a href="https://pic.leetcode-cn.com/06cbc777aee1d0d0a906aefd408e539014f783727e401f136b66581d0856aa6d-image.png" target="_blank" rel="noopener">image.png</a></p><p>情况 3. </p><p>峰值出现在中间某处。这种情况下，当遍历上升部分时，与情况 2 相同，没有元素满足 <em>nums[i] &gt; nums[i + 1]*。我们不需要比较 *nums[i]</em> 和上一个元素 <em>nums[i-1]<em>。当到达峰值元素时，</em>nums[i] &gt; nums[i + 1]</em> 条件满足。此时，我们同样不需要比较 <em>nums[i]</em> 和上一个元素 <em>nums[i-1]*。这是由于“遍历会到达第i个元素”本身就说明上一个元素（第i- 1个）不满足 *nums[i] &gt; nums[i + 1]</em> 这一条件，也就说明 <em>nums[i-1] &lt; nums[i]</em>。于是，我们同样可以得到正确结果。</p><p><a href="https://pic.leetcode-cn.com/802bad70c4444bf708f4c63e30e054a33c27ace43b3c7b4fa64a0ffb8201fb7d-image.png" target="_blank" rel="noopener">image.png</a></p><details>    <summary>线性扫描</summary><figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(n)*。 我们对长度为 *n</em> 的数组 <em>nums</em> 只进行一次遍历。</li><li>空间复杂度 : <em>O(1)</em>。 只使用了常数空间。<br><br></li></ul><hr><h1 id="方法二：递归二分查找"><a href="#方法二：递归二分查找" class="headerlink" title="方法二：递归二分查找"></a>方法二：递归二分查找</h1><p><strong>算法</strong></p><p>我们可以将 <em>nums</em> 数组中的任何给定序列视为交替的升序和降序序列。通过利用这一点，以及“可以返回任何一个峰作为结果”的要求，我们可以利用二分查找来找到所需的峰值元素。</p><p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 <em>nums</em> 中找到中间的元素 <em>mid*。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 *nums[i]</em> 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 <em>mid</em> 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p><p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 <em>nums[i]</em> 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 <em>mid</em> 的右边，并在右侧子数组上重复上述过程。</p><p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p><p>为了理解本方法的原理，让我们再次讨论前文提到的全部三种情况。</p><p>情况 1. 这种情况下，首先找到中间元素 <em>3</em>。由于它处于下降坡度，将搜索空间缩小到 <code>[1, 2, 3]</code>。对于此子数组，<em>2</em> 为中间元素，也处于下降坡度中，于是将搜索空间缩小到 <code>[1, 2]</code>。现在 <em>1</em> 是中间元素并同样处于下降坡度，于是将搜索空间缩小到 <code>[1]</code>。 最终 <em>1</em> 作为答案被正确返回。</p><p> <a href="https://pic.leetcode-cn.com/63177d2c44aab77a657c0eb4589f7b7f45e754cf3408d9872bc3371e680c5908-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/317e900368f211d02e3f107e288824a0e351d39963aae9a210b1fe3730ef1eec-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/1a26071c6f370ccd84a417a4edbfcf7178b1daf78ed3270285861af4f77c6496-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/8a511427f1c0c1b7c58776fa238124f44c300fc632d13658e1f381f6fd23fa03-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/17974218262fc0e235fac8bfe9252058015de312546ce35ac217ab428360b780-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/7d34f6f13915860f01f1e18409534a06db73504ffa3ab7dc66422801697a8a39-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/e2edf7bcc45863a10d438dd92b8c4c6b6b63ff834aa11f05e4a104b5cbf859fc-image.png" target="_blank" rel="noopener">image.png</a> </p><p>情况 2. 这种情况下，首先找到中间元素 <em>3</em>。由于它处于上升坡度，将搜索空间缩小到 <code>[4, 5]</code>。对于此子数组，<em>4</em> 为中间元素，也处于上升坡度中，于是将搜索空间缩小到 <code>[5]</code>。 最终 <em>5</em> 作为答案被正确返回。</p><p> <a href="https://pic.leetcode-cn.com/935aeb721c5901d8f70a64aafc0bff14be030db7cf44605c051e5c87de2890c0-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/fb6d1262315867c62d818b0606b2628b6537d4b1b9c337bbaf3708fad257391c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/6de90b2f77920d015f7a45191090b9265a49dae0c4585e8d514b1aaa39afd2b9-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/d359a685a16480ac4d6ad3d7e5df1f3b00524a74580982920bc01de72a9dd837-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/a976733e8b2e4817b2d88616b519bc58ca471ca15e9ee3f77fcc377a329e0d46-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/b0c6a62e9a0ebdc7a92995a1d633da7176cc82f9f3fe5e9e8f4b921b3d8fc4cc-image.png" target="_blank" rel="noopener">image.png</a> </p><p>情况 3. 这种情况下， 峰值位于中间某处。第一个中间元素是 <em>4</em>。它位于上升坡度，表明峰值在其右侧。于是，搜索空间缩小为 <code>[5, 1]</code>。 现在，<em>5</em> 位于下降坡度（相对其右侧相邻元素）, 搜索空间下降为 <code>[5]</code>。于是，<em>5</em> 被正确识别。</p><p> <a href="https://pic.leetcode-cn.com/3e49bacacecbf67aed75bcee9387dab5ccb7e7160dcc7c33be1be9e7a3acc563-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/8ee64c7b12c6b64b282324be43ecb89d29ac70d15dc3a35f2c62113cea7c23d8-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/78f6084e3bdfe12c05f2304d6a8b8c15e224f1b7f01f254bc04c0832c24c53b2-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/94cae61b8d045a3682d6a479417069776cabf13cc8bed930d07e088bcc2df575-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/03d56e48600ff839e6a6c8819d859d488e8bafd4c052fc61b7bdba09ed78ff8c-image.png" target="_blank" rel="noopener">image.png</a> <a href="https://pic.leetcode-cn.com/95f33e0a46ed380e3e5c2db5cb5a93479bb65463e7fcf6a7c953e3a039fe0461-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>递归二分查找</summary><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> search(nums, l, mid);</span><br><span class="line">        <span class="keyword">return</span> search(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 :  O(log_2(n)) 。每一步都将搜索空间减半。因此，总的搜索空间只需要 <em>log_2(n)</em> 步。其中 <em>n</em> 为 <em>nums</em> 数组的长度。</li><li>空间复杂度: O(log_2(n))  。每一步都将搜索空间减半。因此，总的搜索空间只需要 <em>log_2(n)</em> 步。于是，递归树的深度为 <em>log_2(n)</em>。<br><br></li></ul><hr><h1 id="方法三：迭代二分查找"><a href="#方法三：迭代二分查找" class="headerlink" title="方法三：迭代二分查找"></a>方法三：迭代二分查找</h1><p><strong>算法</strong></p><p>上述二分查找方法使用了递归。我们可以通过迭代达到同样的效果。本方法即为迭代实现二分查找。</p><details>    <summary>迭代二分查找</summary><figure class="highlight java"><figcaption><span>[solution 3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度 : O(log_2(n))。 每一步都将搜索空间减半。因此，总的搜索空间只需要 <em>log_2(n)</em> 步。其中 <em>n</em> 为 <em>nums</em> 数组的长度。</li><li>空间复杂度 : <em>O(1)</em>。 只使用了常数空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>324. 摆动排序 II</title>
    <link href="http://yoursite.com/2020/08/24/324.%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/"/>
    <id>http://yoursite.com/2020/08/24/324. 摆动排序 II/</id>
    <published>2020-08-24T08:40:12.000Z</published>
    <updated>2020-08-24T09:54:43.599Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums = [1, 5, 1, 1, 6, 4]输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</code></pre><p>示例 2:</p><pre><code>输入: nums = [1, 3, 2, 2, 3, 1]输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]</code></pre><p>说明:<br>你可以假设所有输入都会得到有效的结果。</p><p>进阶:<br>你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？</p><p>这道题比较简单,主要说一下思想:         </p><h2 id="有一个数组-a1-a2-…-an-，我们怎么把它排成摇摆序列呢？"><a href="#有一个数组-a1-a2-…-an-，我们怎么把它排成摇摆序列呢？" class="headerlink" title="有一个数组[a1,a2,…,an]，我们怎么把它排成摇摆序列呢？"></a>有一个数组[a1,a2,…,an]，我们怎么把它排成摇摆序列呢？</h2><p>由摇摆序列的定义:<code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>，我们知道了可以分成较大一部分的数和较小一部分数，然后互相穿插即可。比如一个数组排序后为：<code>A=[a1,a2,...,an]</code> <code>(a1&lt;=a2&lt;=....&lt;=an)</code>，然后分成较小和较大的两部分<code>[a1,a2,...,a(n/2)]</code>，<code>[a(n/2+1),...,an]</code>（数组长度为奇数时不影响），再进行穿插操作。</p><h2 id="那是不是穿插成-a1-a-n-2-1-a2-a-n-2-2-…-an-就行了呢？"><a href="#那是不是穿插成-a1-a-n-2-1-a2-a-n-2-2-…-an-就行了呢？" class="headerlink" title="那是不是穿插成[a1,a(n/2+1),a2,a(n/2+2),…,an]就行了呢？"></a>那是不是穿插成[a1,a(n/2+1),a2,a(n/2+2),…,an]就行了呢？</h2><p>其实不对，可以验证特殊情况：n比较小时且为偶数时，穿插后的序列需要满足<code>a(n/2+1)&gt;a2</code>，如果<code>a1&lt;a2&lt;=a(n/2+1)&lt;an</code>，<code>a(n/2+1)</code>正好是<code>a2</code>的后一项且与<code>a2</code>相等呢？即如果是<code>[4,5,5,6]</code>的情况呢？<br>那就分成了<code>[4,5]</code>，<code>[5,6]</code>两部分，之后穿插成的是<code>[4,5,5,6]</code>并不是摇摆序列。</p><h2 id="应该怎样排列呢？"><a href="#应该怎样排列呢？" class="headerlink" title="应该怎样排列呢？"></a>应该怎样排列呢？</h2><ol><li>把较小和较大的两部分<code>[a1,a2,...,a(n/2)]</code>，<code>[a(n/2+1),...,an]</code>翻转成<code>[a(n/2),...,a1]</code>，<code>[an,...,a(n/2+1)]</code></li><li>排列成<code>B=[a(n/2),a(n),a(n/2-1),a(n-1),...,a1,a(n/2+1)]</code>即可。</li></ol><p>这样相邻两个数一定不存在相等的情况，而且满足摇摆序列的要求。</p><ul><li><p><code>n=1</code>时显然正确</p></li><li><p><code>n=2或n=3</code>时也显然正确。</p></li><li><p><code>n&gt;=4时</code>：</p><ol><li><p>首先，判断相邻的情况，如果B中现在相邻两数在原来的有序序列A也相邻，此时令<code>n-n/2=1， (n-1)-(n/2-1)=1，...</code>都解得<code>n=2</code>，意思是<code>n=2</code>是他们的公共解，而<code>n&gt;=4</code>时，<code>n-n/2， (n-1)-(n/2-1)</code>等于<code>n/2&gt;=2</code>，说明B中相邻两数一定在原来的有序序列A中不相邻；</p></li><li><p>有人会说也存在原本(在A中)不相邻但是相等的情况，即几个数连续相等，但其中两个相等的数并不相邻，比如<code>aq=a(q+1)=a(q+2)</code>，<code>aq=a(q+2)</code>相等但是不相邻，但是我们知道如果<code>a(n/2-k)=a(n-k)</code>即不相邻相等，那么由于他们中间的所有数都要相等，而且与这两个数相等才能保证不相邻相等：即<code>a(n/2-k)=a(n/2-k+1)=a(n/2-k+2)=...=a(n-k-2)=a(n-k-1)=a(n-k)</code>，一共<code>n/2+1</code>个数相等。</p></li><li><p>而不相邻相等这种情况是不行的：虽然只有<code>a(n/2-k),a(n-k)</code>（在B中相邻）在原序列A中不相邻相等，但也违背了摇摆序列的定义，所以这道题有一个隐藏的条件：输入序列在排序后最多只有序列长度一半(<code>n/2</code>)的相邻的数连续相等。</p></li></ol></li><li><p>在这个条件下：这道题按此排列就没问题。大家可以用🖊验证一下。</p></li></ul><p>代码如下:</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先排序再穿插</span></span><br><span class="line"><span class="comment">     * O(nlogn)+O(n)=O(nlogn)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> smalllen = (len % <span class="number">2</span> == <span class="number">0</span>) ? len / <span class="number">2</span> : (len / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>[] smaller = <span class="keyword">new</span> <span class="keyword">int</span>[smalllen], bigger = <span class="keyword">new</span> <span class="keyword">int</span>[len / <span class="number">2</span>];</span><br><span class="line">    System.arraycopy(nums, <span class="number">0</span>, smaller, <span class="number">0</span>, smaller.length);</span><br><span class="line">    System.arraycopy(nums,smaller.length,bigger,<span class="number">0</span>,bigger.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        nums[<span class="number">2</span> * i] = smaller[smaller.length - <span class="number">1</span> - i];</span><br><span class="line">        nums[<span class="number">2</span> * i + <span class="number">1</span>] = bigger[bigger.length-i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        nums[len - <span class="number">1</span>] = smaller[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无序的数组 nums，将它重新排列成 nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]… 的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>179. 最大数</title>
    <link href="http://yoursite.com/2020/08/24/179.%20%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <id>http://yoursite.com/2020/08/24/179. 最大数/</id>
    <published>2020-08-24T08:00:12.000Z</published>
    <updated>2020-08-24T08:39:23.127Z</updated>
    
    <content type="html"><![CDATA[<p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [10,2]输出: 210</code></pre><p>示例 2:</p><pre><code>输入: [3,30,34,5,9]输出: 9534330</code></pre><p>说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><h1 id="自定义排序："><a href="#自定义排序：" class="headerlink" title="自定义排序："></a>自定义排序：</h1><p><strong>想法</strong></p><p>为了构建最大数字，我们希望越高位的数字越大越好。</p><p><strong>算法</strong></p><p>首先，我们将每个整数变成字符串。然后进行排序。</p><p>如果仅按降序排序，有相同的开头数字的时候会出现问题。比方说，样例 2 按降序排序得到的数字是 <em>95343303</em> ，然而交换 <em>3</em> 和 <em>30</em> 的位置可以得到正确答案 <em>9534330</em> 。因此，每一对数在排序的比较过程中，我们比较两种连接顺序哪一种更好。我们可以证明这样的做法是正确的：</p><p>假设（不是一般性），某一对整数 <em>a</em> 和 <em>b</em> ，我们的比较结果是 <em>a</em> 应该在 <em>b</em> 前面，这意味着 a ^ b&gt;b ^ a ，其中 ^  表示连接。如果排序结果是错的，说明存在一个 <em>c</em> ， <em>b</em> 在 <em>c</em> 前面且 <em>c</em> 在 <em>a</em> 的前面。这产生了矛盾，因为a ^ b&gt;b ^ a  和b ^c &gt;c ^ b 意味着 a ^ c &gt;c ^ a  。换言之，我们的自定义比较方法保证了传递性，所以这样子排序是对的。</p><p>一旦数组排好了序，最“重要”的数字会在最前面。有一个需要注意的情况是如果数组只包含 0 ，我们直接返回结果 <em>0</em> 即可。否则，我们用排好序的数组形成一个字符串并返回。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LargerNumberComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            String order1 = a + b;</span><br><span class="line">            String order2 = b + a;</span><br><span class="line">           <span class="keyword">return</span> order2.compareTo(order1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Get input integers as strings.</span></span><br><span class="line">        String[] asStrs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            asStrs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort strings according to custom comparator.</span></span><br><span class="line">        Arrays.sort(asStrs, <span class="keyword">new</span> LargerNumberComparator());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If, after being sorted, the largest number is `0`, the entire number</span></span><br><span class="line">        <span class="comment">// is zero.</span></span><br><span class="line">        <span class="keyword">if</span> (asStrs[<span class="number">0</span>].equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build largest number from sorted array.</span></span><br><span class="line">        String largestNumberStr = <span class="keyword">new</span> String();</span><br><span class="line">        <span class="keyword">for</span> (String numAsStr : asStrs) &#123;</span><br><span class="line">            largestNumberStr += numAsStr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> largestNumberStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargerNumKey</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y &gt; y+x</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        largest_num = <span class="string">''</span>.join(sorted(map(str, nums), key=LargerNumKey))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0'</span> <span class="keyword">if</span> largest_num[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">else</span> largest_num</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(nlgn)</em></p><p>  尽管我们在比较函数中做了一些额外的工作，但是这只是一个常数因子。所以总的时间复杂度是由排序决定的，在 Python 和 Java 中都是 <em>O(nlgn)</em> 。</p></li><li><p>空间复杂度：<em>O(n)</em></p><p>  这里，我们使用了 <em>O(n)</em> 的额外空间去保存 <code>nums</code> 的副本。尽管我们就地进行了一些额外的工作，但最后返回的数组需要 <em>O(n)</em> 的空间。因此，需要的额外空间与 <code>nums</code> 大小成线性关系。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>297. 二叉树的序列化与反序列化</title>
    <link href="http://yoursite.com/2020/08/24/297.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2020/08/24/297. 二叉树的序列化与反序列化/</id>
    <published>2020-08-24T03:19:12.000Z</published>
    <updated>2020-08-24T06:54:22.665Z</updated>
    
    <content type="html"><![CDATA[<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><a id="more"></a><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>示例: </p><pre><code>你可以将以下二叉树：    1   / \  2   3     / \    4   5序列化为 &quot;[1,2,3,null,null,4,5]&quot;</code></pre><p>提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><h1 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h1><p><strong>思路和算法</strong></p><p>二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。众所周知，我们一般有两个策略：BFS / DFS。</p><ul><li>BFS 可以按照层次的顺序从上到下遍历所有的节点</li><li>DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：<ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li></ul><p>这里，我们选择先序遍历的编码方式，我们可以通过这样一个例子简单理解：</p><p> <a href="https://assets.leetcode-cn.com/solution-static/297/1.PNG" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/297/2.PNG" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/297/3.PNG" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/297/4.PNG" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/297/5.PNG" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/297/6.PNG" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/297/7.PNG" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/297/8.PNG" target="_blank" rel="noopener">fig8</a> <a href="https://assets.leetcode-cn.com/solution-static/297/9.PNG" target="_blank" rel="noopener">fig9</a> <a href="https://assets.leetcode-cn.com/solution-static/297/10.PNG" target="_blank" rel="noopener">fig10</a> <a href="https://assets.leetcode-cn.com/solution-static/297/11.PNG" target="_blank" rel="noopener">fig11</a> <a href="https://assets.leetcode-cn.com/solution-static/297/12.PNG" target="_blank" rel="noopener">fig12</a> </p><p>我们从根节点 <code>1</code> 开始，序列化字符串是 <code>1,</code>。然后我们跳到根节点 <code>2</code> 的左子树，序列化字符串变成 <code>1,2,</code>。现在从节点 <code>2</code> 开始，我们访问它的左节点 <code>3</code>（<code>1,2,3,None,None,</code>）和右节点 <code>4</code>(<code>1,2,3,None,None,4,None,None</code>)。<code>None,None,</code> 是用来标记缺少左、右子节点，这就是我们在序列化期间保存树结构的方式。最后，我们回到根节点 <code>1</code> 并访问它的右子树，它恰好是叶节点 <code>5</code>。最后，序列化字符串是 <code>1,2,3,None,None,4,None,None,5,None,None,</code>。</p><p>即我们可以先序遍历这颗二叉树，遇到空子树的时候序列化成 <code>None</code>，否则继续递归序列化。那么我们如何反序列化呢？首先我们需要根据 <code>,</code> 把原先的序列分割开来得到先序遍历的元素列表，然后从左向右遍历这个序列：</p><ul><li>如果当前的元素为 <code>None</code>，则当前为空树</li><li>否则先解析这棵树的左子树，再解析它的右子树</li></ul><p>具体请参考下面的代码。</p><p><strong>代码</strong></p><details>    <summary>深度优先搜索java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rserialize</span><span class="params">(TreeNode root, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            str += <span class="string">"None,"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += str.valueOf(root.val) + <span class="string">","</span>;</span><br><span class="line">            str = rserialize(root.left, str);</span><br><span class="line">            str = rserialize(root.right, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rserialize(root, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">rdeserialize</span><span class="params">(List&lt;String&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l.get(<span class="number">0</span>).equals(<span class="string">"None"</span>)) &#123;</span><br><span class="line">            l.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(l.get(<span class="number">0</span>)));</span><br><span class="line">        l.remove(<span class="number">0</span>);</span><br><span class="line">        root.left = rdeserialize(l);</span><br><span class="line">        root.right = rdeserialize(l);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] data_array = data.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;String&gt; data_list = <span class="keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(data_array));</span><br><span class="line">        <span class="keyword">return</span> rdeserialize(data_list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span> &#123;</span><br><span class="line">    l []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Codec</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Codec&#123;&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rserialize</span><span class="params">(root *TreeNode, str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        str += <span class="string">"null,"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str += strconv.Itoa(root.Val) + <span class="string">","</span></span><br><span class="line">        str = rserialize(root.Left, str)</span><br><span class="line">        str = rserialize(root.Right, str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rserialize(root, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deserializes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    l := strings.Split(data, <span class="string">","</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(l); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> l[i] != <span class="string">""</span> &#123;</span><br><span class="line">            this.l = <span class="built_in">append</span>(this.l, l[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.rdeserialize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">rdeserialize</span><span class="params">()</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.l[<span class="number">0</span>] == <span class="string">"null"</span> &#123;</span><br><span class="line">        this.l = this.l[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val, _ := strconv.Atoi(this.l[<span class="number">0</span>])</span><br><span class="line">    root := &amp;TreeNode&#123;Val: val&#125;</span><br><span class="line">    this.l = this.l[<span class="number">1</span>:]</span><br><span class="line">    root.Left = this.rdeserialize()</span><br><span class="line">    root.Right = this.rdeserialize()</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 <em>O(n)*，其中 *n</em> 是节点数，即树的大小。 </li><li>空间复杂度：在序列化和反序列化函数中，我们递归会使用栈空间，故渐进空间复杂度为 <em>O(n)</em>。 </li></ul><h1 id="方法二：括号表示编码-递归下降解码"><a href="#方法二：括号表示编码-递归下降解码" class="headerlink" title="方法二：括号表示编码 + 递归下降解码"></a>方法二：括号表示编码 + 递归下降解码</h1><p><strong>思路和算法</strong></p><p>我们也可以这样表示一颗二叉树：</p><ul><li>如果当前的树为空，则表示为 <code>X</code></li><li>如果当前的树不为空，则表示为 <code>(&lt;LEFT_SUB_TREE&gt;)CUR_NUM(RIGHT_SUB_TREE)</code>，其中：<ul><li><code>&lt;LEFT_SUB_TREE&gt;</code> 是左子树序列化之后的结果</li><li><code>&lt;RIGHT_SUB_TREE&gt;</code> 是右子树序列化之后的结果</li><li><code>CUR_NUM</code> 是当前节点的值</li></ul></li></ul><p>根据这样的定义，我们很好写出序列化的过程，后序遍历这颗二叉树即可，那如何反序列化呢？根据定义，我们可以推导出这样的巴科斯范式（BNF）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T -&gt; (T) num (T) | X</span><br></pre></td></tr></table></figure><p>它的意义是：用 <code>T</code> 代表一棵树序列化之后的结果，<code>|</code> 表示 <code>T</code> 的构成为 <code>(T) num (T)</code> 或者 <code>X</code>，<code>|</code> 左边是对 <code>T</code> 的递归定义，右边规定了递归终止的边界条件。</p><p>因为：</p><ul><li><code>T</code> 的定义中，序列中的第一个字符要么是 <code>X</code>，要么是 <code>(</code>，所以这个定义是不含左递归的</li><li>当我们开始解析一个字符串的时候，如果开头是 <code>X</code>，我们就知道这一定是解析一个「空树」的结构，如果开头是 <code>(</code>，我们就知道需要解析 <code>(T) num (T)</code> 的结构，因此这里两种开头和两种解析方法一一对应，可以确定这是一个无二义性的文法</li><li>我们只需要通过开头的第一个字母是 <code>X</code> 还是 <code>(</code> 来判断使用哪一种解析方法</li></ul><p>所以这个文法是 LL(1) 型文法，<strong>如果你不知道什么是 LL(1) 型文法也没有关系，你只需要知道它定义了一种递归的方法来反序列化，也保证了这个方法的正确性——我们可以设计一个递归函数：</strong></p><ul><li>这个递归函数传入两个参数，带解析的字符串和当前当解析的位置 <code>ptr</code>，<code>ptr</code> 之前的位置是已经解析的，<code>ptr</code> 和 <code>ptr</code> 后面的字符串是待解析的</li><li>如果当前位置为 <code>X</code> 说明解析到了一棵空树，直接返回</li><li>否则当前位置一定是 <code>(</code>，对括号内部按照 <code>(T) num (T)</code> 的模式解析</li></ul><p>具体请参考下面的代码。</p><p><strong>代码</strong></p><details>    <summary>括号表示编码 + 递归下降解码cpp</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">"X"</span>;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="string">"("</span> + serialize(root-&gt;left) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="string">"("</span> + serialize(root-&gt;right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span>  l + to_string(root-&gt;val) + r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> TreeNode* <span class="title">parseSubtree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">int</span> &amp;ptr)</span> </span>&#123;</span><br><span class="line">        ++ptr; <span class="comment">// 跳过左括号</span></span><br><span class="line">        <span class="keyword">auto</span> subtree = parse(data, ptr);</span><br><span class="line">        ++ptr; <span class="comment">// 跳过右括号</span></span><br><span class="line">        <span class="keyword">return</span> subtree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">int</span> &amp;ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, sgn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(data[ptr])) &#123;</span><br><span class="line">            sgn = <span class="number">-1</span>;</span><br><span class="line">            ++ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(data[ptr])) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + data[ptr++] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * sgn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">parse</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">int</span> &amp;ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[ptr] == <span class="string">'X'</span>) &#123;</span><br><span class="line">            ++ptr;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cur = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        cur-&gt;left = parseSubtree(data, ptr);</span><br><span class="line">        cur-&gt;val = parseInt(data, ptr);</span><br><span class="line">        cur-&gt;right = parseSubtree(data, ptr);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> parse(data, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>括号表示编码 + 递归下降解码java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"X"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String l = <span class="string">"("</span> + serialize(root.left) + <span class="string">")"</span>;</span><br><span class="line">        String r = <span class="string">"("</span> + serialize(root.right) + <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span>  l + root.val + r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ptr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> parse(data, ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parse</span><span class="params">(String data, <span class="keyword">int</span>[] ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.charAt(ptr[<span class="number">0</span>]) == <span class="string">'X'</span>) &#123;</span><br><span class="line">            ++ptr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode cur = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        cur.left = parseSubtree(data, ptr);</span><br><span class="line">        cur.val = parseInt(data, ptr);</span><br><span class="line">        cur.right = parseSubtree(data, ptr);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parseSubtree</span><span class="params">(String data, <span class="keyword">int</span>[] ptr)</span> </span>&#123;</span><br><span class="line">        ++ptr[<span class="number">0</span>]; <span class="comment">// 跳过左括号</span></span><br><span class="line">        TreeNode subtree = parse(data, ptr);</span><br><span class="line">        ++ptr[<span class="number">0</span>]; <span class="comment">// 跳过右括号</span></span><br><span class="line">        <span class="keyword">return</span> subtree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String data, <span class="keyword">int</span>[] ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, sgn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(data.charAt(ptr[<span class="number">0</span>]))) &#123;</span><br><span class="line">            sgn = -<span class="number">1</span>;</span><br><span class="line">            ++ptr[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Character.isDigit(data.charAt(ptr[<span class="number">0</span>]))) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + data.charAt(ptr[<span class="number">0</span>]++) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * sgn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：序列化时做了一次遍历，渐进时间复杂度为 <em>O(n)</em>。反序列化时，在解析字符串的时候 <code>ptr</code> 指针对字符串做了一次顺序遍历，字符串长度为 <em>O(n)</em>，故这里的渐进时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：考虑递归使用的栈空间的大小，这里栈空间的使用和递归深度有关，递归深度又和二叉树的深度有关，在最差情况下，二叉树退化成一条链，故这里的渐进空间复杂度为 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <link href="http://yoursite.com/2020/08/24/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yoursite.com/2020/08/24/236. 二叉树的最近公共祖先/</id>
    <published>2020-08-24T01:48:12.000Z</published>
    <updated>2020-08-24T03:19:02.216Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><a id="more"></a><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p>示例 1:</p><pre><code>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</code></pre><p>示例 2:</p><pre><code>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>说明:</p><pre><code>所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="6258a388-b9c6-486c-9d92-c09571d373a9">236. 二叉树的最近公共祖先.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><p><strong>思路和算法</strong></p><p>我们递归遍历整棵二叉树，定义 <em>f_x</em> 表示 <em>x</em> 节点的子树中是否包含 <em>p</em> 节点或 <em>q</em> 节点，如果包含为 <code>true</code>，否则为 <code>false</code>。那么符合条件的最近公共祖先 <em>x</em> 一定满足如下条件：</p><pre><code>(flson&amp;&amp;frson)∣∣((x=p∣∣x=q)&amp;&amp;(flson∣∣frson))</code></pre><p>其中 flson 和frson分别代表 <em>x</em> 节点的左孩子和右孩子。初看可能会感觉条件判断有点复杂，我们来一条条看，flson&amp;&amp;frson说明左子树和右子树均包含 <em>p</em> 节点或 <em>q</em> 节点，如果左子树包含的是 <em>p</em> 节点，那么右子树只能包含 <em>q</em> 节点，反之亦然，因为 <em>p</em> 节点和 <em>q</em> 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 <em>x</em> 就是我们要找的最近公共祖先。再来看第二条判断条件，这个判断条件即是考虑了 <em>x</em> 恰好是 <em>p</em> 节点或 <em>q</em> 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 <em>x</em> 就是我们要找的最近公共祖先。</p><p>你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到，且由于 <em>f_x</em> 本身的定义很巧妙，在找到最近公共祖先 <em>x</em> 以后，<em>f_x</em> 按定义被设置为 <code>true</code> ，即假定了这个子树中只有一个 <em>p</em> 节点或 <em>q</em> 节点，因此其他公共祖先不会再被判断为符合条件。</p><p>下图展示了一个示例，搜索树中两个节点 <code>9</code> 和 <code>11</code> 的最近公共祖先。</p><p> <a href="https://assets.leetcode-cn.com/solution-static/236/1.PNG" target="_blank" rel="noopener">fig1</a> <a href="https://assets.leetcode-cn.com/solution-static/236/2.PNG" target="_blank" rel="noopener">fig2</a> <a href="https://assets.leetcode-cn.com/solution-static/236/3.PNG" target="_blank" rel="noopener">fig3</a> <a href="https://assets.leetcode-cn.com/solution-static/236/4.PNG" target="_blank" rel="noopener">fig4</a> <a href="https://assets.leetcode-cn.com/solution-static/236/5.PNG" target="_blank" rel="noopener">fig5</a> <a href="https://assets.leetcode-cn.com/solution-static/236/6.PNG" target="_blank" rel="noopener">fig6</a> <a href="https://assets.leetcode-cn.com/solution-static/236/7.PNG" target="_blank" rel="noopener">fig7</a> <a href="https://assets.leetcode-cn.com/solution-static/236/8.PNG" target="_blank" rel="noopener">fig8</a> <a href="https://assets.leetcode-cn.com/solution-static/236/9.PNG" target="_blank" rel="noopener">fig9</a> <a href="https://assets.leetcode-cn.com/solution-static/236/10.PNG" target="_blank" rel="noopener">fig10</a> <a href="https://assets.leetcode-cn.com/solution-static/236/11.PNG" target="_blank" rel="noopener">fig11</a> </p><details>    <summary>递归C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = dfs(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rson = dfs(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">root, p, q</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> lson = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">const</span> rson = dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root.val === p.val || root.val === q.val);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lson = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">boolean</span> rson = dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root.val == p.val || root.val == q.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 <em>O(N)</em>。</p></li><li><p>空间复杂度：<em>O(N)</em> ，其中 <em>N</em> 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 <em>N</em>，因此空间复杂度为 <em>O(N)</em>。</p></li></ul><h4 id="方法二：存储父节点"><a href="#方法二：存储父节点" class="headerlink" title="方法二：存储父节点"></a>方法二：存储父节点</h4><p><strong>思路</strong></p><p>我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 <code>p</code> 结点开始不断往上跳，并记录已经访问过的节点，再从 <code>q</code> 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</p><p><strong>算法</strong></p><ol><li>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</li><li>从 <code>p</code> 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</li><li>同样，我们再从 <code>q</code> 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 <code>p</code> 和 <code>q</code> 的深度最深的公共祖先，即 LCA 节点。</li></ol><details>    <summary>存储父节点C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, TreeNode*&gt; fa;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        fa[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">            q = fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>存储父节点Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;Integer, TreeNode&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(root.left.val, root);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(root.right.val, root);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            visited.add(p.val);</span><br><span class="line">            p = parent.get(p.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(q.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            q = parent.get(q.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>存储父节点golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    parent := <span class="keyword">map</span>[<span class="keyword">int</span>]*TreeNode&#123;&#125;</span><br><span class="line">    visited := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line"><span class="function">    <span class="title">dfs</span> = <span class="title">func</span><span class="params">(r *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            parent[r.Left.Val] = r</span><br><span class="line">            dfs(r.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            parent[r.Right.Val] = r</span><br><span class="line">            dfs(r.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        visited[p.Val] = <span class="literal">true</span></span><br><span class="line">        p = parent[p.Val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[q.Val] &#123;</span><br><span class="line">            <span class="keyword">return</span> q</span><br><span class="line">        &#125;</span><br><span class="line">        q = parent[q.Val]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 <code>p</code> 和 <code>q</code> 节点往上跳经过的祖先节点个数不会超过 <em>N</em>，因此总的时间复杂度为 <em>O(N)</em>。</p></li><li><p>空间复杂度：<em>O(N)</em> ，其中 <em>N</em> 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 <em>N</em>，因此空间复杂度为 <em>O(N)*，哈希表存储每个节点的父节点也需要 *O(N)</em> 的空间复杂度，因此最后总的空间复杂度为 <em>O(N)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>230. 二叉搜索树中第K小的元素</title>
    <link href="http://yoursite.com/2020/08/22/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/08/22/230. 二叉搜索树中第K小的元素/</id>
    <published>2020-08-22T05:44:12.000Z</published>
    <updated>2020-08-24T01:47:21.206Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><a id="more"></a><p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p>示例 1:</p><pre><code>输入: root = [3,1,4,null,2], k = 1   3  / \ 1   4  \   2输出: 1</code></pre><p>示例 2:</p><pre><code>输入: root = [5,3,6,2,4,null,null,1], k = 3       5      / \     3   6    / \   2   4  / 1输出: 3</code></pre><p>进阶：</p><p>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><strong>怎么遍历树：</strong></p><ul><li>深度优先搜索（<code>DFS</code>）</li></ul><p>在这个策略中，我们从根延伸到某一片叶子，然后再返回另一个分支。根据根节点，左节点，右节点的相对顺序，<code>DFS</code> 还可以分为前序，中序，后序。 </p><ul><li>广度优先搜索（<code>BFS</code>）</li></ul><p>在这个策略中，我们逐层，从上到下扫描整个树。</p><p>下图展示了不同的遍历策略：<br><a href="https://pic.leetcode-cn.com/40cb9af2a0c21fdc1ce72e6e24b48bd73d5f280c0f4b207ce3d7cf0c19fbdf21-file_1579413216186" target="_blank" rel="noopener">不同的遍历策略</a></p><p>为了解决这个问题，可以使用 BST 的特性：BST 的中序遍历是升序序列。</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><p><strong>算法：</strong></p><p>通过构造 BST 的中序遍历序列，则第 <code>k-1</code> 个元素就是第 <code>k</code> 小的元素。</p><p><a href="https://pic.leetcode-cn.com/7dc3fe454519e27105c5aaf57d20b26137bd77c56bb0289830bf18116627de12-file_1579413216156" target="_blank" rel="noopener">递归</a></p><details>    <summary>递归python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> inorder(r.left) + [r.val] + inorder(r.right) <span class="keyword">if</span> r <span class="keyword">else</span> []</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> inorder(root)[k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>递归java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    inorder(root.left, arr);</span><br><span class="line">    arr.add(root.val);</span><br><span class="line">    inorder(root.right, arr);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums = inorder(root, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> nums.get(k - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：<em>O(N)</em>，遍历了整个树。</li><li>空间复杂度：<em>O(N)</em>，用了一个数组存储中序序列。</li></ul><h1 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h1><p><strong>算法：</strong></p><p>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p><p><a href="https://pic.leetcode-cn.com/25159a5137867644b75f203ee1917645d2cd454d8f4871e371d7edfa67bef083-file_1579413216176" target="_blank" rel="noopener">迭代</a></p><details>    <summary>迭代python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125;</span><br><span class="line">      root = stack.removeLast();</span><br><span class="line">      <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(H+k) ，其中 <em>H</em> 指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为 O(logN+k) 。当树是一个不平衡树时：复杂度为O(N+k) ，此时所有的节点都在左子树。</li><li>空间复杂度：O(H+k)  。当树是一个平衡树时：O(logN+k) 。当树是一个非平衡树时：O(N+k) 。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>380. 常数时间插入、删除和获取随机元素</title>
    <link href="http://yoursite.com/2020/08/21/380.%20%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/08/21/380. 常数时间插入、删除和获取随机元素/</id>
    <published>2020-08-21T09:26:12.000Z</published>
    <updated>2020-08-22T05:41:24.660Z</updated>
    
    <content type="html"><![CDATA[<p>设计一个支持在平均时间复杂度 O(1)下，执行以下操作的数据结构。</p><a id="more"></a><p>操作:</p><pre><code>insert(val)：当元素 val 不存在时，向集合中插入该项。remove(val)：元素 val 存在时，从集合中移除该项。getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</code></pre><p>示例 :</p><pre><code>// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom();</code></pre><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们需要在平均复杂度为  O(1)  实现以下操作：</p><ol><li><code>insert</code></li><li><code>remove</code></li><li><code>getRadom</code></li></ol><p>让我们想想如何实现它。从 <code>insert</code> 开始，我们具有两个平均插入时间为 O(1)的选择：</p><ul><li>哈希表：Java 中为 <code>HashMap</code>，Python 中为 <code>dictionary</code>。</li><li>动态数组：Java 中为 <code>ArrayList</code>，Python 中为 <code>list</code>。</li></ul><p>让我们一个个进行思考，虽然哈希表提供常数时间的插入和删除，但是实现 <code>getRandom</code> 时会出现问题。</p><p><code>getRandom</code> 的思想是选择一个随机索引，然后使用该索引返回一个元素。而哈希表中没有索引，因此要获得真正的随机值，则要将哈希表中的键转换为列表，这需要线性时间。解决的方法是用一个列表存储值，并在该列表中实现常数时间的 <code>getRandom</code>。</p><p>列表有索引可以实现常数时间的 <code>insert</code> 和 <code>getRandom</code>，则接下来的问题是如何实现常数时间的 <code>remove</code>。</p><p>删除任意索引元素需要线性时间，这里的解决方案是总是删除最后一个元素。</p><ul><li>将要删除元素和最后一个元素交换。</li><li>将最后一个元素删除。</li></ul><p>为此，必须在常数时间获取到要删除元素的索引，因此需要一个哈希表来存储值到索引的映射。</p><p>综上所述，我们使用以下数据结构：</p><ul><li>动态数组存储元素值</li><li>哈希表存储存储值到索引的映射。</li></ul><h1 id="方法：哈希表-动态数组"><a href="#方法：哈希表-动态数组" class="headerlink" title="方法：哈希表 + 动态数组"></a>方法：哈希表 + 动态数组</h1><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert:"></a><strong>Insert:</strong></h2><ul><li>添加元素到动态数组。</li><li>在哈希表中添加值到索引的映射</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzgwL2lzZXJ0LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><details>    <summary>哈希表 + 动态数组python</summary><figure class="highlight python"><figcaption><span>[insert-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    self.dict[val] = len(self.list)</span><br><span class="line">    self.list.append(val)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 动态数组java</summary><figure class="highlight java"><figcaption><span>[insert-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">  dict.put(val, list.size());</span><br><span class="line">  list.add(list.size(), val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="remove"><a href="#remove" class="headerlink" title="remove:"></a><strong>remove:</strong></h2><ul><li>在哈希表中查找要删除元素的索引。</li><li>将要删除元素与最后一个元素交换。</li><li>删除最后一个元素。</li><li>更新哈希表中的对应关系。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzgwL2RlbGV0ZS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><details>    <summary>哈希表 + 动态数组python</summary><figure class="highlight python"><figcaption><span>[remove-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">        <span class="comment"># move the last element to the place idx of the element to delete</span></span><br><span class="line">        last_element, idx = self.list[<span class="number">-1</span>], self.dict[val]</span><br><span class="line">        self.list[idx], self.dict[last_element] = last_element, idx</span><br><span class="line">        <span class="comment"># delete the last element</span></span><br><span class="line">        self.list.pop()</span><br><span class="line">        <span class="keyword">del</span> self.dict[val]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表 + 动态数组java</summary><figure class="highlight java"><figcaption><span>[remove-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (! dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move the last element to the place idx of the element to delete</span></span><br><span class="line">  <span class="keyword">int</span> lastElement = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> idx = dict.get(val);</span><br><span class="line">  list.set(idx, lastElement);</span><br><span class="line">  dict.put(lastElement, idx);</span><br><span class="line">  <span class="comment">// delete the last element</span></span><br><span class="line">  list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">  dict.remove(val);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="getRandom："><a href="#getRandom：" class="headerlink" title="getRandom："></a><strong>getRandom：</strong></h2><p>借助 Python 中的 <code>random.choice</code> 和 Java 中 的 <code>Random</code> 实现。</p><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[getRandom-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Get a random element from the set.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> choice(self.list)</span><br></pre></td></tr></table></figure></details><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[getRandom-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Get a random element from the set. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a><strong>完整代码：</strong></h2><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">        self.list = []</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        self.dict[val] = len(self.list)</span><br><span class="line">        self.list.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            <span class="comment"># move the last element to the place idx of the element to delete</span></span><br><span class="line">            last_element, idx = self.list[<span class="number">-1</span>], self.dict[val]</span><br><span class="line">            self.list[idx], self.dict[last_element] = last_element, idx</span><br><span class="line">            <span class="comment"># delete the last element</span></span><br><span class="line">            self.list.pop()</span><br><span class="line">            <span class="keyword">del</span> self.dict[val]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> choice(self.list)</span><br></pre></td></tr></table></figure></details><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">  Map&lt;Integer, Integer&gt; dict;</span><br><span class="line">  List&lt;Integer&gt; list;</span><br><span class="line">  Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    dict.put(val, list.size());</span><br><span class="line">    list.add(list.size(), val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move the last element to the place idx of the element to delete</span></span><br><span class="line">    <span class="keyword">int</span> lastElement = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> idx = dict.get(val);</span><br><span class="line">    list.set(idx, lastElement);</span><br><span class="line">    dict.put(lastElement, idx);</span><br><span class="line">    <span class="comment">// delete the last element</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    dict.remove(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>getRandom</code> 时间复杂度为  O(1)，<code>insert</code> 和 <code>remove</code> 平均时间复杂度为  O(1) ，在最坏情况下为  O(N) 当元素数量超过当前分配的动态数组和哈希表的容量导致空间重新分配时。</li><li>空间复杂度：<em>O(N)*，在动态数组和哈希表分别存储了 *N</em> 个元素的信息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计一个支持在平均时间复杂度 O(1)下，执行以下操作的数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>454. 四数相加 II</title>
    <link href="http://yoursite.com/2020/08/21/454.%20%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/"/>
    <id>http://yoursite.com/2020/08/21/454. 四数相加 II/</id>
    <published>2020-08-21T07:34:12.000Z</published>
    <updated>2020-08-21T09:15:42.339Z</updated>
    
    <content type="html"><![CDATA[<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><a id="more"></a><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p><p>例如:</p><pre><code>输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><h1 id="map函数介绍"><a href="#map函数介绍" class="headerlink" title="map函数介绍"></a>map函数介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当Map集合中有这个key时，就使用这个key值，如果没有就使用默认值defaultValue</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果key值已存在，则不替换对应的value</span></span></span><br><span class="line"><span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><p><strong>思路：</strong></p><p>一. 采用分为两组，HashMap存一组，另一组和HashMap进行比对。</p><p>二. 这样的话情况就可以分为三种：</p><pre><code>1. HashMap存一个数组，如A。然后计算三个数组之和，如BCD。时间复杂度为：O(n)+O(n^3),得到O(n^3).2. HashMap存三个数组之和，如ABC。然后计算一个数组，如D。时间复杂度为：O(n^3)+O(n),得到O(n^3).3. HashMap存两个数组之和，如AB。然后计算两个数组之和，如CD。时间复杂度为：O(n^2)+O(n^2),得到O(n^2).</code></pre><p>三.根据第二点我们可以得出要存两个数组算两个数组。</p><p>四.我们以存AB两数组之和为例。首先求出A和B任意两数之和sumAB，以sumAB为key，sumAB出现的次数为value，存入hashmap中。<br>然后计算C和D中任意两数之和的相反数sumCD，在hashmap中查找是否存在key为sumCD。<br>算法时间复杂度为O(n2)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><details>    <summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : B) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum1 = a + b;</span><br><span class="line">            map1.put(sum1, map1.getOrDefault(sum1, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : C) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d : D) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum2 = c + d;</span><br><span class="line">            <span class="keyword">if</span>(map1.containsKey(-sum2))  res += map1.get(-sum2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h1><p>1）求和法</p><p>A与B所有元素求和，得到数组first；</p><p>C与D所有元素求和，得到数组second：</p><p>2）对second进行排序；</p><p>3）针对first中数组元素*-1，在second数组中遍历，由于可能存在多个，因此我们要获得上边界和下边界</p><p>可以使用lower_bound 和upper_bound</p><p>也可以直接使用equal_range</p><details>    <summary>C++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;D)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; firstvec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; secondvec;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.size(); j++) &#123;</span><br><span class="line">                firstvec.push_back(A[i] + B[j]);</span><br><span class="line">                secondvec.push_back(C[i] + D[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(secondvec.begin(), secondvec.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; firstvec.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> findvalue = firstvec[i] * (<span class="number">-1</span>);</span><br><span class="line">            pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; range = equal_range(secondvec.begin(), secondvec.end(), findvalue);</span><br><span class="line">            result += range.second - range.first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>171. Excel表列序号</title>
    <link href="http://yoursite.com/2020/08/21/Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/"/>
    <id>http://yoursite.com/2020/08/21/Excel表列序号/</id>
    <published>2020-08-21T07:33:12.000Z</published>
    <updated>2020-08-21T09:16:24.239Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><a id="more"></a><p>例如，</p><pre><code>A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ...</code></pre><p>示例 1:</p><pre><code>输入: &quot;A&quot;输出: 1</code></pre><p>示例 2:</p><pre><code>输入: &quot;AB&quot;输出: 28</code></pre><p>示例 3:</p><pre><code>输入: &quot;ZY&quot;输出: 701</code></pre><p>这道题很简单</p><h1 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>标签：字符串遍历，进制转换</li><li>初始化结果<code>ans = 0</code>，遍历时将每个字母与A做减法，因为A表示1，所以减法后需要每个数加1，计算其代表的数值<code>num = 字母 - ‘A’ + 1</code></li><li>因为有26个字母，所以相当于26进制，每26个数则向前进一位</li><li>所以每遍历一位则<code>ans = ans * 26 + num</code></li><li>以ZY为例，Z的值为26，Y的值为25，则结果为<code>26 * 26 + 25=701</code></li><li>时间复杂度：O(n)</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = s.charAt(i) - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">            ans = ans * <span class="number">26</span> + num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画解"><a href="#画解" class="headerlink" title="画解"></a>画解</h2><p> <a href="https://pic.leetcode-cn.com/97416a122f3315e3a0eb9951a1d742e7c1734d915f4b96099610a92629899d04-frame_00001.png" target="_blank" rel="noopener">frame_00001.png</a></p><p> <a href="https://pic.leetcode-cn.com/a5e8e39fa19491e3e1d82c6aba3dec24e080c368d0400bf57012548b0fdb2af4-frame_00002.png" target="_blank" rel="noopener">frame_00002.png</a> </p><p> <a href="https://pic.leetcode-cn.com/da62003ebc140532fe1e42ff2c46d5c920101d6de50fd3c6910eee1e9d9c7df5-frame_00003.png" target="_blank" rel="noopener">frame_00003.png</a> </p><p> <a href="https://pic.leetcode-cn.com/4267220aeef6e659dcae4fa7b59d63c68efdb7b0f748d431d8acca4af278de65-frame_00004.png" target="_blank" rel="noopener">frame_00004.png</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个Excel表格中的列名称，返回其相应的列序号。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>328. 奇偶链表</title>
    <link href="http://yoursite.com/2020/08/21/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/21/328. 奇偶链表/</id>
    <published>2020-08-21T03:45:12.000Z</published>
    <updated>2020-08-21T07:22:45.846Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><a id="more"></a><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code></pre><p>示例 2:</p><pre><code>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></pre><p>说明:</p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>我一开始想用快慢指针来解决，但是没有找到合适的方法来交换奇偶节点。所以还是采用下面的方法。</p><p><strong>想法</strong></p><p>将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。</p><p><strong>算法</strong></p><p>这个解法非常符合直觉思路也很简单。但是要写一个精确且没有 bug 的代码还是很费一番功夫，想要避免空指针和循环链表的情况需要认真考虑边界条件。</p><p>一个 <code>LinkedList</code> 需要一个头指针和一个尾指针来支持双端操作。我们用变量 <code>head</code> 和 <code>odd</code> 保存奇链表的头和尾指针。 <code>evenHead</code> 和 <code>even</code> 保存偶链表的头和尾指针。算法会遍历原链表一次并把奇节点放到奇链表里去、偶节点放到偶链表里去。遍历整个链表我们至少需要一个指针作为迭代器。这里 <code>odd</code> 指针和 <code>even</code> 指针不仅仅是尾指针，也可以扮演原链表迭代器的角色。</p><p>解决链表问题最好的办法是在脑中或者纸上把链表画出来。比方说：</p><p><a href="https://pic.leetcode-cn.com/00bd1d974b5a2e6d7d4faf0d5baad1c691f4ed8963cb1b7133d1112bad4c5e86-image.png" target="_blank" rel="noopener">奇偶链表的例子</a></p><figure class="highlight java"><figcaption><span>[solution-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode odd = head, even = head.next, evenHead = even;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n)</em> 。总共有 <em>n</em> 个节点，我们每个遍历一次。</p></li><li><p>空间复杂度： <em>O(1)</em> 。我们只需要 4 个指针。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>237. 删除链表中的节点</title>
    <link href="http://yoursite.com/2020/08/21/237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/08/21/237. 删除链表中的节点/</id>
    <published>2020-08-21T03:12:12.000Z</published>
    <updated>2020-08-21T03:44:57.927Z</updated>
    
    <content type="html"><![CDATA[<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p><a id="more"></a><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p>示例 1：</p><pre><code>输入：head = [4,5,1,9], node = 5输出：[4,1,9]解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><p>示例 2：</p><pre><code>输入：head = [4,5,1,9], node = 1输出：[4,5,9]解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><p>提示：</p><pre><code>链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。</code></pre><h1 id="方法：与下一个节点交换"><a href="#方法：与下一个节点交换" class="headerlink" title="方法：与下一个节点交换"></a>方法：与下一个节点交换</h1><p>我一开始用了遍历整个链表最后丢弃尾节点，后来发现并不需要这么麻烦</p><p>从链表里删除一个节点 <code>node</code> 的最常见方法是修改<em>之前</em>节点的 <code>next</code> 指针，使其指向<em>之后</em>的节点。</p><p><a href="https://pic.leetcode-cn.com/3579a496897df5321c110bf1301872b6e10c342f5e400ce45d2db0348d00d715-file_1555866623326" target="_blank" rel="noopener">image</a></p><p>因为，我们无法访问我们想要删除的节点 <em>之前</em> 的节点，我们始终不能修改该节点的 <code>next</code> 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p><p><a href="https://pic.leetcode-cn.com/858fae01d89c2080eb7e45a1f9d9a2b2f76e1a5c87815b324fd946e0bd8da495-file_1555866651920" target="_blank" rel="noopener">image</a></p><p><a href="https://pic.leetcode-cn.com/902dc5d3f8c44d3cbc0b6e837711cad2eefc021fd2b9de8dfabc6d478bc779b1-file_1555866680932" target="_blank" rel="noopener">image</a></p><p><a href="https://pic.leetcode-cn.com/2a6409b98dd73d6649fdc6fb984c88690547127467104c3923367be6f8fbc916-file_1555866773685" target="_blank" rel="noopener">image</a></p><p>因为我们知道要删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。</p><figure class="highlight java"><figcaption><span>[juoWzFbK-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间和空间复杂度都是：<em>O(1)</em>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>234. 回文链表</title>
    <link href="http://yoursite.com/2020/08/20/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/20/234. 回文链表/</id>
    <published>2020-08-20T09:53:12.000Z</published>
    <updated>2020-08-21T03:06:08.248Z</updated>
    
    <content type="html"><![CDATA[<p>请判断一个链表是否为回文链表。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 1-&gt;2输出: false</code></pre><p>示例 2:</p><pre><code>输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><p>进阶：</p><p>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><ol><li>采用快慢两个指针去寻找链表的中间节点；</li><li>根据链表的中间节点反转后一半的链表；</li><li>迭代比较链表前一半的元素和后一半的元素，判断节点的值是否相等，得出是否为回文。</li></ol><h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><p><a href="https://pic.leetcode-cn.com/cb25ad29e4c902e12bfe088a79b491dc8e6ff890786f15ce6b176d5419bcbf71-%E9%93%BE%E8%A1%A8%E5%9B%9E%E6%96%87%E5%A5%87%E6%95%B0.jpeg" target="_blank" rel="noopener">链表回文奇数.jpeg</a></p><p><a href="https://pic.leetcode-cn.com/79a887a172f927142b591a28f2d4638223ee992279f6925ec418e1ce1cbc5c1a-%E9%93%BE%E8%A1%A8%E5%9B%9E%E6%96%87%E5%81%B6%E6%95%B0.jpeg" target="_blank" rel="noopener">链表回文偶数.jpeg</a></p><h1 id="解题代码："><a href="#解题代码：" class="headerlink" title="解题代码："></a>解题代码：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">        if(head == null) return true;</span><br><span class="line"></span><br><span class="line">        ListNode midNode = findMidNode(head);</span><br><span class="line">        ListNode secondHalfHead = reverseLinked(midNode.next);</span><br><span class="line">        ListNode curr1 = head;</span><br><span class="line">        ListNode curr2 = secondHalfHead;</span><br><span class="line"></span><br><span class="line">        boolean palindrome = true;</span><br><span class="line">        while(palindrome &amp;&amp; curr2 != null)&#123;</span><br><span class="line">            if(curr1.val != curr2.val) palindrome = false;</span><br><span class="line">            curr1 = curr1.next;</span><br><span class="line">            curr2 = curr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return palindrome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 反转链表 */</span><br><span class="line">    private ListNode reverseLinked(ListNode head)&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode prev = null;</span><br><span class="line">        while(cur != null)&#123;</span><br><span class="line">            ListNode nextTemp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 快慢指针寻找中间节点 */</span><br><span class="line">    private ListNode findMidNode(ListNode head)&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        while(fast.next != null &amp;&amp; fast.next.next != null)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>92. 反转链表II</title>
    <link href="http://yoursite.com/2020/08/19/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yoursite.com/2020/08/19/92. 反转链表II/</id>
    <published>2020-08-19T09:15:12.000Z</published>
    <updated>2020-08-20T09:50:00.006Z</updated>
    
    <content type="html"><![CDATA[<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><a id="more"></a><p> 说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p> 示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</p><p>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><h1 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一: 递归"></a>方法一: 递归</h1><p>这种方法实际上是交换节点的值而非反转链表的指针</p><p><strong>直觉</strong></p><p>使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。</p><p><a href="https://pic.leetcode-cn.com/7f6ec0687455cfecce2019fcb560d7066d7e7dfedd46922d3cc96bcbff3c1eb5-image.png" target="_blank" rel="noopener">image.png</a></p><p>反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 <em>m</em> 个结点，另一个指向第 <em>n</em> 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。</p><blockquote><p>然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 <strong>模拟</strong> 向后指针。递归中的回溯可以帮助我们模拟一个指针从第<em>n</em>个结点向中心移动的移动过程。</p></blockquote><p><strong>算法</strong></p><ol><li>我们定义一个递归函数用于反转给定链表的一部分。</li><li>将函数记为 <code>recurse</code>。该函数使用三个参数: <code>m</code> 为反转的起点, <code>n</code> 为反转的终点, 以及从第 <em>n</em> 个结点开始，随着递归回溯过程向后移动的指针 <code>right</code>。不清楚的话，可以参考后文的示意图。</li><li>此外，我们还有一个指针 <code>left</code>，它从第 <code>m</code> 个结点开始向前移动。在 <code>Python</code> 中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数 <code>recurse</code> 的一个变量。</li><li>在递归调用中，给定 <code>m</code>，<code>n</code>，和 <code>right</code>, 首先判断 <code>n = 1</code>。 若判断为真, 则结束。</li><li>于是，当 <code>n</code> 的值达到 1 时，我们便<strong>回溯</strong>。这时，<code>right</code> 指针在我们要反转的子链表结尾，<code>left</code> 到达了字列表的开头。于是，我们置换数据，并将 <code>left</code> 指针前移：<code>left = left.next</code>。我们需要此变化在回溯过程中保持。</li><li>自此，每当我们回溯时，<code>right</code> 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。</li><li>当 <code>right == left</code> 或者 <code>right.next == left</code> 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。</li></ol><p>下面是一系列整个算法的示意图，希望能够帮助你理解清楚。</p><p><img src="http://pic.leetcode-cn.com/1adc7164bea5cd650af1545682900c792bd37a82df607aeb4f87a233d3eb69cf-image.png" alt="image.png"></p><p>这是递归过程的第一步。给定所用链表，<code>left</code> 和 <code>right</code> 指针从链表的 <code>head</code> 开始。第一步是以更新过的 <code>m</code> 和 <code>n</code> 进行递归调用，换而言之，它们的值各自减 1。此外，<code>left</code> 和 <code>right</code> 指针向前移动一位。</p><p><a href="https://pic.leetcode-cn.com/162f18666a30ffd98e185da1311f2daa48b087b03d3a9eefeeb9541eafbcd013-image.png" target="_blank" rel="noopener">image.png</a></p><p>接下来的两步展示了 <code>left</code> 和 <code>right</code> 指针在链表中的移动。注意到在第二步之后，<code>left</code> 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 <code>right</code> 指针继续移动，直到抵达结点 <code>6</code>。</p><p><a href="https://pic.leetcode-cn.com/4213450e7d9466ddf22f289d5e753df47a94a9a87789312a02de2979ed161718-image.png" target="_blank" rel="noopener">image.png</a></p><p>如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 <code>left</code> 和 <code>right</code> 结点的数据。</p><p><a href="https://pic.leetcode-cn.com/36b2ed0c1859c5574a17597070797d8f26b77a9c13a0c3462ea150b1058fbbce-image.png" target="_blank" rel="noopener">image.png</a></p><p>如你所见，在第三步（回溯）之后，<code>right</code> 指针 <strong>穿过了</strong> <code>left</code> 指针，此时已经完成了要求部分链表的反转。结果是 <code>[7 → 9 → 8 → 1 → 10 → 2 → 6]</code>。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。</p><details>    <summary>递归Java</summary><figure class="highlight java"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object level variables since we need the changes</span></span><br><span class="line">    <span class="comment">// to persist across recursive calls and Java is pass by value.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">    <span class="keyword">private</span> ListNode left;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurseAndReverse</span><span class="params">(ListNode right, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case. Don't proceed any further</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">        right = right.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">        <span class="comment">// from where the reversal is to start.</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recurse with m and n reduced.</span></span><br><span class="line">        <span class="keyword">this</span>.recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case both the pointers cross each other or become equal, we</span></span><br><span class="line">        <span class="comment">// stop i.e. don't swap data any further. We are done reversing at this</span></span><br><span class="line">        <span class="comment">// point.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left == right || right.next == <span class="keyword">this</span>.left) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="keyword">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Until the boolean stop is false, swap data between the two pointers</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.stop) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">this</span>.left.val;</span><br><span class="line">            <span class="keyword">this</span>.left.val = right.val;</span><br><span class="line">            right.val = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move left one step to the right.</span></span><br><span class="line">            <span class="comment">// The right pointer moves one step back via backtracking.</span></span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">this</span>.left.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = head;</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.recurseAndReverse(head, m, n);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Python</summary><figure class="highlight python"><figcaption><span>[solution 1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        left, right = head, head</span><br><span class="line">        stop = <span class="keyword">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recurseAndReverse</span><span class="params">(right, m, n)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> left, stop</span><br><span class="line"></span><br><span class="line">            <span class="comment"># base case. Don't proceed any further</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving the right pointer one step forward until (n == 1)</span></span><br><span class="line">            right = right.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Keep moving left pointer to the right until we reach the proper node</span></span><br><span class="line">            <span class="comment"># from where the reversal is to start.</span></span><br><span class="line">            <span class="keyword">if</span> m &gt; <span class="number">1</span>:</span><br><span class="line">                left = left.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Recurse with m and n reduced.</span></span><br><span class="line">            recurseAndReverse(right, m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># In case both the pointers cross each other or become equal, we</span></span><br><span class="line">            <span class="comment"># stop i.e. don't swap data any further. We are done reversing at this</span></span><br><span class="line">            <span class="comment"># point.</span></span><br><span class="line">            <span class="keyword">if</span> left == right <span class="keyword">or</span> right.next == left:</span><br><span class="line">                stop = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Until the boolean stop is false, swap data between the two pointers     </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stop:</span><br><span class="line">                left.val, right.val = right.val, left.val</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Move left one step to the right.</span></span><br><span class="line">                <span class="comment"># The right pointer moves one step back via backtracking.</span></span><br><span class="line">                left = left.next           </span><br><span class="line"></span><br><span class="line">        recurseAndReverse(right, m, n)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: <em>O(N)</em>。对每个结点最多处理两次。递归过程</li><li>回溯</li><li>在回溯过程中，我们只交换了一半的结点，但总复杂度是 <em>O(N)</em>。</li><li>空间复杂度: 最坏情况下为 <em>O(N)</em>。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。<br><br></li></ul><hr><h1 id="方法二-迭代链接反转"><a href="#方法二-迭代链接反转" class="headerlink" title="方法二: 迭代链接反转"></a>方法二: 迭代链接反转</h1><p>我一开始想到的就是通过迭代方法来反转，但是在处理反转后调整成环的情况时翻车了，想了半天，还是参照下面图例中的方法比较直观。</p><p><strong>直觉</strong></p><p>在上个方法中，我们研究了一种反转给定链表部分的算法，该算法不改变给定链表的内在结构，只是修改了对于结点的值。 然而，有时可能无法修改结点的数据值。这时，我们就需要改变结点的链接来完成反转。</p><p>从位置 <code>m</code> 到位置 <code>n</code> 的全部结点，我们需要反转每个结点的 <code>next</code> 指针。下面来看看具体的算法。</p><p><strong>算法</strong></p><p>在看具体算法之前，有必要先弄清楚链接反转的原理以及需要哪些指针。举例而言，有一个三个不同结点组成的链表 <code>A → B → C</code>，需要反转结点中的链接成为 <code>A ← B ← C</code>。</p><p>假设我们有两个指针，一个指向结点 <code>A</code>，一个指向结点 <code>B</code>。 分别记为 <code>prev</code> 和 <code>cur</code>。则可以用这两个指针简单地实现 <code>A 和 B</code> 之间的链接反转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.next = prev</span><br></pre></td></tr></table></figure><p>这样做唯一的问题是，没有办法继续下去，换而言之，这样做之后就无法再访问到结点 <code>C</code>。因此，我们需要引入第三个指针，用于帮助反转过程的进行。因此，我们不采用上面的反转方法，而是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">third = cur.next</span><br><span class="line">cur.next = prev</span><br><span class="line">prev = cur</span><br><span class="line">cur = third</span><br></pre></td></tr></table></figure><p> <strong>迭代</strong> 地进行上述过程，即可完成问题的要求。下面来看看算法的步骤。</p><ol><li>如上所述，我们需要两个指针 <code>prev</code> 和 <code>cur</code>。</li><li><code>prev</code> 指针初始化为 <code>None</code>，<code>cur</code> 指针初始化为链表的 <code>head</code>。</li><li>一步步地向前推进 <code>cur</code> 指针，<code>prev</code> 指针跟随其后。</li><li>如此推进两个指针，直到 <code>cur</code> 指针到达从链表头起的第 <em>m</em> 个结点。这就是我们反转链表的起始位置。</li><li>注意我们要引入两个额外指针，分别称为 <code>tail</code> 和 <code>con</code>。<code>tail</code> 指针指向从链表头起的第<em>m</em>个结点，此结点是反转后链表的尾部，故称为 <code>tail</code>。<code>con</code> 指针指向第 <em>m</em> 个结点的前一个结点，此结点是新链表的头部。下图可以帮助你更好的理解这两个指针。</li></ol><p><a href="https://pic.leetcode-cn.com/bf38eaeb92184fbfb55bd76336c7f746b6f01b3c83bd921268afe84a3c3cf183-image.png" target="_blank" rel="noopener">image.png</a></p><ol start="6"><li><code>tail</code> 和 <code>con</code> 指针在算法开始时被初始化，在算法最后被调用，用于完成链表反转。</li><li>如前文所解释的那样，抵达第 <em>m</em> 个结点后，在用到上述两个指针前，先迭代地反转链接。不断迭代，直到完成指向第 <em>n</em> 个结点的链接。此时，<code>prev</code> 指针会指向第 <em>n</em> 个结点。</li><li>我们使用 <code>con</code> 指针来连接 <code>prev</code> 指针，这是因为 <code>prev</code> 指针当前指向的结点(第 <em>n</em> 个结点)会代替第 <em>m</em> 个结点的位置。 类似地，我们利用 <code>tail</code> 指针来连接 <code>prev</code> 指针之后的结点（第 <em>n+1</em> 个结点）。</li></ol><p>为了便于理清每个指针的用法，我们来看一个算法运行的实例。给定一个链表 <code>7 → 9 → 2 → 10 → 1 → 8 → 6</code>，我们需要反转从第 3 个结点到第 6 个结点的子链表。</p><p><a href="https://pic.leetcode-cn.com/08d4eb39be0db6ded442a208399b5778bbab1cf75c26bc5b3d93128b7c224cb4-image.png" target="_blank" rel="noopener">image.png</a></p><p>从上图可以看到迭代法的前几步。第一步展示了两个指针的初始化，第三步展示了链表反转过程的初始位置。</p><p><a href="https://pic.leetcode-cn.com/77af1e2ca8bd5f9ccc89802094ce07e2505c6b4483ccd6887f2762a6e67310e1-image.png" target="_blank" rel="noopener">image.png</a></p><p>上图详细显示了链接反转的过程以及反转两个结点的链接后如何向前移动。如下图所示，本步骤将执行多次。</p><p><a href="https://pic.leetcode-cn.com/f634c434bcc5092d84b3125a4cd7c723aa3ddd53dcfb9ec3077423cbff1d2f85-image.png" target="_blank" rel="noopener">image.png</a></p><p><a href="https://pic.leetcode-cn.com/b11861e6d3a86cdec19152d442dd243aaf0fb6c914787e7cf60990f2ecf0d558-image.png" target="_blank" rel="noopener">image.png</a></p><p>如上图所示, 两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 <code>tail</code> 和 <code>con</code> 指针完成链接调整的过程。</p><p><a href="https://pic.leetcode-cn.com/968684e83b4cbc4b4db6f80e3bda03748729af672e702a8d3473b24cd04a7092-image.png" target="_blank" rel="noopener">image.png</a></p><details>    <summary>迭代链接反转Java</summary><figure class="highlight java"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty list</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment">// in the list.</span></span><br><span class="line">        ListNode cur = head, prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The two pointers that will fix the final connections.</span></span><br><span class="line">        ListNode con = prev, tail = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        ListNode third = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            third = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = third;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            con.next = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代链接反转Python</summary><figure class="highlight python"><figcaption><span>[solution 2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Empty list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Move the two pointers until they reach the proper starting point</span></span><br><span class="line">        <span class="comment"># in the list.</span></span><br><span class="line">        cur, prev = head, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">1</span>:</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line">            m, n = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The two pointers that will fix the final connections.</span></span><br><span class="line">        tail, con = cur, prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iteratively reverse the nodes until n becomes 0.</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            third = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = third</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Adjust the final connections as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">if</span> con:</span><br><span class="line">            con.next = prev</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = prev</span><br><span class="line">        tail.next = cur</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: <em>O(N)*。考虑包含 *N</em> 个结点的链表。对每个节点最多会处理</li><li>（第 <em>n</em> 个结点之后的结点不处理）。</li><li>空间复杂度: <em>O(1)*。我们仅仅在原有链表的基础上调整了一些指针，只使用了 *O(1)</em> 的额外存储空间来获得结果。<br></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>206. 反转链表</title>
    <link href="http://yoursite.com/2020/08/18/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/18/206. 反转链表/</id>
    <published>2020-08-18T09:51:12.000Z</published>
    <updated>2020-08-19T09:56:23.485Z</updated>
    
    <content type="html"><![CDATA[<p>反转一个单链表。</p><a id="more"></a><p>示例:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>进阶:</p><pre><code>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><h1 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h1><p>假设存在链表 <code>1 → 2 → 3 → Ø</code>，我们想要把它改成 <code>Ø ← 1 ← 2 ← 3</code>。</p><p>在遍历列表时，将当前节点的 <code>next</code> 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p><details>    <summary>迭代</summary><figure class="highlight java"><figcaption><span>[Tww6MiPp-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)*，假设 *n</em> 是列表的长度，时间复杂度是 <em>O(n)</em>。</li><li>空间复杂度：<em>O(1)</em>。</li></ul><hr><h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><p>递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？</p><p>假设列表为：</p><p>n1→…→nk−1    →n k→n k+1→…→nm→∅</p><p>若从节点 <em>n_{k+1}</em> 到 <em>n_{m}</em> 已经被反转，而我们正处于 <em>n_{k}</em>。</p><p>n1→…→nk−1→n k→n k+1←…←nm</p><p>我们希望 <em>n_{k+1}</em> 的下一个节点指向 <em>n_{k}</em>。</p><p>所以，<em>n_{k}</em>.next.next = <em>n_{k}</em>。</p><p>要小心的是 <em>n_{1}</em> 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。</p><details>    <summary>递归</summary><figure class="highlight java"><figcaption><span>[ESkYHVXb-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li>时间复杂度：<em>O(n)*，假设 *n</em> 是列表的长度，那么时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(n)*，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 *n</em> 层。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转一个单链表。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>160. 相交链表</title>
    <link href="http://yoursite.com/2020/08/18/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/08/18/160. 相交链表/</id>
    <published>2020-08-18T08:55:12.000Z</published>
    <updated>2020-08-18T09:50:02.811Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个程序，找到两个单链表相交的起始节点。</p><a id="more"></a><p>如下面的两个链表：</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank" rel="noopener">image</a></p><p>在节点 c1 开始相交。</p><p>示例 1：</p><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p>示例 2：</p><pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p>示例 3：</p><pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><p>注意：</p><pre><code>如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre><h1 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一: 暴力法"></a>方法一: 暴力法</h1><p>对链表A中的每一个结点 <em>a_i*，遍历整个链表 <code>B</code> 并检查链表 <code>B</code> 中是否存在结点和 *a_i</em> 相同。</p><details>    <summary>暴力法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode p1=headA;</span><br><span class="line">        while (p1 != null) &#123;</span><br><span class="line">            ListNode p2 = headB;</span><br><span class="line">            while ( p2 != null) &#123;</span><br><span class="line">                if (p1 == p2) &#123;</span><br><span class="line">                    return p2;</span><br><span class="line">                &#125;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析*** 时间复杂度 : *(mn)*。* 空间复杂度 : *O(1)*。<br><br><hr><h1 id="方法二-哈希表法"><a href="#方法二-哈希表法" class="headerlink" title="方法二: 哈希表法"></a>方法二: 哈希表法</h1><p>遍历链表 <code>A</code> 并将每个结点的地址/引用存  储在哈希表中。然后检查链表 <code>B</code> 中的每一个结点 <em>b_i</em> 是否在哈希表中。若在，则 <em>b_i</em> 为相交结点。</p><details>    <summary>哈希表法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        if (headA == null || headB == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;ListNode,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        while (pA != null) &#123;</span><br><span class="line">            map.put(pA,1);</span><br><span class="line">            pA=pA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (pB != null) &#123;</span><br><span class="line">            if (map.containsKey(pB)) &#123;</span><br><span class="line">                return pB;</span><br><span class="line">            &#125;</span><br><span class="line">            pB=pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(m+n)</em>。</li><li>空间复杂度 : <em>O(m)</em> 或 <em>O(n)</em>。<br><br></li></ul><hr><h1 id="方法三：双指针法"><a href="#方法三：双指针法" class="headerlink" title="方法三：双指针法"></a>方法三：双指针法</h1><ul><li>创建两个指针 <em>pA</em> 和 <em>pB</em>，分别初始化为链表 <code>A</code> 和 <code>B</code> 的头结点。然后让它们向后逐结点遍历。 </li><li>当 <em>pA</em> 到达链表的尾部时，将它重定位到链表 <code>B</code> 的头结点 (你没看错，就是链表 <code>B</code>); 类似的，当 <em>pB</em> 到达链表的尾部时，将它重定位到链表 <code>A</code> 的头结点。 </li><li>若在某一时刻 <em>pA</em> 和 <em>pB</em> 相遇，则 <em>pA</em>/<em>pB</em> 为相交结点。</li><li>想弄清楚为什么这样可行, 可以考虑以下两个链表: <code>A={1,3,5,7,9,11}</code> 和 <code>B={2,4,9,11}</code>，相交于结点 <code>9</code>。 由于 <code>B.length (=4) &lt; A.length (=6)</code>，<em>pB</em> 比 <em>pA</em> 少经过 <em>2</em> 个结点，会先到达尾部。将 <em>pB</em> 重定向到 <code>A</code> 的头结点，<em>pA</em> 重定向到 <code>B</code> 的头结点后，<em>pB</em> 要比 <em>pA</em> 多走 <code>2</code> 个结点。因此，它们会同时到达交点。</li><li>如果两个链表存在相交，它们末尾的结点必然相同。因此当 <em>pA</em>/<em>pB</em> 到达链表结尾时，记录下链表 <code>A/B</code> 对应的元素。若最后元素不相同，则两个链表不相交。</li></ul><p>这里使用图解的方式，解释比较巧妙的一种实现。</p><p>根据题目意思<br>如果两个链表相交，那么相交点之后的长度是相同的</p><p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p><ol><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li>比较长的链表指针指向较短链表head时，长度差就消除了</li><li>如此，只需要将最短链表遍历两次即可找到位置</li></ol><p>听着可能有点绕，看图最直观，链表的题目最适合看图了</p><p><a href="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" target="_blank" rel="noopener">相交链表</a></p><p>代码也很简单（此处代码是参考评论区的高手的）</p><details>    <summary>双指针法</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : <em>O(m+n)</em>。</li><li>空间复杂度 : <em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>142. 环形链表II</title>
    <link href="http://yoursite.com/2020/07/25/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yoursite.com/2020/07/25/142. 环形链表II/</id>
    <published>2020-07-25T10:22:12.000Z</published>
    <updated>2020-07-31T06:41:23.218Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。</p><a id="more"></a><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。</code></pre><p>进阶：<br>你是否可以不用额外空间解决此题？</p><h1 id="方法-1：哈希表"><a href="#方法-1：哈希表" class="headerlink" title="方法 1：哈希表"></a>方法 1：哈希表</h1><p><strong>想法</strong></p><p>如果我们用一个 <code>Set</code> 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。</p><p><strong>算法</strong></p><p>首先，我们分配一个 <code>Set</code> 去保存所有的列表节点。我们逐一遍历列表，检查当前节点是否出现过，如果节点已经出现过，那么一定形成了环且它是环的入口。否则如果有其他点是环的入口，我们应该先访问到其他节点而不是这个节点。其他情况，没有成环则直接返回 <code>null</code> 。</p><p>算法会在遍历有限个节点后终止，这是因为输入列表会被分成两类：成环的和不成环的。一个不成欢的列表在遍历完所有节点后会到达 <code>null</code> - 即链表的最后一个元素后停止。一个成环列表可以想象成是一个不成环列表将最后一个 <code>null</code> 元素换成环的入口。</p><p>如果 <code>while</code> 循环终止，我们返回 <code>null</code> 因为我们已经将所有的节点遍历了一遍且没有遇到重复的节点，这种情况下，列表是不成环的。对于循环列表， <code>while</code> 循环永远不会停止，但在某个节点上， <code>if</code> 条件会被满足并导致函数的退出。</p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        visited = set()</span><br><span class="line"></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.add(node)</span><br><span class="line">                node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p><p>  不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 <em>n</em> 个节点指向 <code>null</code> ，这会让循环退出。对于循环列表， <code>if</code> 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 <em>n</em> 个，所以运行时间跟节点数目成线性关系。</p></li><li><p>空间复杂度：<em>O(n)</em></p><p>  不管成环或者不成欢的输入，我们都需要将每个节点插入 <code>Set</code> 中一次。两者唯一的区别是最后访问的节点后是 <code>null</code> 还是一个已经访问过的节点。因此，由于 <code>Set</code> 包含 <em>n</em> 个不同的节点，所需空间与节点数目也是线性关系的。</p></li></ul><hr><h1 id="方法-2：Floyd-算法"><a href="#方法-2：Floyd-算法" class="headerlink" title="方法 2：Floyd 算法"></a>方法 2：Floyd 算法</h1><p><strong>想法</strong></p><p>当然一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人。</p><p><strong>算法</strong></p><p>Floyd 的算法被划分成两个不同的 <em>阶段</em> 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回 <code>null</code> 并退出。否则，用 <code>相遇节点</code> 来找到环的入口。</p><h2 id="阶段-1"><a href="#阶段-1" class="headerlink" title="阶段 1"></a>阶段 1</h2><p>这里我们初始化两个指针 - 快指针和慢指针。我们每次移动慢指针一步、快指针两步，直到快指针无法继续往前移动。如果在某次移动后，快慢指针指向了同一个节点，我们就返回它。否则，我们继续，直到 <code>while</code> 循环终止且没有返回任何节点，这种情况说明没有成环，我们返回 <code>null</code> 。</p><p>下图说明了这个算法的工作方式：</p><p> <a href="https://pic.leetcode-cn.com/ea37804a3d86a51a1bf827b9068e1f515ffddf840a0563ea0d1174c58ac64352-image.png" target="_blank" rel="noopener">image.png</a></p><p>环中的节点从 0 到 <em>C-1</em> 编号，其中 <em>C</em> 是环的长度。非环节点从 <em>-F</em> 到 <em>-1</em> 编号，其中 <em>F</em> 是环以外节点的数目。 <em>F</em> 次迭代以后，慢指针指向了 0 且快指针指向某个节点 <em>h</em> ，其中F=h(mod C) 。这是因为快指针在 <em>F</em> 次迭代中遍历了 <em>2F</em> 个节点，且恰好有 <em>F</em> 个在环中。继续迭代 <em>C-h</em> 次，慢指针显然指向第 <em>C-h</em> 号节点，而快指针也会指向相同的节点。原因在于，快指针从 <em>h</em> 号节点出发遍历了 <em>2(C-h)</em> 个节点。</p><pre><code>h+2(C−h)=2C−h≡C−h(modC)</code></pre><p>因此，如果列表是有环的，快指针和慢指针最后会同时指向同一个节点，因此被称为 <em>相遇</em> 。</p><h2 id="阶段-2"><a href="#阶段-2" class="headerlink" title="阶段 2"></a>阶段 2</h2><p>给定阶段 1 找到的相遇点，阶段 2 将找到环的入口。首先我们初始化额外的两个指针： <code>ptr1</code> ，指向链表的头， <code>ptr2</code> 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p><p>下面的图将更好的帮助理解和证明这个方法的正确性。</p><p> <a href="https://pic.leetcode-cn.com/99987d4e679fdfbcfd206a4429d9b076b46ad09bd2670f886703fb35ef130635-image.png" target="_blank" rel="noopener">image.png</a></p><p>我们利用已知的条件：慢指针移动 1 步，快指针移动 2 步，来说明它们相遇在环的入口处。（下面证明中的 tortoise 表示慢指针，hare 表示快指针）</p><pre><code>2⋅distance(tortoise)=distance(hare)2(F+a)=F+a+b+a2F+2a=F+2a+bF=b</code></pre><p>因为 <em>F=b</em> ，指针从 <em>h</em> 点出发和从链表的头出发，最后会遍历相同数目的节点后在环的入口处相遇。</p><p><strong>这个公式F=b其实就说明了相遇节点和头节点距离入口节点的距离是相同的，所以只要从这两个节点同时出发一定会在入口节点相遇。</strong></p><p>下面的动画中动态地演示了整个算法过程：</p><p>  <a href="https://pic.leetcode-cn.com/26d91419cd4e90a8954f4253f779681e135527eb9efcfa761fdea990f6b10770-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/4e82b6ff8e2e46f006da98414ae9f9e5ba342e90405ecc37802e83d7652f33aa-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/efe62f7f9d2b003819dc617dab2342e1b7428a9019fcd5eeceef383b0bf1c6fc-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/05848364a6b75ced28ad6d5f172bf18f9f37c58e89382c7c6f4c5715c00b4d17-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/b16ab0dbc5d98adf9b79f9cf1a83b352c1f316dde4f28aab24d980bc17e7a38d-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/0e1f5788dba0f811c0bfc63fa275424885d3373b43616ab51efb07c8b811f52e-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/566912d38a4fdf7f9fed96cd4d50104c2a110ef24c491e3b8596f0591df1e77c-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/c1aa9989085dacdbfc527130186eeffd1af8a1710528b5c10b318314f5c9ff79-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/e1f0345de3ffc0eff25b1ecd4d80e121c7f38610d2a74f3b98ac38bfd5d38c92-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/4f90bf4e8f1a7d44b686a23394e000573f2bf551fa62816e523161bf0d2da474-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/b7d865deedbda8d686fa9c57e9cc819b57527325e852f26721d1fbcd62719757-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/744cd130ed875602db99c9ee82f2e7d4b6681831b7674ae919764b5e87e44cd5-image.png" target="_blank" rel="noopener">image.png</a>  <a href="https://pic.leetcode-cn.com/a0dc8d96c672509eabcd2ba856c1d533fa2208894a7e40c05981e1616576c8f4-image.png" target="_blank" rel="noopener">image.png</a> </p><details>    <summary>Floyd 算法Java版</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tortoise = head;</span><br><span class="line">        ListNode hare = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment">// pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> (hare != <span class="keyword">null</span> &amp;&amp; hare.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tortoise = tortoise.next;</span><br><span class="line">            hare = hare.next.next;</span><br><span class="line">            <span class="keyword">if</span> (tortoise == hare) &#123;</span><br><span class="line">                <span class="keyword">return</span> tortoise;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment">// node. Otherwise, there is no cycle, so we cannot find an e***ance to</span></span><br><span class="line">        <span class="comment">// a cycle.</span></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To find the e***ance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment">// the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment">// the point of intersection.</span></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Floyd 算法Python版</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersect</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        tortoise = head</span><br><span class="line">        hare = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment"># pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> hare <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> hare.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            tortoise = tortoise.next</span><br><span class="line">            hare = hare.next.next</span><br><span class="line">            <span class="keyword">if</span> tortoise == hare:</span><br><span class="line">                <span class="keyword">return</span> tortoise</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment"># node. Otherwise, there is no cycle, so we cannot find an e***ance to</span></span><br><span class="line">        <span class="comment"># a cycle.</span></span><br><span class="line">        intersect = self.getIntersect(head)</span><br><span class="line">        <span class="keyword">if</span> intersect <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># To find the e***ance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment"># the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment"># the point of intersection.</span></span><br><span class="line">        ptr1 = head</span><br><span class="line">        ptr2 = intersect</span><br><span class="line">        <span class="keyword">while</span> ptr1 != ptr2:</span><br><span class="line">            ptr1 = ptr1.next</span><br><span class="line">            ptr2 = ptr2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr1</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p><p>  对有环列表，快指针和慢指针在 <em>F+C-h</em> 次迭代以后会指向同一个节点，正如上面正确性证明所示，  F+C-h≤F+C=n  ，所以阶段 1 运行时间在 <em>O(n)</em> 时间以内，阶段 2 运行 <em>F &lt; n</em> 次迭代，所以它运行时间也在 <em>O(n)</em> 以内。</p><p>  对于无环链表，快指针大约需要迭代 n/2  次会抵达链表的尾部，这样不会进入阶段 2 就直接退出。</p><p>  因此，不管是哪一类链表，都会在与节点数成线性关系的时间内运行完。</p></li><li><p>空间复杂度：<em>O(1)</em></p><p>Floyd 的快慢指针算法仅需要几个指针，所以只需常数级别的额外空间。</p></li></ul><h2 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h2><p>看不懂算式证明的话，或者你可以这样解释性地来理解阶段2：</p><ol><li><p>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</p></li><li><p>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</p></li><li><p>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</p></li><li><p>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</p></li><li><p>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</p></li><li><p>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</p></li></ol><p>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>148. 排序链表</title>
    <link href="http://yoursite.com/2020/07/25/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/25/148. 排序链表/</id>
    <published>2020-07-25T10:22:12.000Z</published>
    <updated>2020-08-18T08:48:04.575Z</updated>
    
    <content type="html"><![CDATA[<p>在O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p>示例 2:</p><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><p>这道题拖的时间比较长，从写博客到做完持续了半个多月，创纪录了，第二种解法还没太吃透，有待深究。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ol><li><p>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</p></li><li><p>自下而上的迭代；</p></li></ol><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><h1 id="解答一：归并排序（递归法）"><a href="#解答一：归并排序（递归法）" class="headerlink" title="解答一：归并排序（递归法）"></a>解答一：归并排序（递归法）</h1><ul><li><p>题目要求时间空间复杂度分别为<em>O(nlogn)</em>和<em>O(1)</em>，根据时间复杂度我们自然想到二分法，从而联想到归并排序；</p></li><li><p>对数组做归并排序的空间复杂度为 <em>O(n)</em>，分别由新开辟数组<em>O(n)</em>和递归函数调用<em>O(logn)</em>组成，而根据链表特性：</p><ul><li>数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间；</li><li>递归额外空间：递归调用函数将带来<em>O(logn)</em>的空间复杂度，因此若希望达到<em>O(1)</em>空间复杂度，则不能使用递归。</li></ul></li><li><p>通过递归实现链表归并排序，有以下两个环节：</p><ul><li><strong>分割 cut 环节：</strong> 找到当前链表<code>中点</code>，并从<code>中点</code>将链表断开（以便在下次递归 <code>cut</code> 时，链表片段拥有正确边界）；<ul><li>我们使用 <code>fast,slow</code> 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li><li>找到中点 <code>slow</code> 后，执行 <code>slow.next = None</code> 将链表切断。</li><li>递归分割时，输入当前链表左端点 <code>head</code> 和中心节点 <code>slow</code> 的下一个节点 <code>tmp</code>(因为链表是从 <code>slow</code> 切断的)。</li><li><strong>cut 递归终止条件：</strong> 当<code>head.next == None</code>时，说明只有一个节点了，直接返回此节点。</li></ul></li><li><strong>合并 merge 环节：</strong> 将两个排序链表合并，转化为一个排序链表。<ul><li>双指针法合并，建立辅助ListNode <code>h</code> 作为头部。</li><li>设置两指针 <code>left</code>, <code>right</code> 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li><li>返回辅助ListNode <code>h</code> 作为头部的下个节点 <code>h.next</code>。</li><li>时间复杂度 <code>O(l + r)</code>，<code>l, r</code> 分别代表两个链表长度。 </li></ul></li><li>当题目输入的 <code>head == None</code> 时，直接返回None。</li></ul></li></ul><p><img src="https://pic.leetcode-cn.com/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png"></p><details>    <summary>归并排序（递归法）python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head <span class="comment"># termination.</span></span><br><span class="line">        <span class="comment"># cut the LinkedList at the mid index.</span></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast, slow = fast.next.next, slow.next</span><br><span class="line">        mid, slow.next = slow.next, <span class="keyword">None</span> <span class="comment"># save and cut.</span></span><br><span class="line">        <span class="comment"># recursive for cutting.</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line">        <span class="comment"># merge `left` and `right` linked list and return it.</span></span><br><span class="line">        h = res = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val: h.next, left = left, left.next</span><br><span class="line">            <span class="keyword">else</span>: h.next, right = right, right.next</span><br><span class="line">            h = h.next</span><br><span class="line">        h.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure></details><details>    <summary>归并排序（递归法）java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点</span></span><br><span class="line">        ListNode fast=head.next,slow=head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到中点 slow 后，执行 slow.next = None 将链表切断</span></span><br><span class="line">        ListNode tmp=slow.next;</span><br><span class="line">        slow.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp</span></span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(tmp);</span><br><span class="line">        <span class="comment">//合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针法合并，建立辅助ListNode h 作为头部。</span></span><br><span class="line">        ListNode h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res=h;</span><br><span class="line">        <span class="comment">//设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</span></span><br><span class="line">        <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">                h.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h.next=right;</span><br><span class="line">                right=right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回辅助ListNode h 作为头部的下个节点 h.next。</span></span><br><span class="line">        h.next=(left !=<span class="keyword">null</span>) ? left:right;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="解答二：归并排序（从底至顶直接合并）"><a href="#解答二：归并排序（从底至顶直接合并）" class="headerlink" title="解答二：归并排序（从底至顶直接合并）"></a>解答二：归并排序（从底至顶直接合并）</h1><ul><li>对于非递归的归并排序，需要使用迭代的方式替换<code>cut</code>环节：<ul><li>我们知道，<code>cut</code>环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。</li><li>每一轮合并<code>merge</code>操作针对的单元都有固定长度<code>intv</code>，例如：<ul><li>第一轮合并时<code>intv = 1</code>，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。</li><li>第二轮合并时<code>intv = 2</code>，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。</li><li>以此类推，直到单元长度<code>intv &gt;= 链表长度</code>，代表已经排序完成。</li></ul></li><li>根据以上推论，我们可以仅根据<code>intv</code>计算每个单元边界，并完成链表的每轮排序合并，例如:<ul><li>当<code>intv = 1</code>时，将链表第<code>1</code>和第<code>2</code>节点排序合并，第<code>3</code>和第<code>4</code>节点排序合并，……。</li><li>当<code>intv = 2</code>时，将链表第<code>1-2</code>和第<code>3-4</code>节点排序合并，第<code>5-6</code>和第<code>7-8</code>节点排序合并，……。</li><li>当<code>intv = 4</code>时，将链表第<code>1-4</code>和第<code>5-8</code>节点排序合并，第<code>9-12</code>和第<code>13-16</code>节点排序合并，……。</li></ul></li></ul></li><li>此方法时间复杂度<em>O(nlogn)</em>，空间复杂度<em>O(1)</em>。</li></ul><p><img src="https://pic.leetcode-cn.com/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png" alt="Picture1.png"></p><ul><li>模拟上述的多轮排序合并：<ul><li>统计链表长度<code>length</code>，用于通过判断<code>intv &lt; length</code>判定是否完成排序；</li><li>额外声明一个节点<code>res</code>，作为头部后面接整个链表，用于：<ul><li><code>intv *= 2</code>即切换到下一轮合并时，可通过<code>res.next</code>找到链表头部<code>h</code>；</li><li>执行排序合并时，需要一个辅助节点作为头部，而<code>res</code>则作为链表头部排序合并时的辅助头部<code>pre</code>；后面的合并排序可以将上次合并排序的尾部<code>tail</code>用做辅助节点。</li></ul></li><li>在每轮<code>intv</code>下的合并流程：<ol><li>根据<code>intv</code>找到合并单元1和单元2的头部<code>h1</code>, <code>h2</code>。由于链表长度可能不是<code>2^n</code>，需要考虑边界条件：<ul><li>在找<code>h2</code>过程中，如果链表剩余元素个数少于<code>intv</code>，则无需合并环节，直接<code>break</code>，执行下一轮合并；</li><li>若<code>h2</code>存在，但以<code>h2</code>为头部的剩余元素个数少于<code>intv</code>，也执行合并环节，<code>h2</code>单元的长度为<code>c2 = intv - i</code>。</li></ul></li><li>合并长度为<code>c1, c2</code>的<code>h1, h2</code>链表，其中：<ul><li>合并完后，需要修改新的合并单元的尾部<code>pre</code>指针指向下一个合并单元头部<code>h</code>。（在寻找<code>h1, h2</code>环节中，h指针已经被移动到下一个单元头部）</li><li>合并单元尾部同时也作为下次合并的辅助头部<code>pre</code>。</li></ul></li><li>当<code>h == None</code>，代表此轮<code>intv</code>合并完成，跳出。</li></ol></li><li>每轮合并完成后将单元长度×2，切换到下轮合并：<code>intv *= 2</code>。<details><summary>归并排序（从底至顶直接合并) python</summary></details></li></ul></li></ul><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        h, length, intv = head, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> h: h, length = h.next, length + <span class="number">1</span></span><br><span class="line">        res = ListNode(<span class="number">0</span>)</span><br><span class="line">        res.next = head</span><br><span class="line">        <span class="comment"># merge the list in different intv.</span></span><br><span class="line">        <span class="keyword">while</span> intv &lt; length:</span><br><span class="line">            pre, h = res, res.next</span><br><span class="line">            <span class="keyword">while</span> h:</span><br><span class="line">                <span class="comment"># get the two merge head `h1`, `h2`</span></span><br><span class="line">                h1, i = h, intv</span><br><span class="line">                <span class="keyword">while</span> i <span class="keyword">and</span> h: h, i = h.next, i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i: <span class="keyword">break</span> <span class="comment"># no need to merge because the `h2` is None.</span></span><br><span class="line">                h2, i = h, intv</span><br><span class="line">                <span class="keyword">while</span> i <span class="keyword">and</span> h: h, i = h.next, i - <span class="number">1</span></span><br><span class="line">                c1, c2 = intv, intv - i <span class="comment"># the `c2`: length of `h2` can be small than the `intv`.</span></span><br><span class="line">                <span class="comment"># merge the `h1` and `h2`.</span></span><br><span class="line">                <span class="keyword">while</span> c1 <span class="keyword">and</span> c2:</span><br><span class="line">                    <span class="keyword">if</span> h1.val &lt; h2.val: pre.next, h1, c1 = h1, h1.next, c1 - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: pre.next, h2, c2 = h2, h2.next, c2 - <span class="number">1</span></span><br><span class="line">                    pre = pre.next</span><br><span class="line">                pre.next = h1 <span class="keyword">if</span> c1 <span class="keyword">else</span> h2</span><br><span class="line">                <span class="keyword">while</span> c1 &gt; <span class="number">0</span> <span class="keyword">or</span> c2 &gt; <span class="number">0</span>: pre, c1, c2 = pre.next, c1 - <span class="number">1</span>, c2 - <span class="number">1</span></span><br><span class="line">                pre.next = h </span><br><span class="line">            intv *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><details>    <summary>归并排序（从底至顶直接合并）java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        模拟上述的多轮排序合并：</span></span><br><span class="line"><span class="comment">//        统计链表长度length，用于通过判断intv &lt; length判定是否完成排序；</span></span><br><span class="line">        ListNode h,h1,h2,pre,res;</span><br><span class="line">        h=head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>,intv=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">            h=h.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        额外声明一个节点res，作为头部后面接整个链表，用于：</span></span><br><span class="line">        res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res.next=head;</span><br><span class="line"><span class="comment">//        intv *= 2即切换到下一轮合并时，可通过res.next找到链表头部h；</span></span><br><span class="line"><span class="comment">//        执行排序合并时，需要一个辅助节点作为头部，而res则作为链表头部排序合并时的辅助头部pre；后面的合并排序可以将上次合并排序的尾部tail用做辅助节点。</span></span><br><span class="line">        <span class="keyword">while</span> (intv &lt; length) &#123;</span><br><span class="line">            pre = res;</span><br><span class="line">            h = res.next;</span><br><span class="line"><span class="comment">//        在每轮intv下的合并流程：</span></span><br><span class="line"><span class="comment">//        a. 根据intv找到合并单元1和单元2的头部h1, h2。由于链表长度可能不是2^n，需要考虑边界条件：</span></span><br><span class="line">            <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = intv;</span><br><span class="line">                h1 = h;</span><br><span class="line">                <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//              在找h2过程中，如果链表剩余元素个数少于intv，则无需合并环节，直接break，执行下一轮合并；</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                i = intv;</span><br><span class="line">                h2 = h;</span><br><span class="line">                <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//        若h2存在，但以h2为头部的剩余元素个数少于intv，也执行合并环节，h2单元的长度为c2 = intv - i。</span></span><br><span class="line">                <span class="keyword">int</span> c1 = intv, c2 = intv - i;</span><br><span class="line"><span class="comment">//        b. 合并长度为c1, c2的h1, h2链表，其中：</span></span><br><span class="line">                <span class="keyword">while</span> (c1 &gt; <span class="number">0</span> &amp;&amp; c2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h1.val &lt; h2.val) &#123;</span><br><span class="line">                        pre.next = h1;</span><br><span class="line">                        h1 = h1.next;</span><br><span class="line">                        c1--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        pre.next = h2;</span><br><span class="line">                        h2 = h2.next;</span><br><span class="line">                        c2--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next = c1 == <span class="number">0</span> ? h2 : h1;</span><br><span class="line">                <span class="keyword">while</span> (c1 &gt; <span class="number">0</span> || c2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                    c1--;</span><br><span class="line">                    c2--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//        合并完后，需要修改新的合并单元的尾部pre指针指向下一个合并单元头部h。（在寻找h1, h2环节中，h指针已经被移动到下一个单元头部）</span></span><br><span class="line"><span class="comment">//        合并单元尾部同时也作为下次合并的辅助头部pre。</span></span><br><span class="line">                pre.next = h;</span><br><span class="line"><span class="comment">//        c. 当h == None，代表此轮intv合并完成，跳出。</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//        每轮合并完成后将单元长度×2，切换到下轮合并：intv *= 2。</span></span><br><span class="line">            intv *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>141. 环形链表</title>
    <link href="http://yoursite.com/2020/07/24/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/24/141. 环形链表/</id>
    <published>2020-07-24T07:22:12.000Z</published>
    <updated>2020-07-25T10:07:47.894Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，判断链表中是否有环。</p><a id="more"></a><p>这道题十分经典，快慢指针这种解法应该是耳熟能详，记得面试头条时三面时被问到有没有比快慢指针更好的办法或改进方法，当时想了半天没想到递归的方法，现在补充到题解中。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p>进阶：</p><pre><code>你能用 O(1)（即，常量）内存解决此问题吗？</code></pre><hr><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><p><strong>思路</strong></p><p>我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。</p><p><strong>算法</strong></p><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 <code>null</code>（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 <code>true</code>（即该链表为环形链表）。</p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[SiMGFWod-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，对于含有 *n</em> 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 <em>O(1)</em> 的时间。</p></li><li><p>空间复杂度：<em>O(n)*，空间取决于添加到哈希表中的元素数目，最多可以添加 *n</em> 个元素。</p></li></ul><hr><h1 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h1><p><strong>思路</strong></p><p>想象一下，两名运动员以不同的速度在环形赛道上跑步会发生什么？</p><p><strong>算法</strong></p><p>通过使用具有 <strong>不同速度</strong> 的快、慢两个指针遍历链表，空间复杂度可以被降低至 <em>O(1)</em>。慢指针每次移动一步，而快指针每次移动两步。</p><p>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 <code>false</code>。</p><p>现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。</p><p>其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。</p><details>    <summary>双指针Java</summary><figure class="highlight java"><figcaption><span>[qdD5r8PV-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，让我们将 *n</em> 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况。</p><ul><li><p><strong><em>链表中不存在环：</em></strong><br>快指针将会首先到达尾部，其时间取决于列表的长度，也就是 <em>O(n)</em>。</p></li><li><p><strong><em>链表中存在环：</em></strong><br>我们将慢指针的移动过程划分为两个阶段：非环部分与环形部分：</p><ol><li><p>慢指针在走完非环部分阶段后将进入环形部分：此时，快指针已经进入环中 <code>迭代次数=非环部分长度=N</code></p></li><li><p>两个指针都在环形区域中：考虑两个在环形赛道上的运动员 - 快跑者每次移动两步而慢跑者每次只移动一步。其速度的差值为 1，因此需要经过二者之间距离/速度差值 次循环后，快跑者可以追上慢跑者。这个距离几乎就是 “环形部分长度 K”” 且速度差值为 1，我们得出这样的结论迭代次数=近似于环形部分长度K。</p></li></ol><p>因此，在最糟糕的情形下，时间复杂度为 <em>O(N+K)</em>，也就是 <em>O(n)</em>。</p></li></ul></li><li><p>空间复杂度：<em>O(1)</em>，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 <em>O(1)</em>。</p></li></ul><p>这道题相当的经典，重温时一开始被pos迷惑住了，还以为条件变了，要自己写到链表结尾的跳转代码，后来看入参才发现不需要自己处理。</p><h1 id="方法三：JS特殊解法"><a href="#方法三：JS特殊解法" class="headerlink" title="方法三：JS特殊解法"></a>方法三：JS特殊解法</h1><p>相信对于 JS 中的 JSON.stringify() 方法大家都用过，主要用于将 JS 对象 转换为 JSON 字符串。基本使用如下：</p><details>    <summary>基本使用</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var car = &#123; </span><br><span class="line">  name: &apos;小喵&apos;, </span><br><span class="line">  age: 20, </span><br><span class="line">&#125; </span><br><span class="line">var str = JSON.stringify(car);</span><br><span class="line">console.log(str) </span><br><span class="line">//=&gt; &#123;&quot;name&quot;:&quot;小喵&quot;,&quot;age&quot;:20&#125;</span><br></pre></td></tr></table></figure></details>大家想一下，如果是自己实现这样的一个函数，我们需要处理什么样的特殊情况？对，就是循环引用。因为对于循环引用，我们很难通过 JSON 的结构将其进行展示！比如下面：<details>    <summary>例子</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125; </span><br><span class="line">var b = &#123; </span><br><span class="line">  a: a </span><br><span class="line">&#125;</span><br><span class="line">a.b = b</span><br><span class="line">console.log(JSON.stringify(a))</span><br><span class="line">//=&gt; TypeError: Converting circular structure to JSON</span><br></pre></td></tr></table></figure></details>那我们思考，对于环形链表，是不是就是一个循环结构呢？当然是！因为只要是环形链表，它一定存在类似以下代码：<details>    <summary>例子</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.Next = b</span><br><span class="line">b.Next = a</span><br></pre></td></tr></table></figure></details><p>所以我们可以通过 JSON.stringify() 的特性进行求解：</p><details>    <summary>JS特殊解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var hasCycle = function(head) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        JSON.stringify(head)</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>当然，这种解法并不是建议的标准题解！在此列出是为了拓宽思维！（如有兴趣，可以自己去看下JSON.stringify 内部的实现，是如何检测循环引用的。）<h1 id="方法四：递归：破坏链表结构"><a href="#方法四：递归：破坏链表结构" class="headerlink" title="方法四：递归：破坏链表结构"></a>方法四：递归：破坏链表结构</h1><details>    <summary>递归：破坏链表结构</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否是自环状态</span><br><span class="line">        if (head == head.next) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //让遍历过的节点自环</span><br><span class="line">        ListNode breaker=head.next;</span><br><span class="line">        head.next=head;</span><br><span class="line">        return hasCycle(breaker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这种方法可以只使用一个指针来解决，每次遍历一个节点后都把它变成自环结构，这样如果遍历到开始成环的节点时该节点的指向的环路上的节点必然是已经自环的节点，递归到这个自环节点时返回true。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p></li><li><p>空间复杂度：<em>O(1)</em></p></li></ul><h1 id="方法五：递归：标记法"><a href="#方法五：递归：标记法" class="headerlink" title="方法五：递归：标记法"></a>方法五：递归：标记法</h1><details>    <summary>递归：标记法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head.val == 0xcafebabe) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        head.val=0xcafebabe;</span><br><span class="line">        return hasCycle(head.next);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这种递归方法是遍历到一个节点就把它的值标记为魔数0xcafebabe（用个别的十六进制数标记也行），一直递归到遇到标记过的节点或者是空指针。</p><p>魔数0xcafebabe：Java中class文件的前四个字节是 CAFEBABE，它表示这个文件的类型是Class文件(类似于文件名后缀，不过魔数是给编译器看的，后缀是给执行程序看的)</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em></p></li><li><p>空间复杂度：<em>O(1)</em></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>138. 复制带随机指针的链表</title>
    <link href="http://yoursite.com/2020/07/23/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/23/138. 复制带随机指针的链表/</id>
    <published>2020-07-23T08:22:12.000Z</published>
    <updated>2020-07-24T03:06:27.074Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。很经典的一道题，也是剑指Offer 上的面试题26. 复杂链表的复制。</p><a id="more"></a><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><ul><li>val：一个表示 Node.val 的整数。</li><li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li></ul><p>示例 1：</p><pre><code>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><p>示例 2：</p><pre><code>输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]</code></pre><p>示例 3：</p><pre><code>输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]</code></pre><p>示例 4：</p><pre><code>输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。</code></pre><p>提示：</p><pre><code>-10000 &lt;= Node.val &lt;= 10000Node.random 为空（null）或指向链表中的节点。节点数目不超过 1000 。</code></pre><p>首先，我们来看一下有向链表<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao-by-leetcod/" target="_blank" rel="noopener">^1</a>：</p><p> <a href="https://pic.leetcode-cn.com/6a547c42c3a2d05e054223a2a512844ed2bc7f424433e0d99ae20a4a191c582d-image.png" target="_blank" rel="noopener">image.png</a></p><p>在上图中，对于一个节点，它的 <code>next</code> 指针指向链表中的下一个节点。 <code>next</code> 指针是通常有向链表中有的部分且将所有节点 <strong><em>链接</em></strong> 起来。图中有趣的一点，也是这题有趣的一点在于 <code>random</code> 指针，正如名字所示，它可以指向链表中的任一节点也可以为空。</p><h1 id="方法-1：回溯"><a href="#方法-1：回溯" class="headerlink" title="方法 1：回溯"></a>方法 1：回溯</h1><p><strong>想法</strong></p><p>回溯算法的第一想法是将链表想象成一张图。链表中每个节点都有 2 个指针（图中的边）。因为随机指针给图结构添加了随机性，所以我们可能会访问相同的节点多次，这样就形成了环。</p><p> <a href="https://pic.leetcode-cn.com/990d6483f673537e98e6162cc9e1c6c4ca32729d0d54b82bb5e46cbdaf2246b8-image.png" target="_blank" rel="noopener">image.png</a></p><p>上图中，我们可以看到随机指针指向了前一个节点，因此成环。我们需要考虑这种环的实现。</p><p>此方法中，我们只需要遍历整个图并拷贝它。拷贝的意思是每当遇到一个新的未访问过的节点，你都需要创造一个新的节点。遍历按照深度优先进行。我们需要在回溯的过程中记录已经访问过的节点，否则因为随机指针的存在我们可能会产生死循环。</p><p><strong>算法</strong></p><ol><li><p>从 <code>头</code> 指针开始遍历整个图。</p><p> 我们将链表看做一张图。下图对应的是上面的有向链表的例子，<code>Head</code> 是图的出发节点。</p><p><a href="https://pic.leetcode-cn.com/bd3fb0c9f6d3fdcc3bbc4afdb47183d6aaef93552df135130ea42da77aab911d-image.png" target="_blank" rel="noopener">image.png</a></p></li></ol><ol start="2"><li>当我们遍历到某个点时，如果我们已经有了当前节点的一个拷贝，我们不需要重复进行拷贝。</li><li>如果我们还没拷贝过当前节点，我们创造一个新的节点，并把该节点放到已访问字典中，即：<br><code>visited_dictionary[current_node] = cloned_node_for_current_node.</code></li><li>我们针对两种情况进行回溯调用：一个顺着 <code>random</code> 指针调用，另一个沿着 <code>next</code> 指针调用。步骤 1 中将 <code>random</code> 和 <code>next</code> 指针分别红红色和蓝色标注。然后我们分别对两个指针进行函数递归调用：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloned_node_for_current_node.next = copyRandomList(current_node.next);</span><br><span class="line">cloned_node_for_current_node.random = copyRandomList(current_node.random);</span><br></pre></td></tr></table></figure><details>    <summary>回溯Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// HashMap which holds old nodes as keys and new nodes as its values.</span></span><br><span class="line">  HashMap&lt;Node, Node&gt; visitedHash = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have already processed the current node, then we simply return the cloned version of</span></span><br><span class="line">    <span class="comment">// it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visitedHash.containsKey(head)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.visitedHash.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new node with the value same as old node. (i.e. copy the node)</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(head.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save this value in the hash map. This is needed since there might be</span></span><br><span class="line">    <span class="comment">// loops during traversal due to randomness of random pointers and this would help us avoid</span></span><br><span class="line">    <span class="comment">// them.</span></span><br><span class="line">    <span class="keyword">this</span>.visitedHash.put(head, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively copy the remaining linked list starting once from the next pointer and then from</span></span><br><span class="line">    <span class="comment">// the random pointer.</span></span><br><span class="line">    <span class="comment">// Thus we have two independent recursive calls.</span></span><br><span class="line">    <span class="comment">// Finally we update the next and random pointers for the new node created.</span></span><br><span class="line">    node.next = <span class="keyword">this</span>.copyRandomList(head.next);</span><br><span class="line">    node.random = <span class="keyword">this</span>.copyRandomList(head.random);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: Node</span></span><br><span class="line"><span class="string">    :rtype: Node</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Dictionary which holds old nodes as keys and new nodes as its values.</span></span><br><span class="line">        self.visitedHash = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we have already processed the current node, then we simply return the cloned version of it.</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> self.visitedHash:</span><br><span class="line">            <span class="keyword">return</span> self.visitedHash[head]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create a new node</span></span><br><span class="line">        <span class="comment"># with the value same as old node.</span></span><br><span class="line">        node = Node(head.val, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save this value in the hash map. This is needed since there might be</span></span><br><span class="line">        <span class="comment"># loops during traversal due to randomness of random pointers and this would help us avoid them.</span></span><br><span class="line">        self.visitedHash[head] = node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursively copy the remaining linked list starting once from the next pointer and then from the random pointer.</span></span><br><span class="line">        <span class="comment"># Thus we have two independent recursive calls.</span></span><br><span class="line">        <span class="comment"># Finally we update the next and random pointers for the new node created.</span></span><br><span class="line">        node.next = self.copyRandomList(head.next)</span><br><span class="line">        node.random = self.copyRandomList(head.random)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em> ，其中 <em>N</em> 是链表中节点的数目。</li><li>空间复杂度：<em>O(N)</em> 。如果我们仔细分析，我们需要维护一个回溯的栈，同时也需要记录已经被深拷贝过的节点，也就是维护一个已访问字典。渐进时间复杂度为 <em>O(N)</em> 。</li></ul><br><h1 id="方法-2：-O-N-空间的迭代"><a href="#方法-2：-O-N-空间的迭代" class="headerlink" title="方法 2： O(N) 空间的迭代"></a>方法 2： <em>O(N)</em> 空间的迭代</h1><p><strong>想法</strong></p><p>迭代算法不需要将链表视为一个图。当我们在迭代链表时，我们只需要为 <code>random</code> 指针和 <code>next</code> 指针指向的未访问过节点创造新的节点并赋值即可。</p><p><strong>算法</strong></p><ol><li><p>从 <code>head</code> 节点开始遍历链表。下图中，我们首先创造新的 <code>head</code> 拷贝节点。拷贝的节点如下图虚线所示。实现中，我们将该新建节点的引用也放入已访问字典中。</p><p><a href="https://pic.leetcode-cn.com/ba345f073f3edebb79e2500ffea5fd744bf2266bb1426e5b4221f2f21ecea900-image.png" target="_blank" rel="noopener">image.png</a></p></li></ol><ol start="2"><li><p><code>random</code> 指针</p><ul><li><p>如果当前节点 <em>i</em> 的 <code>random</code> 指针指向一个节点 <em>j</em> 且节点 <em>j</em> 已经被拷贝过，我们将直接使用已访问字典中该节点的引用而不会新建节点。</p></li><li><p>如果当前节点 <em>i</em> 的 <code>random</code> 指针指向的节点 <em>j</em> 还没有被拷贝过，我们就对 <em>j</em> 节点创建对应的新节点，并把它放入已访问节点字典中。</p><p>下图中， <em>A</em> 的 <code>random</code> 指针指向的节点 <em>C</em> 。前图中可以看出，节点 <em>C</em> 还没有被访问过，所以我们创造一个拷贝的 <em>C’</em> 节点与之对应，并将它添加到已访问字典中。</p></li></ul></li></ol><p> <a href="https://pic.leetcode-cn.com/ac190cfe6d9de91a765c103c2a79a89f25b404fa355f1b3cb41f30e47467a676-image.png" target="_blank" rel="noopener">image.png</a></p><ol start="3"><li><code>next</code> 指针<ul><li>如果当前节点 <em>i</em> 的 <code>next</code> 指针指向的节点 <em>j</em> 在已访问字典中已有拷贝，我们直接使用它的拷贝节点。</li><li>如果当前节点 <em>i</em> 的<code>next</code> 指针指向的节点 <em>j</em> 还没有被访问过，我们创建一个对应节点的拷贝，并放入已访问字典。</li></ul></li></ol><p>下图中，<em>A</em> 节点的 <code>next</code> 指针指向节点 <em>B</em> 。节点 <em>B</em> 在前面的图中还没有被访问过，因此我们创造一个新的拷贝 <em>B’</em> 节点，并放入已访问字典中。</p><p> <a href="https://pic.leetcode-cn.com/02c55bd01ea1f85231e34ea714de8db3ccb8717f434a80f94c0efdac62b15246-image.png" target="_blank" rel="noopener">image.png</a></p><ol start="4"><li>我们重复步骤 2 和步骤 3 ，直到我们到达链表的结尾。</li></ol><p>下图中， 节点 <em>B</em> 的 <code>random</code> 指针指向的节点 <em>A</em> 已经被访问过了，因此在步骤 2 中，我们不会创建新的拷贝，</p><p>将节点 <em>B’</em> 的 <code>random</code> 指针指向克隆节点 <em>A’</em> 。</p><p>同样的， 节点 <em>B</em> 的 <code>next</code> 指针指向的节点 <em>C</em> 已经访问过，因此在步骤 3 中，我们不会创建新的拷贝，而直接将 <em>B’</em> 的 <code>next</code> 指针指向已经存在的拷贝节点 <em>C’</em> 。</p><p> <a href="https://pic.leetcode-cn.com/203559119fb45aa1bb844a5441ce18089f4005fa386bd794048c51fd25686e87-image.png" target="_blank" rel="noopener">image.png</a></p><details>    <summary>迭代算法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Visited dictionary to hold old node reference as "key" and new node reference as the "value"</span></span><br><span class="line">  HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">getClonedNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the node exists then</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Check if the node is in the visited dictionary</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.visited.containsKey(node)) &#123;</span><br><span class="line">        <span class="comment">// If its in the visited dictionary then return the new node reference from the dictionary</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise create a new node, add to the dictionary and return it</span></span><br><span class="line">        <span class="keyword">this</span>.visited.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node oldNode = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating the new head node.</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(oldNode.val);</span><br><span class="line">    <span class="keyword">this</span>.visited.put(oldNode, newNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate on the linked list until all nodes are cloned.</span></span><br><span class="line">    <span class="keyword">while</span> (oldNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Get the clones of the nodes referenced by random and next pointers.</span></span><br><span class="line">      newNode.random = <span class="keyword">this</span>.getClonedNode(oldNode.random);</span><br><span class="line">      newNode.next = <span class="keyword">this</span>.getClonedNode(oldNode.next);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Move one step ahead in the linked list.</span></span><br><span class="line">      oldNode = oldNode.next;</span><br><span class="line">      newNode = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(head);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>迭代算法Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Creating a visited dictionary to hold old node reference as "key" and new node reference as the "value"</span></span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getClonedNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># If node exists then</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># Check if its in the visited dictionary          </span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> self.visited:</span><br><span class="line">                <span class="comment"># If its in the visited dictionary then return the new node reference from the dictionary</span></span><br><span class="line">                <span class="keyword">return</span> self.visited[node]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Otherwise create a new node, save the reference in the visited dictionary and return it.</span></span><br><span class="line">                self.visited[node] = Node(node.val, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">return</span> self.visited[node]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        old_node = head</span><br><span class="line">        <span class="comment"># Creating the new head node.       </span></span><br><span class="line">        new_node = Node(old_node.val, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line">        self.visited[old_node] = new_node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iterate on the linked list until all nodes are cloned.</span></span><br><span class="line">        <span class="keyword">while</span> old_node != <span class="keyword">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the clones of the nodes referenced by random and next pointers.</span></span><br><span class="line">            new_node.random = self.getClonedNode(old_node.random)</span><br><span class="line">            new_node.next = self.getClonedNode(old_node.next)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Move one step ahead in the linked list.</span></span><br><span class="line">            old_node = old_node.next</span><br><span class="line">            new_node = new_node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.visited[head]</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em> 。因为我们需要将原链表逐一遍历。</li><li>空间复杂度：<em>O(N)</em> 。 我们需要维护一个字典，保存旧的节点和新的节点的对应。因此总共需要 <em>N</em> 个节点，需要 <em>O(N)</em> 的空间复杂度。</li></ul><br><h1 id="方法-3：O-1-空间的迭代"><a href="#方法-3：O-1-空间的迭代" class="headerlink" title="方法 3：O(1) 空间的迭代"></a>方法 3：<em>O(1)</em> 空间的迭代</h1><p><strong>想法</strong></p><p>与上面提到的维护一个旧节点和新节点对应的字典不同，我们通过扭曲原来的链表，并将每个拷贝节点都放在原来对应节点的旁边。这种旧节点和新节点交错的方法让我们可以在不需要额外空间的情况下解决这个问题。让我们看看这个算法如何工作</p><p><strong>算法</strong></p><ol><li>遍历原来的链表并拷贝每一个节点，将拷贝节点放在原来节点的旁边，创造出一个旧节点和新节点交错的链表。</li></ol><p> <a href="https://pic.leetcode-cn.com/c4e075d7eb23b27074430abda66ff5a74307f85958b063ebb530873b66c117b8-image.png" target="_blank" rel="noopener">image.png</a><br> <a href="https://pic.leetcode-cn.com/62ba6efc1d3a77ba04956a105eeaa5738ef1771d9e2fc9f4daf80a0cf1275d70-image.png" target="_blank" rel="noopener">image.png</a></p><p> 如你所见，我们只是用了原来节点的值拷贝出新的节点。原节点 <code>next</code> 指向的都是新创造出来的节点。</p><p><code>cloned_node.next = original_node.next</code></p><p><code>original_node.next = cloned_node</code></p><ol start="2"><li><p>迭代这个新旧节点交错的链表，并用旧节点的 <code>random</code> 指针去更新对应新节点的 <code>random</code> 指针。比方说， <code>B</code> 的 <code>random</code> 指针指向 <code>A</code> ，意味着 <code>B&#39;</code> 的 <code>random</code> 指针指向 <code>A&#39;</code> 。</p><p><a href="https://pic.leetcode-cn.com/1789e6dd9bbe41223cab82b2e0a7615cd1a8ed16a3c992462d4e1eaec3b82fb1-image.png" target="_blank" rel="noopener">image.png</a></p></li><li><p>现在 <code>random</code> 指针已经被赋值给正确的节点， <code>next</code> 指针也需要被正确赋值，以便将新的节点正确链接同时将旧节点重新正确链接。</p></li></ol><p> <a href="https://pic.leetcode-cn.com/a28323ef84883ec02e7d99fd13b444dede9355389c7567e43e7ee1c85262a2d3-image.png" target="_blank" rel="noopener">image.png</a></p><p>说实话前两个方法我都没能太理解，但这种方法清晰易懂，而且空间复杂度较低，推荐。C++版本的是2018.1.9时提交的，回过头来刚看时还是迷糊，太久没有复习这部分内容了，好像狗熊掰棒子哈哈。</p><details>    <summary>O(1)空间的迭代Java</summary><figure class="highlight"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating a new weaved list of original and copied nodes.</span></span><br><span class="line">    Node ptr = head;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Cloned node</span></span><br><span class="line">      Node newNode = <span class="keyword">new</span> Node(ptr.val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Inserting the cloned node just next to the original node.</span></span><br><span class="line">      <span class="comment">// If A-&gt;B-&gt;C is the original linked list,</span></span><br><span class="line">      <span class="comment">// Linked list after weaving cloned nodes would be A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">      newNode.next = ptr.next;</span><br><span class="line">      ptr.next = newNode;</span><br><span class="line">      ptr = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now link the random pointers of the new nodes created.</span></span><br><span class="line">    <span class="comment">// Iterate the newly created list and use the original nodes' random pointers,</span></span><br><span class="line">    <span class="comment">// to assign references to random pointers for cloned nodes.</span></span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr.next.random = (ptr.random != <span class="keyword">null</span>) ? ptr.random.next : <span class="keyword">null</span>;</span><br><span class="line">      ptr = ptr.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unweave the linked list to get back the original linked list and the cloned list.</span></span><br><span class="line">    <span class="comment">// i.e. A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C' would be broken to A-&gt;B-&gt;C and A'-&gt;B'-&gt;C'</span></span><br><span class="line">    Node ptr_old_list = head; <span class="comment">// A-&gt;B-&gt;C</span></span><br><span class="line">    Node ptr_new_list = head.next; <span class="comment">// A'-&gt;B'-&gt;C'</span></span><br><span class="line">    Node head_old = head.next;</span><br><span class="line">    <span class="keyword">while</span> (ptr_old_list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr_old_list.next = ptr_old_list.next.next;</span><br><span class="line">      ptr_new_list.next = (ptr_new_list.next != <span class="keyword">null</span>) ? ptr_new_list.next.next : <span class="keyword">null</span>;</span><br><span class="line">      ptr_old_list = ptr_old_list.next;</span><br><span class="line">      ptr_new_list = ptr_new_list.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head_old;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;O(1)空间的迭代Python&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Python []</span><br><span class="line">class Solution(object):</span><br><span class="line">    <span class="function">def <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line"><span class="function">        """</span></span><br><span class="line"><span class="function">        :type head: Node</span></span><br><span class="line"><span class="function">        :rtype: Node</span></span><br><span class="line"><span class="function">        """</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> not head:</span></span><br><span class="line"><span class="function">            return head</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        # Creating a new weaved list of original and copied nodes.</span></span><br><span class="line"><span class="function">        ptr </span>= head</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line"></span><br><span class="line">            # Cloned node</span><br><span class="line">            new_node = Node(ptr.val, None, None)</span><br><span class="line"></span><br><span class="line">            # Inserting the cloned node just next to the original node.</span><br><span class="line">            # If A-&gt;B-&gt;C is the original linked list,</span><br><span class="line">            # Linked list after weaving cloned nodes would be A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span><br><span class="line">            new_node.next = ptr.next</span><br><span class="line">            ptr.next = new_node</span><br><span class="line">            ptr = new_node.next</span><br><span class="line"></span><br><span class="line">        ptr = head</span><br><span class="line"></span><br><span class="line">        # Now link the random pointers of the new nodes created.</span><br><span class="line">        # Iterate the newly created list and use the original nodes random pointers,</span><br><span class="line">        # to assign references to random pointers for cloned nodes.</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            ptr.next.random = ptr.random.next <span class="keyword">if</span> ptr.random <span class="keyword">else</span> None</span><br><span class="line">            ptr = ptr.next.next</span><br><span class="line"></span><br><span class="line">        # Unweave the linked list to get back the original linked list and the cloned list.</span><br><span class="line">        # i.e. A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C' would be broken to A-&gt;B-&gt;C and A'-&gt;B'-&gt;C'</span><br><span class="line">        ptr_old_list = head # A-&gt;B-&gt;C</span><br><span class="line">        ptr_new_list = head.next # A'-&gt;B'-&gt;C'</span><br><span class="line">        head_old = head.next</span><br><span class="line">        <span class="keyword">while</span> ptr_old_list:</span><br><span class="line">            ptr_old_list.next = ptr_old_list.next.next</span><br><span class="line">            ptr_new_list.next = ptr_new_list.next.next <span class="keyword">if</span> ptr_new_list.next <span class="keyword">else</span> None</span><br><span class="line">            ptr_old_list = ptr_old_list.next</span><br><span class="line">            ptr_new_list = ptr_new_list.next</span><br><span class="line">        <span class="keyword">return</span> head_old</span><br><span class="line">```    </span><br><span class="line">&lt;/details&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;O(1)空间的迭代C++&lt;/summary&gt;</span><br></pre></td></tr></table></figure><p>/**</p><ul><li><p>Definition for singly-linked list with a random pointer.</p></li><li><p>struct RandomListNode {</p></li><li><p>int label;</p></li><li><p>RandomListNode *next, *random;</p></li><li><p>RandomListNode(int x) : label(x), next(NULL), random(NULL) {}</p></li><li><p>};</p><p> 剑指Offer 面试题２６　复杂链表的复制</p></li><li><p>/<br>class Solution {<br>public:<br>  RandomListNode *copyRandomList(RandomListNode *head) {</p><pre><code>CloneNodes(head);ConnectRandomNodes(head);return ReconnectNodes(head);</code></pre><p>  }</p></li></ul><pre><code>void CloneNodes(RandomListNode* pHead){    RandomListNode *pNode=pHead;    while(pNode!=NULL){        RandomListNode *pCloned;//= new RandomListNode();        /* copy the node and create the new node */        pCloned=new RandomListNode(pNode-&gt;label);       // pCloned-&gt;label=pNode-&gt;label;        pCloned-&gt;next=pNode-&gt;next;        pCloned-&gt;random=NULL;        pNode-&gt;next=pCloned;// connect the new clone node to the old node        pNode=pCloned-&gt;next;// push forward = i++    }}void ConnectRandomNodes(RandomListNode *pHead){    RandomListNode *pNode=pHead;    while(pNode!= NULL){        RandomListNode *pCloned=pNode-&gt;next;        if(pNode-&gt;random!=NULL){            pCloned-&gt;random = pNode-&gt;random-&gt;next;// pNode-&gt;random-&gt;next point to the next Clone Node which can see the graph of the P149        }        pNode= pCloned-&gt;next;// push forward to the next Node    }}RandomListNode * ReconnectNodes(RandomListNode *pHead){    RandomListNode *pNode=pHead;    RandomListNode *pClonedHead=NULL;    RandomListNode *pClonedNode = NULL;    if(pNode!=NULL){        pClonedHead= pClonedNode= pNode-&gt; next;        pNode-&gt;next=pClonedNode-&gt;next;        pNode = pNode-&gt;next;    }    while(pNode!= NULL){        pClonedNode-&gt;next= pNode-&gt;next;        pClonedNode=pClonedNode-&gt;next;        pNode-&gt;next=pClonedNode-&gt;next;        pNode=pNode-&gt;next;    }    return pClonedHead;}</code></pre><p>};<br>//runtime:50 ms<br>//memory:N/A</p><p>```</p></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)</em></li><li>空间复杂度：<em>O(1)</em>    </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。&lt;/p&gt;
&lt;p&gt;要求返回这个链表的 深拷贝。很经典的一道题，也是剑指Offer 上的面试题26. 复杂链表的复制。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>150. 逆波兰表达式求值</title>
    <link href="http://yoursite.com/2020/07/23/150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>http://yoursite.com/2020/07/23/150. 逆波兰表达式求值/</id>
    <published>2020-07-23T07:36:12.000Z</published>
    <updated>2020-07-23T08:21:38.495Z</updated>
    
    <content type="html"><![CDATA[<p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><a id="more"></a><p>说明：</p><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><pre><code>输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</code></pre><p>示例 2：</p><pre><code>输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</code></pre><p>示例 3：</p><pre><code>输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: 该算式转化为常见的中缀算术表达式为：  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</li><li>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>我首先想到的是用栈的解法</p><p><strong>Java相关优化操作：</strong></p><ul><li>switch代替if-else，效率优化</li><li>Integer.parseInt代替Integer.valueOf,减少自动拆箱装箱操作</li></ul><details>    <summary>栈</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String s : tokens) &#123;</span><br><span class="line">            if (!isOp(s)) &#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int ans = res(s.charAt(0), stack.pop(), stack.pop());</span><br><span class="line">                stack.push(ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isOp(String s) &#123;</span><br><span class="line">        if (s.length() &gt; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (s.charAt(0)) &#123;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                return true; //因为直接返回了所以不加break了</span><br><span class="line">            case &apos;/&apos;:</span><br><span class="line">                return true;</span><br><span class="line">            case &apos;+&apos;:</span><br><span class="line">                return true;</span><br><span class="line">            case &apos;-&apos;:</span><br><span class="line">                return true;</span><br><span class="line">            default:</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int res(char op, int b, int a) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        switch (op) &#123;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                res = a * b;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;/&apos;:</span><br><span class="line">                res = a / b;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;+&apos;:</span><br><span class="line">                res = a + b;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;-&apos;:</span><br><span class="line">                res = a - b;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="纯数组模拟栈实现："><a href="#纯数组模拟栈实现：" class="headerlink" title="纯数组模拟栈实现："></a>纯数组模拟栈实现：</h1><p><strong>其他Java相关优化操作：</strong></p><ul><li>数组最大长度为<code>tokens.length / 2 + 1</code></li></ul><details>    <summary>纯数组模拟栈实现(推荐)</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//纯数组模拟栈实现(推荐)   3 ms36 MB</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] numStack = <span class="keyword">new</span> <span class="keyword">int</span>[tokens.length / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] += numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] -= numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] *= numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">numStack[index - <span class="number">2</span>] /= numStack[--index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// numStack[index++] = Integer.valueOf(s);</span></span><br><span class="line"><span class="comment">//valueOf改为parseInt，减少自动拆箱装箱操作</span></span><br><span class="line">numStack[index++] = Integer.parseInt(s);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numStack[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 逆波兰表示法，求表达式的值。&lt;/p&gt;
&lt;p&gt;有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年7月" scheme="http://yoursite.com/categories/2020%E5%B9%B47%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
</feed>
