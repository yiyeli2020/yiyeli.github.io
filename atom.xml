<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-08-22T07:44:11.656Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>733. 图像渲染</title>
    <link href="http://yoursite.com/2022/08/22/733.%20%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2022/08/22/733.%20%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</id>
    <published>2022-08-22T07:12:12.000Z</published>
    <updated>2022-08-22T07:44:11.656Z</updated>
    
    <content type="html"><![CDATA[<p>图像渲染。</p><span id="more"></span><p>[TOC]</p><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。</p><p>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。</p><p>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。</p><p>最后返回 经过上色渲染后的图像 。</p><p>示例 1:</p><pre><code>输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。</code></pre><p>示例 2:</p><pre><code>输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2输出: [[2,2,2],[2,2,2]]</code></pre><p>提示:</p><pre><code>m == image.lengthn == image[i].length1 &lt;= m, n &lt;= 500 &lt;= image[i][j], newColor &lt; 2160 &lt;= sr &lt; m0 &lt;= sc &lt; n</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题要求将给定的二维数组中指定的「色块」染成另一种颜色。「色块」的定义是：直接或间接相邻的同色方格构成的整体。</p><p>可以发现，「色块」就是被不同颜色的方格包围的一个同色岛屿。我们从色块中任意一个地方开始，利用广度优先搜索或深度优先搜索即可遍历整个岛屿。</p><p>注意：当目标颜色和初始颜色相同时，我们无需对原数组进行修改。</p><h1 id="方法一：广度优先搜索-1"><a href="#方法一：广度优先搜索-1" class="headerlink" title="方法一：广度优先搜索^1"></a>方法一：广度优先搜索<a href="https://leetcode.cn/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/">^1</a></h1><h2 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>我们从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。</p><p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor == newColor) return image;</span><br><span class="line">        int n = image.size(), m = image[0].size();</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; que;</span><br><span class="line">        que.emplace(sr, sc);</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int x = que.front().first, y = que.front().second;</span><br><span class="line">            que.pop();</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class="line">                    que.emplace(mx, my);</span><br><span class="line">                    image[mx][my] = newColor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] dx = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    int[] dy = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor == newColor) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = image.length, m = image[0].length;</span><br><span class="line">        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();</span><br><span class="line">        queue.offer(new int[]&#123;sr, sc&#125;);</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int[] cell = queue.poll();</span><br><span class="line">            int x = cell[0], y = cell[1];</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class="line">                    queue.offer(new int[]&#123;mx, my&#125;);</span><br><span class="line">                    image[mx][my] = newColor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]:</span><br><span class="line">        currColor = image[sr][sc]</span><br><span class="line">        if currColor == newColor:</span><br><span class="line">            return image</span><br><span class="line">        </span><br><span class="line">        n, m = len(image), len(image[0])</span><br><span class="line">        que = collections.deque([(sr, sc)])</span><br><span class="line">        image[sr][sc] = newColor</span><br><span class="line">        while que:</span><br><span class="line">            x, y = que.popleft()</span><br><span class="line">            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:</span><br><span class="line">                if 0 &lt;= mx &lt; n and 0 &lt;= my &lt; m and image[mx][my] == currColor:</span><br><span class="line">                    que.append((mx, my))</span><br><span class="line">                    image[mx][my] = newColor</span><br><span class="line">        </span><br><span class="line">        return image</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int newColor, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    int n = imageSize, m = imageColSize[0];</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    int currColor = image[sr][sc];</span><br><span class="line">    if (currColor == newColor) return image;</span><br><span class="line">    int que[n * m][2];</span><br><span class="line">    int l = 0, r = 0;</span><br><span class="line">    que[r][0] = sr, que[r++][1] = sc;</span><br><span class="line">    image[sr][sc] = newColor;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        int x = que[l][0], y = que[l++][1];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class="line">                que[r][0] = mx, que[r++][1] = my;</span><br><span class="line">                image[mx][my] = newColor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    dx = []int&#123;1, 0, 0, -1&#125;</span><br><span class="line">    dy = []int&#123;0, 1, -1, 0&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func floodFill(image [][]int, sr int, sc int, newColor int) [][]int &#123;</span><br><span class="line">    currColor := image[sr][sc]</span><br><span class="line">    if currColor == newColor &#123;</span><br><span class="line">        return image</span><br><span class="line">    &#125;</span><br><span class="line">    n, m := len(image), len(image[0])</span><br><span class="line">    queue := [][]int&#123;&#125;</span><br><span class="line">    queue = append(queue, []int&#123;sr, sc&#125;)</span><br><span class="line">    image[sr][sc] = newColor</span><br><span class="line">    for i := 0; i &lt; len(queue); i++ &#123;</span><br><span class="line">        cell := queue[i]</span><br><span class="line">        for j := 0; j &lt; 4; j++ &#123;</span><br><span class="line">            mx, my := cell[0] + dx[j], cell[1] + dy[j]</span><br><span class="line">            if mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor &#123;</span><br><span class="line">                queue = append(queue, []int&#123;mx, my&#125;)</span><br><span class="line">                image[mx][my] = newColor</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return image</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。<br>空间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。主要为队列的开销。</p><h1 id="方法二：深度优先搜索"><a href="#方法二：深度优先搜索" class="headerlink" title="方法二：深度优先搜索"></a>方法二：深度优先搜索</h1><h2 id="思路及算法-1"><a href="#思路及算法-1" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>我们从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。</p><p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int color, int newColor) &#123;</span><br><span class="line">        if (image[x][y] == color) &#123;</span><br><span class="line">            image[x][y] = newColor;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; image.size() &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; image[0].size()) &#123;</span><br><span class="line">                    dfs(image, mx, my, color, newColor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor != newColor) &#123;</span><br><span class="line">            dfs(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    int[] dx = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    int[] dy = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        int currColor = image[sr][sc];</span><br><span class="line">        if (currColor != newColor) &#123;</span><br><span class="line">            dfs(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[][] image, int x, int y, int color, int newColor) &#123;</span><br><span class="line">        if (image[x][y] == color) &#123;</span><br><span class="line">            image[x][y] = newColor;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">                if (mx &gt;= 0 &amp;&amp; mx &lt; image.length &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; image[0].length) &#123;</span><br><span class="line">                    dfs(image, mx, my, color, newColor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]:</span><br><span class="line">        n, m = len(image), len(image[0])</span><br><span class="line">        currColor = image[sr][sc]</span><br><span class="line"></span><br><span class="line">        def dfs(x: int, y: int):</span><br><span class="line">            if image[x][y] == currColor:</span><br><span class="line">                image[x][y] = newColor</span><br><span class="line">                for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:</span><br><span class="line">                    if 0 &lt;= mx &lt; n and 0 &lt;= my &lt; m and image[mx][my] == currColor:</span><br><span class="line">                        dfs(mx, my)</span><br><span class="line"></span><br><span class="line">        if currColor != newColor:</span><br><span class="line">            dfs(sr, sc)</span><br><span class="line">        return image</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">void dfs(int** image, int x, int y, int color, int newColor) &#123;</span><br><span class="line">    if (image[x][y] == color) &#123;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int mx = x + dx[i], my = y + dy[i];</span><br><span class="line">            if (mx &gt;= 0 &amp;&amp; mx &lt; n &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; m) &#123;</span><br><span class="line">                dfs(image, mx, my, color, newColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int newColor, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    n = imageSize, m = imageColSize[0];</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    int currColor = image[sr][sc];</span><br><span class="line">    if (currColor != newColor) &#123;</span><br><span class="line">        dfs(image, sr, sc, currColor, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    dx = []int&#123;1, 0, 0, -1&#125;</span><br><span class="line">    dy = []int&#123;0, 1, -1, 0&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func floodFill(image [][]int, sr int, sc int, newColor int) [][]int &#123;</span><br><span class="line">    currColor := image[sr][sc]</span><br><span class="line">    if currColor != newColor &#123;</span><br><span class="line">        dfs(image, sr, sc, currColor, newColor)</span><br><span class="line">    &#125;</span><br><span class="line">    return image</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dfs(image [][]int, x, y, color, newColor int) &#123;</span><br><span class="line">    if image[x][y] == color &#123;</span><br><span class="line">        image[x][y] = newColor</span><br><span class="line">        for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">            mx, my := x + dx[i], y + dy[i]</span><br><span class="line">            if mx &gt;= 0 &amp;&amp; mx &lt; len(image) &amp;&amp; my &gt;= 0 &amp;&amp; my &lt; len(image[0]) &#123;</span><br><span class="line">                dfs(image, mx, my, color, newColor)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。<br>空间复杂度：<br>O(n×m)，其中 n 和 m 分别是二维数组的行数和列数。主要为栈空间的开销。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;图像渲染。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>463. 岛屿的周长</title>
    <link href="http://yoursite.com/2022/08/22/463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <id>http://yoursite.com/2022/08/22/463.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</id>
    <published>2022-08-22T03:12:12.000Z</published>
    <updated>2022-08-22T06:47:41.313Z</updated>
    
    <content type="html"><![CDATA[<p>计算这个岛屿的周长。</p><span id="more"></span><p>[TOC]</p><p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] &#x3D; 1 表示陆地， grid[i][j] &#x3D; 0 表示水域。</p><p>网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 1：</p><pre><code>输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]输出：16解释：它的周长是上面图片中的 16 个黄色的边</code></pre><p>示例 2：</p><pre><code>输入：grid = [[1]]输出：4示例 3：输入：grid = [[1,0]]输出：4</code></pre><p>提示：</p><pre><code>row == grid.lengthcol == grid[i].length1 &lt;= row, col &lt;= 100grid[i][j] 为 0 或 1</code></pre><h1 id="方法一：迭代-1"><a href="#方法一：迭代-1" class="headerlink" title="方法一：迭代^1"></a>方法一：迭代<a href="https://leetcode.cn/problems/island-perimeter/solution/dao-yu-de-zhou-chang-by-leetcode-solution/">^1</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即1）加入答案 ans 中即可。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    constexpr static int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    constexpr static int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line">public:</span><br><span class="line">    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        int n = grid.size(), m = grid[0].size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j]) &#123;</span><br><span class="line">                    int cnt = 0;</span><br><span class="line">                    for (int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                        int tx = i + dx[k];</span><br><span class="line">                        int ty = j + dy[k];</span><br><span class="line">                        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || !grid[tx][ty]) &#123;</span><br><span class="line">                            cnt += 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int[] dx = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    static int[] dy = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int islandPerimeter(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length, m = grid[0].length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    int cnt = 0;</span><br><span class="line">                    for (int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                        int tx = i + dx[k];</span><br><span class="line">                        int ty = j + dy[k];</span><br><span class="line">                        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || grid[tx][ty] == 0) &#123;</span><br><span class="line">                            cnt += 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type pair struct&#123; x, y int &#125;</span><br><span class="line">var dir4 = []pair&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;</span><br><span class="line"></span><br><span class="line">func islandPerimeter(grid [][]int) (ans int) &#123;</span><br><span class="line">    n, m := len(grid), len(grid[0])</span><br><span class="line">    for i, row := range grid &#123;</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == 1 &#123;</span><br><span class="line">                for _, d := range dir4 &#123;</span><br><span class="line">                    if x, y := i+d.x, j+d.y; x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0 &#123;</span><br><span class="line">                        ans++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int islandPerimeter(int** grid, int gridSize, int* gridColSize) &#123;</span><br><span class="line">    int n = gridSize, m = gridColSize[0];</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (grid[i][j]) &#123;</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                for (int k = 0; k &lt; 4; ++k) &#123;</span><br><span class="line">                    int tx = i + dx[k];</span><br><span class="line">                    int ty = j + dy[k];</span><br><span class="line">                    if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || !grid[tx][ty]) &#123;</span><br><span class="line">                        cnt += 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(nm)，其中 n 为网格的高度，m 为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 4 个格子是否为岛屿，因此总时间复杂度为O(4nm)&#x3D;O(nm)。<br>空间复杂度：<br>O(1)。只需要常数空间存放若干变量。</p><h1 id="方法二：深度优先搜索"><a href="#方法二：深度优先搜索" class="headerlink" title="方法二：深度优先搜索"></a>方法二：深度优先搜索</h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>我们也可以将方法一改成深度优先搜索遍历的方式，此时遍历的方式可扩展至统计多个岛屿各自的周长。需要注意的是为了防止陆地格子在深度优先搜索中被重复遍历导致死循环，我们需要将遍历过的陆地格子标记为已经遍历过，下面的代码中我们设定值为 2 的格子为已经遍历过的陆地格子。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    constexpr static int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    constexpr static int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line">public:</span><br><span class="line">    int dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;grid, int n, int m) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[x][y] == 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = 2;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int tx = x + dx[i];</span><br><span class="line">            int ty = y + dy[i];</span><br><span class="line">            res += dfs(tx, ty, grid, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        int n = grid.size(), m = grid[0].size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    ans += dfs(i, j, grid, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    static int[] dx = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">    static int[] dy = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">    public int islandPerimeter(int[][] grid) &#123;</span><br><span class="line">        int n = grid.length, m = grid[0].length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    ans += dfs(i, j, grid, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dfs(int x, int y, int[][] grid, int n, int m) &#123;</span><br><span class="line">        if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[x][y] == 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = 2;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int tx = x + dx[i];</span><br><span class="line">            int ty = y + dy[i];</span><br><span class="line">            res += dfs(tx, ty, grid, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type pair struct&#123; x, y int &#125;</span><br><span class="line">var dir4 = []pair&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;</span><br><span class="line"></span><br><span class="line">func islandPerimeter(grid [][]int) (ans int) &#123;</span><br><span class="line">    n, m := len(grid), len(grid[0])</span><br><span class="line">    var dfs func(x, y int)</span><br><span class="line">    dfs = func(x, y int) &#123;</span><br><span class="line">        if x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0 &#123;</span><br><span class="line">            ans++</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if grid[x][y] == 2 &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = 2</span><br><span class="line">        for _, d := range dir4 &#123;</span><br><span class="line">            dfs(x+d.x, y+d.y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i, row := range grid &#123;</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == 1 &#123;</span><br><span class="line">                dfs(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary></summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">int dfs(int x, int y, int** grid, int n, int m) &#123;</span><br><span class="line">    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (grid[x][y] == 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = 2;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">        int tx = x + dx[i];</span><br><span class="line">        int ty = y + dy[i];</span><br><span class="line">        res += dfs(tx, ty, grid, n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int islandPerimeter(int** grid, int gridSize, int* gridColSize) &#123;</span><br><span class="line">    int n = gridSize, m = gridColSize[0];</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (grid[i][j] == 1) &#123;</span><br><span class="line">                ans += dfs(i, j, grid, n, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(nm)，其中 n 为网格的高度，m 为网格的宽度。每个格子至多会被遍历一次，因此总时间复杂度为 O(nm)。<br>空间复杂度：O(nm)。深度优先搜索复杂度取决于递归的栈空间，而栈空间最坏情况下会达到 O(nm)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算这个岛屿的周长。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Depth-First Search" scheme="http://yoursite.com/tags/Depth-First-Search/"/>
    
    <category term="Breadth-First Search" scheme="http://yoursite.com/tags/Breadth-First-Search/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>748. 最短补全词</title>
    <link href="http://yoursite.com/2022/08/09/748.%20%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/"/>
    <id>http://yoursite.com/2022/08/09/748.%20%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/</id>
    <published>2022-08-09T02:12:12.000Z</published>
    <updated>2022-08-09T03:37:36.854Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。</p><span id="more"></span><p>[TOC]</p><p>补全词 是一个包含 licensePlate 中所有字母的单词。忽略 licensePlate 中的 数字和空格 。不区分大小写。如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。</p><p>例如：licensePlate &#x3D; “aBc 12c”，那么它的补全词应当包含字母 ‘a’、’b’ （忽略大写）和两个 ‘c’ 。可能的 补全词 有 “abccdef”、”caaacab” 以及 “cbca” 。</p><p>请返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 第一个 出现的那个。<a href="https://leetcode.cn/problems/shortest-completing-word/">^1</a></p><p>示例 1：</p><pre><code>输入：licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]输出：&quot;steps&quot;解释：最短补全词应该包括 &quot;s&quot;、&quot;p&quot;、&quot;s&quot;（忽略大小写） 以及 &quot;t&quot;。&quot;step&quot; 包含 &quot;t&quot;、&quot;p&quot;，但只包含一个 &quot;s&quot;，所以它不符合条件。&quot;steps&quot; 包含 &quot;t&quot;、&quot;p&quot; 和两个 &quot;s&quot;。&quot;stripe&quot; 缺一个 &quot;s&quot;。&quot;stepple&quot; 缺一个 &quot;s&quot;。因此，&quot;steps&quot; 是唯一一个包含所有字母的单词，也是本例的答案。</code></pre><p>示例 2：</p><pre><code>输入：licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]输出：&quot;pest&quot;解释：licensePlate 只包含字母 &quot;s&quot; 。所有的单词都包含字母 &quot;s&quot; ，其中 &quot;pest&quot;、&quot;stew&quot;、和 &quot;show&quot; 三者最短。答案是 &quot;pest&quot; ，因为它是三个单词中在 words 里最靠前的那个。</code></pre><p>提示：</p><pre><code>1 &lt;= licensePlate.length &lt;= 7licensePlate 由数字、大小写字母或空格 &#39; &#39; 组成1 &lt;= words.length &lt;= 10001 &lt;= words[i].length &lt;= 15words[i] 由小写英文字母组成</code></pre><h1 id="根据字符串长度对vector数组进行稳定排序-哈希表"><a href="#根据字符串长度对vector数组进行稳定排序-哈希表" class="headerlink" title="根据字符串长度对vector数组进行稳定排序 + 哈希表"></a>根据字符串长度对vector数组进行稳定排序 + 哈希表</h1><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void sortByLen(vector&lt;string&gt; &amp;words)&#123;</span><br><span class="line">        stable_sort(words.begin(),words.end(),[](string a, string b)&#123;</span><br><span class="line">            return a.length()&lt;b.length();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;char,int&gt; sToMap(string s)&#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; map;</span><br><span class="line">        for(auto c: s)&#123;</span><br><span class="line">            if(isalpha(c))&#123;</span><br><span class="line">                map[tolower(c)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string shortestCompletingWord(string licensePlate, vector&lt;string&gt; &amp;words) &#123;</span><br><span class="line">        sortByLen(words);</span><br><span class="line">        unordered_map&lt;char, int&gt; map=sToMap(licensePlate);</span><br><span class="line">        for(auto &amp;s: words)&#123;</span><br><span class="line">            unordered_map&lt;char, int&gt; dic=sToMap(s);</span><br><span class="line">            bool contain=true;</span><br><span class="line">            for(auto a:map)&#123;</span><br><span class="line">                if(dic.count(a.first)==0)&#123;</span><br><span class="line">                    contain = false;</span><br><span class="line">                &#125;else if(dic[a.first] &lt; a.second)&#123;</span><br><span class="line">                    contain = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(contain)&#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void unstableSortByLen(String[] words) &#123;</span><br><span class="line">        Arrays.sort(words, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String o1, String o2) &#123;</span><br><span class="line">                return o1.length() - o2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stableSortByLen(ArrayList&lt;String&gt; words) &#123;</span><br><span class="line">        //对于Arrays.sort(int[] var0)使用的是快排,所以是不稳定的.但是试了下发现这个也能过</span><br><span class="line">        //对于Collections.sort(List&lt;T&gt; elements)使用的是归并排序,是稳定的.</span><br><span class="line">        Collections.sort(words, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String s1, String s2) &#123;</span><br><span class="line">                return s1.length() - s2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sToMap(HashMap&lt;Character, Integer&gt; map, String s) &#123;</span><br><span class="line">        for (Character c : s.toCharArray()) &#123;</span><br><span class="line">            if (Character.isAlphabetic(c)) &#123;</span><br><span class="line">                 map.put(Character.toLowerCase(c), map.getOrDefault(Character.toLowerCase(c), 0) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String shortestCompletingWord(String licensePlate, String[] words) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; word = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(word, words);</span><br><span class="line">        stableSortByLen(word);</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        sToMap(map, licensePlate);</span><br><span class="line">        for (String s : word) &#123;</span><br><span class="line">            boolean flag = true;</span><br><span class="line">            HashMap&lt;Character, Integer&gt; mapWords = new HashMap&lt;&gt;();</span><br><span class="line">            sToMap(mapWords, s);</span><br><span class="line">            for (Character c : map.keySet()) &#123;</span><br><span class="line">                if (mapWords.getOrDefault(c, 0) == 0) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if (mapWords.getOrDefault(c, 0) &lt; map.get(c)) &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>C++二维动态静态数组传参速查</title>
    <link href="http://yoursite.com/2022/08/05/C++%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E9%80%9F%E6%9F%A5/"/>
    <id>http://yoursite.com/2022/08/05/C++%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E9%80%9F%E6%9F%A5/</id>
    <published>2022-08-05T10:12:12.000Z</published>
    <updated>2022-08-08T02:16:55.082Z</updated>
    
    <content type="html"><![CDATA[<p>动态静态数组传参数都是引用传递</p><span id="more"></span><p>[TOC]</p><p>参考<a href="https://www.cnblogs.com/usa007lhy/p/3286186.html">^1</a></p><details>    <summary>动态静态数组传参</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//  二维数组</span><br><span class="line">//  Created by yiye on 2022/8/4.</span><br><span class="line">//https://www.cnblogs.com/usa007lhy/p/3286186.html</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//void iniMatrix(int a[3][5], int rows)&#123;</span><br><span class="line">void iniMatrix(int a[][5], int rows)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******初始化二维静态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;5;j++)&#123;</span><br><span class="line">            a[i][j]=i*10+j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void iniDynamicMatrix(int **a, int rows, int cols)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******初始化二维动态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;cols;j++)&#123;</span><br><span class="line">            a[i][j]=i*10+j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printStaticMatrix(int a[][5],int rows)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******打印二维静态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;5;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void printDynamicMatrix(int **a,int rows, int cols)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******打印二维动态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;rows;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;cols;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void changeArray(int *num, int len)&#123;</span><br><span class="line">    for(int i=0;i&lt;len/2;i++)&#123;</span><br><span class="line">        num[i] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printArray(int *num, int len)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;**********打印一维数组**********&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printStaticMatrix(int **num, int row, int col)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;*******打印二维静态数组******&quot;&lt;&lt;endl;</span><br><span class="line">    for (int i=0; i&lt;row; i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;col; j++) &#123;</span><br><span class="line">            cout&lt;&lt;*((int *)num + col*i+j)&lt;&lt;&quot; &quot;; // 可行方案</span><br><span class="line">//            cout&lt;&lt;((int *)num + col*i)[j]&lt;&lt;&quot; &quot;; //可行方案</span><br><span class="line">//            cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;;//不可行方案</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int a[3][5];</span><br><span class="line">    iniMatrix(a, 3);</span><br><span class="line">    printStaticMatrix(a, 3);</span><br><span class="line">    printStaticMatrix((int **)a, 3, 5);</span><br><span class="line">    cout&lt;&lt;&quot;*******新的二维数组******&quot;&lt;&lt;endl;</span><br><span class="line">    int b[][5] = &#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;</span><br><span class="line">    printStaticMatrix(b, 3);</span><br><span class="line">    int len = 5;</span><br><span class="line">    int num[5]=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    printArray(num, 5);</span><br><span class="line">    changeArray(num, len);</span><br><span class="line">    printArray(num, 5);</span><br><span class="line">    cout&lt;&lt;&quot;#####静态数组传参数是引用传递#####&quot;&lt;&lt;endl;</span><br><span class="line">    int *num2 = new int[len];</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        num2[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(num2, len);</span><br><span class="line">    changeArray(num2, len);</span><br><span class="line">    printArray(num2, len);</span><br><span class="line">    cout&lt;&lt;&quot;#####动态数组传参数是引用传递#####&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] num2;</span><br><span class="line">    </span><br><span class="line">    int row = 3, col=5;</span><br><span class="line">    int **num3  = new int*[row];</span><br><span class="line">    for (int i=0; i&lt;row; i++) &#123;</span><br><span class="line">        num3[i]=new int[col];</span><br><span class="line">    &#125;</span><br><span class="line">    iniDynamicMatrix(num3, row, col);</span><br><span class="line">    printDynamicMatrix(num3, row, col);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态静态数组传参数都是引用传递&lt;/p&gt;</summary>
    
    
    
    <category term="2022年8月" scheme="http://yoursite.com/categories/2022%E5%B9%B48%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树(剑指 Offer 07. 重建二叉树)</title>
    <link href="http://yoursite.com/2022/07/14/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91)/"/>
    <id>http://yoursite.com/2022/07/14/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91)/</id>
    <published>2022-07-14T06:12:12.000Z</published>
    <updated>2022-07-14T10:06:12.239Z</updated>
    
    <content type="html"><![CDATA[<p>剑指 Offer 07. 重建二叉树</p><span id="more"></span><p>[TOC]</p><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p>示例 1:</p><pre><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p>示例 2:</p><pre><code>输入: preorder = [-1], inorder = [-1]输出: [-1]</code></pre><p>提示:</p><pre><code>1 &lt;= preorder.length &lt;= 3000inorder.length == preorder.length-3000 &lt;= preorder[i], inorder[i] &lt;= 3000preorder 和 inorder 均 无重复 元素inorder 均出现在 preorderpreorder 保证 为二叉树的前序遍历序列inorder 保证 为二叉树的中序遍历序列</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二叉树前序遍历的顺序为：</p><p>先遍历根节点；<br>随后递归地遍历左子树；<br>最后递归地遍历右子树。<br>二叉树中序遍历的顺序为：</p><p>先递归地遍历左子树；<br>随后遍历根节点；<br>最后递归地遍历右子树。<br>在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于任意一颗树而言，前序遍历的形式总是</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)的时间对根节点进行定位了</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, int&gt; index;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 前序遍历中的第一个节点就是根节点</span><br><span class="line">        int preorder_root = preorder_left;</span><br><span class="line">        // 在中序遍历中定位根节点</span><br><span class="line">        int inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        </span><br><span class="line">        // 先把根节点建立出来</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[preorder_root]);</span><br><span class="line">        // 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        // 递归地构造左子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        // 递归地构造右子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        int n = preorder.size();</span><br><span class="line">        // 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 前序遍历中的第一个节点就是根节点</span><br><span class="line">        int preorder_root = preorder_left;</span><br><span class="line">        // 在中序遍历中定位根节点</span><br><span class="line">        int inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">        </span><br><span class="line">        // 先把根节点建立出来</span><br><span class="line">        TreeNode root = new TreeNode(preorder[preorder_root]);</span><br><span class="line">        // 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        // 递归地构造左子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        // 递归地构造右子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        int n = preorder.length;</span><br><span class="line">        // 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        indexMap = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:</span><br><span class="line">        def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int):</span><br><span class="line">            if preorder_left &gt; preorder_right:</span><br><span class="line">                return None</span><br><span class="line">            </span><br><span class="line">            # 前序遍历中的第一个节点就是根节点</span><br><span class="line">            preorder_root = preorder_left</span><br><span class="line">            # 在中序遍历中定位根节点</span><br><span class="line">            inorder_root = index[preorder[preorder_root]]</span><br><span class="line">            </span><br><span class="line">            # 先把根节点建立出来</span><br><span class="line">            root = TreeNode(preorder[preorder_root])</span><br><span class="line">            # 得到左子树中的节点数目</span><br><span class="line">            size_left_subtree = inorder_root - inorder_left</span><br><span class="line">            # 递归地构造左子树，并连接到根节点</span><br><span class="line">            # 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">            root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1)</span><br><span class="line">            # 递归地构造右子树，并连接到根节点</span><br><span class="line">            # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">            root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right)</span><br><span class="line">            return root</span><br><span class="line">        </span><br><span class="line">        n = len(preorder)</span><br><span class="line">        # 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        index = &#123;element: i for i, element in enumerate(inorder)&#125;</span><br><span class="line">        return myBuildTree(0, n - 1, 0, n - 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func buildTree(preorder []int, inorder []int) *TreeNode &#123;</span><br><span class="line">    if len(preorder) == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;preorder[0], nil, nil&#125;</span><br><span class="line">    i := 0</span><br><span class="line">    for ; i &lt; len(inorder); i++ &#123;</span><br><span class="line">        if inorder[i] == preorder[0] &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left = buildTree(preorder[1:len(inorder[:i])+1], inorder[:i])</span><br><span class="line">    root.Right = buildTree(preorder[len(inorder[:i])+1:], inorder[i+1:])</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是树中的节点个数。<br>空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及<br>O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</p><h1 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>迭代法是一种非常巧妙的实现方法。</p><p>对于前序遍历中的任意两个连续节点<br>u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：<br>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；</p><p>u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果<br>u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果<br>u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点 ua ，那么<br>v 就是 ua  的右儿子。</p><p>第二种关系看上去有些复杂。我们举一个例子来说明其正确性，并在例子中给出我们的迭代算法。</p><p>我们以树</p><pre><code>        3       / \      9  20     /  /  \    8  15   7   / \  5  10 /4</code></pre><p>为例，它的前序遍历和中序遍历分别为</p><p>preorder &#x3D; [3, 9, 8, 5, 4, 10, 20, 15, 7]<br>inorder &#x3D; [4, 5, 8, 10, 9, 3, 15, 20, 7]</p><p>我们用一个栈 stack 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 index 指向中序遍历的某个位置，初始值为 0。index 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p><p>首先我们将根节点 3 入栈，再初始化 index 所指向的节点为 4，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p><p>我们遍历 9。9 一定是栈顶节点 3 的左儿子。我们使用反证法，假设 9 是 3 的右儿子，那么 3 没有左儿子，index 应该恰好指向 3，但实际上为 4，因此产生了矛盾。所以我们将 9 作为 3 的左儿子，并将 9 入栈。</p><p>stack &#x3D; [3, 9]<br>index -&gt; inorder[0] &#x3D; 4</p><p>我们遍历 8，5 和 4。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p><p>stack &#x3D; [3, 9, 8, 5, 4]<br>index -&gt; inorder[0] &#x3D; 4</p><p>我们遍历 10，这时情况就不一样了。我们发现 index 恰好指向当前的栈顶节点 4，也就是说 4 没有左儿子，那么 10 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。</p><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p><p>因此我们可以把 index 不断向右移动，并与栈顶节点进行比较。如果 index 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 index 增加 1 并弹出栈顶节点，直到 index 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 x 就是 10 的双亲节点，这是因为 10 出现在了 x 与 x 在栈中的下一个节点的中序遍历之间，因此 10 就是 x 的右儿子。</p><p>回到我们的例子，我们会依次从栈顶弹出 4，5 和 8，并且将 index 向右移动了三次。我们将 10 作为最后弹出的节点 8 的右儿子，并将 10 入栈。</p><p>stack &#x3D; [3, 9, 10]<br>index -&gt; inorder[3] &#x3D; 10</p><p>我们遍历 20。同理，index 恰好指向当前栈顶节点 10，那么我们会依次从栈顶弹出 10，9 和 3，并且将 index 向右移动了三次。我们将 20 作为最后弹出的节点 3 的右儿子，并将 20 入栈。</p><p>stack &#x3D; [20]<br>index -&gt; inorder[6] &#x3D; 15</p><p>我们遍历 15，将 15 作为栈顶节点 20 的左儿子，并将 15 入栈。</p><p>stack &#x3D; [20, 15]<br>index -&gt; inorder[6] &#x3D; 15</p><p>我们遍历 7。index 恰好指向当前栈顶节点 15，那么我们会依次从栈顶弹出 15 和 20，并且将 index 向右移动了两次。我们将 7 作为最后弹出的节点 20 的右儿子，并将 7 入栈。</p><p>stack &#x3D; [7]<br>index -&gt; inorder[8] &#x3D; 7</p><p>此时遍历结束，我们就构造出了正确的二叉树。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>我们归纳出上述例子中的算法流程：</p><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p><p>无论是哪一种情况，我们最后都将当前的节点入栈。<br>最后得到的二叉树即为答案。</p><details>    <summary>C++</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        if (!preorder.size()) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[0]);</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        int inorderIndex = 0;</span><br><span class="line">        for (int i = 1; i &lt; preorder.size(); ++i) &#123;</span><br><span class="line">            int preorderVal = preorder[i];</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            if (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;left = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    ++inorderIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;right = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if (preorder == null || preorder.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = new TreeNode(preorder[0]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        int inorderIndex = 0;</span><br><span class="line">        for (int i = 1; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            int preorderVal = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            if (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left = new TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = new TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:</span><br><span class="line">        if not preorder:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        root = TreeNode(preorder[0])</span><br><span class="line">        stack = [root]</span><br><span class="line">        inorderIndex = 0</span><br><span class="line">        for i in range(1, len(preorder)):</span><br><span class="line">            preorderVal = preorder[i]</span><br><span class="line">            node = stack[-1]</span><br><span class="line">            if node.val != inorder[inorderIndex]:</span><br><span class="line">                node.left = TreeNode(preorderVal)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            else:</span><br><span class="line">                while stack and stack[-1].val == inorder[inorderIndex]:</span><br><span class="line">                    node = stack.pop()</span><br><span class="line">                    inorderIndex += 1</span><br><span class="line">                node.right = TreeNode(preorderVal)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">func buildTree(preorder []int, inorder []int) *TreeNode &#123;</span><br><span class="line">    if len(preorder) == 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;preorder[0], nil, nil&#125;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    stack = append(stack, root)</span><br><span class="line">    var inorderIndex int</span><br><span class="line">    for i := 1; i &lt; len(preorder); i++ &#123;</span><br><span class="line">        preorderVal := preorder[i]</span><br><span class="line">        node := stack[len(stack)-1]</span><br><span class="line">        if node.Val != inorder[inorderIndex] &#123;</span><br><span class="line">            node.Left = &amp;TreeNode&#123;preorderVal, nil, nil&#125;</span><br><span class="line">            stack = append(stack, node.Left)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for len(stack) != 0 &amp;&amp; stack[len(stack)-1].Val == inorder[inorderIndex] &#123;</span><br><span class="line">                node = stack[len(stack)-1]</span><br><span class="line">                stack = stack[:len(stack)-1]</span><br><span class="line">                inorderIndex++</span><br><span class="line">            &#125;</span><br><span class="line">            node.Right = &amp;TreeNode&#123;preorderVal, nil, nil&#125;</span><br><span class="line">            stack = append(stack, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：<br>O(n)，其中 n 是树中的节点个数。</p><p>空间复杂度：<br>O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里h&lt;n，所以（在最坏情况下）总空间复杂度为 O(n)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;剑指 Offer 07. 重建二叉树&lt;/p&gt;</summary>
    
    
    
    <category term="2022年7月" scheme="http://yoursite.com/categories/2022%E5%B9%B47%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/06/13/Flask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/06/13/Flask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-13T10:00:12.000Z</published>
    <updated>2022-07-07T09:03:20.135Z</updated>
    
    <content type="html"><![CDATA[<p>Flask学习笔记</p><span id="more"></span><p>[TOC]</p><p>学习教程参考<a href="https://www.w3cschool.cn/flask/flask_application.html">^1</a></p><h1 id="命令行启动notebook"><a href="#命令行启动notebook" class="headerlink" title="命令行启动notebook"></a>命令行启动notebook</h1><p>python3 -m IPython notebook</p><p>-m参数 “mod”是“module”的缩写，即“-m”选项后面的内容是 module（模块），其作用是把模块当成脚本来运行。<a href="https://zhuanlan.zhihu.com/p/91120727">^4</a></p><h1 id="内置变量：name"><a href="#内置变量：name" class="headerlink" title="内置变量：name"></a>内置变量：<strong>name</strong></h1><h2 id="不同情况下的-name-的值-2"><a href="#不同情况下的-name-的值-2" class="headerlink" title="不同情况下的 name 的值^2"></a>不同情况下的 <strong>name</strong> 的值<a href="https://zhuanlan.zhihu.com/p/157439994">^2</a></h2><p>首先我们需要知道 <strong>name</strong> 在不同情况下会有不同值，它的值取决于我们是如何执行脚本的.</p><p>有时候，我们用 Python 写了一个脚本，当我们既希望这个脚本可以单独运行，同样希望它可以在其他的脚本中发挥作用. 这个时候就需要考虑使用 <strong>name</strong> 了. </p><h1 id="运行遇到的错误及解决方案"><a href="#运行遇到的错误及解决方案" class="headerlink" title="运行遇到的错误及解决方案"></a>运行遇到的错误及解决方案</h1><h2 id="zmq-error-ZMQError-Address-already-in-use-3"><a href="#zmq-error-ZMQError-Address-already-in-use-3" class="headerlink" title="zmq.error.ZMQError: Address already in use ^3"></a>zmq.error.ZMQError: Address already in use <a href="https://www.cnblogs.com/shengulong/p/8207179.html">^3</a></h2><pre><code>app.run(debug = True)</code></pre><p>开启debug模式后端口报被占用</p><p>之前用的是<a href="http://localhost:5000/">http://localhost:5000</a></p><p>sudo lsof -i:5000</p><p>sudo kill PID</p><h2 id="查找指定名称（例如python）的进程并显示进程详细信息"><a href="#查找指定名称（例如python）的进程并显示进程详细信息" class="headerlink" title="查找指定名称（例如python）的进程并显示进程详细信息"></a>查找指定名称（例如python）的进程并显示进程详细信息</h2><p>ps -ef  | grep python</p><p>但是如果关掉flask的debug模式，就没有问题</p><p>6、原因是：flask的debug模式会额外开启一个进程，这个进程负责监控代码是否发生变化，如果发生变化，会自动重启应用，使新修改代码立即自动生效；因此我猜想，是这个进程破坏了rpc服务的启动。</p><p>DEBUG模式下flask多开一个线程来监视项目的变化。</p><p>The first thing it does is start the main function in a new thread so it can monitor &gt;the source files and restart the thread when they change.</p><p>参考自这篇文章<a href="http://stackoverflow.com/questions/9276078/whats-the-right-approach-for-calling-functions-after-a-flask-app-is-run%E3%80%82">http://stackoverflow.com/questions/9276078/whats-the-right-approach-for-calling-functions-after-a-flask-app-is-run。</a></p><p>如果你想要避免加载两次，应该设置</p><pre><code>app.run(debug=True, use_reloader=False)</code></pre><h2 id="文件上传报错：FileNotFoundError-Errno-2-No-such-file-or-directory"><a href="#文件上传报错：FileNotFoundError-Errno-2-No-such-file-or-directory" class="headerlink" title="文件上传报错：FileNotFoundError: [Errno 2] No such file or directory:"></a>文件上传报错：FileNotFoundError: [Errno 2] No such file or directory:</h2><p>根据代码内容，需要在代码的根目录下创建一个文件夹upload才能保存文件</p><h2 id="Flask-WTF-ImportError-cannot-import-name-‘ContactForm’-from-‘forms’"><a href="#Flask-WTF-ImportError-cannot-import-name-‘ContactForm’-from-‘forms’" class="headerlink" title="Flask WTF : ImportError: cannot import name ‘ContactForm’ from ‘forms’"></a>Flask WTF : ImportError: cannot import name ‘ContactForm’ from ‘forms’</h2><p>这个ContactForm是自己建的forms.py文件中的类</p><h2 id="ImportError-cannot-import-name-‘TextField’-from-‘wtforms’"><a href="#ImportError-cannot-import-name-‘TextField’-from-‘wtforms’" class="headerlink" title="ImportError: cannot import name ‘TextField’ from ‘wtforms’"></a>ImportError: cannot import name ‘TextField’ from ‘wtforms’</h2><p>原因是版本更新问题</p><pre><code>from wtforms import StringField</code></pre><p>使用StringField即可</p><h2 id="AttributeError-module-‘wtforms-validators’-has-no-attribute-‘Required’"><a href="#AttributeError-module-‘wtforms-validators’-has-no-attribute-‘Required’" class="headerlink" title="AttributeError: module ‘wtforms.validators’ has no attribute ‘Required’"></a>AttributeError: module ‘wtforms.validators’ has no attribute ‘Required’</h2><p>looks like wtforms.validators split the Required into DataRequired and InputRequired in version version 1.0.2</p><p>新版本将Required换成InputRequired</p><h2 id="Install-‘email-validator’-for-email-validation-support"><a href="#Install-‘email-validator’-for-email-validation-support" class="headerlink" title="Install ‘email_validator’ for email validation support."></a>Install ‘email_validator’ for email validation support.</h2><p>还是版本兼容问题</p><h2 id="TypeError-init-takes-1-positional-argument-but-5-were-given"><a href="#TypeError-init-takes-1-positional-argument-but-5-were-given" class="headerlink" title="TypeError: init() takes 1 positional argument but 5 were given"></a>TypeError: <strong>init</strong>() takes 1 positional argument but 5 were given</h2><p>在 Flask SQLAlchemy中 students 的class初始化函数如下：</p><pre><code>def __init__(self, name, city, addr,pin):</code></pre><p>调用的时候赋值：</p><pre><code> student = students(request.form[&#39;name&#39;], request.form[&#39;city&#39;],    request.form[&#39;addr&#39;], request.form[&#39;pin&#39;])</code></pre><p>报错：</p><p>改成下列调用方式即可</p><pre><code>student = students(name = request.form[&#39;name&#39;], city = request.form[&#39;city&#39;],                           addr = request.form[&#39;addr&#39;], pin = request.form[&#39;pin&#39;])</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flask学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="2022年6月" scheme="http://yoursite.com/categories/2022%E5%B9%B46%E6%9C%88/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>从文本中读取数据</title>
    <link href="http://yoursite.com/2022/05/22/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2022/05/22/%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/</id>
    <published>2022-05-22T00:12:12.000Z</published>
    <updated>2022-08-08T02:17:07.249Z</updated>
    
    <content type="html"><![CDATA[<p>从文本中读取数据</p><span id="more"></span><p>[TOC]</p><p>一些比赛遇到需要从文本中读取输入数据,读取方式如下</p><h1 id="fstream读取"><a href="#fstream读取" class="headerlink" title="fstream读取"></a>fstream读取</h1><details>    <summary>从文本中读取文件</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    ifstream inFile(&quot;in.txt&quot;);</span><br><span class="line">    ofstream outFile(&quot;out.txt&quot;);</span><br><span class="line">    if (!inFile.is_open())&#123;</span><br><span class="line">       cerr &lt;&lt; &quot;open file failed!&quot; &lt;&lt; endl;</span><br><span class="line">       exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    int num=0;</span><br><span class="line">    string str;</span><br><span class="line">    inFile&gt;&gt;num;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    outFile&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    while(!inFile.eof())&#123;</span><br><span class="line">        getline(inFile, str);</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        outFile&lt;&lt;str;</span><br><span class="line">    &#125;</span><br><span class="line">    inFile.close();</span><br><span class="line">    outFile.close();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h1 id="修改配置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory"><a href="#修改配置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory" class="headerlink" title="修改配置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory"></a>修改配置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory</h1><p>但是在Xcode中一开始无法读入，发现问题是因为没有配置路径<a href="http://stackoverflow.com/questions/23438393/new-to-xcode-cant-open-files-in-c">^1</a></p><p>Put your .txt files in the same directory where your main.cpp file is (or anywhere you like).</p><p>In Xcode go to Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top) </p><p>Down under Options check “Use custom working directory” and set it to the directory where you .txt files are located. </p><p>To work with the files, you will have to specify just file names, e.g. in_file.open(“inputFile.txt”); no path is necessary.</p><details>    <summary>Java</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Scanner scanner = new Scanner(new File(System.getProperty(&quot;user.dir&quot;) + &quot;/src/in.txt&quot;));</span><br><span class="line">       while (scanner.hasNext()) &#123;</span><br><span class="line">           String number = scanner.nextLine();</span><br><span class="line">           Integer num = Integer.valueOf(number);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">with open(&#x27;number.txt&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        f.write(str(random.randint(1, 10))+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">L = []</span><br><span class="line">with open(&#x27;number.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    read_data = f.read()</span><br><span class="line">    strs = read_data.split();</span><br><span class="line">    for i in strs:</span><br><span class="line">        L.append(int(i))</span><br><span class="line">    L.sort()</span><br><span class="line">    print(L)</span><br><span class="line">     </span><br></pre></td></tr></table></figure></details><h1 id="Mac上无法读取data-in文件，而改成data-in就可以读取"><a href="#Mac上无法读取data-in文件，而改成data-in就可以读取" class="headerlink" title="Mac上无法读取data.in文件，而改成data.in就可以读取"></a>Mac上无法读取data.in文件，而改成data.in就可以读取</h1><p>首先需要确认data.in文件后缀是否为txt，打开文件简介，要在简介里才能看到真实的扩展名<br>看文件种类也可以区分，如果是txt后缀文件种类是纯文本文档，<br>如果后缀就是为.in或.out文件种类就是文本编辑文档</p><p>但修改后发现还是不行，同样的代码在windows下用VS可以读取，但在Mac下用Xcode无法读取.in文件</p><h2 id="最后发现如果先用代码创建data-in然后再读取就可以"><a href="#最后发现如果先用代码创建data-in然后再读取就可以" class="headerlink" title="最后发现如果先用代码创建data.in然后再读取就可以"></a>最后发现如果先用代码创建data.in然后再读取就可以</h2><p>手工创建就不行，可能还是手动创建的文本格式不对。用data.out复制改后缀为data.in一开始也不行，后来可以了。</p><h1 id="Visual-Studio设置文本输入输出"><a href="#Visual-Studio设置文本输入输出" class="headerlink" title="Visual Studio设置文本输入输出"></a>Visual Studio设置文本输入输出</h1><p>打开解决方案管理器然后在管理方案那里右键点击，选择属性<br>然后选择通配属性，里面的命令行设置为&lt;input.txt表示把文件input.txt作为我们运行程序的输入流。 </p><blockquote><p>output.txt表示把文件output.txt作为程序的输出流。</p></blockquote><h1 id="Visual-Studio一个项目下建立多个源代码"><a href="#Visual-Studio一个项目下建立多个源代码" class="headerlink" title="Visual Studio一个项目下建立多个源代码"></a>Visual Studio一个项目下建立多个源代码</h1><p>在不用包括main函数的代码，右键属性-》常规-》从生成中排除-》选择是<br>就不会报错了</p><h1 id="XCode一个项目下建立多个源代码"><a href="#XCode一个项目下建立多个源代码" class="headerlink" title="XCode一个项目下建立多个源代码"></a>XCode一个项目下建立多个源代码</h1><p>File-》New-》Target-》Command Line Tool</p><p>就可以新建，运行时选择中间上方选择当前的target目录就可以</p><h1 id="每次创建新的Target时都要设置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory，-不然无法读取新文件！！！"><a href="#每次创建新的Target时都要设置Product-gt-Scheme-gt-Edit-Scheme-gt-Run-test-on-the-right-gt-Options-middle-top-gt-Working-Directory，-不然无法读取新文件！！！" class="headerlink" title="每次创建新的Target时都要设置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory， 不然无法读取新文件！！！"></a>每次创建新的Target时都要设置Product &gt; Scheme &gt; Edit Scheme &gt; Run test (on the right) &gt; Options (middle top)-&gt;Working Directory， 不然无法读取新文件！！！</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;从文本中读取数据&lt;/p&gt;</summary>
    
    
    
    <category term="2022年5月" scheme="http://yoursite.com/categories/2022%E5%B9%B45%E6%9C%88/"/>
    
    
    <category term="fstream" scheme="http://yoursite.com/tags/fstream/"/>
    
  </entry>
  
  <entry>
    <title>399. 除法求值</title>
    <link href="http://yoursite.com/2022/03/09/399.%20%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>http://yoursite.com/2022/03/09/399.%20%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</id>
    <published>2022-03-09T13:12:12.000Z</published>
    <updated>2022-03-09T15:02:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>返回 所有除法求值问题的答案</p><span id="more"></span><p>[TOC]</p><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] &#x3D; [Ai, Bi] 和 values[i] 共同表示等式 Ai &#x2F; Bi &#x3D; values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] &#x3D; [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj &#x2F; Dj &#x3D; ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p>示例 1：</p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]解释：条件：a / b = 2.0, b / c = 3.0问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</code></pre><p>示例 2：</p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]输出：[3.75000,0.40000,5.00000,0.20000]</code></pre><p>示例 3：</p><pre><code>输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]输出：[0.50000,2.00000,-1.00000,-1.00000]</code></pre><p>提示：</p><pre><code>1 &lt;= equations.length &lt;= 20equations[i].length == 21 &lt;= Ai.length, Bi.length &lt;= 5values.length == equations.length0.0 &lt; values[i] &lt;= 20.01 &lt;= queries.length &lt;= 20queries[i].length == 21 &lt;= Cj.length, Dj.length &lt;= 5Ai, Bi, Cj, Dj 由小写英文字母与数字组成</code></pre><p>这道题是在「力扣」第 990 题（等式方程的可满足性）的基础上，在变量和变量之间有了倍数关系。由于 变量之间的倍数关系具有传递性，处理有传递性关系的问题，可以使用「并查集」，我们需要在并查集的「合并」与「查询」操作中 维护这些变量之间的倍数关系。</p><p>说明：请大家注意看一下题目中的「注意」和「数据范围」，例如：每个 Ai 或 Bi 是一个表示单个变量的字符串。所以用例 equation &#x3D; [“ab”, “cd”] ，这里的 ab 视为一个变量，不表示 a * b。如果面试中遇到这样的问题，一定要和面试官确认清楚题目的条件。还有 1 &lt;&#x3D; equations.length &lt;&#x3D; 20 和 values[i] &gt; 0.0 可以避免一些特殊情况的讨论。</p><h1 id="方法：并查集-1"><a href="#方法：并查集-1" class="headerlink" title="方法：并查集^1"></a>方法：并查集<a href="https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/">^1</a></h1><p>分析示例 1：</p><ul><li>a &#x2F; b &#x3D; 2.0 说明 a&#x3D;2b， a 和 b 在同一个集合中；</li><li>b &#x2F; c &#x3D; 3.0 说明 b&#x3D;3c ，b 和 c 在同一个集合中。</li></ul><p>求a&#x2F;c和b&#x2F;a</p><p>我们计算了两个结果，不难知道：可以将题目给出的 equation 中的两个变量所在的集合进行「合并」，同在一个集合中的两个变量就可以通过某种方式计算出它们的比值。具体来说，可以把 不同的变量的比值转换成为相同的变量的比值，这样在做除法的时候就可以消去相同的变量，然后再计算转换成相同变量以后的系数的比值，就是题目要求的结果。统一了比较的标准，可以以 O(1) 的时间复杂度完成计算。</p><p>如果两个变量不在同一个集合中， 返回 −1.0。并且根据题目的意思，如果两个变量中 至少有一个 变量没有出现在所有 equations 出现的字符集合中，也返回 −1.0。</p><h2 id="构建有向图"><a href="#构建有向图" class="headerlink" title="构建有向图"></a>构建有向图</h2><p>通过例 1 的分析，我们就知道了，题目给出的 equations 和 values 可以表示成一个图，equations 中出现的变量就是图的顶点，「分子」于「分母」的比值可以表示成一个有向关系（因为「分子」和「分母」是有序的，不可以对换），并且这个图是一个带权图，values 就是对应的有向边的权值。例 1 中给出的 equations 和 values 表示的「图形表示」、「数学表示」和「代码表示」如下表所示。其中 parent[a] &#x3D; b 表示：结点 a 的（直接）父亲结点是 b，与之对应的有向边的权重，记为 weight[a] &#x3D; 2.0，即 weight[a] 表示结点 a 到它的 直接父亲结点 的有向边的权重。</p><h2 id="「统一变量」与「路径压缩」的关系"><a href="#「统一变量」与「路径压缩」的关系" class="headerlink" title="「统一变量」与「路径压缩」的关系"></a>「统一变量」与「路径压缩」的关系</h2><p>刚刚在分析例 1 的过程中，提到了：可以把一个一个 query 中的不同变量转换成 同一个变量，这样在计算 query 的时候就可以以 O(1) 的时间复杂度计算出结果，在「并查集」的一个优化技巧中，「路径压缩」就恰好符合了这样的应用场景。</p><p>为了避免并查集所表示的树形结构高度过高，影响查询性能。「路径压缩」就是针对树的高度的优化。「路径压缩」的效果是：在查询一个结点 a 的根结点同时，把结点 a 到根结点的沿途所有结点的父亲结点都指向根结点。如下图所示，除了根结点以外，所有的结点的父亲结点都指向了根结点。特别地，也可以认为根结点的父亲结点就是根结点自己。如下国所示：路径压缩前后，并查集所表示的两棵树形结构等价，路径压缩以后的树的高度为 2，查询性能最好。</p><p>由于有「路径压缩」的优化，两个同在一个连通分量中的不同的变量，它们分别到根结点（父亲结点）的权值的比值，就是题目的要求的结果。</p><h2 id="如何在「查询」操作的「路径压缩」优化中维护权值变化"><a href="#如何在「查询」操作的「路径压缩」优化中维护权值变化" class="headerlink" title="如何在「查询」操作的「路径压缩」优化中维护权值变化"></a>如何在「查询」操作的「路径压缩」优化中维护权值变化</h2><p>如下图所示，我们在结点 a 执行一次「查询」操作。路径压缩会先一层一层向上先找到根结点 d，然后依次把 c、b 、a 的父亲结点指向根结点 d。</p><ul><li>c 的父亲结点已经是根结点了，它的权值不用更改；</li><li>b 的父亲结点要修改成根结点，它的权值就是从当前结点到根结点经过的所有有向边的权值的乘积，因此是 3.0 乘以 4.0 也就是 12.0；</li><li>a 的父亲结点要修改成根结点，它的权值就是依然是从当前结点到根结点经过的所有有向边的权值的乘积，但是我们 没有必要把这三条有向边的权值乘起来，这是因为 b 到 c，c 到 d 这两条有向边的权值的乘积，我们在把 b 指向 d 的时候已经计算出来了。因此，a 到根结点的权值就等于 b 到根结点 d 的新的权值乘以 a 到 b 的原来的有向边的权值。</li></ul><h2 id="如何在「合并」操作中维护权值的变化"><a href="#如何在「合并」操作中维护权值的变化" class="headerlink" title="如何在「合并」操作中维护权值的变化"></a>如何在「合并」操作中维护权值的变化</h2><p> 「合并」操作基于这样一个 很重要的前提：我们将要合并的两棵树的高度最多为 2，换句话说两棵树都必需是「路径压缩」以后的效果，两棵树的叶子结点到根结点最多只需要经过一条有向边。</p><p>例如已知  a&#x2F;b&#x3D;3.0， d&#x2F;c&#x3D;4.0 ，又已知  a&#x2F;d&#x3D; &#x3D;6.0 ，现在合并结点 a 和 d 所在的集合，其实就是把 a 的根结点 b 指向 d 的根结 c，那么如何计算 b 指向 c 的这条有向边的权重呢？</p><p>根据 a 经过 b 可以到达 c，a 经过 d 也可以到达 c，因此 两条路径上的有向边的权值的乘积是一定相等的。设 b 到 c 的权值为 x，那么 3.0⋅x&#x3D;6.0⋅4.0 ，得 x&#x3D;8.0。</p><h2 id="一个容易忽略的细节"><a href="#一个容易忽略的细节" class="headerlink" title="一个容易忽略的细节"></a>一个容易忽略的细节</h2><p>接下来还有一个小的细节问题：在合并以后，产生了一棵高度为 3 的树，那么我们在执行查询的时候，例如下图展示的绿色结点和黄色结点，绿色结点并不直接指向根结点，在计算这两个变量的比值的时候，计算边的权值的比值得到的结果是不对的。</p><p>但其实不用担心这个问题，并查集的「查询」操作会执行「路径压缩」，所以真正在计算两个变量的权值的时候，绿色结点已经指向了根结点，和黄色结点的根结点相同。因此可以用它们指向根结点的有向边的权值的比值作为两个变量的比值。</p><p>我们通过这个细节向大家强调：一边查询一边修改结点指向是并查集的特色。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        int equationsSize = equations.size();</span><br><span class="line"></span><br><span class="line">        UnionFind unionFind = new UnionFind(2 * equationsSize);</span><br><span class="line">        // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span><br><span class="line">        Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(2 * equationsSize);</span><br><span class="line">        int id = 0;</span><br><span class="line">        for (int i = 0; i &lt; equationsSize; i++) &#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            String var1 = equation.get(0);</span><br><span class="line">            String var2 = equation.get(1);</span><br><span class="line"></span><br><span class="line">            if (!hashMap.containsKey(var1)) &#123;</span><br><span class="line">                hashMap.put(var1, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!hashMap.containsKey(var2)) &#123;</span><br><span class="line">                hashMap.put(var2, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第 2 步：做查询</span><br><span class="line">        int queriesSize = queries.size();</span><br><span class="line">        double[] res = new double[queriesSize];</span><br><span class="line">        for (int i = 0; i &lt; queriesSize; i++) &#123;</span><br><span class="line">            String var1 = queries.get(i).get(0);</span><br><span class="line">            String var2 = queries.get(i).get(1);</span><br><span class="line"></span><br><span class="line">            Integer id1 = hashMap.get(var1);</span><br><span class="line">            Integer id2 = hashMap.get(var2);</span><br><span class="line"></span><br><span class="line">            if (id1 == null || id2 == null) &#123;</span><br><span class="line">                res[i] = -1.0d;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res[i] = unionFind.isConnected(id1, id2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class UnionFind &#123;</span><br><span class="line"></span><br><span class="line">        private int[] parent;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 指向的父结点的权值</span><br><span class="line">         */</span><br><span class="line">        private double[] weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public UnionFind(int n) &#123;</span><br><span class="line">            this.parent = new int[n];</span><br><span class="line">            this.weight = new double[n];</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                weight[i] = 1.0d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void union(int x, int y, double value) &#123;</span><br><span class="line">            int rootX = find(x);</span><br><span class="line">            int rootY = find(y);</span><br><span class="line">            if (rootX == rootY) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">          // 关系式的推导请见「参考代码」下方的示意图</span><br><span class="line">            weight[rootX] = weight[y] * value / weight[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 路径压缩</span><br><span class="line">         *</span><br><span class="line">         * @param x</span><br><span class="line">         * @return 根结点的 id</span><br><span class="line">         */</span><br><span class="line">        public int find(int x) &#123;</span><br><span class="line">            if (x != parent[x]) &#123;</span><br><span class="line">                int origin = parent[x];</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">                weight[x] *= weight[origin];</span><br><span class="line">            &#125;</span><br><span class="line">            return parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public double isConnected(int x, int y) &#123;</span><br><span class="line">            int rootX = find(x);</span><br><span class="line">            int rootY = find(y);</span><br><span class="line">            if (rootX == rootY) &#123;</span><br><span class="line">                return weight[x] / weight[y];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return -1.0d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>说明：代码 weight[rootX] &#x3D; weight[y] * value &#x2F; weight[x]; 的推导过程，主要需要明白各个变量的含义，由两条路径有向边的权值乘积相等得到相等关系，然后做等价变换即可。</p><h1 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h1><p>时间复杂度：O((N+Q)logA)，</p><ul><li>构建并查集 O(NlogA) ，这里 N 为输入方程 equations 的长度，每一次执行合并操作的时间复杂度是 O(logA)，这里 A 是 equations 里不同字符的个数；</li><li>查询并查集 O(QlogA)，这里 Q 为查询数组 queries 的长度，每一次查询时执行「路径压缩」的时间复杂度是 O(logA)。</li></ul><p>空间复杂度：O(A)：创建字符与 id 的对应关系 hashMap 长度为 A，并查集底层使用的两个数组 parent 和 weight 存储每个变量的连通分量信息，parent 和 weight 的长度均为 A。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;返回 所有除法求值问题的答案&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
    <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
    <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
    <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>394. 字符串解码</title>
    <link href="http://yoursite.com/2022/03/09/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2022/03/09/394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</id>
    <published>2022-03-09T07:12:12.000Z</published>
    <updated>2022-03-09T07:11:33.114Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个经过编码的字符串，返回它解码后的字符串。</p><span id="more"></span><p>[TOC]</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例 1：</p><pre><code>输入：s = &quot;3[a]2[bc]&quot;输出：&quot;aaabcbc&quot;</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;3[a2[c]]&quot;输出：&quot;accaccacc&quot;</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;输出：&quot;abcabccdcdcdef&quot;</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;abc3[cd]xyz&quot;输出：&quot;abccdcdcdxyz&quot;</code></pre><h1 id="方法一：栈操作-1"><a href="#方法一：栈操作-1" class="headerlink" title="方法一：栈操作^1"></a>方法一：栈操作<a href="https://leetcode-cn.com/problems/decode-string/solution/zi-fu-chuan-jie-ma-by-leetcode-solution/">^1</a></h1><h2 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h2><p>本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：</p><ul><li>如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈</li><li>如果当前的字符为字母或者左括号，直接进栈</li><li>如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈</li></ul><p>重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：这里可以用不定长数组来模拟栈操作，方便从栈底向栈顶遍历。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string getDigits(string &amp;s, size_t &amp;ptr) &#123;</span><br><span class="line">        string ret = &quot;&quot;;</span><br><span class="line">        while (isdigit(s[ptr])) &#123;</span><br><span class="line">            ret.push_back(s[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getString(vector &lt;string&gt; &amp;v) &#123;</span><br><span class="line">        string ret;</span><br><span class="line">        for (const auto &amp;s: v) &#123;</span><br><span class="line">            ret += s;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        vector &lt;string&gt; stk;</span><br><span class="line">        size_t ptr = 0;</span><br><span class="line"></span><br><span class="line">        while (ptr &lt; s.size()) &#123;</span><br><span class="line">            char cur = s[ptr];</span><br><span class="line">            if (isdigit(cur)) &#123;</span><br><span class="line">                // 获取一个数字并进栈</span><br><span class="line">                string digits = getDigits(s, ptr);</span><br><span class="line">                stk.push_back(digits);</span><br><span class="line">            &#125; else if (isalpha(cur) || cur == &#x27;[&#x27;) &#123;</span><br><span class="line">                // 获取一个字母并进栈</span><br><span class="line">                stk.push_back(string(1, s[ptr++])); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                vector &lt;string&gt; sub;</span><br><span class="line">                while (stk.back() != &quot;[&quot;) &#123;</span><br><span class="line">                    sub.push_back(stk.back());</span><br><span class="line">                    stk.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(sub.begin(), sub.end());</span><br><span class="line">                // 左括号出栈</span><br><span class="line">                stk.pop_back();</span><br><span class="line">                // 此时栈顶为当前 sub 对应的字符串应该出现的次数</span><br><span class="line">                int repTime = stoi(stk.back()); </span><br><span class="line">                stk.pop_back();</span><br><span class="line">                string t, o = getString(sub);</span><br><span class="line">                // 构造字符串</span><br><span class="line">                while (repTime--) t += o; </span><br><span class="line">                // 将构造好的字符串入栈</span><br><span class="line">                stk.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getString(stk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int ptr;</span><br><span class="line"></span><br><span class="line">    public String decodeString(String s) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; stk = new LinkedList&lt;String&gt;();</span><br><span class="line">        ptr = 0;</span><br><span class="line"></span><br><span class="line">        while (ptr &lt; s.length()) &#123;</span><br><span class="line">            char cur = s.charAt(ptr);</span><br><span class="line">            if (Character.isDigit(cur)) &#123;</span><br><span class="line">                // 获取一个数字并进栈</span><br><span class="line">                String digits = getDigits(s);</span><br><span class="line">                stk.addLast(digits);</span><br><span class="line">            &#125; else if (Character.isLetter(cur) || cur == &#x27;[&#x27;) &#123;</span><br><span class="line">                // 获取一个字母并进栈</span><br><span class="line">                stk.addLast(String.valueOf(s.charAt(ptr++))); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                LinkedList&lt;String&gt; sub = new LinkedList&lt;String&gt;();</span><br><span class="line">                while (!&quot;[&quot;.equals(stk.peekLast())) &#123;</span><br><span class="line">                    sub.addLast(stk.removeLast());</span><br><span class="line">                &#125;</span><br><span class="line">                Collections.reverse(sub);</span><br><span class="line">                // 左括号出栈</span><br><span class="line">                stk.removeLast();</span><br><span class="line">                // 此时栈顶为当前 sub 对应的字符串应该出现的次数</span><br><span class="line">                int repTime = Integer.parseInt(stk.removeLast());</span><br><span class="line">                StringBuffer t = new StringBuffer();</span><br><span class="line">                String o = getString(sub);</span><br><span class="line">                // 构造字符串</span><br><span class="line">                while (repTime-- &gt; 0) &#123;</span><br><span class="line">                    t.append(o);</span><br><span class="line">                &#125;</span><br><span class="line">                // 将构造好的字符串入栈</span><br><span class="line">                stk.addLast(t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return getString(stk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDigits(String s) &#123;</span><br><span class="line">        StringBuffer ret = new StringBuffer();</span><br><span class="line">        while (Character.isDigit(s.charAt(ptr))) &#123;</span><br><span class="line">            ret.append(s.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString(LinkedList&lt;String&gt; v) &#123;</span><br><span class="line">        StringBuffer ret = new StringBuffer();</span><br><span class="line">        for (String s : v) &#123;</span><br><span class="line">            ret.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">func decodeString(s string) string &#123;</span><br><span class="line">    stk := []string&#123;&#125;</span><br><span class="line">    ptr := 0</span><br><span class="line">    for ptr &lt; len(s) &#123;</span><br><span class="line">        cur := s[ptr]</span><br><span class="line">        if cur &gt;= &#x27;0&#x27; &amp;&amp; cur &lt;= &#x27;9&#x27; &#123;</span><br><span class="line">            digits := getDigits(s, &amp;ptr)</span><br><span class="line">            stk = append(stk, digits)</span><br><span class="line">        &#125; else if (cur &gt;= &#x27;a&#x27; &amp;&amp; cur &lt;= &#x27;z&#x27; || cur &gt;= &#x27;A&#x27; &amp;&amp; cur &lt;= &#x27;Z&#x27;) || cur == &#x27;[&#x27; &#123;</span><br><span class="line">            stk = append(stk, string(cur))</span><br><span class="line">            ptr++</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ptr++</span><br><span class="line">            sub := []string&#123;&#125;</span><br><span class="line">            for stk[len(stk)-1] != &quot;[&quot; &#123;</span><br><span class="line">                sub = append(sub, stk[len(stk)-1])</span><br><span class="line">                stk = stk[:len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            for i := 0; i &lt; len(sub)/2; i++ &#123;</span><br><span class="line">                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = stk[:len(stk)-1]</span><br><span class="line">            repTime, _ := strconv.Atoi(stk[len(stk)-1])</span><br><span class="line">            stk = stk[:len(stk)-1]</span><br><span class="line">            t := strings.Repeat(getString(sub), repTime)</span><br><span class="line">            stk = append(stk, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getString(stk)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getDigits(s string, ptr *int) string &#123;</span><br><span class="line">    ret := &quot;&quot;</span><br><span class="line">    for ; s[*ptr] &gt;= &#x27;0&#x27; &amp;&amp; s[*ptr] &lt;= &#x27;9&#x27;; *ptr++ &#123;</span><br><span class="line">        ret += string(s[*ptr])</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getString(v []string) string &#123;</span><br><span class="line">    ret := &quot;&quot;</span><br><span class="line">    for _, s := range v &#123;</span><br><span class="line">        ret += s</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：记解码后得出的字符串长度为 S，除了遍历一次原字符串 s，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S)。</p><p>空间复杂度：记解码后得出的字符串长度为 S，这里用栈维护 TOKEN，栈的总大小最终与 S 相同，故渐进空间复杂度为 O(S)。</p><h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><h2 id="思路和算法-1"><a href="#思路和算法-1" class="headerlink" title="思路和算法"></a>思路和算法</h2><p>我们也可以用递归来解决这个问题，从左向右解析字符串：</p><p>如果当前位置为数字位，那么后面一定包含一个用方括号表示的字符串，即属于这种情况：k[…]：<br>我们可以先解析出一个数字，然后解析到了左括号，递归向下解析后面的内容，遇到对应的右括号就返回，此时我们可以根据解析出的数字 x 解析出的括号里的字符串s′构造出一个新的字符串 x×s′</p><p>我们把 k[…] 解析结束后，再次调用递归函数，解析右括号右边的内容。<br>如果当前位置是字母位，那么我们直接解析当前这个字母，然后递归向下解析这个字母后面的内容。<br>如果觉得这里讲的比较抽象，可以结合代码理解一下这个过程。</p><p>下面我们可以来讲讲这样做的依据，涉及到《编译原理》相关内容，感兴趣的同学可以参考阅读。 根据题目的定义，我们可以推导出这样的巴科斯范式（BNF）：</p><pre><code>String-&gt;Digit [String]String|Alpha String|StringDigits-&gt;Digit Digits |DigitsAlpha-&gt;a|...|z|A|...|ZDigit-&gt;0|...|9</code></pre><ul><li>Digit 表示十进制数位，可能的取值是 0 到 9 之间的整数</li><li>Alpha 表示字母，可能的取值是大小写字母的集合，共 52 个</li><li>Digit 表示一个整数，它的组成是 Digit 出现一次或多次</li><li>String 代表一个代解析的字符串，它可能有三种构成，如 BNF 所示</li><li>epsilon 表示空串，即没有任何子字符</li></ul><p> 由于 Digits 和 Alpha 构成简单，很容易进行词法分析，我们把它他们看作独立的 TOKEN。那么此时的非终结符有 String，终结符有 Digits、Alpha 和 ϵ，我们可以根据非终结符和 FOLLOW 集构造出这样的预测分析表：</p><p>可见不含多重定义的项，为 LL(1) 文法，即：</p><ul><li>从左向右分析（Left-to-right-parse）</li><li>最左推导（Leftmost-derivation）</li><li>超前查看一个符号（1-symbol lookahead）<br>它决定了我们从左向右遍历这个字符串，每次只判断当前最左边的一个字符的分析方法是正确的。</li></ul><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string src; </span><br><span class="line">    size_t ptr;</span><br><span class="line"></span><br><span class="line">    int getDigits() &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        while (ptr &lt; src.size() &amp;&amp; isdigit(src[ptr])) &#123;</span><br><span class="line">            ret = ret * 10 + src[ptr++] - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getString() &#123;</span><br><span class="line">        if (ptr == src.size() || src[ptr] == &#x27;]&#x27;) &#123;</span><br><span class="line">            // String -&gt; EPS</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char cur = src[ptr]; int repTime = 1;</span><br><span class="line">        string ret;</span><br><span class="line"></span><br><span class="line">        if (isdigit(cur)) &#123;</span><br><span class="line">            // String -&gt; Digits [ String ] String</span><br><span class="line">            // 解析 Digits</span><br><span class="line">            repTime = getDigits(); </span><br><span class="line">            // 过滤左括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 解析 String</span><br><span class="line">            string str = getString(); </span><br><span class="line">            // 过滤右括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 构造字符串</span><br><span class="line">            while (repTime--) ret += str; </span><br><span class="line">        &#125; else if (isalpha(cur)) &#123;</span><br><span class="line">            // String -&gt; Char String</span><br><span class="line">            // 解析 Char</span><br><span class="line">            ret = string(1, src[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        src = s;</span><br><span class="line">        ptr = 0;</span><br><span class="line">        return getString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    String src;</span><br><span class="line">    int ptr;</span><br><span class="line"></span><br><span class="line">    public String decodeString(String s) &#123;</span><br><span class="line">        src = s;</span><br><span class="line">        ptr = 0;</span><br><span class="line">        return getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        if (ptr == src.length() || src.charAt(ptr) == &#x27;]&#x27;) &#123;</span><br><span class="line">            // String -&gt; EPS</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char cur = src.charAt(ptr);</span><br><span class="line">        int repTime = 1;</span><br><span class="line">        String ret = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        if (Character.isDigit(cur)) &#123;</span><br><span class="line">            // String -&gt; Digits [ String ] String</span><br><span class="line">            // 解析 Digits</span><br><span class="line">            repTime = getDigits(); </span><br><span class="line">            // 过滤左括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 解析 String</span><br><span class="line">            String str = getString(); </span><br><span class="line">            // 过滤右括号</span><br><span class="line">            ++ptr;</span><br><span class="line">            // 构造字符串</span><br><span class="line">            while (repTime-- &gt; 0) &#123;</span><br><span class="line">                ret += str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (Character.isLetter(cur)) &#123;</span><br><span class="line">            // String -&gt; Char String</span><br><span class="line">            // 解析 Char</span><br><span class="line">            ret = String.valueOf(src.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDigits() &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        while (ptr &lt; src.length() &amp;&amp; Character.isDigit(src.charAt(ptr))) &#123;</span><br><span class="line">            ret = ret * 10 + src.charAt(ptr++) - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    src string</span><br><span class="line">    ptr int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func decodeString(s string) string &#123;</span><br><span class="line">    src = s</span><br><span class="line">    ptr = 0</span><br><span class="line">    return getString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getString() string &#123;</span><br><span class="line">    if ptr == len(src) || src[ptr] == &#x27;]&#x27; &#123;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    cur := src[ptr]</span><br><span class="line">    repTime := 1</span><br><span class="line">    ret := &quot;&quot;</span><br><span class="line">    if cur &gt;= &#x27;0&#x27; &amp;&amp; cur &lt;= &#x27;9&#x27; &#123;</span><br><span class="line">        repTime = getDigits()</span><br><span class="line">        ptr++</span><br><span class="line">        str := getString()</span><br><span class="line">        ptr++</span><br><span class="line">        ret = strings.Repeat(str, repTime)</span><br><span class="line">    &#125; else if cur &gt;= &#x27;a&#x27; &amp;&amp; cur &lt;= &#x27;z&#x27; || cur &gt;= &#x27;A&#x27; &amp;&amp; cur &lt;= &#x27;Z&#x27; &#123;</span><br><span class="line">        ret = string(cur)</span><br><span class="line">        ptr++</span><br><span class="line">    &#125;</span><br><span class="line">    return ret + getString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getDigits() int &#123;</span><br><span class="line">    ret := 0</span><br><span class="line">    for ; src[ptr] &gt;= &#x27;0&#x27; &amp;&amp; src[ptr] &lt;= &#x27;9&#x27;; ptr++ &#123;</span><br><span class="line">        ret = ret * 10 + int(src[ptr] - &#x27;0&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：记解码后得出的字符串长度为 S，除了遍历一次原字符串 s，我们还需要将解码后的字符串中的每个字符都拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S)。</p><p>空间复杂度：若不考虑答案所占用的空间，那么就只剩递归使用栈空间的大小，这里栈空间的使用和递归树的深度成正比，最坏情况下为 O(∣s∣)，故渐进空间复杂度为 O(∣s∣)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Recursive" scheme="http://yoursite.com/tags/Recursive/"/>
    
  </entry>
  
  <entry>
    <title>494. 目标和</title>
    <link href="http://yoursite.com/2022/03/09/494.%20%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <id>http://yoursite.com/2022/03/09/494.%20%E7%9B%AE%E6%A0%87%E5%92%8C/</id>
    <published>2022-03-09T07:12:12.000Z</published>
    <updated>2022-03-09T06:52:42.114Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><span id="more"></span><p>[TOC]</p><p>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>示例 1：</p><pre><code>输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3</code></pre><p>示例 2：</p><pre><code>输入：nums = [1], target = 1输出：1</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 200 &lt;= nums[i] &lt;= 10000 &lt;= sum(nums[i]) &lt;= 1000-1000 &lt;= target &lt;= 1000</code></pre><h1 id="方法一：回溯-1"><a href="#方法一：回溯-1" class="headerlink" title="方法一：回溯^1"></a>方法一：回溯<a href="https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/">^1</a></h1><p>数组 nums 的每个元素都可以添加符号 + 或 -，因此每个元素有 2 种添加符号的方法，n 个数共有 2^n 种添加符号的方法，对应 2^n 种不同的表达式。当 n 个元素都添加符号之后，即得到一种表达式，如果表达式的结果等于目标数 target，则该表达式即为符合要求的表达式。</p><p>可以使用回溯的方法遍历所有的表达式，回溯过程中维护一个计数器 count，当遇到一种表达式的结果等于目标数 target 时，将 count 的值加 1。遍历完所有的表达式之后，即可得到结果等于目标数 target 的表达式的数目。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        backtrack(nums, target, 0, 0);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtrack(int[] nums, int target, int index, int sum) &#123;</span><br><span class="line">        if (index == nums.length) &#123;</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    public int FindTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        Backtrack(nums, target, 0, 0);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Backtrack(int[] nums, int target, int index, int sum) &#123;</span><br><span class="line">        if (index == nums.Length) &#123;</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            Backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var findTargetSumWays = function(nums, target) &#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    const backtrack = (nums, target, index, sum) =&gt; &#123;</span><br><span class="line">        if (index === nums.length) &#123;</span><br><span class="line">            if (sum === target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(nums, target, 0, 0);</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func findTargetSumWays(nums []int, target int) (count int) &#123;</span><br><span class="line">    var backtrack func(int, int)</span><br><span class="line">    backtrack = func(index, sum int) &#123;</span><br><span class="line">        if index == len(nums) &#123;</span><br><span class="line">            if sum == target &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(index+1, sum+nums[index])</span><br><span class="line">        backtrack(index+1, sum-nums[index])</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(0, 0)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        backtrack(nums, target, 0, 0);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backtrack(vector&lt;int&gt;&amp; nums, int target, int index, int sum) &#123;</span><br><span class="line">        if (index == nums.size()) &#123;</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            backtrack(nums, target, index + 1, sum + nums[index]);</span><br><span class="line">            backtrack(nums, target, index + 1, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int count;</span><br><span class="line"></span><br><span class="line">int findTargetSumWays(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    count = 0;</span><br><span class="line">    backtrack(nums, numsSize, target, 0, 0);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(int* nums, int numSize, int target, int index, int sum) &#123;</span><br><span class="line">    if (index == numSize) &#123;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        backtrack(nums, numSize, target, index + 1, sum + nums[index]);</span><br><span class="line">        backtrack(nums, numSize, target, index + 1, sum - nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(2^n)，其中 n 是数组 nums 的长度。回溯需要遍历所有不同的表达式，共有 2^n 种不同的表达式，每种表达式计算结果需要 O(1) 的时间，因此总时间复杂度是 O(2^n)。<br>空间复杂度：O(n)，其中 n 是数组 nums 的长度。空间复杂度主要取决于递归调用的栈空间，栈的深度不超过 n。</p><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><p>记数组的元素和为 sum，添加 - 号的元素之和为 neg，则其余添加 + 的元素之和为 sum−neg，得到的表达式的结果为</p><pre><code>(sum−neg)−neg=sum−2⋅neg=target</code></pre><p>即</p><pre><code>neg= (sum−target)/2</code></pre><p>由于数组 nums 中的元素都是非负整数，neg 也必须是非负整数，所以上式成立的前提是 sum−target 是非负偶数。若不符合该条件可直接返回 0。</p><p>若上式成立，问题转化成在数组 nums 中选取若干元素，使得这些元素之和等于 neg，计算选取元素的方案数。我们可以使用动态规划的方法求解。</p><p>定义二维数组 dp，其中 dp[i][j] 表示在数组 nums 的前 i 个数中选取元素，使得这些元素之和等于 j 的方案数。假设数组 nums 的长度为 n，则最终答案为 dp[n][neg]。</p><p>当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：</p><p>当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：</p><pre><code>dp[0][j]=&#123;  1,j=0            0,j≥1</code></pre><p>当 1≤i≤n 时，对于数组 nums 中的第 i 个元素 num（i 的计数从 1 开始），遍历 0≤j≤neg，计算 dp[i][j] 的值：</p><ul><li>如果 j&lt;num，则不能选 num，此时有 dp[i][j]&#x3D;dp[i−1][j]；</li><li>如果 j≥num，则如果不选 num，方案数是 dp[i−1][j]，如果选 num，方案数是 dp[i−1][j−num]，此时有 dp[i][j]&#x3D;dp[i−1][j]+dp[i−1][j−num]。</li></ul><p>因此状态转移方程如下：</p><pre><code>dp&#125;[i][j]=&#123; dp[i-1][j], j&lt;nums[i]            dp[i-1][j]+dp[i-1][j-nums[i]], j&gt;=nums[i]</code></pre><p>最终得到 dp[n][neg] 的值即为答案。</p><p>由此可以得到空间复杂度为 O(n×neg) 的实现。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums.length, neg = diff / 2;</span><br><span class="line">        int[][] dp = new int[n + 1][neg + 1];</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        foreach (int num in nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums.Length, neg = diff / 2;</span><br><span class="line">        int[,] dp = new int[n + 1, neg + 1];</span><br><span class="line">        dp[0, 0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">                dp[i, j] = dp[i - 1, j];</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i, j] += dp[i - 1, j - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n, neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var findTargetSumWays = function(nums, target) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    const diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 !== 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const n = nums.length, neg = diff / 2;</span><br><span class="line">    const dp = new Array(n + 1).fill(0).map(() =&gt; new Array(neg + 1).fill(0));</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (let i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        const num = nums[i - 1];</span><br><span class="line">        for (let j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][neg];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func findTargetSumWays(nums []int, target int) int &#123;</span><br><span class="line">    sum := 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    diff := sum - target</span><br><span class="line">    if diff &lt; 0 || diff%2 == 1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    n, neg := len(nums), diff/2</span><br><span class="line">    dp := make([][]int, n+1)</span><br><span class="line">    for i := range dp &#123;</span><br><span class="line">        dp[i] = make([]int, neg+1)</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][0] = 1</span><br><span class="line">    for i, num := range nums &#123;</span><br><span class="line">        for j := 0; j &lt;= neg; j++ &#123;</span><br><span class="line">            dp[i+1][j] = dp[i][j]</span><br><span class="line">            if j &gt;= num &#123;</span><br><span class="line">                dp[i+1][j] += dp[i][j-num]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][neg]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = nums.size(), neg = diff / 2;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(neg + 1));</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int findTargetSumWays(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = numsSize, neg = diff / 2;</span><br><span class="line">    int dp[n + 1][neg + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int num = nums[i - 1];</span><br><span class="line">        for (int j = 0; j &lt;= neg; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] += dp[i - 1][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][neg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>由于 dp 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，将空间复杂度优化到 O(neg)。</p><p>实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 dp[i−1][] 中的元素值。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int neg = diff / 2;</span><br><span class="line">        int[] dp = new int[neg + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        foreach (int num in nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int neg = diff / 2;</span><br><span class="line">        int[] dp = new int[neg + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        foreach (int num in nums) &#123;</span><br><span class="line">            for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var findTargetSumWays = function(nums, target) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    const diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 !== 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const neg = Math.floor(diff / 2);</span><br><span class="line">    const dp = new Array(neg + 1).fill(0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        for (let j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[neg];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func findTargetSumWays(nums []int, target int) int &#123;</span><br><span class="line">    sum := 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    diff := sum - target</span><br><span class="line">    if diff &lt; 0 || diff%2 == 1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    neg := diff / 2</span><br><span class="line">    dp := make([]int, neg+1)</span><br><span class="line">    dp[0] = 1</span><br><span class="line">    for _, num := range nums &#123;</span><br><span class="line">        for j := neg; j &gt;= num; j-- &#123;</span><br><span class="line">            dp[j] += dp[j-num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[neg]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        int diff = sum - target;</span><br><span class="line">        if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int neg = diff / 2;</span><br><span class="line">        vector&lt;int&gt; dp(neg + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int&amp; num : nums) &#123;</span><br><span class="line">            for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int findTargetSumWays(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int diff = sum - target;</span><br><span class="line">    if (diff &lt; 0 || diff % 2 != 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int neg = diff / 2;</span><br><span class="line">    int dp[neg + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        int num = nums[i];</span><br><span class="line">        for (int j = neg; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[neg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n×(sum−target))，其中 n 是数组 nums 的长度，sum 是数组 nums 的元素和，target 是目标数。动态规划有 (n+1)×((sum−target)&#x2F;2+1) 个状态，需要计算每个状态的值。</p><p>空间复杂度：O(sum−target)，其中 sum 是数组 nums 的元素和，target 是目标数。使用空间优化的实现，需要创建长度为  (sum−target)&#x2F;2+1 的数组 dp。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个整数数组 nums 和一个整数 target 。&lt;/p&gt;
&lt;p&gt;向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
    <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>416. 分割等和子集</title>
    <link href="http://yoursite.com/2022/03/08/416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2022/03/08/416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</id>
    <published>2022-03-08T09:12:12.000Z</published>
    <updated>2022-03-08T09:28:09.428Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 只包含正整数 的 非空 数组nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2001 &lt;= nums[i] &lt;= 100</code></pre><h1 id="文字题解-1"><a href="#文字题解-1" class="headerlink" title="文字题解^1"></a>文字题解<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/">^1</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作者在这里希望读者认真阅读前言部分。</p><p>本题是经典的「NP 完全问题」，也就是说，如果你发现了该问题的一个多项式算法，那么恭喜你证明出了 P&#x3D;NP，可以期待一下图灵奖了。</p><p>正因如此，我们不应期望该问题有多项式时间复杂度的解法。我们能想到的，例如基于贪心算法的「将数组降序排序后，依次将每个元素添加至当前元素和较小的子集中」之类的方法都是错误的，可以轻松地举出反例。因此，我们必须尝试非多项式时间复杂度的算法，例如时间复杂度与元素大小相关的动态规划。</p><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>这道题可以换一种表述：给定一个只包含正整数的非空数组 nums[0]，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。因此这个问题可以转换成「0−1 背包问题」。这道题与传统的「0−1 背包问题」的区别在于，传统的「0−1 背包问题」要求选取的物品的重量之和不能超过背包的总容量，这道题则要求选取的数字的和恰好等于整个数组的元素和的一半。类似于传统的「0−1 背包问题」，可以使用动态规划求解。</p><p>在使用动态规划求解之前，首先需要进行以下判断。</p><ul><li><p>根据数组的长度 n 判断数组是否可以被划分。如果 n&lt;2，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。</p></li><li><p>计算整个数组的元素和 sum 以及最大元素 maxNum。如果 sum 是奇数，则不可能将数组分割成元素和相等的两个子集，因此直接返回 false。如果 sum 是偶数，则令 target&#x3D; 2sum，需要判断是否可以从数组中选出一些数字，使得这些数字的和等于 target。如果 maxNum&gt;target，则除了 maxNum 以外的所有元素之和一定小于 target，因此不可能将数组分割成元素和相等的两个子集，直接返回 false。</p></li></ul><p>创建二维数组 dp，包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。</p><p>在定义状态之后，需要考虑边界情况。以下两种情况都属于边界情况。</p><ul><li>如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有 0≤i&lt;n，都有 dp[i][0]&#x3D;true。</li><li>当 i&#x3D;&#x3D;0 时，只有一个正整数 nums[0] 可以被选取，因此 dp[0][nums[0]]&#x3D;true。</li></ul><p>对于 i&gt;0 且 j&gt;0 的情况，如何确定 dp[i][j] 的值？需要分别考虑以下两种情况。</p><ul><li><p>如果 j≥nums[i]，则对于当前的数字 nums[i]，可以选取也可以不选取，两种情况只要有一个为 true，就有 dp[i][j]&#x3D;true。</p><p>  如果不选取 nums[i]，则 dp[i][j]&#x3D;dp[i−1][j]；<br>  如果选取 nums[i]，则 dp[i][j]&#x3D;dp[i−1][j−nums[i]]。</p></li><li><p>如果 j&lt;nums[i]，则在选取的数字的和等于 j 的情况下无法选取当前的数字 nums[i]，因此有 dp[i][j]&#x3D;dp[i−1][j]。</p></li></ul><p>状态转移方程如下：</p><pre><code>dp[i][j]=&#123; dp[i−1][j] ∣ dp[i−1][j−nums[i]], j≥nums[i]           dp[i−1][j],  j&lt;nums[i]</code></pre><p>最终得到 dp[n−1][target] 即为答案。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0, maxNum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 2 != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[][] dp = new boolean[n][target + 1];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][nums[0]] = true;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0);</span><br><span class="line">        int maxNum = *max_element(nums.begin(), nums.end());</span><br><span class="line">        if (sum &amp; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(target + 1, 0));</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0][nums[0]] = true;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">                if (j &gt;= num) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n - 1][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var canPartition = function(nums) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    if (n &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let sum = 0, maxNum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        maxNum = maxNum &gt; num ? maxNum : num;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const target = Math.floor(sum / 2);</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const dp = new Array(n).fill(0).map(v =&gt; new Array(target + 1, false));</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][0] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][nums[0]] = true;</span><br><span class="line">    for (let i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        const num = nums[i];</span><br><span class="line">        for (let j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][target];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func canPartition(nums []int) bool &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    if n &lt; 2 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum, max := 0, 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        if v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if sum%2 != 0 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target := sum / 2</span><br><span class="line">    if max &gt; target &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp := make([][]bool, n)</span><br><span class="line">    for i := range dp &#123;</span><br><span class="line">        dp[i] = make([]bool, target+1)</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i][0] = true</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][nums[0]] = true</span><br><span class="line">    for i := 1; i &lt; n; i++ &#123;</span><br><span class="line">        v := nums[i]</span><br><span class="line">        for j := 1; j &lt;= target; j++ &#123;</span><br><span class="line">            if j &gt;= v &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j] || dp[i-1][j-v]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1][target]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">bool canPartition(int* nums, int numsSize) &#123;</span><br><span class="line">    if (numsSize &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0, maxNum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        maxNum = fmax(maxNum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int target = sum / 2;</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int dp[numsSize][target + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        dp[i][0] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][nums[0]] = true;</span><br><span class="line">    for (int i = 1; i &lt; numsSize; i++) &#123;</span><br><span class="line">        int num = nums[i];</span><br><span class="line">        for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">            if (j &gt;= num) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[numsSize - 1][target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canPartition(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        if n &lt; 2:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        total = sum(nums)</span><br><span class="line">        maxNum = max(nums)</span><br><span class="line">        if total &amp; 1:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        target = total // 2</span><br><span class="line">        if maxNum &gt; target:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        dp = [[False] * (target + 1) for _ in range(n)]</span><br><span class="line">        for i in range(n):</span><br><span class="line">            dp[i][0] = True</span><br><span class="line">        </span><br><span class="line">        dp[0][nums[0]] = True</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            num = nums[i]</span><br><span class="line">            for j in range(1, target + 1):</span><br><span class="line">                if j &gt;= num:</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] = dp[i - 1][j]</span><br><span class="line">        </span><br><span class="line">        return dp[n - 1][target]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>上述代码的空间复杂度是 O(n×target)。但是可以发现在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：</p><pre><code>dp[j]=dp[j] ∣ dp[j−nums[i]]</code></pre><p>且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 dp[j] 值的时候，dp[j−nums[i]] 已经是被更新过的状态，不再是上一行的 dp 值。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0, maxNum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 2 != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] dp = new boolean[target + 1];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0, maxNum = 0;</span><br><span class="line">        for (auto&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum &amp; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        if (maxNum &gt; target) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp(target + 1, 0);</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            for (int j = target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var canPartition = function(nums) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    if (n &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let sum = 0, maxNum = 0;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        maxNum = maxNum &gt; num ? maxNum : num;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const target = Math.floor(sum / 2);</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const dp = new Array(target + 1).fill(false);</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        for (let j = target; j &gt;= num; --j) &#123;</span><br><span class="line">            dp[j] |= dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func canPartition(nums []int) bool &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    if n &lt; 2 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum, max := 0, 0</span><br><span class="line">    for _, v := range nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        if v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if sum%2 != 0 &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target := sum / 2</span><br><span class="line">    if max &gt; target &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp := make([]bool, target+1)</span><br><span class="line">    dp[0] = true</span><br><span class="line">    for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        v := nums[i]</span><br><span class="line">        for j := target; j &gt;= v; j-- &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j-v]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool canPartition(int* nums, int numsSize) &#123;</span><br><span class="line">    if (numsSize &lt; 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = 0, maxNum = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        maxNum = fmax(maxNum, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum &amp; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int target = sum / 2;</span><br><span class="line">    if (maxNum &gt; target) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int dp[target + 1];</span><br><span class="line">    memset(dp, 0, sizeof(dp));</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        int num = nums[i];</span><br><span class="line">        for (int j = target; j &gt;= num; --j) &#123;</span><br><span class="line">            dp[j] |= dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canPartition(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        if n &lt; 2:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        total = sum(nums)</span><br><span class="line">        if total % 2 != 0:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        target = total // 2</span><br><span class="line">        dp = [True] + [False] * target</span><br><span class="line">        for i, num in enumerate(nums):</span><br><span class="line">            for j in range(target, num - 1, -1):</span><br><span class="line">                dp[j] |= dp[j - num]</span><br><span class="line">        </span><br><span class="line">        return dp[target]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n×target)，其中 n 是数组的长度，target 是整个数组的元素和的一半。需要计算出所有的状态，每个状态在进行转移时的时间复杂度为 O(1)。</p><p>空间复杂度：O(target)，其中 target 是整个数组的元素和的一半。空间复杂度取决于 dp 数组，在不进行空间优化的情况下，空间复杂度是 O(n×target)，在进行空间优化的情况下，空间复杂度可以降到 O(target)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 只包含正整数 的 非空 数组nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>581. 最短无序连续子数组</title>
    <link href="http://yoursite.com/2022/03/08/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2022/03/08/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2022-03-08T08:12:12.000Z</published>
    <updated>2022-03-08T07:55:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,3,4]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [1]输出：0</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 104-105 &lt;= nums[i] &lt;= 105</code></pre><p>进阶：你可以设计一个时间复杂度为 O(n) 的解决方案吗？</p><h1 id="方法一：排序-1"><a href="#方法一：排序-1" class="headerlink" title="方法一：排序^1"></a>方法一：排序<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leet-yhlf/">^1</a></h1><p>思路与算法</p><p>我们将给定的数组nums表示为三段子数组拼接的形式，分别记作 numsA，numsB，numsC。当我们对numsB进行排序，整个数组将变为有序。换而言之，当我们对整个序列进行排序，numsA和 numsC都不会改变。</p><p>本题要求我们找到最短的numsB，即找到最大的numsA和numsC的长度之和。因此我们将原数组 nums 排序与原数组进行比较，取最长的相同的前缀为 numsA ，取最长的相同的后缀为 numsC，这样我们就可以取到最短的 numsB。</p><p>具体地，我们创建数组  nums 的拷贝，记作数组  numsSorted，并对该数组进行排序，然后我们从左向右找到第一个两数组不同的位置，即为<br>numsB的左边界。同理也可以找到 numsB 右边界。最后我们输出 numsB的长度即可。</p><p>特别地，当原数组有序时，numsB的长度为0，我们可以直接返回结果。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (is_sorted(nums.begin(), nums.end())) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; numsSorted(nums);</span><br><span class="line">        sort(numsSorted.begin(), numsSorted.end());</span><br><span class="line">        int left = 0;</span><br><span class="line">        while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        if (isSorted(nums)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] numsSorted = new int[nums.length];</span><br><span class="line">        System.arraycopy(nums, 0, numsSorted, 0, nums.length);</span><br><span class="line">        Arrays.sort(numsSorted);</span><br><span class="line">        int left = 0;</span><br><span class="line">        while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isSorted(int[] nums) &#123;</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        if (IsSorted(nums)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] numsSorted = new int[nums.Length];</span><br><span class="line">        Array.Copy(nums, numsSorted, nums.Length);</span><br><span class="line">        Array.Sort(numsSorted);</span><br><span class="line">        int left = 0;</span><br><span class="line">        while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        int right = nums.Length - 1;</span><br><span class="line">        while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsSorted(int[] nums) &#123;</span><br><span class="line">        for (int i = 1; i &lt; nums.Length; i++) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        def isSorted() -&gt; bool:</span><br><span class="line">            for i in range(1, n):</span><br><span class="line">                if nums[i - 1] &gt; nums[i]:</span><br><span class="line">                    return False</span><br><span class="line">            return True</span><br><span class="line">        </span><br><span class="line">        if isSorted():</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        numsSorted = sorted(nums)</span><br><span class="line">        left = 0</span><br><span class="line">        while nums[left] == numsSorted[left]:</span><br><span class="line">            left += 1</span><br><span class="line"></span><br><span class="line">        right = n - 1</span><br><span class="line">        while nums[right] == numsSorted[right]:</span><br><span class="line">            right -= 1</span><br><span class="line">        </span><br><span class="line">        return right - left + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var findUnsortedSubarray = function(nums) &#123;</span><br><span class="line">    if (isSorted(nums)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const numsSorted = [...nums].sort((a, b) =&gt; a - b);</span><br><span class="line">    let left = 0;</span><br><span class="line">    while (nums[left] === numsSorted[left]) &#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    let right = nums.length - 1;</span><br><span class="line">    while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const isSorted = (nums) =&gt; &#123;</span><br><span class="line">    for (let i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func findUnsortedSubarray(nums []int) int &#123;</span><br><span class="line">    if sort.IntsAreSorted(nums) &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    numsSorted := append([]int(nil), nums...)</span><br><span class="line">    sort.Ints(numsSorted)</span><br><span class="line">    left, right := 0, len(nums)-1</span><br><span class="line">    for nums[left] == numsSorted[left] &#123;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    for nums[right] == numsSorted[right] &#123;</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">bool is_sorted(int* arr, int arrSize) &#123;</span><br><span class="line">    for (int i = 1; i &lt; arrSize; i++) &#123;</span><br><span class="line">        if (arr[i - 1] &gt; arr[i]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(int* a, int* b) &#123;</span><br><span class="line">    return *a - *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findUnsortedSubarray(int* nums, int numsSize) &#123;</span><br><span class="line">    if (is_sorted(nums, numsSize)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int numsSorted[numsSize];</span><br><span class="line">    memcpy(numsSorted, nums, sizeof(int) * numsSize);</span><br><span class="line">    qsort(numsSorted, numsSize, sizeof(int), cmp);</span><br><span class="line">    int left = 0;</span><br><span class="line">    while (nums[left] == numsSorted[left]) &#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    int right = numsSize - 1;</span><br><span class="line">    while (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(nlogn)，其中 n 为给定数组的长度。我们需要  O(nlogn) 的时间进行排序，以及  O(n) 的时间遍历数组，因此总时间复杂度为 O(n)。<br>空间复杂度： O(n)，其中  n 为给定数组的长度。我们需要额外的一个数组保存排序后的数组  numsSorted。</p><h1 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h1><p>思路与算法</p><p>假设 numsB 在  nums 中对应区间为  [left,right]。<br> 注意到 numsB和  numsC 中任意一个数都大于等于  numsA 中任意一个数。因此有<br>numsA 中每一个数 numsi 都满足：</p><p>我们可以从大到小枚举  i，用一个变量  minn 记录 i后的numsi 。每次移动  i，都可以<br> O(1) 地更新  minn。这样最后一个使得不等式不成立的 i 即为  left 左侧即为  numsA 能取得的最大范围。</p><p>同理，我们可以用类似的方法确定 right。在实际代码中，我们可以在一次循环中同时完成左右边界的计算。</p><p>特别地，我们需要特判  nums 有序的情况，此时  numsB 的长度为  0。当我们计算完成左右边界，即可返回  numsB 的长度。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int maxn = INT_MIN, right = -1;</span><br><span class="line">        int minn = INT_MAX, left = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">                left = n - i - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minn = nums[n - i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right == -1 ? 0 : right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int maxn = Integer.MIN_VALUE, right = -1;</span><br><span class="line">        int minn = Integer.MAX_VALUE, left = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">                left = n - i - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minn = nums[n - i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right == -1 ? 0 : right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int FindUnsortedSubarray(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int maxn = int.MinValue, right = -1;</span><br><span class="line">        int minn = int.MaxValue, left = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">                left = n - i - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                minn = nums[n - i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right == -1 ? 0 : right - left + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxn, right = float(&quot;-inf&quot;), -1</span><br><span class="line">        minn, left = float(&quot;inf&quot;), -1</span><br><span class="line"></span><br><span class="line">        for i in range(n):</span><br><span class="line">            if maxn &gt; nums[i]:</span><br><span class="line">                right = i</span><br><span class="line">            else:</span><br><span class="line">                maxn = nums[i]</span><br><span class="line">            </span><br><span class="line">            if minn &lt; nums[n - i - 1]:</span><br><span class="line">                left = n - i - 1</span><br><span class="line">            else:</span><br><span class="line">                minn = nums[n - i - 1]</span><br><span class="line">        </span><br><span class="line">        return 0 if right == -1 else right - left + 1</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var findUnsortedSubarray = function(nums) &#123;</span><br><span class="line">    const n = nums.length;</span><br><span class="line">    let maxn = -Number.MAX_VALUE, right = -1;</span><br><span class="line">    let minn = Number.MAX_VALUE, left = -1;</span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (maxn &gt; nums[i]) &#123;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">            left = n - i - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = nums[n - i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return right === -1 ? 0 : right - left + 1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func findUnsortedSubarray(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    minn, maxn := math.MaxInt64, math.MinInt64</span><br><span class="line">    left, right := -1, -1</span><br><span class="line">    for i, num := range nums &#123;</span><br><span class="line">        if maxn &gt; num &#123;</span><br><span class="line">            right = i</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn = num</span><br><span class="line">        &#125;</span><br><span class="line">        if minn &lt; nums[n-i-1] &#123;</span><br><span class="line">            left = n - i - 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = nums[n-i-1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if right == -1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    return right - left + 1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int findUnsortedSubarray(int* nums, int numsSize) &#123;</span><br><span class="line">    int n = numsSize;</span><br><span class="line">    int maxn = INT_MIN, right = -1;</span><br><span class="line">    int minn = INT_MAX, left = -1;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (maxn &gt; nums[i]) &#123;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            maxn = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (minn &lt; nums[n - i - 1]) &#123;</span><br><span class="line">            left = n - i - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minn = nums[n - i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return right == -1 ? 0 : right - left + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度： O(n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。<br>时间复杂度： O(1)。我们只需要常数的空间保存若干变量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。&lt;/p&gt;
&lt;p&gt;请你找出符合题意的 最短 子数组，并输出它的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年3月" scheme="http://yoursite.com/categories/2022%E5%B9%B43%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
    <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
    <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
    <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>Latex极简教程</title>
    <link href="http://yoursite.com/2022/02/28/Latex%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2022/02/28/Latex%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/</id>
    <published>2022-02-28T03:12:12.000Z</published>
    <updated>2022-03-07T12:56:58.784Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上快速安装使用Latex</p><span id="more"></span><h1 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h1><p>步骤参照<a href="https://www.cnblogs.com/ouyangsong/p/9348175.html">^1</a><br>Latex 是个复杂但是很强大的排版工具，在 MAC 系统上如果不想安装 3G 大的 MacTex 的话，可以试试 BasicTex。</p><p>安装<br>MacTex 安装包非常大，而且自带了很多图形应用。我更喜欢用命令行，所以选择 BasicTex。使用 Homebrew 安装非常简单，一条命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install basictex</span><br></pre></td></tr></table></figure><p>如果报错：</p><p>Error: Unknown command: cask</p><p>原因就是新版本的 homebrew 已经取消了 cask 这条命令，改用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask basictex</span><br></pre></td></tr></table></figure><p>安装完还不能直接使用，还需要把 texlive 添加到环境变量中，才能找到相关的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/usr/local/texlive/2020basic/bin/x86_64-darwin:$PATH</span><br></pre></td></tr></table></figure><p>然后就是安装相关的包，以及更新包,要cd到目录&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2020basic&#x2F;bin&#x2F;x86_64-darwin中运行下列命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr update --self --repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br><span class="line">sudo tlmgr install latexmk --repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br></pre></td></tr></table></figure><p>安装包的时候推荐使用清华的 CTAN 镜像，不然的话下载速度实在太慢了。</p><p>到了2021年这个目录也要换成21年的，安装包可以在<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/%E9%87%8C%E4%B8%8B%E8%BD%BDBasicTex.pkg">https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/里下载BasicTex.pkg</a></p><p>特别注意，如果你是 macOS 用户，那么今年的安装与往年的有点不一样，主要是 texlive 的文件结构稍有改变，在配置 PATH、MAN、INFO 等环境变量时，应特别注意。以下是 2021 版 TeXlive 的 macOS 环境变量配置： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export MANPATH=/usr/local/texlive/2021/texmf-dist/doc/man:$&#123;MANPATH&#125;</span><br><span class="line">export INFOPATH=/usr/local/texlive/2021/texmf-dist/doc/info:$&#123;INFOPATH&#125;</span><br><span class="line">export PATH=/usr/local/texlive/2021/bin/universal-darwin:$&#123;PATH&#125;</span><br><span class="line">alias tlmgr=&#x27;sudo /usr/local/texlive/2021/bin/universal-darwin/tlmgr&#x27;</span><br></pre></td></tr></table></figure><p>PATH 里的 universal-darwim 代表此后无论是 Intel Core 还是 M1 芯片，都将得到适配。不过 M1 的兼容性此处未验证。特别强调，下文的配置是全平台通用的，无论你的操作系统是 macOS 还是 Windows，抑或是 Linux，只要不是太小众，应该都没问题。全网只有一个 texlive 的 iso 镜像，并没有特殊适配某个操作系统或某种 CPU 体系结构的版本。</p><h1 id="Atom开发"><a href="#Atom开发" class="headerlink" title="Atom开发"></a>Atom开发</h1><p>配合Atom来运行latex，参照<a href="https://blog.csdn.net/violet_echo_0908/article/details/78160273">^2</a></p><p>安装好插件后会报错缺失一些包可以更新插件或者npm install相应的包</p><h1 id="命令行直接编译"><a href="#命令行直接编译" class="headerlink" title="命令行直接编译"></a>命令行直接编译</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex demo.tex</span><br></pre></td></tr></table></figure><h1 id="遇到错误-LaTeX-Error-File-xifthen-sty-39-not-found"><a href="#遇到错误-LaTeX-Error-File-xifthen-sty-39-not-found" class="headerlink" title="遇到错误 ! LaTeX Error: File `xifthen.sty&#39; not found"></a>遇到错误 <code>! LaTeX Error: File `xifthen.sty&#39; not found</code></h1><p>那么去搜索一下它被包含在哪个包中，比如 xifthen.sty 就是包含在 xifthen 中。那么使用 tlmgr 安装即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tlmgr install xifthen</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在mac上快速安装使用Latex&lt;/p&gt;</summary>
    
    
    
    <category term="2022年2月" scheme="http://yoursite.com/categories/2022%E5%B9%B42%E6%9C%88/"/>
    
    
    <category term="Latex" scheme="http://yoursite.com/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>85. 最大矩形</title>
    <link href="http://yoursite.com/2022/02/17/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2022/02/17/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</id>
    <published>2022-02-17T14:34:12.000Z</published>
    <updated>2022-02-17T15:54:59.632Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：6解释：最大矩形如上图所示。</code></pre><p>示例 2：</p><pre><code>输入：matrix = []输出：0</code></pre><p>示例 3：</p><pre><code>输入：matrix = [[&quot;0&quot;]]输出：0</code></pre><p>示例 4：</p><pre><code>输入：matrix = [[&quot;1&quot;]]输出：1</code></pre><p>示例 5：</p><pre><code>输入：matrix = [[&quot;0&quot;,&quot;0&quot;]]输出：0</code></pre><p>提示：</p><pre><code>rows == matrix.lengthcols == matrix[0].length1 &lt;= row, cols &lt;= 200matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39;</code></pre><h1 id="方法一-使用柱状图的优化暴力方法-1"><a href="#方法一-使用柱状图的优化暴力方法-1" class="headerlink" title="方法一: 使用柱状图的优化暴力方法^1"></a>方法一: 使用柱状图的优化暴力方法<a href="https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode-solution-bjlu/">^1</a></h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>最原始地，我们可以列举每个可能的矩形。我们枚举矩形所有可能的左上角坐标和右下角坐标，并检查该矩形是否符合要求。然而该方法的时间复杂度过高，不能通过所有的测试用例，因此我们必须寻找其他方法。</p><p>我们首先计算出矩阵的每个元素的左边连续 1 的数量，使用二维数组 left 记录，其中 left[i][j] 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。</p><p>随后，对于矩阵中任意一个点，我们枚举以该点为右下角的全 1 矩形。</p><p>具体而言，当考察以 </p><p>matrix[i][j] 为右下角的矩形时，我们枚举满足  0≤k≤i 的所有可能的 k，此时矩阵的最大宽度就为</p><p>left[i][j],left[i−1][j],…,left[k][j]</p><p>的最小值。</p><p>下图有助于理解。给定每个点的最大宽度，可计算出底端黄色方块的最大矩形面积。</p><p>对每个点重复这一过程，就可以得到全局的最大矩形。</p><p>我们预计算最大宽度的方法事实上将输入转化成了一系列的柱状图，我们针对每个柱状图计算最大面积。</p><p>于是，上述方法本质上是「84. 柱状图中最大的矩形」题中优化暴力算法的复用。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; left(m, vector&lt;int&gt;(n, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int width = left[i][j];</span><br><span class="line">                int area = width;</span><br><span class="line">                for (int k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                    width = min(width, left[k][j]);</span><br><span class="line">                    area = max(area, (i - k + 1) * width);</span><br><span class="line">                &#125;</span><br><span class="line">                ret = max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        int m = matrix.length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].length;</span><br><span class="line">        int[][] left = new int[m][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int width = left[i][j];</span><br><span class="line">                int area = width;</span><br><span class="line">                for (int k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                    width = Math.min(width, left[k][j]);</span><br><span class="line">                    area = Math.max(area, (i - k + 1) * width);</span><br><span class="line">                &#125;</span><br><span class="line">                ret = Math.max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var maximalRectangle = function(matrix) &#123;</span><br><span class="line">    const m = matrix.length;</span><br><span class="line">    if (m === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const n = matrix[0].length;</span><br><span class="line">    const left = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0));</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] === &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j === 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let ret = 0;</span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] === &#x27;0&#x27;) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            let width = left[i][j];</span><br><span class="line">            let area = width;</span><br><span class="line">            for (let k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                width = Math.min(width, left[k][j]);</span><br><span class="line">                area = Math.max(area, (i - k + 1) * width);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = Math.max(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">func maximalRectangle(matrix [][]byte) (ans int) &#123;</span><br><span class="line">    if len(matrix) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    m, n := len(matrix), len(matrix[0])</span><br><span class="line">    left := make([][]int, m)</span><br><span class="line">    for i, row := range matrix &#123;</span><br><span class="line">        left[i] = make([]int, n)</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == &#x27;0&#x27; &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            if j == 0 &#123;</span><br><span class="line">                left[i][j] = 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left[i][j] = left[i][j-1] + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i, row := range matrix &#123;</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == &#x27;0&#x27; &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            width := left[i][j]</span><br><span class="line">            area := width</span><br><span class="line">            for k := i - 1; k &gt;= 0; k-- &#123;</span><br><span class="line">                width = min(width, left[k][j])</span><br><span class="line">                area = max(area, (i-k+1)*width)</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, area)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(a, b int) int &#123;</span><br><span class="line">    if a &lt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if a &gt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize) &#123;</span><br><span class="line">    int m = matrixSize;</span><br><span class="line">    if (m == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = matrixColSize[0];</span><br><span class="line">    int left[m][n];</span><br><span class="line">    memset(left, 0, sizeof(left));</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] == &#x27;0&#x27;) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int width = left[i][j];</span><br><span class="line">            int area = width;</span><br><span class="line">            for (int k = i - 1; k &gt;= 0; k--) &#123;</span><br><span class="line">                width = fmin(width, left[k][j]);</span><br><span class="line">                area = fmax(area, (i - k + 1) * width);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = fmax(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>O(m^2 *n)，其中 m 和 n 分别是矩阵的行数和列数。计算 left 矩阵需要 O(mn) 的时间。随后对于矩阵的每个点，需要 O(m) 的时间枚举高度。故总的时间复杂度为 </p><p>O(mn)+O(mn)⋅O(m)&#x3D;O(m^2 *n)。</p><p>空间复杂度：<br>O(mn)，其中<br>m 和 n 分别是矩阵的行数和列数。我们分配了一个与给定矩阵等大的数组，用于存储每个元素的左边连续 1 的数量。</p><h1 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h1><p>思路与算法</p><p>在方法一中，我们讨论了将输入拆分成一系列的柱状图。为了计算矩形的最大面积，我们只需要计算每个柱状图中的最大面积，并找到全局最大值。</p><p>我们可以使用「84. 柱状图中最大的矩形的官方题解」中的单调栈的做法，将其应用在我们生成的柱状图中。</p><p>代码</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size();</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; left(m, vector&lt;int&gt;(n, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">            vector&lt;int&gt; up(m, 0), down(m, 0);</span><br><span class="line"></span><br><span class="line">            stack&lt;int&gt; stk;</span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; left[stk.top()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stk.empty() ? -1 : stk.top();</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stk = stack&lt;int&gt;();</span><br><span class="line">            for (int i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; left[stk.top()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stk.empty() ? m : stk.top();</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                int height = down[i] - up[i] - 1;</span><br><span class="line">                int area = height * left[i][j];</span><br><span class="line">                ret = max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        int m = matrix.length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = matrix[0].length;</span><br><span class="line">        int[][] left = new int[m][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">            int[] up = new int[m];</span><br><span class="line">            int[] down = new int[m];</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();</span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stack.isEmpty() ? -1 : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.clear();</span><br><span class="line">            for (int i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stack.isEmpty() ? m : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">                int height = down[i] - up[i] - 1;</span><br><span class="line">                int area = height * left[i][j];</span><br><span class="line">                ret = Math.max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var maximalRectangle = function(matrix) &#123;</span><br><span class="line">    const m = matrix.length;</span><br><span class="line">    if (m === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    const n = matrix[0].length;</span><br><span class="line">    const left = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0));</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] === &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j === 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let ret = 0;</span><br><span class="line">    for (let j = 0; j &lt; n; j++) &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">        const up = new Array(m).fill(0);</span><br><span class="line">        const down = new Array(m).fill(0);</span><br><span class="line"></span><br><span class="line">        let stack = new Array();</span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            while (stack.length &amp;&amp; left[stack[stack.length - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            up[i] = stack.length === 0 ? -1 : stack[stack.length - 1];</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack = [];</span><br><span class="line">        for (let i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            while (stack.length &amp;&amp; left[stack[stack.length - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            down[i] = stack.length === 0 ? m : stack[stack.length - 1];</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (let i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            const height = down[i] - up[i] - 1;</span><br><span class="line">            const area = height * left[i][j];</span><br><span class="line">            ret = Math.max(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func maximalRectangle(matrix [][]byte) (ans int) &#123;</span><br><span class="line">    if len(matrix) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    m, n := len(matrix), len(matrix[0])</span><br><span class="line">    left := make([][]int, m)</span><br><span class="line">    for i, row := range matrix &#123;</span><br><span class="line">        left[i] = make([]int, n)</span><br><span class="line">        for j, v := range row &#123;</span><br><span class="line">            if v == &#x27;0&#x27; &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            if j == 0 &#123;</span><br><span class="line">                left[i][j] = 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left[i][j] = left[i][j-1] + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for j := 0; j &lt; n; j++ &#123; // 对于每一列，使用基于柱状图的方法</span><br><span class="line">        up := make([]int, m)</span><br><span class="line">        down := make([]int, m)</span><br><span class="line">        stk := []int&#123;&#125;</span><br><span class="line">        for i, l := range left &#123;</span><br><span class="line">            for len(stk) &gt; 0 &amp;&amp; left[stk[len(stk)-1]][j] &gt;= l[j] &#123;</span><br><span class="line">                stk = stk[:len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            up[i] = -1</span><br><span class="line">            if len(stk) &gt; 0 &#123;</span><br><span class="line">                up[i] = stk[len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = append(stk, i)</span><br><span class="line">        &#125;</span><br><span class="line">        stk = nil</span><br><span class="line">        for i := m - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">            for len(stk) &gt; 0 &amp;&amp; left[stk[len(stk)-1]][j] &gt;= left[i][j] &#123;</span><br><span class="line">                stk = stk[:len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            down[i] = m</span><br><span class="line">            if len(stk) &gt; 0 &#123;</span><br><span class="line">                down[i] = stk[len(stk)-1]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = append(stk, i)</span><br><span class="line">        &#125;</span><br><span class="line">        for i, l := range left &#123;</span><br><span class="line">            height := down[i] - up[i] - 1</span><br><span class="line">            area := height * l[j]</span><br><span class="line">            ans = max(ans, area)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b int) int &#123;</span><br><span class="line">    if a &gt; b &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize) &#123;</span><br><span class="line">    int m = matrixSize;</span><br><span class="line">    if (m == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = matrixColSize[0];</span><br><span class="line">    int left[m][n];</span><br><span class="line">    memset(left, 0, sizeof(left));</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    for (int j = 0; j &lt; n; j++) &#123;  // 对于每一列，使用基于柱状图的方法</span><br><span class="line">        int up[m], down[m];</span><br><span class="line">        memset(up, 0, sizeof(up));</span><br><span class="line">        memset(down, 0, sizeof(down));</span><br><span class="line">        int stk[m], top = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            while (top &gt; 0 &amp;&amp; left[stk[top - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            up[i] = top == 0 ? -1 : stk[top - 1];</span><br><span class="line">            stk[top++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        top = 0;</span><br><span class="line">        for (int i = m - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            while (top &gt; 0 &amp;&amp; left[stk[top - 1]][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            down[i] = top == 0 ? m : stk[top - 1];</span><br><span class="line">            stk[top++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            int height = down[i] - up[i] - 1;</span><br><span class="line">            int area = height * left[i][j];</span><br><span class="line">            ret = fmax(ret, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>读者可以自行比对上面的代码与此前第 84 题的代码的相似之处。</p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>O(mn)，其中 m 和 n 分别是矩阵的行数和列数。计算 left 矩阵需要 O(mn) 的时间；对每一列应用柱状图算法需要 O(m) 的时间，一共需要 O(mn) 的时间。</p><p>空间复杂度：</p><p>O(mn)，其中 m 和 n 分别是矩阵的行数和列数。我们分配了一个与给定矩阵等大的数组，用于存储每个元素的左边连续 1 的数量。</p><h1 id="方法三：单调栈优化"><a href="#方法三：单调栈优化" class="headerlink" title="方法三：单调栈优化"></a>方法三：单调栈优化</h1><p>参考84题的优化方法</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maximalRectangle(char[][] matrix) &#123;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        if (row == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int[][] num = new int[row][col];</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                num[i][j] = matrix[i][j] - &#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //原地修改矩阵，使其每行都是柱状图的高度</span><br><span class="line">        for (int i = 1; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                num[i][j] = num[i][j] == 0 ? 0 : num[i - 1][j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxarea = 0;</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            maxarea = Math.max(maxarea, largestRectangleArea(num[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        int len = heights.length;</span><br><span class="line">        int[] left = new int[len];</span><br><span class="line">        int[] right = new int[len];</span><br><span class="line">        Arrays.fill(right, len);</span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            while (!mono_stack.isEmpty() &amp;&amp; heights[i] &lt;= heights[mono_stack.peek()]) &#123;</span><br><span class="line">                right[mono_stack.pop()] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = mono_stack.isEmpty() ? -1 : mono_stack.peek();</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int maxarea = 0;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            maxarea = Math.max(maxarea, heights[i] * (right[i] - left[i] - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年2月" scheme="http://yoursite.com/categories/2022%E5%B9%B42%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
    <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
    <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github搭建个人博客问题总结</title>
    <link href="http://yoursite.com/2022/02/17/Hexo%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/02/17/Hexo%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-02-17T06:12:12.000Z</published>
    <updated>2022-03-08T02:49:20.811Z</updated>
    
    <content type="html"><![CDATA[<p>总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法</p><span id="more"></span><p>[TOC]</p><h1 id="Mac-上配置多个git账号"><a href="#Mac-上配置多个git账号" class="headerlink" title="Mac 上配置多个git账号"></a>Mac 上配置多个git账号</h1><p><a href="https://www.jianshu.com/p/698f82e72415">https://www.jianshu.com/p/698f82e72415</a></p><p>此处将公司gitlab地址假设为company.cn</p><pre><code>ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitlab -C &quot;yiyeli@company.cn&quot;ssh-keygen -t rsa -f ~/.ssh/id_rsa_github -C &quot;15652771941@163.com&quot;ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitee -C &quot;15652771941@163.com&quot;ssh -T git@company.cnssh -T git@gitee.comssh -T git@github.comssh: connect to host github.com port 22: Operation timed out</code></pre><p>连接其它git时都成功了，只有github报错，可以换个端口,在github下加一栏 Port 443，但还是没作用</p><pre><code>#公司Host gitlab.company.corpHostname gitlab.company.corpIdentityFile ~/.ssh/id_rsa_gitlabUser gitlabLoginName  #个人githubHost github.comHostname github.comIdentityFile ~/.ssh/id_rsa_githubUser githubLoginName# Port 443#个人giteeHost gitee.comHostname gitee.comIdentityFile ~/.ssh/id_rsa_giteeUser giteeLoginName</code></pre><h2 id="使用公司gitlab时出错"><a href="#使用公司gitlab时出错" class="headerlink" title="使用公司gitlab时出错"></a>使用公司gitlab时出错</h2><pre><code>Total 10 (delta 4), reused 0 (delta 0), pack-reused 0remote: git rev-list xxxx--after=&#39;2021-11-29 15:55:00&#39;        remote: GL-HOOK-ERR: 6xxxx的提交者xxxx@163.com不是公司邮箱，请修改您的邮箱为公司邮箱,若仍无法解决，请提交jira工单:remote: error: hook declined to update refs/heads/feature-chinese2022        error: failed to push some refs to &#39;gitlab.company.corp:ce-datamonitorsystem/grafana.git&#39;</code></pre><p>从错误原因可以看到是提交的邮箱错误，原因是第一次commit时IDE会弹出一个Git User Name Is Not Defined的窗口，填完用户名和邮箱后会默认将Set properties globally的选项打上勾，这样在配置多个git账户时就会出错，因为邮箱等参数不能是全局一致的，记得每次把这个Set properties globally选项去掉就好了。</p><h1 id="问题：本地同时配置多个github账号导致博客部署失败"><a href="#问题：本地同时配置多个github账号导致博客部署失败" class="headerlink" title="问题：本地同时配置多个github账号导致博客部署失败"></a>问题：本地同时配置多个github账号导致博客部署失败</h1><p>因为本地同时配置有两个github账号，在Hexo+github搭建个人博客部署到账号A成功后用相同方式部署到账号B时执行hexo d时出现问题</p><pre><code>remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &#39;https://github.com/B/B.github.io.git/&#39;: The requested URL returned error: 403FATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: remote: Permission to B/B.github.io.git denied to A.fatal: unable to access &#39;https://github.com/B/B.github.io.git/&#39;: The requested URL returned error: 403</code></pre><p>原因是在缺省设置下，github page只有该page对应的账号A才能push，为了解决该问题，在hexo的 _config.yml部署的repo地址改用ssh而不是用https，同时对ssh地址做Host别名替换，原有repo地址为repository: <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:Name&#x2F;Name.github.io.git，替换为repository: git@B:Name&#x2F;Name.github.io.git。<br>在原有的~.ssh\config中配置内容如下：</p><pre><code># 该配置用于账户AHost A # Host 服务器别名HostName github.com  # HostName 服务器ip地址或机器名User A # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa # IdentityFile 密匙文件的具体路径# 该配置用于账户BHost B # Host 服务器别名HostName github.com # HostName 服务器ip地址或机器名User B # User连接服务器的用户名IdentityFile C:\Users\yiye\.ssh\id_rsa_new # IdentityFile 密匙文件的具体路径</code></pre><p>这样ssh解析的时候就会自动把B转换为 github.com，push的时候系统就会根据不同的仓库地址使用不同的账号提交</p><h1 id="问题：历史删除文件仍存在于repository中"><a href="#问题：历史删除文件仍存在于repository中" class="headerlink" title="问题：历史删除文件仍存在于repository中"></a>问题：历史删除文件仍存在于repository中</h1><p>原本删除的文件仍存在于生成的blog\public中，这是因为没有执行hexo clean命令</p><p>##问题3：Hexo deploy 发布不成功<br>始终停留在</p><pre><code>nothing to commit (working directory clean)</code></pre><p>Hexo的issue中有提到这个问题哦，原因就是第一次设置错了，然后即使正确设置 Repository 再次 Deploy 的时候它也会报错：nothing to commit, working directory clean；error: src refspec master does not match any。所以，当重新设置 Repo 的时候要把 .deploy_git&#x2F; 文件夹删掉，让 Hexo 再次初始化，否则 Hexo 只是执行 push 操作，所以会一直报错。解决方法是删除.deploy_git</p><pre><code>rm -rf .deploy_githexo generaterhexo deploy</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结Hexo+github搭建个人博客过程中两个费时较长的问题及其解决方法&lt;/p&gt;</summary>
    
    
    
    <category term="2022年2月" scheme="http://yoursite.com/categories/2022%E5%B9%B42%E6%9C%88/"/>
    
    
    <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
    <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
    <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>312. 戳气球</title>
    <link href="http://yoursite.com/2022/01/18/312.%20%E6%88%B3%E6%B0%94%E7%90%83%E4%BA%8C%E5%88%B7/"/>
    <id>http://yoursite.com/2022/01/18/312.%20%E6%88%B3%E6%B0%94%E7%90%83%E4%BA%8C%E5%88%B7/</id>
    <published>2022-01-18T15:50:12.000Z</published>
    <updated>2022-01-18T15:54:23.897Z</updated>
    
    <content type="html"><![CDATA[<p>求所能获得硬币的最大数量。</p><span id="more"></span><p>[TOC]</p><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例 1：</p><pre><code>输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,5]输出：10</code></pre><p>提示：</p><pre><code>n == nums.length1 &lt;= n &lt;= 5000 &lt;= nums[i] &lt;= 100</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode-cn.com/problems/burst-balloons/solution/chuo-qi-qiu-by-leetcode-solution/">^1</a></h1><p>为了方便处理，我们对 nums 数组稍作处理，将其两边各加上题目中假设存在的 nums[n] ，并保存在 val 数组中，即 val[i]&#x3D;nums[i−1] 。之所以这样处理是为了处理 nums[−1] ，防止下标越界。</p><p>下文中的区间均指数组 val 上的区间。</p><h1 id="方法一：记忆化搜索"><a href="#方法一：记忆化搜索" class="headerlink" title="方法一：记忆化搜索"></a>方法一：记忆化搜索</h1><h2 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>我们观察戳气球的操作，发现这会导致两个气球从不相邻变成相邻，使得后续操作难以处理。于是我们倒过来看这些操作，将全过程看作是每次添加一个气球。</p><p>我们定义方法 solve，令 solve(i,j) 表示将开区间 (i,j) 内的位置全部填满气球能够得到的最多硬币数。由于是开区间，因此区间两端的气球的编号就是 i 和 j，对应着 val[i] 和 val[j]。</p><p>当 i≥j−1 时，开区间中没有气球，solve(i,j) 的值为 0；</p><p>当 i&lt;j−1 时，我们枚举开区间 (i,j) 内的全部位置 mid，令 mid 为当前区间第一个添加的气球，该操作能得到的硬币数为 val[i]×val[mid]×val[j]。同时我们递归地计算分割出的两区间对 solve(i,j) 的贡献，这三项之和的最大值，即为 solve(i,j) 的值。这样问题就转化为求 solve(i,mid) 和 solve(mid,j) ，可以写出方程：</p><pre><code>if i&lt;j−1solve(i,j)=max(mid in (i+1, j−1)) val[i]×val[mid]×val[j]+solve(i,mid)+solve(mid,j),if i≥j−1solve(i,j)=0,</code></pre><p>为了防止重复计算，我们存储 solve 的结果，使用记忆化搜索的方法优化时间复杂度。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; rec;</span><br><span class="line">    vector&lt;int&gt; val;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int solve(int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right - 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rec[left][right] != -1) &#123;</span><br><span class="line">            return rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = left + 1; i &lt; right; i++) &#123;</span><br><span class="line">            int sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        val.resize(n + 2);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        rec.resize(n + 2, vector&lt;int&gt;(n + 2, -1));</span><br><span class="line">        return solve(0, n + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] rec;</span><br><span class="line">    public int[] val;</span><br><span class="line"></span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        val = new int[n + 2];</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        rec = new int[n + 2][n + 2];</span><br><span class="line">        for (int i = 0; i &lt;= n + 1; i++) &#123;</span><br><span class="line">            Arrays.fill(rec[i], -1);</span><br><span class="line">        &#125;</span><br><span class="line">        return solve(0, n + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int solve(int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right - 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rec[left][right] != -1) &#123;</span><br><span class="line">            return rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = left + 1; i &lt; right; i++) &#123;</span><br><span class="line">            int sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxCoins(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        val = [1] + nums + [1]</span><br><span class="line">        </span><br><span class="line">        @lru_cache(None)</span><br><span class="line">        def solve(left: int, right: int) -&gt; int:</span><br><span class="line">            if left &gt;= right - 1:</span><br><span class="line">                return 0</span><br><span class="line">            </span><br><span class="line">            best = 0</span><br><span class="line">            for i in range(left + 1, right):</span><br><span class="line">                total = val[left] * val[i] * val[right]</span><br><span class="line">                total += solve(left, i) + solve(i, right)</span><br><span class="line">                best = max(best, total)</span><br><span class="line">            </span><br><span class="line">            return best</span><br><span class="line"></span><br><span class="line">        return solve(0, n + 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">func maxCoins(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    val := make([]int, n + 2)</span><br><span class="line">    for i := 1; i &lt;= n; i++ &#123;</span><br><span class="line">        val[i] = nums[i - 1]</span><br><span class="line">    &#125;</span><br><span class="line">    val[0], val[n+1] = 1, 1</span><br><span class="line">    rec := make([][]int, n + 2)</span><br><span class="line">    for i := 0; i &lt; len(rec); i++ &#123;</span><br><span class="line">        rec[i] = make([]int, n + 2)</span><br><span class="line">        for j := 0; j &lt; len(rec[i]); j++ &#123;</span><br><span class="line">            rec[i][j] = -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return solve(0, n + 1, val, rec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func solve(left, right int, val []int, rec [][]int) int &#123;</span><br><span class="line">    if left &gt;= right - 1 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    if rec[left][right] != -1 &#123;</span><br><span class="line">        return rec[left][right]</span><br><span class="line">    &#125;</span><br><span class="line">    for i := left + 1; i &lt; right; i++ &#123;</span><br><span class="line">        sum := val[left] * val[i] * val[right]</span><br><span class="line">        sum += solve(left, i, val, rec) + solve(i, right, val, rec)</span><br><span class="line">        rec[left][right] = max(rec[left][right], sum)</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[left][right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int rec[502][502];</span><br><span class="line">int val[502];</span><br><span class="line">int solve(int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rec[left][right] != -1) &#123;</span><br><span class="line">        return rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = left + 1; i &lt; right; i++) &#123;</span><br><span class="line">        int sum = val[left] * val[i] * val[right];</span><br><span class="line">        sum += solve(left, i) + solve(i, right);</span><br><span class="line">        rec[left][right] = fmax(rec[left][right], sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxCoins(int* nums, int numsSize) &#123;</span><br><span class="line">    memset(rec, -1, sizeof(rec));</span><br><span class="line">    val[0] = val[numsSize + 1] = 1;</span><br><span class="line">    for (int i = 1; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        val[i] = nums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return solve(0, numsSize + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^3)，其中 n 是气球数量。区间数为 n^2 ，区间迭代复杂度为 O(n)，最终复杂度为 O(n^2 × n)&#x3D;O(n^3)。</p><p>空间复杂度：O(n^2)，其中 n 是气球数量。缓存大小为区间的个数。</p><h1 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h1><h2 id="思路及算法-1"><a href="#思路及算法-1" class="headerlink" title="思路及算法"></a>思路及算法</h2><p>按照方法一的思路，我们发现我们可以通过变换计算顺序，从「自顶向下」的记忆化搜索变为「自底向上」的动态规划。</p><p>令 dp[i][j] 表示填满开区间 (i,j) 能得到的最多硬币数，那么边界条件是 i≥j−1，此时有 dp[i][j]&#x3D;0。</p><p>可以写出状态转移方程：</p><pre><code>if i&lt;j−1dp[i][j]=max(k in (i+1, j−1)) val[i]×val[k]×val[j]+dp[i][k]+dp[k][j]if i≥j−1dp[i][j]=0,</code></pre><p>最终答案即为 dp[0][n+1]。实现时要注意到动态规划的次序。</p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; rec(n + 2, vector&lt;int&gt;(n + 2));</span><br><span class="line">        vector&lt;int&gt; val(n + 2);</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i + 2; j &lt;= n + 1; j++) &#123;</span><br><span class="line">                for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                    int sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[0][n + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxCoins(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[][] rec = new int[n + 2][n + 2];</span><br><span class="line">        int[] val = new int[n + 2];</span><br><span class="line">        val[0] = val[n + 1] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i + 2; j &lt;= n + 1; j++) &#123;</span><br><span class="line">                for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                    int sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = Math.max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rec[0][n + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxCoins(self, nums: List[int]) -&gt; int:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        rec = [[0] * (n + 2) for _ in range(n + 2)]</span><br><span class="line">        val = [1] + nums + [1]</span><br><span class="line"></span><br><span class="line">        for i in range(n - 1, -1, -1):</span><br><span class="line">            for j in range(i + 2, n + 2):</span><br><span class="line">                for k in range(i + 1, j):</span><br><span class="line">                    total = val[i] * val[k] * val[j]</span><br><span class="line">                    total += rec[i][k] + rec[k][j]</span><br><span class="line">                    rec[i][j] = max(rec[i][j], total)</span><br><span class="line">        </span><br><span class="line">        return rec[0][n + 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func maxCoins(nums []int) int &#123;</span><br><span class="line">    n := len(nums)</span><br><span class="line">    rec := make([][]int, n + 2)</span><br><span class="line">    for i := 0; i &lt; n + 2; i++ &#123;</span><br><span class="line">        rec[i] = make([]int, n + 2)</span><br><span class="line">    &#125;</span><br><span class="line">    val := make([]int, n + 2)</span><br><span class="line">    val[0], val[n+1] = 1, 1</span><br><span class="line">    for i := 1; i &lt;= n; i++ &#123;</span><br><span class="line">        val[i] = nums[i-1]</span><br><span class="line">    &#125;</span><br><span class="line">    for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">        for j := i + 2; j &lt;= n + 1; j++ &#123;</span><br><span class="line">            for k := i + 1; k &lt; j; k++ &#123;</span><br><span class="line">                sum := val[i] * val[k] * val[j]</span><br><span class="line">                sum += rec[i][k] + rec[k][j]</span><br><span class="line">                rec[i][j] = max(rec[i][j], sum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[0][n+1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(x, y int) int &#123;</span><br><span class="line">    if x &gt; y &#123;</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int maxCoins(int* nums, int numsSize) &#123;</span><br><span class="line">    int rec[numsSize + 2][numsSize + 2];</span><br><span class="line">    memset(rec, 0, sizeof(rec));</span><br><span class="line">    int val[numsSize + 2];</span><br><span class="line">    val[0] = val[numsSize + 1] = 1;</span><br><span class="line">    for (int i = 1; i &lt;= numsSize; i++) &#123;</span><br><span class="line">        val[i] = nums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = numsSize - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (int j = i + 2; j &lt;= numsSize + 1; j++) &#123;</span><br><span class="line">            for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                int sum = val[i] * val[k] * val[j];</span><br><span class="line">                sum += rec[i][k] + rec[k][j];</span><br><span class="line">                rec[i][j] = fmax(rec[i][j], sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rec[0][numsSize + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^3)，其中 n 是气球数量。状态数为 n^2 ，状态转移复杂度为 O(n)，最终复杂度为 O(n^2 × n)&#x3D;O(n^3)。</p><p>空间复杂度：O(n^2)，其中 n 是气球数量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;求所能获得硬币的最大数量。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>114. 二叉树展开为链表</title>
    <link href="http://yoursite.com/2022/01/18/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/01/18/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-18T15:12:12.000Z</published>
    <updated>2022-01-18T15:06:19.158Z</updated>
    
    <content type="html"><![CDATA[<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><span id="more"></span><p>[TOC]</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</p><p>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p>示例 1：</p><pre><code>输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6]</code></pre><p>示例 2：</p><pre><code>输入：root = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：root = [0]输出：[0]</code></pre><p>提示：</p><pre><code>树中结点数在范围 [0, 2000] 内-100 &lt;= Node.val &lt;= 100</code></pre><p>进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？</p><h1 id="方法一：前序遍历-1"><a href="#方法一：前序遍历-1" class="headerlink" title="方法一：前序遍历^1"></a>方法一：前序遍历<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/">^1</a></h1><p>将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。</p><p>对二叉树的前序遍历不熟悉的读者请自行练习「144. 二叉树的前序遍历」。</p><p>前序遍历可以通过递归或者迭代的方式实现。以下代码通过递归实现前序遍历。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        int size = list.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode prev = list.get(i - 1), curr = list.get(i);</span><br><span class="line">            prev.left = null;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preorderTraversal(TreeNode root, List&lt;TreeNode&gt; list) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; l;</span><br><span class="line">        preorderTraversal(root, l);</span><br><span class="line">        int n = l.size();</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode *prev = l.at(i - 1), *curr = l.at(i);</span><br><span class="line">            prev-&gt;left = nullptr;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preorderTraversal(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) &#123;</span><br><span class="line">        if (root != NULL) &#123;</span><br><span class="line">            l.push_back(root);</span><br><span class="line">            preorderTraversal(root-&gt;left, l);</span><br><span class="line">            preorderTraversal(root-&gt;right, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    list := preorderTraversal(root)</span><br><span class="line">    for i := 1; i &lt; len(list); i++ &#123;</span><br><span class="line">        prev, curr := list[i-1], list[i]</span><br><span class="line">        prev.Left, prev.Right = nil, curr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func preorderTraversal(root *TreeNode) []*TreeNode &#123;</span><br><span class="line">    list := []*TreeNode&#123;&#125;</span><br><span class="line">    if root != nil &#123;</span><br><span class="line">        list = append(list, root)</span><br><span class="line">        list = append(list, preorderTraversal(root.Left)...)</span><br><span class="line">        list = append(list, preorderTraversal(root.Right)...)</span><br><span class="line">    &#125;</span><br><span class="line">    return list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        preorderList = list()</span><br><span class="line"></span><br><span class="line">        def preorderTraversal(root: TreeNode):</span><br><span class="line">            if root:</span><br><span class="line">                preorderList.append(root)</span><br><span class="line">                preorderTraversal(root.left)</span><br><span class="line">                preorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        preorderTraversal(root)</span><br><span class="line">        size = len(preorderList)</span><br><span class="line">        for i in range(1, size):</span><br><span class="line">            prev, curr = preorderList[i - 1], preorderList[i]</span><br><span class="line">            prev.left = None</span><br><span class="line">            prev.right = curr</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    const list = [];</span><br><span class="line">    preorderTraversal(root, list);</span><br><span class="line">    const size = list.length;</span><br><span class="line">    for (let i = 1; i &lt; size; i++) &#123;</span><br><span class="line">        const prev = list[i - 1], curr = list[i];</span><br><span class="line">        prev.left = null;</span><br><span class="line">        prev.right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const preorderTraversal = (root, list) =&gt; &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        list.push(root);</span><br><span class="line">        preorderTraversal(root.left, list);</span><br><span class="line">        preorderTraversal(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line"></span><br><span class="line">void flatten(struct TreeNode* root) &#123;</span><br><span class="line">    num = 0;</span><br><span class="line">    struct TreeNode** l = (struct TreeNode**)malloc(0);</span><br><span class="line">    preorderTraversal(root, &amp;l);</span><br><span class="line">    for (int i = 1; i &lt; num; i++) &#123;</span><br><span class="line">        struct TreeNode *prev = l[i - 1], *curr = l[i];</span><br><span class="line">        prev-&gt;left = NULL;</span><br><span class="line">        prev-&gt;right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    free(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preorderTraversal(struct TreeNode* root, struct TreeNode*** l) &#123;</span><br><span class="line">    if (root != NULL) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        (*l) = (struct TreeNode**)realloc((*l), sizeof(struct TreeNode*) * num);</span><br><span class="line">        (*l)[num - 1] = root;</span><br><span class="line">        preorderTraversal(root-&gt;left, l);</span><br><span class="line">        preorderTraversal(root-&gt;right, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>以下代码通过迭代实现前序遍历。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        while (node != null || !stack.isEmpty()) &#123;</span><br><span class="line">            while (node != null) &#123;</span><br><span class="line">                list.add(node);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = list.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode prev = list.get(i - 1), curr = list.get(i);</span><br><span class="line">            prev.left = null;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        auto v = vector&lt;TreeNode*&gt;();</span><br><span class="line">        auto stk = stack&lt;TreeNode*&gt;();</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        while (node != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                v.push_back(node);</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top(); stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = v.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">            auto prev = v.at(i - 1), curr = v.at(i);</span><br><span class="line">            prev-&gt;left = nullptr;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Go</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    list := []*TreeNode&#123;&#125;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    for node != nil || len(stack) &gt; 0 &#123;</span><br><span class="line">        for node != nil &#123;</span><br><span class="line">            list = append(list, node)</span><br><span class="line">            stack = append(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack[len(stack)-1]</span><br><span class="line">        node = node.Right</span><br><span class="line">        stack = stack[:len(stack)-1]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 1; i &lt; len(list); i++ &#123;</span><br><span class="line">        prev, curr := list[i-1], list[i]</span><br><span class="line">        prev.Left, prev.Right = nil, curr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        preorderList = list()</span><br><span class="line">        stack = list()</span><br><span class="line">        node = root</span><br><span class="line"></span><br><span class="line">        while node or stack:</span><br><span class="line">            while node:</span><br><span class="line">                preorderList.append(node)</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.right</span><br><span class="line">        </span><br><span class="line">        size = len(preorderList)</span><br><span class="line">        for i in range(1, size):</span><br><span class="line">            prev, curr = preorderList[i - 1], preorderList[i]</span><br><span class="line">            prev.left = None</span><br><span class="line">            prev.right = curr</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    const list = [];</span><br><span class="line">    const stack = [];</span><br><span class="line">    let node = root;</span><br><span class="line">    while (node !== null || stack.length) &#123;</span><br><span class="line">        while (node !== null) &#123;</span><br><span class="line">            list.push(node);</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    const size = list.length;</span><br><span class="line">    for (let i = 1; i &lt; size; i++) &#123;</span><br><span class="line">        const prev = list[i - 1], curr = list[i];</span><br><span class="line">        prev.left = null;</span><br><span class="line">        prev.right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void flatten(struct TreeNode* root) &#123;</span><br><span class="line">    struct TreeNode** stk = (struct TreeNode**)malloc(0);</span><br><span class="line">    int stk_top = 0;</span><br><span class="line">    struct TreeNode** vec = (struct TreeNode**)malloc(0);</span><br><span class="line">    int vec_len = 0;</span><br><span class="line">    struct TreeNode* node = root;</span><br><span class="line">    while (node != NULL || stk_top != 0) &#123;</span><br><span class="line">        while (node != NULL) &#123;</span><br><span class="line">            vec_len++;</span><br><span class="line">            vec = (struct TreeNode**)realloc(vec, sizeof(struct TreeNode*) * vec_len);</span><br><span class="line">            vec[vec_len - 1] = node;</span><br><span class="line">            stk_top++;</span><br><span class="line">            stk = (struct TreeNode**)realloc(stk, sizeof(struct TreeNode*) * stk_top);</span><br><span class="line">            stk[stk_top - 1] = node;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stk[--stk_top];</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; vec_len; i++) &#123;</span><br><span class="line">        struct TreeNode *prev = vec[i - 1], *curr = vec[i];</span><br><span class="line">        prev-&gt;left = NULL;</span><br><span class="line">        prev-&gt;right = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    free(stk);</span><br><span class="line">    free(vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>O(n)，其中 n 是二叉树的节点数。前序遍历的时间复杂度是 O(n)，前序遍历之后，需要对每个节点更新左右子节点的信息，时间复杂度也是 O(n)。</p><p>空间复杂度：</p><p>O(n)，其中 n 是二叉树的节点数。空间复杂度取决于栈（递归调用栈或者迭代中显性使用的栈）和存储前序遍历结果的列表的大小，栈内的元素个数不会超过 n，前序遍历列表中的元素个数是 n。</p><h1 id="方法二：前序遍历和展开同步进行"><a href="#方法二：前序遍历和展开同步进行" class="headerlink" title="方法二：前序遍历和展开同步进行"></a>方法二：前序遍历和展开同步进行</h1><p>使用方法一的前序遍历，由于将节点展开之后会破坏二叉树的结构而丢失子节点的信息，因此前序遍历和展开为单链表分成了两步。能不能在不丢失子节点的信息的情况下，将前序遍历和展开为单链表同时进行？</p><p>之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历时，没有存储右子节点的信息，在遍历完左子树之后才获得右子节点的信息。只要对前序遍历进行修改，在遍历左子树之前就获得左右子节点的信息，并存入栈内，子节点的信息就不会丢失，就可以将前序遍历和展开为单链表同时进行。</p><p>该做法不适用于递归实现的前序遍历，只适用于迭代实现的前序遍历。修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则依次将右子节点和左子节点压入栈内（注意入栈顺序）。</p><p>展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode prev = null;</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode curr = stack.pop();</span><br><span class="line">            if (prev != null) &#123;</span><br><span class="line">                prev.left = null;</span><br><span class="line">                prev.right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode left = curr.left, right = curr.right;</span><br><span class="line">            if (right != null) &#123;</span><br><span class="line">                stack.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left != null) &#123;</span><br><span class="line">                stack.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        auto stk = stack&lt;TreeNode*&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        TreeNode *prev = nullptr;</span><br><span class="line">        while (!stk.empty()) &#123;</span><br><span class="line">            TreeNode *curr = stk.top(); stk.pop();</span><br><span class="line">            if (prev != nullptr) &#123;</span><br><span class="line">                prev-&gt;left = nullptr;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *left = curr-&gt;left, *right = curr-&gt;right;</span><br><span class="line">            if (right != nullptr) &#123;</span><br><span class="line">                stk.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left != nullptr) &#123;</span><br><span class="line">                stk.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line">    var prev *TreeNode</span><br><span class="line">    for len(stack) &gt; 0 &#123;</span><br><span class="line">        curr := stack[len(stack)-1]</span><br><span class="line">        stack = stack[:len(stack)-1]</span><br><span class="line">        if prev != nil &#123;</span><br><span class="line">            prev.Left, prev.Right = nil, curr</span><br><span class="line">        &#125;</span><br><span class="line">        left, right := curr.Left, curr.Right</span><br><span class="line">        if right != nil &#123;</span><br><span class="line">            stack = append(stack, right)</span><br><span class="line">        &#125;</span><br><span class="line">        if left != nil &#123;</span><br><span class="line">            stack = append(stack, left)</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        if not root:</span><br><span class="line">            return</span><br><span class="line">        </span><br><span class="line">        stack = [root]</span><br><span class="line">        prev = None</span><br><span class="line">        </span><br><span class="line">        while stack:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            if prev:</span><br><span class="line">                prev.left = None</span><br><span class="line">                prev.right = curr</span><br><span class="line">            left, right = curr.left, curr.right</span><br><span class="line">            if right:</span><br><span class="line">                stack.append(right)</span><br><span class="line">            if left:</span><br><span class="line">                stack.append(left)</span><br><span class="line">            prev = curr</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    const stack = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    let prev = null;</span><br><span class="line">    while (stack.length) &#123;</span><br><span class="line">        const curr = stack.pop();</span><br><span class="line">        if (prev !== null) &#123;</span><br><span class="line">            prev.left = null;</span><br><span class="line">            prev.right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        const left = curr.left, right = curr.right;</span><br><span class="line">        if (right !== null) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (left !== null) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void flatten(struct TreeNode *root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    struct TreeNode **stk = (struct TreeNode **)malloc(sizeof(struct TreeNode *));</span><br><span class="line">    int stk_top = 1;</span><br><span class="line">    stk[0] = root;</span><br><span class="line">    struct TreeNode *prev = NULL;</span><br><span class="line">    while (stk_top != 0) &#123;</span><br><span class="line">        struct TreeNode *curr = stk[--stk_top];</span><br><span class="line">        if (prev != NULL) &#123;</span><br><span class="line">            prev-&gt;left = NULL;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        struct TreeNode *left = curr-&gt;left, *right = curr-&gt;right;</span><br><span class="line">        if (right != NULL) &#123;</span><br><span class="line">            stk_top++;</span><br><span class="line">            stk = (struct TreeNode **)realloc(stk, sizeof(struct TreeNode *) * stk_top);</span><br><span class="line">            stk[stk_top - 1] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left != NULL) &#123;</span><br><span class="line">            stk_top++;</span><br><span class="line">            stk = (struct TreeNode **)realloc(stk, sizeof(struct TreeNode *) * stk_top);</span><br><span class="line">            stk[stk_top - 1] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    free(stk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。前序遍历的时间复杂度是 O(n)，前序遍历的同时对每个节点更新左右子节点的信息，更新子节点信息的时间复杂度是 O(1)，因此总时间复杂度是 O(n)。</p><p>空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度取决于栈的大小，栈内的元素个数不会超过 n。</p><h1 id="方法三：寻找前驱节点"><a href="#方法三：寻找前驱节点" class="headerlink" title="方法三：寻找前驱节点"></a>方法三：寻找前驱节点</h1><p>前两种方法都借助前序遍历，前序遍历过程中需要使用栈存储节点。有没有空间复杂度是 O(1) 的做法呢？</p><p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p><p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        while (curr != null) &#123;</span><br><span class="line">            if (curr.left != null) &#123;</span><br><span class="line">                TreeNode next = curr.left;</span><br><span class="line">                TreeNode predecessor = next;</span><br><span class="line">                while (predecessor.right != null) &#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor.right = curr.right;</span><br><span class="line">                curr.left = null;</span><br><span class="line">                curr.right = next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *curr = root;</span><br><span class="line">        while (curr != nullptr) &#123;</span><br><span class="line">            if (curr-&gt;left != nullptr) &#123;</span><br><span class="line">                auto next = curr-&gt;left;</span><br><span class="line">                auto predecessor = next;</span><br><span class="line">                while (predecessor-&gt;right != nullptr) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor-&gt;right = curr-&gt;right;</span><br><span class="line">                curr-&gt;left = nullptr;</span><br><span class="line">                curr-&gt;right = next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func flatten(root *TreeNode)  &#123;</span><br><span class="line">    curr := root</span><br><span class="line">    for curr != nil &#123;</span><br><span class="line">        if curr.Left != nil &#123;</span><br><span class="line">            next := curr.Left</span><br><span class="line">            predecessor := next</span><br><span class="line">            for predecessor.Right != nil &#123;</span><br><span class="line">                predecessor = predecessor.Right</span><br><span class="line">            &#125;</span><br><span class="line">            predecessor.Right = curr.Right</span><br><span class="line">            curr.Left, curr.Right = nil, next</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.Right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        curr = root</span><br><span class="line">        while curr:</span><br><span class="line">            if curr.left:</span><br><span class="line">                predecessor = nxt = curr.left</span><br><span class="line">                while predecessor.right:</span><br><span class="line">                    predecessor = predecessor.right</span><br><span class="line">                predecessor.right = curr.right</span><br><span class="line">                curr.left = None</span><br><span class="line">                curr.right = nxt</span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var flatten = function(root) &#123;</span><br><span class="line">    let curr = root;</span><br><span class="line">    while (curr !== null) &#123;</span><br><span class="line">        if (curr.left !== null) &#123;</span><br><span class="line">            const next = curr.left;</span><br><span class="line">            let predecessor = next;</span><br><span class="line">            while (predecessor.right !== null) &#123;</span><br><span class="line">                predecessor = predecessor.right;</span><br><span class="line">            &#125;</span><br><span class="line">            predecessor.right = curr.right;</span><br><span class="line">            curr.left = null;</span><br><span class="line">            curr.right = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void flatten(struct TreeNode* root) &#123;</span><br><span class="line">    struct TreeNode* curr = root;</span><br><span class="line">    while (curr != NULL) &#123;</span><br><span class="line">        if (curr-&gt;left != NULL) &#123;</span><br><span class="line">            struct TreeNode* next = curr-&gt;left;</span><br><span class="line">            struct TreeNode* predecessor = next;</span><br><span class="line">            while (predecessor-&gt;right != NULL) &#123;</span><br><span class="line">                predecessor = predecessor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            predecessor-&gt;right = curr-&gt;right;</span><br><span class="line">            curr-&gt;left = NULL;</span><br><span class="line">            curr-&gt;right = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。展开为单链表的过程中，需要对每个节点访问一次，在寻找前驱节点的过程中，每个节点最多被额外访问一次。</p><p>空间复杂度：O(1)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你二叉树的根结点 root ，请你将它展开为一个单链表：&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
    <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="http://yoursite.com/2022/01/18/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2022/01/18/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-01-18T10:12:12.000Z</published>
    <updated>2022-01-18T15:04:46.678Z</updated>
    
    <content type="html"><![CDATA[<p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：root = [1,null,2,3]输出：[3,2,1]</code></pre><p>示例 2：</p><pre><code>输入：root = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：root = [1]输出：[1]</code></pre><p>提示：</p><pre><code>树中节点的数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100</code></pre><p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>首先我们需要了解什么是二叉树的后序遍历：按照访问左子树——右子树——根节点的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。</p><p>定义 postorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要递归调用 postorder(root-&gt;left) 来遍历 root 节点的左子树，然后递归调用 postorder(root-&gt;right) 来遍历 root 节点的右子树，最后将 root 节点的值加入答案即可，递归终止的条件为碰到空节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void postorder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root-&gt;left, res);</span><br><span class="line">        postorder(root-&gt;right, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void postorder(TreeNode root, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, res);</span><br><span class="line">        postorder(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        def postorder(root: TreeNode):</span><br><span class="line">            if not root:</span><br><span class="line">                return</span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        res = list()</span><br><span class="line">        postorder(root)</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func postorderTraversal(root *TreeNode) (res []int) &#123;</span><br><span class="line">    var postorder func(*TreeNode)</span><br><span class="line">    postorder = func(node *TreeNode) &#123;</span><br><span class="line">        if node == nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.Left)</span><br><span class="line">        postorder(node.Right)</span><br><span class="line">        res = append(res, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void postorder(struct TreeNode *root, int *res, int *resSize) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root-&gt;left, res, resSize);</span><br><span class="line">    postorder(root-&gt;right, res, resSize);</span><br><span class="line">    res[(*resSize)++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *postorderTraversal(struct TreeNode *root, int *returnSize) &#123;</span><br><span class="line">    int *res = malloc(sizeof(int) * 2001);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    postorder(root, res, returnSize);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。<br>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)</p><h1 id="方法二：迭代-1"><a href="#方法二：迭代-1" class="headerlink" title="方法二：迭代^1"></a>方法二：迭代<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/">^1</a></h1><h2 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = nullptr;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            if (root-&gt;right == nullptr || root-&gt;right == prev) &#123;</span><br><span class="line">                res.emplace_back(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = nullptr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = null;</span><br><span class="line">        while (root != null || !stack.isEmpty()) &#123;</span><br><span class="line">            while (root != null) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            //右子树为空或者已经遍历过</span><br><span class="line">            if (root.right == null || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        if not root:</span><br><span class="line">            return list()</span><br><span class="line">        </span><br><span class="line">        res = list()</span><br><span class="line">        stack = list()</span><br><span class="line">        prev = None</span><br><span class="line"></span><br><span class="line">        while root or stack:</span><br><span class="line">            while root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            if not root.right or root.right == prev:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                prev = root</span><br><span class="line">                root = None</span><br><span class="line">            else:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">        </span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func postorderTraversal(root *TreeNode) (res []int) &#123;</span><br><span class="line">    stk := []*TreeNode&#123;&#125;</span><br><span class="line">    var prev *TreeNode</span><br><span class="line">    for root != nil || len(stk) &gt; 0 &#123;</span><br><span class="line">        for root != nil &#123;</span><br><span class="line">            stk = append(stk, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[len(stk)-1]</span><br><span class="line">        stk = stk[:len(stk)-1]</span><br><span class="line">        if root.Right == nil || root.Right == prev &#123;</span><br><span class="line">            res = append(res, root.Val)</span><br><span class="line">            prev = root</span><br><span class="line">            root = nil</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stk = append(stk, root)</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int *postorderTraversal(struct TreeNode *root, int *returnSize) &#123;</span><br><span class="line">    int *res = malloc(sizeof(int) * 2001);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    struct TreeNode **stk = malloc(sizeof(struct TreeNode *) * 2001);</span><br><span class="line">    int top = 0;</span><br><span class="line">    struct TreeNode *prev = NULL;</span><br><span class="line">    while (root != NULL || top &gt; 0) &#123;</span><br><span class="line">        while (root != NULL) &#123;</span><br><span class="line">            stk[top++] = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[--top];</span><br><span class="line">        if (root-&gt;right == NULL || root-&gt;right == prev) &#123;</span><br><span class="line">            res[(*returnSize)++] = root-&gt;val;</span><br><span class="line">            prev = root;</span><br><span class="line">            root = NULL;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stk[top++] = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>二叉树前中后序的递归版本属于easy题，而迭代版本通常是medium甚至是hard。</p><p>在做迭代版本之前，我建议大家先问问各类“遍历”算法的本质是什么？是最后输出的那一串有序的数字吗？数字的顺序是对的，遍历算法就是对的吗？</p><p>个人认为，以上问题的答案都应该是：否。“遍历”的本质是对内存的有序访问，失去了访问顺序，即便你用各种数据结构恢复了这个次序，遍历本身也显得毫无意义。常见的后序遍历写法中有一种已经出现在评论区了——它的思想也很简单，大家做过单词串翻转吗？</p><p>String in  &#x3D; “it is a word”</p><p>String out &#x3D; “word a is it”</p><p>这个问题有一种很优雅的写法是先reverse(in)，然后再逐词翻转——“两次反转”，最后得到的就是正确顺序。</p><p>回到二叉树后序遍历，你也可以利用这种思想，利用双向链表的addFirst，对外部次序和内含次序进行同时翻转，同样会得到一种非常”优雅”的解法，结构简单明晰，甚至还有点好背（狗头）。但是，它并没有真正实现“遍历”——仔细看会发现，该算法其实在使用一种异构的前序遍历：“中-&gt;右-&gt;左”，而非传统意义上的“中-&gt;左-&gt;右”，而这种异构也正是他的第一次反转。而第二次反转就在输出序列上。</p><p>所以本质上，这是一个“前序遍历”，而不是所谓的“后序遍历”。只有当你的各个节点以“左-&gt;右-&gt;中”的次序依次出现在迭代的loop当中时，它才是真正的后序遍历，就像官解那样。更易理解的版本。</p><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; seen = new HashSet&lt;&gt;();</span><br><span class="line">        while (root != null || !s.isEmpty()) &#123;</span><br><span class="line">            if (root == null &amp;&amp; seen.contains(s.peek())) &#123;</span><br><span class="line">                ans.add(s.pop().val);</span><br><span class="line">            &#125; else if (root == null) &#123;</span><br><span class="line">                seen.add(s.peek());</span><br><span class="line">                root = s.peek().right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p><h1 id="方法三：Morris-遍历"><a href="#方法三：Morris-遍历" class="headerlink" title="方法三：Morris 遍历"></a>方法三：Morris 遍历</h1><h2 id="思路与算法-2"><a href="#思路与算法-2" class="headerlink" title="思路与算法"></a>思路与算法</h2><p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现后序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其后序遍历规则总结如下：</p><ol><li>新建临时节点，令该节点为 root；</li><li>如果当前节点的左子节点为空，则遍历当前节点的右子节点；</li><li>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；</li></ol><ul><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。</li><li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。</li></ul><ol start="4"><li>重复步骤 2 和步骤 3，直到遍历结束。</li></ol><p>这样我们利用 Morris 遍历的方法，后序遍历该二叉搜索树，即可实现线性时间与常数空间的遍历。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode p1 = root, p2 = null;</span><br><span class="line"></span><br><span class="line">        while (p1 != null) &#123;</span><br><span class="line">            p2 = p1.left;</span><br><span class="line">            if (p2 != null) &#123;</span><br><span class="line">                while (p2.right != null &amp;&amp; p2.right != p1) &#123;</span><br><span class="line">                    p2 = p2.right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (p2.right == null) &#123;</span><br><span class="line">                    p2.right = p1;</span><br><span class="line">                    p1 = p1.left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    p2.right = null;</span><br><span class="line">                    addPath(res, p1.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(res, root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addPath(List&lt;Integer&gt; res, TreeNode node) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (node != null) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = res.size() - count, right = res.size() - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int temp = res.get(left);</span><br><span class="line">            res.set(left, res.get(right));</span><br><span class="line">            res.set(right, temp);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void addPath(vector&lt;int&gt; &amp;vec, TreeNode *node) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            vec.emplace_back(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(vec.end() - count, vec.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = nullptr;</span><br><span class="line"></span><br><span class="line">        while (p1 != nullptr) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            if (p2 != nullptr) &#123;</span><br><span class="line">                while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (p2-&gt;right == nullptr) &#123;</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    p2-&gt;right = nullptr;</span><br><span class="line">                    addPath(res, p1-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(res, root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        def addPath(node: TreeNode):</span><br><span class="line">            count = 0</span><br><span class="line">            while node:</span><br><span class="line">                count += 1</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                node = node.right</span><br><span class="line">            i, j = len(res) - count, len(res) - 1</span><br><span class="line">            while i &lt; j:</span><br><span class="line">                res[i], res[j] = res[j], res[i]</span><br><span class="line">                i += 1</span><br><span class="line">                j -= 1</span><br><span class="line">        </span><br><span class="line">        if not root:</span><br><span class="line">            return list()</span><br><span class="line">        </span><br><span class="line">        res = list()</span><br><span class="line">        p1 = root</span><br><span class="line"></span><br><span class="line">        while p1:</span><br><span class="line">            p2 = p1.left</span><br><span class="line">            if p2:</span><br><span class="line">                while p2.right and p2.right != p1:</span><br><span class="line">                    p2 = p2.right</span><br><span class="line">                if not p2.right:</span><br><span class="line">                    p2.right = p1</span><br><span class="line">                    p1 = p1.left</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    p2.right = None</span><br><span class="line">                    addPath(p1.left)</span><br><span class="line">            p1 = p1.right</span><br><span class="line">        </span><br><span class="line">        addPath(root)</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func reverse(a []int) &#123;</span><br><span class="line">    for i, n := 0, len(a); i &lt; n/2; i++ &#123;</span><br><span class="line">        a[i], a[n-1-i] = a[n-1-i], a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func postorderTraversal(root *TreeNode) (res []int) &#123;</span><br><span class="line">    addPath := func(node *TreeNode) &#123;</span><br><span class="line">        resSize := len(res)</span><br><span class="line">        for ; node != nil; node = node.Right &#123;</span><br><span class="line">            res = append(res, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res[resSize:])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1 := root</span><br><span class="line">    for p1 != nil &#123;</span><br><span class="line">        if p2 := p1.Left; p2 != nil &#123;</span><br><span class="line">            for p2.Right != nil &amp;&amp; p2.Right != p1 &#123;</span><br><span class="line">                p2 = p2.Right</span><br><span class="line">            &#125;</span><br><span class="line">            if p2.Right == nil &#123;</span><br><span class="line">                p2.Right = p1</span><br><span class="line">                p1 = p1.Left</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            p2.Right = nil</span><br><span class="line">            addPath(p1.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.Right</span><br><span class="line">    &#125;</span><br><span class="line">    addPath(root)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void addPath(int *vec, int *vecSize, struct TreeNode *node) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (node != NULL) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        vec[(*vecSize)++] = node-&gt;val;</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = (*vecSize) - count, j = (*vecSize) - 1; i &lt; j; ++i, --j) &#123;</span><br><span class="line">        int t = vec[i];</span><br><span class="line">        vec[i] = vec[j];</span><br><span class="line">        vec[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *postorderTraversal(struct TreeNode *root, int *returnSize) &#123;</span><br><span class="line">    int *res = malloc(sizeof(int) * 2001);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct TreeNode *p1 = root, *p2 = NULL;</span><br><span class="line"></span><br><span class="line">    while (p1 != NULL) &#123;</span><br><span class="line">        p2 = p1-&gt;left;</span><br><span class="line">        if (p2 != NULL) &#123;</span><br><span class="line">            while (p2-&gt;right != NULL &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                p2 = p2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            if (p2-&gt;right == NULL) &#123;</span><br><span class="line">                p2-&gt;right = p1;</span><br><span class="line">                p1 = p1-&gt;left;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p2-&gt;right = NULL;</span><br><span class="line">                addPath(res, returnSize, p1-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    addPath(res, returnSize, root);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</p><p>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
    <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
    <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>84.柱状图中最大的矩形</title>
    <link href="http://yoursite.com/2022/01/12/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://yoursite.com/2022/01/12/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2022-01-12T02:50:12.000Z</published>
    <updated>2022-02-17T15:51:36.043Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><span id="more"></span><p>[TOC]</p><p>柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p>示例1:</p><pre><code>输入: [2,1,5,6,2,3]输出: 10解释：最大的矩形为图中红色区域，面积为 10</code></pre><p>示例 2：</p><pre><code>输入： heights = [2,4]输出： 4</code></pre><p>提示：</p><pre><code>1 &lt;= heights.length &lt;=1050 &lt;= heights[i] &lt;= 104</code></pre><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言^1"></a>前言<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/">^1</a></h1><p>我们需要在柱状图中找出最大的矩形，因此我们可以考虑枚举矩形的宽和高，其中「宽」表示矩形贴着柱状图底边的宽度，「高」表示矩形在柱状图上的高度。</p><ul><li>如果我们枚举「宽」，我们可以使用两重循环枚举矩形的左右边界以固定宽度 <em>w</em>，此时矩形的高度 <em>h</em>，就是所有包含在内的柱子的「最小高度」，对应的面积为 <img src="/./p__w_times_h_.png" alt="w\timesh "> 。下面给出了这种方法的 <code>C++</code> 代码。</li></ul><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol01-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left &lt; n; ++left) &#123;</span><br><span class="line">            <span class="type">int</span> minHeight = INT_MAX;</span><br><span class="line">            <span class="comment">// 枚举右边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                <span class="comment">// 确定高度</span></span><br><span class="line">                minHeight = <span class="built_in">min</span>(minHeight, heights[right]);</span><br><span class="line">                <span class="comment">// 计算面积</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * minHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><ul><li>如果我们枚举「高」，我们可以使用一重循环枚举某一根柱子，将其固定为矩形的高度 <em>h</em>。随后我们从这跟柱子开始向两侧延伸，直到遇到高度小于 <em>h</em> 的柱子，就确定了矩形的左右边界。如果左右边界之间的宽度为 <em>w</em>，那么对应的面积为 <img src="/./p__w_times_h_.png" alt="w\timesh "> 。下面给出了这种方法的 <code>C++</code> 代码。</li></ul><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol02-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">0</span>; mid &lt; n; ++mid) &#123;</span><br><span class="line">            <span class="comment">// 枚举高</span></span><br><span class="line">            <span class="type">int</span> height = heights[mid];</span><br><span class="line">            <span class="type">int</span> left = mid, right = mid;</span><br><span class="line">            <span class="comment">// 确定左右边界</span></span><br><span class="line">            <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= height) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right + <span class="number">1</span> &lt; n &amp;&amp; heights[right + <span class="number">1</span>] &gt;= height) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算面积</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right - left + <span class="number">1</span>) * height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>可以发现，这两种暴力方法的时间复杂度均为 *O(N^2)*，会超出时间限制，我们必须要进行优化。考虑到枚举「宽」的方法使用了两重循环，本身就已经需要 <em>O(N^2)</em> 的时间复杂度，不容易优化，因此我们可以考虑优化只使用了一重循环的枚举「高」的方法。</p><h1 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h1><p><strong>思路</strong></p><p>我们归纳一下枚举「高」的方法：</p><ul><li><p>首先我们枚举某一根柱子 <em>i</em> 作为高 heights；</p></li><li><p>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 <em>h</em>。换句话说，我们需要找到<strong>左右两侧最近的高度小于 <em>h</em> 的柱子</strong>，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 <em>h</em>，并且就是 <em>i</em> 能够扩展到的最远范围。</p></li></ul><p>那么我们先来看看如何求出<strong>一根柱子的左侧且最近的小于其高度的柱子</strong>。除了根据「前言」部分暴力地进行枚举之外，我们可以通过如下的一个结论来深入地进行思考：</p><blockquote><p>对于两根柱子 <em>j_0</em> 以及 <em>j_1</em>，如果 <em>j_0 &lt; j_1* 并且<br>heights[j_0]&gt;&#x3D;heights[j_1] ，那么**对于任意的在它们之后出现的柱子 <em>i</em>（</em>j_1 &lt; i<em>），</em>j_0* 一定不会是 <em>i</em> 左侧且最近的小于其高度的柱子**。</p></blockquote><p>换句话说，如果有两根柱子 <em>j_0</em> 和 <em>j_1</em>，其中 <em>j_0</em> 在 <em>j_1</em> 的左侧，并且 <em>j_0</em> 的高度大于等于 <em>j_1</em>，那么在后面的柱子 <em>i</em> 向左找小于其高度的柱子时，<em>j_1</em> 会「挡住」<em>j_0</em>，<em>j_0</em> 就不会作为答案了。</p><p>这样以来，我们可以对数组从左向右进行遍历，同时维护一个「可能作为答案」的数据结构，其中按照从小到大的顺序存放了一些 <em>j</em> 值。根据上面的结论，如果我们存放了 j_0,j_1,…,j_s ，那么一定有 height[j_0]&lt;height[j_1]&lt;…&lt;height[j_s] ，因为如果有两个相邻的 <em>j</em> 值对应的高度不满足 <em>&lt;</em> 关系，那么后者会「挡住」前者，前者就不可能作为答案了。</p><p>当我们枚举到第 <em>i</em> 根柱子时，我们的数据结构中存放了j_0,j_1,…,j_s  ，如果第 <em>i</em> 根柱子左侧且最近的小于其高度的柱子为 <em>j_i</em>，那么必然有</p><p><img src="/./p___textit%7Bheight%7D_j_0____textit%7Bheight%7D_j_1____cdots___textit%7Bheight%7D_j_i____textit%7Bheight%7D_i__leq_textit%7Bheight%7D_j_%7Bi+1%7D____cdots___textit%7Bheight%7D_j_s___.png" alt="\textit{height}[j_0]&lt;\textit{height}[j_1]&lt;\cdots&lt;\textit{height}[j_i]&lt;\textit{height}[i]\leq\textit{height}[j_{i+1}]&lt;\cdots&lt;\textit{height}[j_s] "> </p><p>这样我们就可以使用二分查找的方法找到 <em>i</em> 对应的 <em>j_i</em>，<strong>但真的需要吗</strong>？当我们枚举到 <em>i+1</em> 时，原来的 <em>i</em> 也变成了 <em>j</em> 值，因此 <em>i</em> 会被放入数据结构。由于所有在数据结构中的 <em>j</em> 值均小于 <em>i</em>，那么所有高度大于等于 height[i] 的 <em>j</em> 都不会作为答案，需要从数据结构中移除。而我们发现，这些被移除的 <em>j</em> 值恰好就是</p><p>j_i+1,…j_s</p><p>这样我们在枚举到第 <em>i</em> 根柱子的时候，就可以先把所有高度大于等于 <img src="/./p__textit%7Bheight%7D_i__.png" alt="\textit{height}[i] ">  的 <em>j</em> 值全部移除，剩下的 <em>j</em> 值中高度最高的即为答案。在这之后，我们将 <em>i</em> 放入数据结构中，开始接下来的枚举。此时，我们需要使用的数据结构也就呼之欲出了，它就是<strong>栈</strong>。</p><ul><li><p>栈中存放了 <em>j</em> 值。从栈底到栈顶，<em>j</em> 的值严格单调递增，同时对应的高度值也严格单调递增；</p></li><li><p>当我们枚举到第 <em>i</em> 根柱子时，我们从栈顶不断地移除 <img src="/./p__textit%7Bheight%7D_j__geq_textit%7Bheight%7D_i__.png" alt="\textit{height}[j]\geq\textit{height}[i] ">  的 <em>j</em> 值。在移除完毕后，栈顶的 <em>j</em> 值就一定满足 <img src="/./p__textit%7Bheight%7D_j____textit%7Bheight%7D_i__.png" alt="\textit{height}[j]&lt;\textit{height}[i] "> ，此时 <em>j</em> 就是 <em>i</em> 左侧且最近的小于其高度的柱子。</p><ul><li>这里会有一种特殊情况。如果我们移除了栈中所有的 <em>j</em> 值，那就说明 <em>i</em> 左侧所有柱子的高度都大于 <img src="/./p__textit%7Bheight%7D_i__.png" alt="\textit{height}[i] "> ，那么我们可以认为 <em>i</em> 左侧且最近的小于其高度的柱子在位置 <em>j&#x3D;-1</em>，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。</li></ul></li><li><p>我们再将 <em>i</em> 放入栈顶。</p></li></ul><p>栈中存放的元素具有单调性，这就是经典的数据结构「单调栈」了。</p><p><strong>例子</strong></p><p>我们用一个具体的例子 <em>[6, 7, 5, 2, 4, 5, 9, 3]</em> 来帮助读者理解单调栈。我们需要求出每一根柱子的左侧且最近的小于其高度的柱子。初始时的栈为空。</p><ul><li><p>我们枚举 <em>6</em>，因为栈为空，所以 <em>6</em> 左侧的柱子是「哨兵」，位置为 -1。随后我们将 <em>6</em> 入栈。</p><ul><li>栈：<code>[6(0)]</code>。（这里括号内的数字表示柱子在原数组中的位置）</li></ul></li><li><p>我们枚举 <em>7</em>，由于 <em>6&lt;7</em>，因此不会移除栈顶元素，所以 <em>7</em> 左侧的柱子是 <em>6</em>，位置为 <em>0</em>。随后我们将 <em>7</em> 入栈。</p><ul><li>栈：<code>[6(0), 7(1)]</code></li></ul></li><li><p>我们枚举 <em>5</em>，由于 7&gt;&#x3D;5 ，因此移除栈顶元素 <em>7</em>。同样地，6&gt;&#x3D;5 ，再移除栈顶元素 <em>6</em>。此时栈为空，所以 <em>5</em> 左侧的柱子是「哨兵」，位置为 <em>-1</em>。随后我们将 <em>5</em> 入栈。</p><ul><li>栈：<code>[5(2)]</code></li></ul></li><li><p>接下来的枚举过程也大同小异。我们枚举 <em>2</em>，移除栈顶元素 <em>5</em>，得到 <em>2</em> 左侧的柱子是「哨兵」，位置为 <em>-1</em>。将 <em>2</em> 入栈。</p><ul><li>栈：<code>[2(3)]</code></li></ul></li><li><p>我们枚举 <em>4</em>，<em>5</em> 和 <em>9</em>，都不会移除任何栈顶元素，得到它们左侧的柱子分别是 <em>2</em>，<em>4</em> 和 <em>5</em>，位置分别为 <em>3</em>，<em>4</em> 和 <em>5</em>。将它们入栈。</p><ul><li>栈：<code>[2(3), 4(4), 5(5), 9(6)]</code></li></ul></li><li><p>我们枚举 <em>3</em>，依次移除栈顶元素 <em>9</em>，<em>5</em> 和 <em>4</em>，得到 <em>3</em> 左侧的柱子是 <em>2</em>，位置为 <em>3</em>。将 <em>3</em> 入栈。</p><ul><li>栈：<code>[2(3), 3(7)]</code></li></ul></li></ul><p>这样以来，我们得到它们左侧的柱子编号分别为 *[-1, 0, -1, -1, 3, 4, 5, 3]*。用相同的方法，我们从右向左进行遍历，也可以得到它们右侧的柱子编号分别为 *[2, 2, 3, 8, 7, 7, 7, 8]*，这里我们将位置 <em>8</em> 看作「哨兵」。</p><p>在得到了左右两侧的柱子之后，我们就可以计算出每根柱子对应的左右边界，并求出答案了。</p><p><strong>分析</strong></p><p>单调栈的时间复杂度是多少？直接计算十分困难，但是我们可以发现：</p><blockquote><p>每一个位置只会入栈一次（在枚举到它时），并且最多出栈一次。</p></blockquote><p>因此当我们从左向右&#x2F;总右向左遍历数组时，对栈的操作的次数就为 *O(N)*。所以单调栈的总时间复杂度为 *O(N)*。</p><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; mono_stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.<span class="built_in">empty</span>() ? n : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        left, right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            right[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> n</span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line">    left, right := <span class="built_in">make</span>([]<span class="type">int</span>, n), <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    mono_stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(mono_stack) &gt; <span class="number">0</span> &amp;&amp; heights[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] &gt;= heights[i] &#123;</span><br><span class="line">            mono_stack = mono_stack[:<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mono_stack) == <span class="number">0</span> &#123;</span><br><span class="line">            left[i] = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        mono_stack = <span class="built_in">append</span>(mono_stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    mono_stack = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(mono_stack) &gt; <span class="number">0</span> &amp;&amp; heights[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] &gt;= heights[i] &#123;</span><br><span class="line">            mono_stack = mono_stack[:<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mono_stack) == <span class="number">0</span> &#123;</span><br><span class="line">            right[i] = n</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right[i] = mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        mono_stack = <span class="built_in">append</span>(mono_stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*。</p></li><li><p>空间复杂度：*O(N)*。</p></li></ul><h1 id="方法二：单调栈-常数优化"><a href="#方法二：单调栈-常数优化" class="headerlink" title="方法二：单调栈 + 常数优化"></a>方法二：单调栈 + 常数优化</h1><p>在方法一中，我们首先从左往右对数组进行遍历，借助单调栈求出了每根柱子的左边界，随后从右往左对数组进行遍历，借助单调栈求出了每根柱子的右边界。那么我们是否可以只遍历一次就求出答案呢？</p><p>答案是可以的。在方法一中，我们在对位置 <em>i</em> 进行入栈操作时，确定了它的左边界。从直觉上来说，与之对应的我们在对位置 <em>i</em> 进行出栈操作时可以确定它的右边界！仔细想一想，这确实是对的。当位置 <em>i</em> 被弹出栈时，说明此时遍历到的位置 <em>i_0</em> 的高度<strong>小于等于</strong> height[i] ，并且在 <em>i_0</em> 与 <em>i</em> 之间没有其他高度小于等于 height[i] 的柱子。这是因为，如果在 <em>i</em> 和 <em>i_0</em> 之间还有其它位置的高度小于等于 height[i] 的，那么在遍历到那个位置的时候，<em>i</em> 应该已经被弹出栈了。所以位置 <em>i_0</em> 就是位置 <em>i</em> 的右边界。</p><p>等等，我们需要的是「一根柱子的左侧且最近的<strong>小于</strong>其高度的柱子」，但这里我们求的是<strong>小于等于</strong>，那么会造成什么影响呢？答案是：我们确实无法求出正确的右边界，但对最终的答案没有任何影响。这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么<strong>最右侧的那根柱子是可以求出正确的右边界的</strong>，而我们没有对求出左边界的算法进行任何改动，因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的。读者可以仔细思考一下这一步。</p><p>在遍历结束后，栈中仍然有一些位置，这些位置对应的右边界就是位置为 <em>n</em> 的「哨兵」。我们可以将它们依次出栈并更新右边界，也可以在初始化右边界数组时就将所有的元素的值置为 <em>n</em>。</p><p>我们沿用方法一中的例子 *[6, 7, 5, 2, 4, 5, 9, 3]*，下面的幻灯片给出了优化后的流程。</p><details>    <summary>C++</summary>    <figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; mono_stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(right, n);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.peek()] = i;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary>    <figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        left, right = [<span class="number">0</span>] * n, [n] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> heights[mono_stack[-<span class="number">1</span>]] &gt;= heights[i]:</span><br><span class="line">                right[mono_stack[-<span class="number">1</span>]] = i</span><br><span class="line">                mono_stack.pop()</span><br><span class="line">            left[i] = mono_stack[-<span class="number">1</span>] <span class="keyword">if</span> mono_stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            mono_stack.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>((right[i] - left[i] - <span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>    <figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line">    left, right := <span class="built_in">make</span>([]<span class="type">int</span>, n), <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        right[i] = n</span><br><span class="line">    &#125;</span><br><span class="line">    mono_stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(mono_stack) &gt; <span class="number">0</span> &amp;&amp; heights[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] &gt;= heights[i] &#123;</span><br><span class="line">            right[mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]] = i</span><br><span class="line">            mono_stack = mono_stack[:<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mono_stack) == <span class="number">0</span> &#123;</span><br><span class="line">            left[i] = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = mono_stack[<span class="built_in">len</span>(mono_stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        mono_stack = <span class="built_in">append</span>(mono_stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：*O(N)*。</p></li><li><p>空间复杂度：*O(N)*。</p></li></ul><h1 id="方法三：单调栈-空间优化"><a href="#方法三：单调栈-空间优化" class="headerlink" title="方法三：单调栈+空间优化"></a>方法三：单调栈+空间优化</h1><p>分析寻找的过程，如果要在O(n)的时间内找到最大的面积，则需要记录下来每个高度为N的矩形，其长度最大可以达到多少。这样就分为两种情况，如图中描述的，首先是高度N越来越大，其次是高度N越来越小。</p><ul><li><p>在高度N越来越大时，其上一个数字构成的高度的矩形的最大长度则增加1，例如，[2 3]，高度为3时，则高度为2的矩形的长度就加1. </p></li><li><p>在高度N越来越小时，其上一个数字构成的高度的矩形的最大长度就不变，例如[4 3]，高度为4时，其构成的矩形长度为1，到了3，矩形长度没有递增，而4之前的数字3构成的矩形的长度也加1。</p></li></ul><p>可以使用一个stack来存储矩形的高度和长度，其中长度会动态的变化。当遇到一个数字大于栈顶数字的时候就压入栈，小于栈顶的数字就弹出栈，在这个动态过程中，更新最大的矩形面积。</p><p><strong>重点在于每次弹出时，首先需要给heights数组加一个右边界，每次弹出时的高度heights[h]是要计算的矩形高度，右边界是i位置，左边界是从右往左第一个比高度heights[h]低的位置，如果栈为空的话左边界位置为-1，不为空则为弹出后栈顶的位置。</strong></p><details>    <summary>C++</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        heights.push_back(0);</span><br><span class="line">        int len=heights.size();</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int i=0,maxarea=0;</span><br><span class="line">        while(i&lt;len)&#123;</span><br><span class="line">            if(stk.empty() || heights[i]&gt;=heights[stk.top()]) &#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                int h=stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                maxarea=max(maxarea,heights[h]*(stk.empty()? i: i-stk.top()-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">        int len = heights.length;</span><br><span class="line">        int[] heightnew = new int[len + 1];</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            heightnew[i] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int maxarea = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt;= len) &#123;</span><br><span class="line">            if (mono_stack.isEmpty() || heightnew[mono_stack.peek()] &lt; heightnew[i]) &#123;</span><br><span class="line">                mono_stack.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int h = mono_stack.pop();</span><br><span class="line">                maxarea = Math.max(maxarea, (mono_stack.isEmpty() ? i : i - mono_stack.peek() - 1) * heightnew[h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
  <entry>
    <title>32. 最长有效括号</title>
    <link href="http://yoursite.com/2022/01/11/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2022/01/11/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</id>
    <published>2022-01-11T10:12:12.000Z</published>
    <updated>2022-01-12T01:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个只包含 ‘(‘和’)’的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><span id="more"></span><p>[TOC]</p><p>示例 1：</p><pre><code>输入：s = &quot;(()&quot;输出：2解释：最长有效括号子串是 &quot;()&quot;</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;)()())&quot;输出：4解释：最长有效括号子串是 &quot;()()&quot;</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;&quot;输出：0</code></pre><p>提示：</p><pre><code>0 &lt;= s.length &lt;= 3 * 104s[i] 为 &#39;(&#39; 或 &#39;)&#39;</code></pre><h1 id="方法一：动态规划-1"><a href="#方法一：动态规划-1" class="headerlink" title="方法一：动态规划^1"></a>方法一：动态规划<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/">^1</a></h1><p><strong>思路和算法</strong></p><details>    <summary>Java</summary>    <figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = Math.max(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>        <figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxans = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = <span class="built_in">max</span>(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>        <figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxans = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp[n];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] +</span><br><span class="line">                        ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = fmax(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>        <figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxAns := <span class="number">0</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxAns = max(maxAns, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： *O(n)*，其中 <em>n</em> 为字符串的长度。我们只需遍历整个字符串一次，即可将 dp 数组求出来。</p></li><li><p>空间复杂度： *O(n)*。我们需要一个大小为 <em>n</em> 的 dp 数组。</p></li></ul><h1 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h1><p><strong>思路和算法</strong></p><p>撇开方法一提及的动态规划方法，相信大多数人对于这题的第一直觉是找到每个可能的子串后判断它的有效性，但这样的时间复杂度会达到 *O(n^3)*，无法通过所有测试用例。但是通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。</p><p>具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p><ul><li>对于遇到的每个 ‘(’ ，我们将它的下标放入栈中</li><li>对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li></ul></li></ul><p>我们从前往后遍历字符串并更新答案即可。</p><p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 <em>-1</em> 的元素。</p><details>    <summary>Java</summary>        <figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxans = Math.max(maxans, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>        <figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxans = <span class="built_in">max</span>(maxans, i - stk.<span class="built_in">top</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>        <figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxans = <span class="number">0</span>, n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> stk[n + <span class="number">1</span>], top = <span class="number">-1</span>;</span><br><span class="line">    stk[++top] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk[++top] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --top;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">                stk[++top] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxans = fmax(maxans, i - stk[top]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>        <figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxAns := <span class="number">0</span></span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxAns = max(maxAns, i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(n)<em>，</em>n</em> 是给定字符串的长度。我们只需要遍历字符串一次即可。</p></li><li><p>空间复杂度： *O(n)*。栈的大小在最坏情况下会达到 <em>n</em>，因此空间复杂度为 <em>O(n)</em> 。</p></li></ul><h1 id="方法三：不需要额外的空间"><a href="#方法三：不需要额外的空间" class="headerlink" title="方法三：不需要额外的空间"></a>方法三：不需要额外的空间</h1><p><strong>思路和算法</strong></p><details>    <summary>Java</summary>        <figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary>        <figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary>        <figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxlength = fmax(maxlength, <span class="number">2</span> * right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left = right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxlength = fmax(maxlength, <span class="number">2</span> * left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary>        <figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right, maxLength := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            maxLength = max(maxLength, <span class="number">2</span> * right)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> right &gt; left &#123;</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            maxLength = max(maxLength, <span class="number">2</span> * left)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： *O(n)*，其中 <em>n</em> 为字符串长度。我们只要正反遍历两边字符串即可。</p></li><li><p>空间复杂度： *O(1)*。我们只需要常数空间存放若干变量。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个只包含 ‘(‘和’)’的字符串，找出最长有效（格式正确且连续）括号子串的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
    <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
    <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
    <category term="Dynammic Programming" scheme="http://yoursite.com/tags/Dynammic-Programming/"/>
    
  </entry>
  
</feed>
