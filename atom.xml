<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-01-10T08:25:55.075Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo与Nodejs版本不匹配问题解决方案</title>
    <link href="http://yoursite.com/2022/01/10/Hexo%E4%B8%8ENodejs%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2022/01/10/Hexo与Nodejs版本不匹配问题解决方案/</id>
    <published>2022-01-10T08:12:12.000Z</published>
    <updated>2022-01-10T08:25:55.075Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo与Nodejs版本不匹配问题解决方案，升级hexo或者降级nodejs</p><a id="more"></a><p>[TOC]</p><h1 id="部署hexo报错"><a href="#部署hexo报错" class="headerlink" title="部署hexo报错"></a>部署hexo报错</h1><pre><code>FATAL Something&apos;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object    at copyFile (node:fs:2774:10)</code></pre><h1 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h1><p>hexo暂时不能在新版的nodejs环境下运行</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>降级nodejs即可，卸载现有nodejs，安装旧版nodejs。</p><p>如果有nvm的话，可以直接用nvm切换版本</p><p>查看当前的node版本</p><pre><code>node -v</code></pre><p>目前是<br>v16.13.1</p><p>查看安装过的node版本 </p><pre><code>nvm list</code></pre><p>安装某个node版本 </p><pre><code>nvm install &lt;version&gt;nvm install 12</code></pre><p>使用某个node版本 </p><pre><code>nvm use&lt;version&gt;nvm use 12</code></pre><p>卸载某个node版本</p><pre><code>nvm uninstall &lt;version&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo与Nodejs版本不匹配问题解决方案，升级hexo或者降级nodejs&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（算法）</title>
    <link href="http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/07/JAVA 学习笔记（算法）/</id>
    <published>2022-01-07T10:12:12.000Z</published>
    <updated>2022-01-10T07:57:14.032Z</updated>
    
    <content type="html"><![CDATA[<p>查找，排序，回溯等算法</p><a id="more"></a><p>[TOC]</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><p>二分法模板参见笔记：</p><ol start="69"><li>x 的平方根(二分法模板题及经典解释）</li></ol><h1 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h1><p>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。</p><p>（2）这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1 个位置。</p><p>（3）N=N-1，如果 N 不为 0 就重复前面二步，否则排序完成</p><h1 id="选择排序算法-1"><a href="#选择排序算法-1" class="headerlink" title="选择排序算法^1"></a>选择排序算法<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html" target="_blank" rel="noopener">^1</a></h1><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><details>    <summary>选择排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SelectionSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        // 总共要经过 N-1 轮比较</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line"></span><br><span class="line">            // 每轮需要比较的次数 N-i</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    // 记录目前能找到的最小值元素的下标</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将找到的最小值和i位置所在的值进行交换</span><br><span class="line">            if (i != min) &#123;</span><br><span class="line">                int tmp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h1><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。</p><p>如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><details>    <summary>插入排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void sort(int arr[])&#123;</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++)&#123;</span><br><span class="line">        //插入的数</span><br><span class="line">        int insertVal = arr[i];</span><br><span class="line">        //被插入的位置(准备和前一个数比较)</span><br><span class="line">        int index = i - 1;</span><br><span class="line">        //如果插入的数比被插入的数小</span><br><span class="line">        while (index &gt;= 0 &amp;&amp; insertVal &lt; arr[index]) &#123;</span><br><span class="line">            //将把 arr[index] 向后移动</span><br><span class="line">            arr[index + 1] = arr[index];</span><br><span class="line">            //让 index 向前移动</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        //把插入的数放入合适位置</span><br><span class="line">        arr[index + 1] = insertVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h1><p>快速排序的原理：</p><p>选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</p><p>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><p>此代码仅是快排的一种写法，更多需要搜索</p><details>    <summary>快速排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void sort(int[] a, int low, int high) &#123;</span><br><span class="line">       int start = low;</span><br><span class="line">       int end = high;</span><br><span class="line">       int key = a[low];</span><br><span class="line">       while (end &gt; start) &#123;</span><br><span class="line">           //从后往前比较</span><br><span class="line">           while (end &gt; start &amp;&amp; a[end] &gt;= key) &#123;</span><br><span class="line">               //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span><br><span class="line">               end--;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[end] &lt;= key) &#123;</span><br><span class="line">               int temp = a[end];</span><br><span class="line">               a[end] = a[start];</span><br><span class="line">               a[start] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           //从前往后比较</span><br><span class="line">           while (end &gt; start &amp;&amp; a[start] &lt;= key) &#123;</span><br><span class="line">               //如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span><br><span class="line">               start++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (a[start] &gt;= key) &#123;</span><br><span class="line">               int temp = a[start];</span><br><span class="line">               a[start] = a[end];</span><br><span class="line">               a[end] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，</span><br><span class="line">           // 右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span><br><span class="line">       &#125;</span><br><span class="line">       //递归</span><br><span class="line">       if (start &gt; low) sort(a, low, start - 1);//左边序列。第一个索引位置到关键值索引-1</span><br><span class="line">       if (end &lt; high) sort(a, end + 1, high);//右边序列。从关键值索引+1 到最后一个</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><h1 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h1><p>基本思想：希尔排序，通过增量(gap)将元素分成n组，对每组使用直接插入排序算法排序。增量(gap)逐渐减少，当增量(gap)减至1时，整个数据恰被分成一组，最后进行一次插入排序。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><ol><li>操作方法：<br>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><details>    <summary>希尔排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void shellSort(int[] a) &#123;</span><br><span class="line">    int dk = a.length/2;</span><br><span class="line">    while( dk &gt;= 1 )&#123;</span><br><span class="line">        ShellInsertSort(a, dk);</span><br><span class="line">        dk = dk/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void ShellInsertSort(int[] a, int dk) &#123;</span><br><span class="line">    //类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了</span><br><span class="line">    for(int i=dk;i&lt;a.length;i++)&#123;</span><br><span class="line">        if(a[i]&lt;a[i-dk])&#123;</span><br><span class="line">            int j;</span><br><span class="line">            int x=a[i];//x 为待插入元素</span><br><span class="line">            a[i]=a[i-dk];</span><br><span class="line">            for(j=i-dk; j&gt;=0 &amp;&amp; x&lt;a[j];j=j-dk)&#123;</span><br><span class="line">                //通过循环，逐个后移一位找到要插入的位置。</span><br><span class="line">                a[j+dk]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+dk]=x;//插入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h1><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><details>    <summary>归并排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MergeSortTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] data = new int[]&#123;5, 3, 6, 2, 1, 9, 4, 8, 7&#125;;</span><br><span class="line">        print(data);</span><br><span class="line">        mergeSort(data);</span><br><span class="line">        System.out.println(&quot;排序后的数组：&quot;);</span><br><span class="line">        print(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void mergeSort(int[] data) &#123;</span><br><span class="line">        sort(data, 0, data.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] data, int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right)</span><br><span class="line">            return;</span><br><span class="line">        // 找出中间索引</span><br><span class="line">        int center = (left + right) / 2;</span><br><span class="line">        // 对左边数组进行递归</span><br><span class="line">        sort(data, left, center);</span><br><span class="line">        // 对右边数组进行递归</span><br><span class="line">        sort(data, center + 1, right);</span><br><span class="line">        // 合并</span><br><span class="line">        merge(data, left, center, right);</span><br><span class="line">        print(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将两个数组进行归并，归并前面 2 个数组已有序，归并后依然有序</span><br><span class="line">     *</span><br><span class="line">     * @param data   数组对象</span><br><span class="line">     * @param left   左数组的第一个元素的索引</span><br><span class="line">     * @param center 左数组的最后一个元素的索引，center+1 是右数组第一个元素的索引</span><br><span class="line">     * @param right  右数组最后一个元素的索引</span><br><span class="line">     */</span><br><span class="line">    public static void merge(int[] data, int left, int center, int right) &#123;</span><br><span class="line">        // 临时数组</span><br><span class="line">        int[] tmpArr = new int[data.length];</span><br><span class="line">        // 右数组第一个元素索引</span><br><span class="line">        int mid = center + 1;</span><br><span class="line">        // third 记录临时数组的索引</span><br><span class="line">        int third = left;</span><br><span class="line">        // 缓存左数组第一个元素的索引</span><br><span class="line">        int tmp = left;</span><br><span class="line">        while (left &lt;= center &amp;&amp; mid &lt;= right) &#123;</span><br><span class="line">            // 从两个数组中取出最小的放入临时数组</span><br><span class="line">            if (data[left] &lt;= data[mid]) &#123;</span><br><span class="line">                tmpArr[third++] = data[left++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tmpArr[third++] = data[mid++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 剩余部分依次放入临时数组（实际上两个 while 只会执行其中一个）</span><br><span class="line">        while (mid &lt;= right) &#123;</span><br><span class="line">            tmpArr[third++] = data[mid++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (left &lt;= center) &#123;</span><br><span class="line">            tmpArr[third++] = data[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将临时数组中的内容拷贝回原数组中</span><br><span class="line">        // （原 left-right 范围的内容被复制回原数组）</span><br><span class="line">        while (tmp &lt;= right) &#123;</span><br><span class="line">            data[tmp] = tmpArr[tmp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void print(int[] data) &#123;</span><br><span class="line">        for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            System.out.print(data[i] + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="桶排序算法"><a href="#桶排序算法" class="headerlink" title="桶排序算法"></a>桶排序算法</h1><p>桶排序的基本思想是： 把数组 arr 划分为 n 个大小相同子区间（桶），每个子区间各自排序，最后合并。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值 max、最小值 min</p><p>2.我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1</p><p>3.遍历数组 arr，计算每个元素 arr[i] 放的桶</p><p>4.每个桶各自排序</p><details>    <summary>桶排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建桶</span><br><span class="line">    int bucketNum = (max - min) / arr.length + 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i = 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    //将每个元素放入桶</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int num = (arr[i] - min) / (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //对每个桶进行排序</span><br><span class="line">    for(int i = 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p><p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]  </p><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p><p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)</p><p>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><p>简单总结下堆排序的基本思路：</p><p>　　a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>　　b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p><p>　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p><details>    <summary>堆排序</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;7, 6, 7, 11, 5, 12, 3, 0, 1&#125;;</span><br><span class="line">        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(&quot;排序前：&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] arr) &#123;</span><br><span class="line">        //1.构建大顶堆</span><br><span class="line">        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            //从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">        for (int j = arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">            swap(arr, 0, j);//将堆顶元素与末尾元素进行交换</span><br><span class="line">            adjustHeap(arr, 0, j);//重新对堆进行调整</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="line">     */</span><br><span class="line">    public static void adjustHeap(int[] arr, int i, int length) &#123;</span><br><span class="line">        int temp = arr[i];//先取出当前元素i</span><br><span class="line">        for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123;//从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;//如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[k] &gt; temp) &#123;//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;//将temp值放到最终的位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交换元素</span><br><span class="line">     */</span><br><span class="line">    public static void swap(int[] arr, int a, int b) &#123;</span><br><span class="line">        int temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h2 id="计数排序的特征"><a href="#计数排序的特征" class="headerlink" title="计数排序的特征"></a>计数排序的特征</h2><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p> 算法的步骤如下：</p><p>（1）找出待排序的数组中最大和最小的元素</p><p>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p><p>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p><p>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><details>    <summary>计数排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CountingSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        int maxValue = getMaxValue(arr);</span><br><span class="line"></span><br><span class="line">        return countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int[] countingSort(int[] arr, int maxValue) &#123;</span><br><span class="line">        int bucketLen = maxValue + 1;</span><br><span class="line">        int[] bucket = new int[bucketLen];</span><br><span class="line"></span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int sortedIndex = 0;</span><br><span class="line">        for (int j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            while (bucket[j] &gt; 0) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getMaxValue(int[] arr) &#123;</span><br><span class="line">        int maxValue = arr[0];</span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            if (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="基数排序算法"><a href="#基数排序算法" class="headerlink" title="基数排序算法"></a>基数排序算法</h1><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><details>    <summary>基数排序算法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static int[] RadixSort(int[] array) &#123;</span><br><span class="line">    if (array == null || array.length &lt; 2)</span><br><span class="line">        return array;</span><br><span class="line">    // 1.先算出最大数的位数；</span><br><span class="line">    int max = array[0];</span><br><span class="line">    for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //最大数的位数</span><br><span class="line">    int maxDigit = 0;</span><br><span class="line">    while (max != 0) &#123;</span><br><span class="line">        max /= 10;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    int mod = 10, div = 1;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        bucketList.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) &#123;</span><br><span class="line">        for (int j = 0; j &lt; array.length; j++) &#123;</span><br><span class="line">            int num = (array[j] % mod) / div;</span><br><span class="line">            bucketList.get(num).add(array[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int j = 0; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">            for (int k = 0; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                array[index++] = bucketList.get(j).get(k);</span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>*<em>最佳情况：T(n) = O(n * k) *</em></p><p>*<em>最差情况：T(n) = O(n * k) *</em></p><p>平均情况：T(n) = O(n * k)</p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序</p><p>LSD 从低位开始进行排序</p><h2 id="与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题"><a href="#与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题" class="headerlink" title="与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题"></a>与人们的直觉相反，基数排序是首先按最低位有效数字进行排序，以解决卡片排序的问题</h2><p>从高位可以，但是麻烦</p><p>道理是基数排序每次都调用一个稳定排序，也就是说这一轮比不出大小的数据，保持原来的相对位置顺序不变。(这是稳定排序的定义，是性质，不是某种随意的文字描述) 而数字比较大小就是从高位开始，比不出大小去看低位，当然应该让低位先排出“原来的相对顺序”了。</p><p>从高位开始排，就要分段了，每排完一位，把分不出大小的几个当成一段，一段段的排，不要让排完的数据跨段移动，保证这一段的数都比下一段小，排到最后每段就只有一个数了。这样就完全没有利用到每次调用的都是稳定排序这一点</p><p>以 [111, 22, 3] 三个数从小排到大为例如果完全按照从低位开始排的写法，简单换成从高位开始排的话，每轮结果分别为：<br>第一轮：比较百位</p><p>百位为 0 的有 [22, 3]百位为 1 的有 [111]合并一下，本轮结果为 [22, 3, 111]</p><p>第二轮：比较十位 </p><p>十位为 0 的有 [3]十位为 1 的有 [111]十位为 2 的有 [22]合并一下，本轮结果为 [3, 111, 22]</p><p>第三轮：比较个位</p><p>个位为 1 的有 [111]个位为 2 的有 [22]个位为 3 的有 [3]合并一下，本轮结果为 [111, 22, 3]最终结果为 [111, 22, 3]，结果是完全错的错在哪儿了呢？</p><p>错在 个位的排序结果完全覆盖了百位的排序结果从例子里可以看到，排序轮数越靠后，相当于其权重越高，会覆盖之前的在从低位到高位的模式下，这个逻辑完全没问题，我们先按个位排序，再按十位排序，十位的排序结果会覆盖个位的排序结果，只有在两个数字十位相同的情况下，才会使用上一轮的个位排序而在从高位到低位的模式下，这个逻辑就完全行不通了，低位的排序结果覆盖高位的排序结果，这是不正确的为了解决这个问题，从高位排序的话，每轮要额外用一个数组，或是递归，来继承高位排序的结果，避免被低位覆盖</p><p>仍然以 [111, 22, 3] 为例</p><p>第一轮：比较百位</p><p>百位为 0 的有 [22, 3]百位为 1 的有 [111]合并一下，本轮结果为</p><pre><code>[   [22, 3],   [111]]</code></pre><p>注意，这一步不是把结果合并成一维数组 [22, 3, 111] 了，而是变成了二维数组，用来保证百位上的排序不被下一轮覆盖</p><p>第二轮：比较十位</p><p>由于数组变成了二维数组，这一轮要分别对数组里的子数组进行遍历对 [22, 3] 来说十位为 0 的有 [3]十位为 2 的有 [22]合并一下，结果为</p><pre><code>[   [3],   [22],]</code></pre><p>对 [111] 来说，本轮结果为</p><pre><code>[   [111]]</code></pre><p>合并一下，本轮结果总共为</p><pre><code>[   [      [3],      [22],   ],   [      [111]   ]]</code></pre><p>可以看到，现在又变成了三维数组，下一轮判断个位，又将变成四维所以说为什么高位麻烦，就是麻烦在递归这里。回到题目本身，从例子里可以看到，每轮遍历结果数组都是从前往后遍历，因此原始数据里 相同数据的相对顺序 是会被保留的，所以从高位排序其实也是稳定的。</p><h1 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h1><p>在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。</p><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><p>从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最短路径。解决最短路的问题有以下算法，Dijkstra 算法，Bellman-Ford 算法，Floyd 算法和 SPFA算法等。</p><h1 id="最大子数组算法"><a href="#最大子数组算法" class="headerlink" title="最大子数组算法"></a>最大子数组算法</h1><h1 id="最长公共子序算法"><a href="#最长公共子序算法" class="headerlink" title="最长公共子序算法"></a>最长公共子序算法</h1><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><p>现在假设有一个很实际的问题：我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要布置 n-1 一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？</p><p>于是我们就可以引入连通图来解决我们遇到的问题，n 个城市就是图上的 n 个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有 n 个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。</p><p>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST 性质（假设N=(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果（u，v）是一条具有最小权值的边，其中 u 属于 U，v 属于 V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使<br>用 MST 性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查找，排序，回溯等算法&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（YARN）</title>
    <link href="http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88YARN%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/07/JAVA 学习笔记（YARN）/</id>
    <published>2022-01-07T07:12:12.000Z</published>
    <updated>2022-01-07T07:53:50.837Z</updated>
    
    <content type="html"><![CDATA[<p>YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。</p><a id="more"></a><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。其中，ResourceManager 负责所有资源的监控、分配和管理； ApplicationMaster 负责每一个具体应用程序的调度和协调；NodeManager 负责每一个节点的维护。对于所有的 applications，RM 拥有绝对的控制权和对资源的分配权。而每个 AM 则会和 RM 协商资源，同时和 NodeManager 通信来执行和监控 task。 几个模块之间的关系如图所示。</p><h1 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h1><ol><li><p>ResourceManager 负责整个集群的资源管理和分配，是一个全局的资源管理系统。</p></li><li><p>NodeManager 以心跳的方式向 ResourceManager 汇报资源使用情况（目前主要是 CPU 和内存的使用情况）。RM 只接受 NM 的资源回报信息，对于具体的资源处理则交给 NM 自己处理。</p></li><li><p>YARN Scheduler 根据 application 的请求为其分配资源，不负责 application job 的监控、追踪、运行状态反馈、启动等工作。</p></li></ol><h1 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h1><ol><li><p>NodeManager 是每个节点上的资源和任务管理器，它是管理这台机器的代理，负责该节点程序的运行，以及该节点资源的管理和监控。YARN集群每个节点都运行一个NodeManager</p></li><li><p>NodeManager 定时向 ResourceManager 汇报本节点资源（CPU、内存）的使用情况和Container 的运行状态。当 ResourceManager 宕机时 NodeManager 自动连接 RM 备用节点。</p></li><li><p>NodeManager 接收并处理来自 ApplicationMaster 的 Container 启动、停止等各种请求。</p></li></ol><h1 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h1><p>用户提交的每个应用程序均包含一个 ApplicationMaster，它可以运行在 ResourceManager 以外的机器上。</p><ol><li>负责与 RM 调度器协商以获取资源（用 Container 表示）。</li><li>将得到的任务进一步分配给内部的任务(资源的二次分配)。</li><li>与 NM 通信以启动/停止任务。</li><li>监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。</li><li>当前 YARN 自带了两个 ApplicationMaster 实现，一个是用于演示 AM 编写方法的实例程序DistributedShell，它可以申请一定数目的 Container 以并行运行一个 Shell 命令或者 Shell脚本；另一个是运行 MapReduce 应用程序的 AM—MRAppMaster。</li></ol><p>注：RM 只负责监控 AM，并在 AM 运行失败时候启动它。RM 不负责 AM 内部任务的容错，任务的容错由 AM 完成。 </p><h1 id="YARN-运行流程"><a href="#YARN-运行流程" class="headerlink" title="YARN 运行流程"></a>YARN 运行流程</h1><ol><li>client 向 RM 提交应用程序，其中包括启动该应用的 ApplicationMaster 的必须信息，例如ApplicationMaster 程序、启动 ApplicationMaster 的命令、用户程序等。</li><li>ResourceManager 启动一个 container 用于运行 ApplicationMaster。</li><li>启动中的ApplicationMaster向ResourceManager注册自己，启动成功后与RM保持心跳。</li><li>ApplicationMaster 向 ResourceManager 发送请求，申请相应数目的 container。</li><li>ResourceManager 返回 ApplicationMaster 的申请的 containers 信息。申请成功的container，由 ApplicationMaster 进行初始化。container 的启动信息初始化后，AM 与对应的 NodeManager 通信，要求 NM 启动 container。AM 与 NM 保持心跳，从而对 NM 上运行的任务进行监控和管理。</li><li>container 运行期间，ApplicationMaster 对 container 进行监控。container 通过 RPC 协议向对应的 AM 汇报自己的进度和状态等信息。</li><li>应用运行期间，client 直接与 AM 通信获取应用的状态、进度更新等信息。</li><li>应用运行结束后，ApplicationMaster 向 ResourceManager 注销自己，并允许属于它的container 被收回</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="YARN" scheme="http://yoursite.com/tags/YARN/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（云计算）</title>
    <link href="http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/07/JAVA 学习笔记（云计算）/</id>
    <published>2022-01-07T07:12:12.000Z</published>
    <updated>2022-01-07T10:26:08.824Z</updated>
    
    <content type="html"><![CDATA[<p>SaaS, PaaS, IaaS, Docker, Openstack</p><a id="more"></a><p>[TOC]</p><h1 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h1><p>SaaS 是 Software-as-a-Service（软件即服务）</p><h1 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h1><p>PaaS 是 Platform-as-a-Service 的缩写，意思是平台即服务。 把服务器平台作为一种服务提供的商业模式。通过网络进行程序提供的服务称之为 SaaS(Software as a Service)，而云计算时代相应的服务器平台或者开发环境作为服务进行提供就成为了 PaaS(Platform as a Service)。</p><h1 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h1><p>IaaS（Infrastructure as a Service），即基础设施即服务。提供给消费者的服务是对所有设施的利用，包括处理、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板。</td></tr><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用。</td></tr><tr><td>Docker 客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker 仓库(Registry)</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub 提供了庞大的镜像集合供使用。</td></tr><tr><td>Docker Machine</td><td>Docker Machine 是一个简化 Docker 安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装 Docker，比如 VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><p>Docker 的出现一定是因为目前的后端在开发和运维阶段确实需要一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过 Docker 我们可以将程序运行的环境也纳入到版本控制中，排除因为环境造成不同运行结果的可能。但是上述需求虽然推动了虚拟化技术的产生，但是如果没有合<br>适的底层技术支撑，那么我们仍然得不到一个完美的产品。本文剩下的内容会介绍几种 Docker 使用的核心技术，如果我们了解它们的使用方法和原理，就能清楚 Docker 的实现原理。Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。Docker 容器通过Docker 镜像来创建。</p><h2 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h2><p>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p><p>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 CLONE_NEWCGROUP、CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER 和 CLONE_NEWUTS，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p><h2 id="进程-CLONE-NEWPID-实现的进程隔离"><a href="#进程-CLONE-NEWPID-实现的进程隔离" class="headerlink" title="进程(CLONE_NEWPID 实现的进程隔离)"></a>进程(CLONE_NEWPID 实现的进程隔离)</h2><p>docker 创建新进程时传入 CLONE_NEWPID 实现的进程隔离，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。当我们每次运行docker run 或者 docker start 时，都会在创建一个用于设置进程间隔离的 Spec，同时会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间，所有命名空间相关的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置。</p><h2 id="Libnetwork-与网络隔离"><a href="#Libnetwork-与网络隔离" class="headerlink" title="Libnetwork 与网络隔离"></a>Libnetwork 与网络隔离</h2><p>如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却有没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。</p><p>Docker 整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。</p><p>libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network。在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux网桥或者 VLAN。</p><p>每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。</p><p>在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。</p><h2 id="资源隔离与-CGroups"><a href="#资源隔离与-CGroups" class="headerlink" title="资源隔离与 CGroups"></a>资源隔离与 CGroups</h2><p>Control Groups（简称 CGroups）能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。</p><h2 id="镜像与-UnionFS"><a href="#镜像与-UnionFS" class="headerlink" title="镜像与 UnionFS"></a>镜像与 UnionFS</h2><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。</p><p>Docker 镜像其实本质就是一个压缩包，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说Docker 镜像就是一个文件。</p><h2 id="存储驱动"><a href="#存储驱动" class="headerlink" title="存储驱动"></a>存储驱动</h2><p>Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，这些存储驱动与Docker卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储。</p><p>当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。</p><p>容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p><p>AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和 vfs 等等，在最新的 Docker 中，overlay2 取代了aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker<br>的默认驱动。</p><h1 id="Openstack"><a href="#Openstack" class="headerlink" title="Openstack"></a>Openstack</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SaaS, PaaS, IaaS, Docker, Openstack&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Spark）</title>
    <link href="http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Spark%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/07/JAVA 学习笔记（Spark）/</id>
    <published>2022-01-07T01:12:12.000Z</published>
    <updated>2022-01-07T01:13:09.775Z</updated>
    
    <content type="html"><![CDATA[<p>Spark 提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。</p><a id="more"></a><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Spark 提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。</p><h1 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h1><h2 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h2><p>包含 Spark 的基本功能；尤其是定义 RDD 的 API、操作以及这两者上的动作。其他 Spark 的库都是构建在 RDD 和 Spark Core 之上的</p><h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><p>提供通过 Apache Hive 的 SQL 变体 Hive 查询语言（HiveQL）与 Spark 进行交互的 API。每个数据库表被当做一个 RDD，Spark SQL 查询被转换为 Spark 操作。</p><h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><p>对实时数据流进行处理和控制。Spark Streaming 允许程序能够像普通 RDD 一样处理实时数据</p><h2 id="Mllib"><a href="#Mllib" class="headerlink" title="Mllib"></a>Mllib</h2><p>一个常用机器学习算法库，算法被实现为对 RDD 的 Spark 操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。</p><h2 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h2><p>控制图、并行图操作和计算的一组算法和工具的集合。GraphX 扩展了 RDD API，包含控制图、创建子图、访问路径上所有顶点的操作</p><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="Cluster-Manager-制整个集群，监控-worker"><a href="#Cluster-Manager-制整个集群，监控-worker" class="headerlink" title="Cluster Manager-制整个集群，监控 worker"></a>Cluster Manager-制整个集群，监控 worker</h2><p>在 standalone 模式中即为 Master 主节点，控制整个集群，监控 worker。在 YARN 模式中为资源管理器</p><h2 id="Worker-节点-负责控制计算节点"><a href="#Worker-节点-负责控制计算节点" class="headerlink" title="Worker 节点-负责控制计算节点"></a>Worker 节点-负责控制计算节点</h2><p>从节点，负责控制计算节点，启动 Executor 或者 Driver。</p><h2 id="Driver："><a href="#Driver：" class="headerlink" title="Driver："></a>Driver：</h2><p>运行 Application 的 main()函数</p><h2 id="Executor："><a href="#Executor：" class="headerlink" title="Executor："></a>Executor：</h2><p>执行器，是为某个 Application 运行在 worker node 上的一个进程</p><h1 id="SPARK-编程模型"><a href="#SPARK-编程模型" class="headerlink" title="SPARK 编程模型"></a>SPARK 编程模型</h1><p>Spark 应用程序从编写到提交、执行、输出的整个过程如图所示，图中描述的步骤如下：</p><ol><li><p>用户使用 SparkContext 提供的 API（常用的有 textFile、sequenceFile、runJob、stop 等）编写 Driver application 程序。此外 SQLContext、HiveContext 及 StreamingContext 对SparkContext 进行封装，并提供了 SQL、Hive 及流式计算相关的 API。</p></li><li><p>使用SparkContext提交的用户应用程序，首先会使用BlockManager和BroadcastManager将任务的 Hadoop 配置进行广播。然后由 DAGScheduler 将任务转换为 RDD 并组织成 DAG，DAG 还将被划分为不同的 Stage。最后由 TaskScheduler 借助 ActorSystem 将任务提交给集群管理器（Cluster Manager）。</p></li><li><p>集群管理器（ClusterManager）给任务分配资源，即将具体任务分配到Worker上，Worker创建 Executor 来处理任务的运行。Standalone、YARN、Mesos、EC2 等都可以作为 Spark的集群管理器。</p></li></ol><h1 id="SPARK-计算模型"><a href="#SPARK-计算模型" class="headerlink" title="SPARK 计算模型"></a>SPARK 计算模型</h1><p>RDD 可以看做是对各种数据计算模型的统一抽象，Spark 的计算过程主要是 RDD 的迭代计算过程。RDD 的迭代计算过程非常类似于管道。分区数量取决于 partition 数量的设定，每个分区的数据只会在一个 Task 中计算。所有分区可以在多个机器节点的 Executor 上并行执行。</p><h1 id="SPARK-运行流程"><a href="#SPARK-运行流程" class="headerlink" title="SPARK 运行流程"></a>SPARK 运行流程</h1><ol><li>构建 Spark Application 的运行环境，启动 SparkContext</li><li>SparkContext 向资源管理器（可以是 Standalone，Mesos，Yarn）申请运行 Executor 资源，并启动 StandaloneExecutorbackend，</li><li>Executor 向 SparkContext 申请 Task</li><li>SparkContext 将应用程序分发给 Executor</li><li>SparkContext 构建成 DAG 图，将 DAG 图分解成 Stage、将 Taskset 发送给 Task Scheduler，最后由 Task Scheduler 将 Task 发送给 Executor 运行</li><li>Task 在 Executor 上运行，运行完释放所有资源</li></ol><h1 id="SPARK-RDD-流程"><a href="#SPARK-RDD-流程" class="headerlink" title="SPARK RDD 流程"></a>SPARK RDD 流程</h1><ol><li>创建 RDD 对象</li><li>DAGScheduler 模块介入运算，计算 RDD 之间的依赖关系，RDD 之间的依赖关系就形成了DAG</li><li>每一个 Job 被分为多个 Stage。划分 Stage 的一个主要依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个 Stage，避免多个 Stage 之间的消息传递开销</li></ol><h1 id="SPARK-RDD"><a href="#SPARK-RDD" class="headerlink" title="SPARK RDD"></a>SPARK RDD</h1><h2 id="RDD-的创建方式"><a href="#RDD-的创建方式" class="headerlink" title="RDD 的创建方式"></a>RDD 的创建方式</h2><p>1）从 Hadoop 文件系统（或与Hadoop兼容的其他持久化存储系统，如Hive、Cassandra、HBase）输入（例如 HDFS）创建。</p><p>2）从父 RDD 转换得到新 RDD。</p><p>3）通过 parallelize 或 makeRDD 将单机数据创建为分布式 RDD。</p><h2 id="RDD-的两种操作算子（转换（Transformation）与行动（Action））"><a href="#RDD-的两种操作算子（转换（Transformation）与行动（Action））" class="headerlink" title="RDD 的两种操作算子（转换（Transformation）与行动（Action））"></a>RDD 的两种操作算子（转换（Transformation）与行动（Action））</h2><p>对于 RDD 可以有两种操作算子：转换（Transformation）与行动（Action）。</p><p>1）转换（Transformation）：Transformation操作是延迟计算的，也就是说从一个RDD转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算。</p><p>2）行动（Action）：Action 算子会触发 Spark 提交作业（Job），并将数据输出 Spark 系统</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spark 提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Storm）</title>
    <link href="http://yoursite.com/2022/01/07/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Storm%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/07/JAVA 学习笔记（Storm）/</id>
    <published>2022-01-07T01:12:12.000Z</published>
    <updated>2022-01-07T07:35:23.065Z</updated>
    
    <content type="html"><![CDATA[<p>Storm 是一个免费并开源的分布式实时计算系统。利用 Storm可以很容易做到可靠地处理无限的数据流，像 Hadoop 批量处理大数据一样，Storm 可以实时处理数据。</p><a id="more"></a><p>[TOC]</p><p>Storm这部分看的晕头转向，如果需要还得看些其它资料</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Storm 是一个免费并开源的分布式实时计算系统。利用 Storm可以很容易做到可靠地处理无限的数据流，像 Hadoop 批量处理大数据一样，Storm 可以实时处理数据。</p><h1 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h1><h2 id="Nimbus（master-代码分发给-Supervisor）"><a href="#Nimbus（master-代码分发给-Supervisor）" class="headerlink" title="Nimbus（master-代码分发给 Supervisor）"></a>Nimbus（master-代码分发给 Supervisor）</h2><p>Storm 集群的 Master 节点，负责分发用户代码，指派给具体的 Supervisor 节点上的 Worker 节点，去运行 Topology 对应的组件（Spout/Bolt）的 Task。</p><h2 id="Supervisor（slave-管理-Worker-进程的启动和终止）"><a href="#Supervisor（slave-管理-Worker-进程的启动和终止）" class="headerlink" title="Supervisor（slave-管理 Worker 进程的启动和终止）"></a>Supervisor（slave-管理 Worker 进程的启动和终止）</h2><p>Storm 集群的从节点，负责管理运行在 Supervisor 节点上的每一个 Worker 进程的启动和终止。通过 Storm 的配置文件中的 supervisor.slots.ports 配置项，可以指定在一个 Supervisor 上最大允许多少个 Slot，每个 Slot 通过端口号来唯一标识，一个端口号对应一个 Worker 进程（如果该Worker 进程被启动）。</p><h2 id="Worker（具体处理组件逻辑的进程）"><a href="#Worker（具体处理组件逻辑的进程）" class="headerlink" title="Worker（具体处理组件逻辑的进程）"></a>Worker（具体处理组件逻辑的进程）</h2><p>运行具体处理组件逻辑的进程。Worker 运行的任务类型只有两种，一种是 Spout 任务，一种是Bolt 任务。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>worker中每一个spout/bolt的线程称为一个task. 在storm0.8 之后，task不再与物理线程对应，不同 spout/bolt 的 task 可能会共享一个物理线程，该线程称为 executor。</p><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>用来协调 Nimbus 和 Supervisor，如果 Supervisor 因故障出现问题而无法运行 Topology，Nimbus 会第一时间感知到，并重新分配 Topology 到其它可用的 Supervisor 上运行</p><h1 id="编程模型（spout-gt-tuple-gt-bolt）"><a href="#编程模型（spout-gt-tuple-gt-bolt）" class="headerlink" title="编程模型（spout-&gt;tuple-&gt;bolt）"></a>编程模型（spout-&gt;tuple-&gt;bolt）</h1><p>strom 在运行中可分为 spout 与 bolt 两个组件，其中，数据源从 spout 开始，数据以 tuple 的方式发送到 bolt，多个 bolt 可以串连起来，一个 bolt 也可以接入多个 spot/bolt.运行时原理如下图：</p><h2 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h2><p>Storm 中运行的一个实时应用程序的名称。将 Spout、 Bolt 整合起来的拓扑图。定义了 Spout 和Bolt 的结合关系、并发数量、配置等等。</p><h2 id="Spout"><a href="#Spout" class="headerlink" title="Spout"></a>Spout</h2><p>在一个 topology 中获取源数据流的组件。通常情况下 spout 会从外部数据源中读取数据，然后转换为 topology 内部的源数据。</p><h2 id="Bolt"><a href="#Bolt" class="headerlink" title="Bolt"></a>Bolt</h2><p>接受数据然后执行处理的组件,用户可以在其中执行自己想要的操作。</p><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>一次消息传递的基本单元，理解为一组消息就是一个 Tuple。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Tuple 的集合。表示数据的流向。</p><h1 id="Topology-运行"><a href="#Topology-运行" class="headerlink" title="Topology 运行"></a>Topology 运行</h1><p>在 Storm 中,一个实时应用的计算任务被打包作为 Topology 发布，这同 Hadoop MapReduce任务相似。但是有一点不同的是:在 Hadoop 中，MapReduce 任务最终会执行完成后结束；而在Storm 中，Topology 任务一旦提交后永远不会结束，除非你显示去停止任务。计算任务Topology 是由不同的 Spouts 和 Bolts，通过数据流（Stream）连接起来的图｡一个 Storm 在集群上运行一个 Topology 时，主要通过以下 3 个实体来完成 Topology 的执行工作：</p><p>(1). Worker（进程）</p><p>(2). Executor（线程）</p><p>(3). Task</p><h2 id="Worker-1-个-worker-进程执行的是-1-个-topology-的子集"><a href="#Worker-1-个-worker-进程执行的是-1-个-topology-的子集" class="headerlink" title="Worker(1 个 worker 进程执行的是 1 个 topology 的子集)"></a>Worker(1 个 worker 进程执行的是 1 个 topology 的子集)</h2><p>1 个 worker 进程执行的是 1 个 topology 的子集（注：不会出现 1 个 worker 为多个 topology服务）。1 个 worker 进程会启动 1 个或多个 executor 线程来执行 1 个 topology 的component(spout 或 bolt)。因此，1 个运行中的 topology 就是由集群中多台物理机上的多个worker 进程组成的。</p><h2 id="Executor-executor-是-1-个被-worker-进程启动的单独线程"><a href="#Executor-executor-是-1-个被-worker-进程启动的单独线程" class="headerlink" title="Executor(executor 是 1 个被 worker 进程启动的单独线程)"></a>Executor(executor 是 1 个被 worker 进程启动的单独线程)</h2><p>executor 是 1 个被 worker 进程启动的单独线程。每个 executor 只会运行 1 个 topology 的 1 个component(spout 或 bolt)的 task（注：task 可以是 1 个或多个，storm 默认是 1 个component 只生成 1 个 task，executor 线程里会在每次循环里顺序调用所有 task 实例）。</p><h2 id="Task-最终运行-spout-或-bolt-中代码的单元"><a href="#Task-最终运行-spout-或-bolt-中代码的单元" class="headerlink" title="Task(最终运行 spout 或 bolt 中代码的单元)"></a>Task(最终运行 spout 或 bolt 中代码的单元)</h2><p>是最终运行 spout 或 bolt 中代码的单元（注：1 个 task 即为 spout 或 bolt 的 1 个实例，executor 线程在执行期间会调用该 task 的 nextTuple 或 execute 方法）。topology 启动后，1个 component(spout 或 bolt)的 task 数目是固定不变的，但该 component 使用的 executor 线程数可以动态调整（例如：1 个 executor 线程可以执行该 component 的 1 个或多个 task 实例）。这意味着，对于 1 个 component 存在这样的条件：#threads&lt;=#tasks（即：线程数小于等于 task 数目）。默认情况下 task 的数目等于 executor 线程数目，即 1 个 executor 线程只运<br>行 1 个 task。</p><h1 id="Storm-Streaming-Grouping"><a href="#Storm-Streaming-Grouping" class="headerlink" title="Storm Streaming Grouping"></a>Storm Streaming Grouping</h1><p>Storm 中最重要的抽象，应该就是 Stream grouping 了，它能够控制 Spot/Bolt 对应的 Task 以什么样的方式来分发 Tuple，将 Tuple 发射到目的 Spot/Bolt 对应的 Task.</p><p>目前，Storm Streaming Grouping 支持如下几种类型：</p><h2 id="huffle-Grouping"><a href="#huffle-Grouping" class="headerlink" title="huffle Grouping"></a>huffle Grouping</h2><p>随机分组，尽量均匀分布到下游 Bolt 中将流分组定义为混排。这种混排分组意味着来自 Spout 的输入将混排，或随机分发给此 Bolt 中的任务。shuffle grouping 对各个 task 的 tuple 分配的比较均匀。</p><h2 id="Fields-Grouping"><a href="#Fields-Grouping" class="headerlink" title="Fields Grouping"></a>Fields Grouping</h2><p>按字段分组，按数据中 field 值进行分组；相同 field 值的 Tuple 被发送到相同的 Task 这种grouping 机制保证相同 field 值的 tuple 会去同一个 task。</p><h2 id="All-grouping-：广播"><a href="#All-grouping-：广播" class="headerlink" title="All grouping ：广播"></a>All grouping ：广播</h2><p>广播发送， 对于每一个 tuple 将会复制到每一个 bolt 中处理</p><h2 id="Global-grouping"><a href="#Global-grouping" class="headerlink" title="Global grouping"></a>Global grouping</h2><p>全局分组，Tuple 被分配到一个 Bolt 中的一个 Task，实现事务性的 Topology。Stream 中的所有的 tuple 都会发送给同一个 bolt 任务处理，所有的 tuple 将会发送给拥有最小 task_id 的 bolt任务处理。</p><h2 id="None-grouping-：不分组"><a href="#None-grouping-：不分组" class="headerlink" title="None grouping ：不分组"></a>None grouping ：不分组</h2><p>不关注并行处理负载均衡策略时使用该方式，目前等同于 shuffle grouping,另外 storm 将会把bolt 任务和他的上游提供数据的任务安排在同一个线程下。</p><h2 id="Direct-grouping-：直接分组-指定分组"><a href="#Direct-grouping-：直接分组-指定分组" class="headerlink" title="Direct grouping ：直接分组 指定分组"></a>Direct grouping ：直接分组 指定分组</h2><p>由 tuple 的发射单元直接决定 tuple 将发射给那个 bolt，一般情况下是由接收 tuple 的 bolt 决定接收哪个 bolt 发射的 Tuple。这是一种比较特别的分组方法，用这种分组意味着消息的发送者指定由消息接收者的哪个 task 处理这个消息。 只有被声明为 Direct Stream 的消息流可以声明这种分组方法。而且这种消息 tuple 必须使用 emitDirect 方法来发射。消息处理者可以通过TopologyContext 来获取处理它的消息的 taskid (OutputCollector.emit 方法也会返回taskid)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Storm 是一个免费并开源的分布式实时计算系统。利用 Storm可以很容易做到可靠地处理无限的数据流，像 Hadoop 批量处理大数据一样，Storm 可以实时处理数据。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Storm" scheme="http://yoursite.com/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Hadoop）</title>
    <link href="http://yoursite.com/2022/01/06/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Hadoop%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/06/JAVA 学习笔记（Hadoop）/</id>
    <published>2022-01-06T15:12:12.000Z</published>
    <updated>2022-01-06T15:19:24.674Z</updated>
    
    <content type="html"><![CDATA[<p>Hbase是一个大数据解决方案。它提供了一套分布式系统基础架构。 核心内容包含 hdfs 和mapreduce。hadoop2.0 以后引入 yarn.</p><a id="more"></a><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>hdfs 是提供数据存储的，mapreduce 是方便数据计算的。</p><ol><li>hdfs 又对应 namenode 和 datanode. namenode 负责保存元数据的基本信息，datanode 直接存放数据本身；</li><li>mapreduce 对应 jobtracker 和 tasktracker. jobtracker 负责分发任务，tasktracker 负责执行具体任务；</li><li>对应到 master/slave 架构，namenode 和 jobtracker 就应该对应到 master, datanode和 tasktracker 就应该对应到 slave</li></ol><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>Client（代表用 户） 通过与 NameNode 和 DataNode 交互访问 HDFS 中 的文件。 Client 提供了一个类似 POSIX 的文件系统接口供用户调用。</p><h2 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h2><p>整个 Hadoop 集群中只有一个 NameNode。 它是整个系统的“ 总管”， 负责管理 HDFS 的目录树和相关的文件元数据信息。 这些信息是以“ fsimage”（ HDFS 元数据镜像文件）和“ editlog”（HDFS 文件改动日志）两个文件形式存放在本地磁盘，当 HDFS 重启时重新构造出来的。此外， NameNode 还负责监控各个 DataNode 的健康状态， 一旦发现某个 DataNode 宕掉，则将该 DataNode 移出 HDFS 并重新备份其上面的数据。</p><h2 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h2><p>Secondary NameNode 最重要的任务并不是为 NameNode 元数据进行热备份， 而是定期合并fsimage 和 edits 日志， 并传输给 NameNode。 这里需要注意的是，为了减小 NameNode 压力， NameNode 自己并不会合并 fsimage 和 edits， 并将文件存储到磁盘上， 而是交由Secondary NameNode 完成。</p><h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><p>一般而言， 每个 Slave 节点上安装一个 DataNode， 它负责实际的数据存储， 并将数据信息定期汇报给 NameNode。 DataNode 以固定大小的 block 为基本单位组织文件内容， 默认情况下block 大小为 64MB。 当用户上传一个大的文件到 HDFS 上时， 该文件会被切分成若干个 block，分别存储到不同的 DataNode ； 同时，为了保证数据可靠， 会将同一个 block 以流水线方式写到若干个（默认是 3，该参数可配置）不同的 DataNode 上。这种文件切割后存储的过程是对用户透明的。</p><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>同 HDFS 一样，Hadoop MapReduce 也采用了 Master/Slave（M/S）架构，具体如图所示。它主要由以下几个组件组成：Client、JobTracker、TaskTracker 和 Task。 下面分别对这几个组件进行介绍。</p><h2 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h2><p>用户编写的 MapReduce 程序通过 Client 提交到 JobTracker 端； 同时， 用户可通过 Client 提供的一些接口查看作业运行状态。 在 Hadoop 内部用“作业”（Job） 表示 MapReduce 程序。</p><p>一个 MapReduce 程序可对应若干个作业，而每个作业会被分解成若干个 Map/Reduce 任务（Task）。</p><h2 id="JobTracker"><a href="#JobTracker" class="headerlink" title="JobTracker"></a>JobTracker</h2><p>JobTracker 主要负责资源监控和作业调度。JobTracker 监控所有 TaskTracker与作业的健康状况，一旦发现失败情况后，其会将相应的任务转移到其他节点；同时 JobTracker 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合适的任务使用这些资源。在 Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的需要设计相应的调度器。</p><h2 id="TaskTracker"><a href="#TaskTracker" class="headerlink" title="TaskTracker"></a>TaskTracker</h2><p>TaskTracker 会周期性地通过 Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给JobTracker， 同时接收 JobTracker 发送过来的命令并执行相应的操作（如启动新任务、 杀死任务等）。TaskTracker 使用“slot” 等量划分本节点上的资源量。“slot” 代表计算资源（CPU、<br>内存等）。一个 Task 获取到一个 slot 后才有机会运行，而 Hadoop 调度器的作用就是将各个TaskTracker 上的空闲 slot 分配给 Task 使用。 slot 分为 Map slot 和 Reduce slot 两种，分别供MapTask 和 Reduce Task 使用。 TaskTracker 通过 slot 数目（可配置参数）限定 Task 的并发度。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>Task 分为 Map Task 和 Reduce Task 两种， 均由 TaskTracker 启动。 HDFS 以固定大小的 block为基本单位存储数据， 而对于 MapReduce 而言， 其处理单位是 split。split 与 block 的对应关系如图所示。 split 是一个逻辑概念，它只包含一些元数据信息，比如数据起始位置、数据长度、数据所在节点等。它的划分方法完全由用户自己决定。 但需要注意的是，split 的多少决定了 Map Task 的数目 ，因为每个 split 会交由一个 Map Task 处理。</p><p>Map Task 执行过程如图所示。 由该图可知，Map Task 先将对应的 split 迭代解析成一个个key/value 对，依次调用用户自定义的 map() 函数进行处理，最终将临时结果存放到本地磁盘上，其中临时数据被分成若干个 partition，每个 partition 将被一个 Reduce Task 处理。</p><h2 id="Reduce-Task-执行过程"><a href="#Reduce-Task-执行过程" class="headerlink" title="Reduce Task 执行过程"></a>Reduce Task 执行过程</h2><p>该过程分为三个阶段</p><ol><li><p>从远程节点上读取 MapTask 中间结果（称为“Shuffle 阶段”）；</p></li><li><p>按照 key 对 key/value 对进行排序（称为“ Sort 阶段”）；</p></li><li><p>依次读取&lt;key, value list&gt;，调用用户自定义的 reduce() 函数处理，并将最终结果存到 HDFS上（称为“ Reduce 阶段”）。</p></li></ol><h1 id="Hadoop-MapReduce-作业的生命周期"><a href="#Hadoop-MapReduce-作业的生命周期" class="headerlink" title="Hadoop MapReduce 作业的生命周期"></a>Hadoop MapReduce 作业的生命周期</h1><h2 id="作业提交与初始化"><a href="#作业提交与初始化" class="headerlink" title="作业提交与初始化"></a>作业提交与初始化</h2><ol><li>用户提交作业后， 首先由 JobClient 实例将作业相关信息， 比如将程序 jar 包、作业配置文件、 分片元信息文件等上传到分布式文件系统（ 一般为 HDFS）上，其中，分片元信息文件记录了每个输入分片的逻辑位置信息。 然后 JobClient 通过 RPC 通知 JobTracker。<br>JobTracker 收到新作业提交请求后， 由 作业调度模块对作业进行初始化：为作业创建一个JobInProgress 对象以跟踪作业运行状况， 而 JobInProgress 则会为每个 Task 创建一个TaskInProgress 对象以跟踪每个任务的运行状态， TaskInProgress 可能需要管理多个“ Task 运行尝试”（ 称为“ Task Attempt”）。</li></ol><h2 id="任务调度与监控。"><a href="#任务调度与监控。" class="headerlink" title="任务调度与监控。"></a>任务调度与监控。</h2><ol start="2"><li>前面提到，任务调度和监控的功能均由 JobTracker 完成。TaskTracker 周期性地通过Heartbeat 向 JobTracker 汇报本节点的资源使用 情况， 一旦出 现空闲资源， JobTracker会按照一定的策略选择一个合适的任务使用该空闲资源， 这由任务调度器完成。 任务调度器是一个可插拔的独立模块， 且为双层架构， 即首先选择作业， 然后从该作业中选择任务， 其中，选择任务时需要重点考虑数据本地性。 此外，JobTracker 跟踪作业的整个运行过程，并为作业的成功运行提供全方位的保障。 首先， 当 TaskTracker 或者 Task 失败时， 转移计算任务 ； 其次， 当某个 Task 执行进度远落后于同一作业的其他 Task 时，为之启动一个相同Task， 并选取计算快的 Task 结果作为最终结果。</li></ol><h2 id="任务运行环境准备"><a href="#任务运行环境准备" class="headerlink" title="任务运行环境准备"></a>任务运行环境准备</h2><ol start="3"><li>运行环境准备包括 JVM 启动和资源隔 离， 均由 TaskTracker 实现。 TaskTracker 为每个Task 启动一个独立的 JVM 以避免不同 Task 在运行过程中相互影响 ； 同时，TaskTracker 使用了操作系统进程实现资源隔离以防止 Task 滥用资源。</li></ol><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><ol start="4"><li>TaskTracker 为 Task 准备好运行环境后， 便会启动 Task。 在运行过程中， 每个 Task 的最新进度首先由 Task 通过 RPC 汇报给 TaskTracker， 再由 TaskTracker 汇报给 JobTracker。</li></ol><h2 id="作业完成"><a href="#作业完成" class="headerlink" title="作业完成"></a>作业完成</h2><ol start="5"><li>待所有 Task 执行完毕后， 整个作业执行成功。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hbase是一个大数据解决方案。它提供了一套分布式系统基础架构。 核心内容包含 hdfs 和mapreduce。hadoop2.0 以后引入 yarn.&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（加密算法）</title>
    <link href="http://yoursite.com/2022/01/06/%20JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/06/ JAVA 学习笔记（加密算法）/</id>
    <published>2022-01-06T14:12:12.000Z</published>
    <updated>2022-01-06T14:11:59.323Z</updated>
    
    <content type="html"><![CDATA[<p>AES, RSA, CRC和MD5等加密算法</p><a id="more"></a><p>[TOC]</p><h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p>RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的</p><p>RSA 加密算法是一种典型的非对称加密算法，它基于大数的因式分解数学难题，它也是应用最广泛的非对称加密算法。</p><p>非对称加密是通过两个密钥（公钥-私钥）来实现对数据的加密和解密的。公钥用于加密，私钥用于解密。</p><h1 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h1><p>循环冗余校验(Cyclic Redundancy Check,CRC)是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p><h1 id="MD5（Message-Digest-Algorithm-信息摘要算法第5版）"><a href="#MD5（Message-Digest-Algorithm-信息摘要算法第5版）" class="headerlink" title="MD5（Message-Digest Algorithm 信息摘要算法第5版）"></a>MD5（Message-Digest Algorithm 信息摘要算法第5版）</h1><p>MD5 常常作为文件的签名出现，我们在下载文件的时候，常常会看到文件页面上附带一个扩展名为.MD5的文本或者一行字符，这行字符就是就是把整个文件当作原数据通过 MD5 计算后的值，我们下载文件后，可以用检查文件 MD5 信息的软件对下载到的文件在进行一次计算。两次结果对比就可以确保下载到文件的准确性。 </p><p>另一种常见用途就是网站敏感信息加密，比如用户名密码，支付签名等等。随着 https 技术的普及，现在的网站广泛采用前台明文传输到后台，MD5 加密（使用偏移量）的方式保护敏感数据保护站点和数据安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AES, RSA, CRC和MD5等加密算法&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Encryption" scheme="http://yoursite.com/tags/Encryption/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（分布式缓存）</title>
    <link href="http://yoursite.com/2022/01/06/%20JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/06/ JAVA 学习笔记（分布式缓存）/</id>
    <published>2022-01-06T14:12:12.000Z</published>
    <updated>2022-01-06T14:26:22.183Z</updated>
    
    <content type="html"><![CDATA[<p>缓存雪崩，缓存穿透，缓存预热，缓存更新，缓存降级</p><a id="more"></a><p>[TOC]</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。一般有三种处理办法：</p><ol><li><p>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</p></li><li><p>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p></li><li><p>为 key 设置不同的缓存失效时间。</p></li></ol><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<a href="https://developer.aliyun.com/article/773205" target="_blank" rel="noopener">布隆过滤器</a>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><p>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。</p><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 种策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>（1）定时去清理过期的缓存；</p><p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缓存雪崩，缓存穿透，缓存预热，缓存更新，缓存降级&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Grafana汉化指南</title>
    <link href="http://yoursite.com/2022/01/06/Grafana%E6%B1%89%E5%8C%96%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2022/01/06/Grafana汉化指南/</id>
    <published>2022-01-06T11:12:12.000Z</published>
    <updated>2022-01-06T12:04:29.073Z</updated>
    
    <content type="html"><![CDATA[<p>Grafana汉化指南,仅供学习使用。</p><a id="more"></a><p>[TOC]</p><p>主要步骤参考自<a href="https://www.bilibili.com/read/cv6735751?spm_id_from=333.999.0.0" target="_blank" rel="noopener">^1</a></p><h1 id="grafana汉化步骤："><a href="#grafana汉化步骤：" class="headerlink" title="grafana汉化步骤："></a>grafana汉化步骤：</h1><p>CentOs 7.6 x64环境</p><h2 id="第一步：安装nodejs和yarn，nodejs版本要大于12-0-0"><a href="#第一步：安装nodejs和yarn，nodejs版本要大于12-0-0" class="headerlink" title="第一步：安装nodejs和yarn，nodejs版本要大于12.0.0"></a>第一步：安装nodejs和yarn，nodejs版本要大于12.0.0</h2><p>如何安装nodejs和yarn？参考以下链接</p><p><a href="https://yarn.bootcss.com/docs/install/#centos-stable" target="_blank" rel="noopener">https://yarn.bootcss.com/docs/install/#centos-stable</a></p><p>或直接使用以下命令安装</p><pre><code># curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | tee /etc/yum.repos.d/yarn.repo# curl --silent --location https://rpm.nodesource.com/setup_12.x | bash -# yum install -y nodejs# yum install -y yarn</code></pre><h2 id="第二步：到github（https-github-com-grafana-grafana-tree-v6-7-x）上找到grafana源码"><a href="#第二步：到github（https-github-com-grafana-grafana-tree-v6-7-x）上找到grafana源码" class="headerlink" title="第二步：到github（https://github.com/grafana/grafana/tree/v6.7.x）上找到grafana源码"></a>第二步：到github（<a href="https://github.com/grafana/grafana/tree/v6.7.x）上找到grafana源码" target="_blank" rel="noopener">https://github.com/grafana/grafana/tree/v6.7.x）上找到grafana源码</a></h2><p>选择对应的分支，直接Dowload ZIP文件。不需要clone整个仓库，太慢太耗时间。</p><h2 id="第三步：指定yarn源"><a href="#第三步：指定yarn源" class="headerlink" title="第三步：指定yarn源"></a>第三步：指定yarn源</h2><pre><code># yarn config set registry https://registry.npm.taobao.org --global# yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -g# yarn config get registry</code></pre><h2 id="第四步：安装依赖和构建"><a href="#第四步：安装依赖和构建" class="headerlink" title="第四步：安装依赖和构建"></a>第四步：安装依赖和构建</h2><pre><code># cd grafana-6.7.x# yarn install# yarn build</code></pre><h2 id="第五步：确认能编译成功（无报错），然后将编译后的目录同步到-usr-share-grafana"><a href="#第五步：确认能编译成功（无报错），然后将编译后的目录同步到-usr-share-grafana" class="headerlink" title="第五步：确认能编译成功（无报错），然后将编译后的目录同步到/usr/share/grafana/"></a>第五步：确认能编译成功（无报错），然后将编译后的目录同步到/usr/share/grafana/</h2><p>首次同步前，先备份/usr/share/grafana/public目录</p><pre><code># mv /usr/share/grafana/public  /usr/share/grafana/public.source</code></pre><p>将当前编译目录下的public目录拷贝到/usr/share/grafana/</p><pre><code># /bin/cp -rp public/ /usr/share/grafana/</code></pre><p>重启grafana-server</p><p>systemctl restart grafana-server</p><p>确认编译环境正常后，开始第六步。</p><h2 id="第六步：汉化，然后重复第四、第五步。"><a href="#第六步：汉化，然后重复第四、第五步。" class="headerlink" title="第六步：汉化，然后重复第四、第五步。"></a>第六步：汉化，然后重复第四、第五步。</h2><p>windows 10设置编译环境</p><p>node下载: <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>yarn下载：<a href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener">https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable</a></p><p>下对安装包后直接双击安装。</p><pre><code>yarn config set registry https://registry.npm.taobao.org -gyarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -gyarn config get registryyarn install yarn build</code></pre><p>注：在编译时，系统内存要大于4GB</p><p>以下是例出几个汉化的页面。</p><p>修改登录页</p><pre><code>app/core/components/Login/LoginForm.tsx修改Change Passwordapp/features/profile/ChangePasswordPage.tsx app/features/profile/ChangePasswordForm.tsx</code></pre><p>修改偏好设置Preferences</p><pre><code>app/features/org/SelectOrgCtrl.tsapp/core/components/SharedPreferences/SharedPreferences.tsxapp/features/admin/partials/edit_user.htmlapp/features/profile/ChangePasswordForm.tsx</code></pre><p>总结：若时间充裕以及有需求，后续会考虑将Grafana 6.7.4做一个完整的汉化版。</p><h1 id="Grafana侧边栏汉化"><a href="#Grafana侧边栏汉化" class="headerlink" title="Grafana侧边栏汉化"></a>Grafana侧边栏汉化</h1><p>步骤补充如下：但如果侧边菜单栏要中文化还需要修改Grafana源码中用go语言编写的代码。</p><h2 id="第一步：安装go并设置环境变量"><a href="#第一步：安装go并设置环境变量" class="headerlink" title="第一步：安装go并设置环境变量"></a>第一步：安装go并设置环境变量</h2><pre><code># wget https://gomirrors.org/dl/go/go1.13.12.linux-amd64.tar.gz# tar xvf go1.13.12.linux-amd64.tar.gz -C /usr/local</code></pre><p>设置环境变量</p><pre><code>export GOROOT=/usr/local/goexport PATH=$PATH:/usr/local/go/binexport GOPATH=/home/go/srcexport GO111MODULE=onexport GOPROXY=https://goproxy.io</code></pre><h2 id="第二步：将下载下来的Grafana源码移到GOPATH对应路径下"><a href="#第二步：将下载下来的Grafana源码移到GOPATH对应路径下" class="headerlink" title="第二步：将下载下来的Grafana源码移到GOPATH对应路径下"></a>第二步：将下载下来的Grafana源码移到GOPATH对应路径下</h2><p>如在克隆grafana时非常慢，可以到gitee进行下载</p><pre><code>##git clone https://gitee.com/mirrors/grafana.gitcd $GOPATH/src/github.com/grafana/grafana</code></pre><h2 id="第三步：编译"><a href="#第三步：编译" class="headerlink" title="第三步：编译"></a>第三步：编译</h2><pre><code>go run build.go setupgo run build.go build    </code></pre><h2 id="第四步：备份grafana-server二进制文件，并使用新编译的grafana-server二进制文件"><a href="#第四步：备份grafana-server二进制文件，并使用新编译的grafana-server二进制文件" class="headerlink" title="第四步：备份grafana-server二进制文件，并使用新编译的grafana-server二进制文件"></a>第四步：备份grafana-server二进制文件，并使用新编译的grafana-server二进制文件</h2><pre><code>mv /usr/sbin/grafana-server /usr/sbin/grafana-server.sourcesystemctl stop grafana-serversleep 1cp -rp ./bin/linux-amd64/grafana-server /usr/sbin/sleep 1systemctl start grafana-server</code></pre><h2 id="第五步：中文化go部分代码后，只需重复第三、四步。"><a href="#第五步：中文化go部分代码后，只需重复第三、四步。" class="headerlink" title="第五步：中文化go部分代码后，只需重复第三、四步。"></a>第五步：中文化go部分代码后，只需重复第三、四步。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Grafana汉化指南,仅供学习使用。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Grafana" scheme="http://yoursite.com/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（一致性算法）</title>
    <link href="http://yoursite.com/2022/01/06/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/06/JAVA 学习笔记（一致性算法）/</id>
    <published>2022-01-06T09:12:12.000Z</published>
    <updated>2022-01-06T13:56:07.367Z</updated>
    
    <content type="html"><![CDATA[<p>Paxos，Zab，Raft，NWR和Gossip，一致性Hash算法</p><a id="more"></a><p>[TOC]</p><h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><p>Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的一个实现。 在 Paxos 算法中，有三种角色：Proposer，Acceptor，Learners</p><h2 id="Paxos-三种角色：Proposer，Acceptor，Learners"><a href="#Paxos-三种角色：Proposer，Acceptor，Learners" class="headerlink" title="Paxos 三种角色：Proposer，Acceptor，Learners"></a>Paxos 三种角色：Proposer，Acceptor，Learners</h2><h3 id="Proposer："><a href="#Proposer：" class="headerlink" title="Proposer："></a>Proposer：</h3><p>只要 Proposer 发的提案被半数以上 Acceptor 接受，Proposer 就认为该提案里的 value 被选定了。</p><h3 id="Acceptor："><a href="#Acceptor：" class="headerlink" title="Acceptor："></a>Acceptor：</h3><p>只要 Acceptor 接受了某个提案，Acceptor 就认为该提案里的 value 被选定了。</p><h3 id="Learner："><a href="#Learner：" class="headerlink" title="Learner："></a>Learner：</h3><p>Acceptor 告诉 Learner 哪个 value 被选定，Learner 就认为那个 value 被选定。</p><h2 id="Paxos-算法分为两个阶段。具体如下："><a href="#Paxos-算法分为两个阶段。具体如下：" class="headerlink" title="Paxos 算法分为两个阶段。具体如下："></a>Paxos 算法分为两个阶段。具体如下：</h2><h3 id="阶段一（准-leader-确定-）："><a href="#阶段一（准-leader-确定-）：" class="headerlink" title="阶段一（准 leader 确定 ）："></a>阶段一（准 leader 确定 ）：</h3><p>(a) Proposer 选择一个提案编号 N，然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。</p><p>(b) 如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。</p><h3 id="阶段二（leader-确认）："><a href="#阶段二（leader-确认）：" class="headerlink" title="阶段二（leader 确认）："></a>阶段二（leader 确认）：</h3><p>(a) 如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor。注意：V 就是收到的响应中编号最大的提案的 value，如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定。</p><p>(b) 如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求做出过响应，它就接受该提案</p><h1 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h1><p> ZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议）协议包括两种基本的模式：崩溃恢复和消息广播</p><ol><li><p>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断崩溃退出与重启等异常情况时，ZAB 就会进入恢复模式并选举产生新的 Leader 服务器。</p></li><li><p>当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出崩溃恢复模式，进入消息广播模式。</p></li><li><p>当有新的服务器加入到集群中去，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器会自动进入数据恢复模式，找到 Leader 服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p></li></ol><p>以上其实大致经历了三个步骤：</p><p>1.崩溃恢复：主要就是 Leader 选举过程</p><p>2.数据同步：Leader 服务器与其他服务器进行数据同步</p><p>3.消息广播：Leader 服务器将数据发送给其他服务器</p><p>说明：zookeeper 章节对该协议有详细描述。</p><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>与 Paxos 不同 Raft 强调的是易懂（Understandability），Raft 和 Paxos 一样只要保证 n/2+1节点正常就能够提供服务；raft把算法流程分为三个子问题：选举（Leader election）、日志复制（Log replication）、安全性（Safety）三个子问题。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p> Raft 把集群中的节点分为三种状态：Leader、 Follower 、Candidate，理所当然每种状态负责的任务也是不一样的，Raft 运行时提供服务的时候只存在 Leader 与 Follower 两种状态；</p><h3 id="Leader（领导者-日志管理）"><a href="#Leader（领导者-日志管理）" class="headerlink" title="Leader（领导者-日志管理）"></a>Leader（领导者-日志管理）</h3><p>负责日志的同步管理，处理来自客户端的请求，与 Follower 保持这 heartBeat 的联系；</p><h3 id="Follower（追随者-日志同步）"><a href="#Follower（追随者-日志同步）" class="headerlink" title="Follower（追随者-日志同步）"></a>Follower（追随者-日志同步）</h3><p>刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应Candidate的请求，把请求到 Follower 的事务转发给 Leader；</p><h3 id="Candidate（候选者-负责选票）"><a href="#Candidate（候选者-负责选票）" class="headerlink" title="Candidate（候选者-负责选票）"></a>Candidate（候选者-负责选票）</h3><p>负责选举投票，Raft 刚启动时由一个节点从 Follower 转为 Candidate 发起选举，选举出Leader 后从 Candidate 转为 Leader 状态；</p><h3 id="Term（任期）"><a href="#Term（任期）" class="headerlink" title="Term（任期）"></a>Term（任期）</h3><p>在 Raft 中使用了一个可以理解为周期（第几届、任期）的概念，用 Term 作为一个周期，每个 Term 都是一个连续递增的编号，每一轮选举都是一个 Term 周期，在一个 Term 中只能产生一个 Leader；当某节点收到的请求中 Term 比当前 Term 小时则拒绝该请求。</p><h2 id="选举（Election）"><a href="#选举（Election）" class="headerlink" title="选举（Election）"></a>选举（Election）</h2><h3 id="选举定时器"><a href="#选举定时器" class="headerlink" title="选举定时器"></a>选举定时器</h3><p>Raft 的选举由定时器来触发，每个节点的选举定时器时间都是不一样的，开始时状态都为Follower</p><p>某个节点定时器触发选举后 Term 递增，状态由 Follower 转为 Candidate，向其他节点发起 RequestVote RPC 请求，这时候有三种可能的情况发生：</p><p>1：该 RequestVote 请求接收到 n/2+1（过半数）个节点的投票，从 Candidate 转为 Leader，向其他节点发送 heartBeat 以保持 Leader 的正常运转。</p><p>2：在此期间如果收到其他节点发送过来的 AppendEntries RPC 请求，如该节点的 Term 大则当前节点转为 Follower，否则保持 Candidate 拒绝该请求。</p><p>3：Election timeout 发生则 Term 递增，重新发起选举</p><p>在一个 Term 期间每个节点只能投票一次，所以当有多个 Candidate 存在时就会出现每个Candidate发起的选举都存在接收到的投票数都不过半的问题，这时每个 Candidate 都将 Term递增、重启定时器并重新发起选举，由于每个节点中定时器的时间都是随机的，所以就不会多次存在有多个 Candidate同时发起投票的问题。</p><p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过heartbeat 把该 Entry 同步给其他 Follower，Follower<br>接收到日志后记录日志然后向 Leader 发送ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p><h2 id="安全性（Safety）"><a href="#安全性（Safety）" class="headerlink" title="安全性（Safety）"></a>安全性（Safety）</h2><p>安全性是用于保证每个节点都执行相同序列的安全机制如当某个 Follower 在当前 Leader commit Log 时变得不可用了，稍后可能该 Follower 又会被选举为 Leader，这时新 Leader 可能会用新的Log 覆盖先前已 committed 的 Log，这就是导致节点执行不同序列；Safety 就是用于保证选举出来的 Leader 一定包含先前 commited Log 的机制；</p><p>选举安全性（Election Safety）：每个 Term 只能选举出一个 Leader</p><p>Leader 完整性（Leader Completeness）：这里所说的完整性是指 Leader 日志的完整性，Raft 在选举阶段就使用 Term的判断用于保证完整性：当请求投票的该 Candidate 的 Term 较大或 Term 相同 Index 更大则投票，该节点将容易变成 leader。</p><h2 id="raft-协议和-zab-协议区别"><a href="#raft-协议和-zab-协议区别" class="headerlink" title="raft 协议和 zab 协议区别"></a>raft 协议和 zab 协议区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p> 采用 quorum 来确定整个系统的一致性,这个 quorum 一般实现是集群中半数以上的服务器,</p><p> zookeeper 里还提供了带权重的 quorum 实现.</p><p> 都由 leader 来发起写操作.</p><p> 都采用心跳检测存活性</p><p>leader election 都采用先到先得的投票方式</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p> zab 用的是 epoch 和 count 的组合来唯一表示一个值, 而 raft 用的是 term 和 index</p><p> zab 的 follower 在投票给一个 leader 之前必须和 leader 的日志达成一致,而 raft 的 follower则简单地说是谁的 term 高就投票给谁</p><p> raft 协议的心跳是从 leader 到 follower, 而 zab 协议则相反</p><p> raft 协议数据只有单向地从 leader 到 follower(成为 leader 的条件之一就是拥有最新的 log)</p><p>而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面最新的 log,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致.</p><h1 id="NWR"><a href="#NWR" class="headerlink" title="NWR"></a>NWR</h1><p>N：在分布式存储系统中，有多少份备份数据</p><p>W：代表一次成功的更新操作要求至少有 w 份数据写入成功</p><p>R： 代表一次成功的读数据操作要求至少有 R 份数据成功读取</p><p>NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N 的时候，整个系统对于客户端来讲能保证强一致性。而如果 R+W&lt;=N，则无法保证数据的强一致性。以常见的 N=3、W=2、R=2 为例：</p><p>N=3，表示，任何一个对象都必须有三个副本（Replica），W=2 表示，对数据的修改操作（Write）只需要在 3 个 Replica 中的 2 个上面完成就返回，R=2 表示，从三个对象中要读取到 2个数据对象，才能返回。</p><p>如果R+W&gt;N,则读取操作和写入操作成功的数据一定会有交集（如图中的Node2），这样就可以保证一定能够读取到最新版本的更新数据，数据的强一致性得到了保证。在满足数据一致性协议的前提下，R或者W设置的越大，则系统延迟越大，因为这取决于最慢的那份备份数据的响应时间。</p><p>当R+W&lt;=N，无法保证数据的强一致性</p><p>因为成功写和成功读集合可能不存在交集，这样读操作无法读取到最新的更新数值，也就无法保证数据的强一致性。</p><h1 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h1><p>Gossip 算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致，这充分说明了 Gossip 的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</p><h1 id="一致性-Hash"><a href="#一致性-Hash" class="headerlink" title="一致性 Hash"></a>一致性 Hash</h1><p>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client 也选择这种算法，解决将 key-value 均匀分配到众多 Memcached server 上的问题。</p><p>它可以取代传统的取模操作，解决了取模操作无法应对增删 Memcached Server 的问题(增删 server 会导致同一个 key,在 get 操作时分配不到数据真正存储的 server，命中率会急剧下降)。</p><h2 id="一致性-Hash-特性"><a href="#一致性-Hash-特性" class="headerlink" title="一致性 Hash 特性"></a>一致性 Hash 特性</h2><p> 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p><p> 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。容易看到，上面的简单求余算法hash(object)%N 难以满足单调性要求。</p><p> 平滑性(Smoothness)：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</p><h2 id="一致性-Hash-原理"><a href="#一致性-Hash-原理" class="headerlink" title="一致性 Hash 原理"></a>一致性 Hash 原理</h2><h3 id="建构环形-hash-空间："><a href="#建构环形-hash-空间：" class="headerlink" title="建构环形 hash 空间："></a>建构环形 hash 空间：</h3><ol><li>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环。</li></ol><h3 id="把需要缓存的内容-对象-映射到-hash-空间"><a href="#把需要缓存的内容-对象-映射到-hash-空间" class="headerlink" title="把需要缓存的内容(对象)映射到 hash 空间"></a>把需要缓存的内容(对象)映射到 hash 空间</h3><ol start="2"><li>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布</li></ol><h3 id="把服务器-节点-映射到-hash-空间"><a href="#把服务器-节点-映射到-hash-空间" class="headerlink" title="把服务器(节点)映射到 hash 空间"></a>把服务器(节点)映射到 hash 空间</h3><ol start="3"><li>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。一般的方法可以使用 服务器(节点) 机器的 IP 地址或者机器名作为hash 输入。</li></ol><h3 id="把对象映射到服务节点"><a href="#把对象映射到服务节点" class="headerlink" title="把对象映射到服务节点"></a>把对象映射到服务节点</h3><ol start="4"><li>现在服务节点和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，首先确定对象hash值在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器</li></ol><h3 id="考察-cache-的变动"><a href="#考察-cache-的变动" class="headerlink" title="考察 cache 的变动"></a>考察 cache 的变动</h3><ol start="5"><li>通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时，cache 会失效。</li></ol><p>5.1 移除 cache：考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象。</p><p>5.2 添加 cache：再考虑添加一台新的 cache D 的情况，这时受影响的将仅是那些沿 cacheD 逆时针遍历直到下一个 cache 之间的对象，将这些对象重新映射到 cache D 上即可。</p><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：</p><p>虚拟节点（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash值排列。</p><p>仍以仅部署 cache A 和 cache C 的情况为例。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A； cache C1,cache C2 代表了 cache C 。此时，对象到“虚拟节点”的映射关系为：</p><pre><code>objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ；</code></pre><p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。</p><p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如下图 所示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Paxos，Zab，Raft，NWR和Gossip，一致性Hash算法&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Consistency" scheme="http://yoursite.com/tags/Consistency/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（数据库）</title>
    <link href="http://yoursite.com/2022/01/06/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/06/JAVA 学习笔记（数据库）/</id>
    <published>2022-01-06T02:12:12.000Z</published>
    <updated>2022-01-06T09:34:00.065Z</updated>
    
    <content type="html"><![CDATA[<p>存储引擎，索引，事务，锁等概念</p><a id="more"></a><p>[TOC]</p><details>    <summary></summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></details><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。</p><h2 id="InnoDB（B-树）"><a href="#InnoDB（B-树）" class="headerlink" title="InnoDB（B+树）"></a>InnoDB（B+树）</h2><p>InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。</p><p>适用场景：</p><p>1）经常更新的表，适合处理多重并发的更新请求。</p><p>2）支持事务。</p><p>3）可以从灾难中恢复（通过 bin-log 日志等）。</p><p>4）外键约束。只有他支持外键。</p><p>5）支持自动增加列属性 auto_increment</p><h2 id="TokuDB（Fractal-Tree-节点带数据）"><a href="#TokuDB（Fractal-Tree-节点带数据）" class="headerlink" title="TokuDB（Fractal Tree-节点带数据）"></a>TokuDB（Fractal Tree-节点带数据）</h2><p>TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree中，每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个Message Buffer 是一个 FIFO 的队列，用来缓存更新操作。</p><p>例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</p><p>TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p><h2 id="MyIASM"><a href="#MyIASM" class="headerlink" title="MyIASM"></a>MyIASM</h2><p>MyIASM是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织<br>成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。</p><p>缺点是它不 支持事务处理。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉。Memory同时支持散列索引和B树索引，B树索引可以使用部分查询和通配查询，也可以使用&lt;,&gt;和&gt;=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）</p><h2 id="常见索引原则"><a href="#常见索引原则" class="headerlink" title="常见索引原则"></a>常见索引原则</h2><ol><li><p>选择唯一性索引<br>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</p></li><li><p>为经常需要排序、分组和联合操作的字段建立索引：</p></li></ol><p>3．为常作为查询条件的字段建立索引。</p><p>4．限制索引的数目：  </p><p>越多的索引，会使更新表变得很浪费时间。</p><p>5．尽量使用数据量少的索引   </p><p>如果索引的值很长，那么查询的速度会受到影响。</p><p>6．尽量使用前缀来索引   </p><p>如果索引字段的值很长，最好使用值的前缀来索引。</p><p>7．删除不再使用或者很少使用的索引</p><ol start="8"><li><p>最左前缀匹配原则，非常重要的原则。</p></li><li><p>尽量选择区分度高的列作为索引    </p></li></ol><p>区分度的公式是表示字段不重复的比例</p><ol start="10"><li><p>索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</p></li><li><p>尽量的扩展索引，不要新建索引。</p></li></ol><h1 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h1><p>范式是具有最小冗余的表结构。3 范式具体如下：</p><h2 id="第一范式-1st-NF-－列都是不可再分"><a href="#第一范式-1st-NF-－列都是不可再分" class="headerlink" title="第一范式(1st NF －列都是不可再分)"></a>第一范式(1st NF －列都是不可再分)</h2><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）</p><h2 id="第二范式-2nd-NF－每个表只描述一件事情"><a href="#第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="第二范式(2nd NF－每个表只描述一件事情)"></a>第二范式(2nd NF－每个表只描述一件事情)</h2><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。</p><h2 id="第三范式-3rd-NF－-不存在对非主键列的传递依赖"><a href="#第三范式-3rd-NF－-不存在对非主键列的传递依赖" class="headerlink" title="第三范式(3rd NF－ 不存在对非主键列的传递依赖)"></a>第三范式(3rd NF－ 不存在对非主键列的传递依赖)</h2><p> 第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号</p><h1 id="数据库是事务"><a href="#数据库是事务" class="headerlink" title="数据库是事务"></a>数据库是事务</h1><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行。事务是一个不可分割的工作逻辑单元</p><p>事务必须具备以下四个属性，简称 ACID 属性：</p><h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h2><ol><li>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</li></ol><h2 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h2><ol start="2"><li>当事务完成时，数据必须处于一致状态。</li></ol><h2 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h2><ol start="3"><li>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</li></ol><h2 id="永久性（Durability）"><a href="#永久性（Durability）" class="headerlink" title="永久性（Durability）"></a>永久性（Durability）</h2><ol start="4"><li>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</li></ol><h1 id="存储过程-特定功能的-SQL-语句集"><a href="#存储过程-特定功能的-SQL-语句集" class="headerlink" title="存储过程(特定功能的 SQL 语句集)"></a>存储过程(特定功能的 SQL 语句集)</h1><p>一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。</p><h2 id="存储过程优化思路："><a href="#存储过程优化思路：" class="headerlink" title="存储过程优化思路："></a>存储过程优化思路：</h2><ol><li>尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。</li><li>中间结果存放于临时表，加索引。</li><li>少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。</li><li>事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。</li><li>使用 try-catch 处理错误异常。</li><li>查找语句尽量不要放在循环内。</li></ol><h1 id="触发器-一段能自动执行的程序"><a href="#触发器-一段能自动执行的程序" class="headerlink" title="触发器(一段能自动执行的程序)"></a>触发器(一段能自动执行的程序)</h1><p>触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、alter、drop 语句。</p><p>SQL（Structure Query Language）结构化查询语言</p><p>DQL（data query language）数据查询语言 select操作</p><p>DML（data manipulation language）数据操作语言，主要是数据库增删改三种操作</p><p>DDL（data defination language）数据库定义语言，主要是建表、删除表、修改表字段等操作</p><p>DCL（data control language）数据库控制语言，如commit，revoke之类的，在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</p><h1 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h1><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，</p><p>以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。</p><h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：</p><ol><li>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li><li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li><li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li></ol><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><h2 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h2><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</p><h1 id="基于-Redis-分布式锁"><a href="#基于-Redis-分布式锁" class="headerlink" title="基于 Redis 分布式锁"></a>基于 Redis 分布式锁</h1><ol><li>获取锁的时候，使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁。</li><li>获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ol><h1 id="分区分表"><a href="#分区分表" class="headerlink" title="分区分表"></a>分区分表</h1><p>分库分表有垂直切分和水平切分两种。</p><h2 id="垂直切分-按照功能模块"><a href="#垂直切分-按照功能模块" class="headerlink" title="垂直切分(按照功能模块)"></a>垂直切分(按照功能模块)</h2><p> 将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</p><h2 id="水平切分-按照规则划分存储"><a href="#水平切分-按照规则划分存储" class="headerlink" title="水平切分(按照规则划分存储)"></a>水平切分(按照规则划分存储)</h2><p> 当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。</p><h1 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h1><p>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。</p><p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</p><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并<br>最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><h2 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h2><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="同步阻塞问题"><a href="#同步阻塞问题" class="headerlink" title="同步阻塞问题"></a>同步阻塞问题</h3><p>1、执行过程中，所有参与节点都是事务阻塞型的。</p><h3 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h3><p>2、由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。</p><h3 id="数据不一致（脑裂问题）"><a href="#数据不一致（脑裂问题）" class="headerlink" title="数据不一致（脑裂问题）"></a>数据不一致（脑裂问题）</h3><p>3、在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。</p><h2 id="二阶段无法解决的问题（数据状态不确定）"><a href="#二阶段无法解决的问题（数据状态不确定）" class="headerlink" title="二阶段无法解决的问题（数据状态不确定）"></a>二阶段无法解决的问题（数据状态不确定）</h2><p>4、协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><h1 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h1><p>三阶段提交（ Three-phase commit ） ， 也 叫 三 阶 段 提 交 协 议 （ Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。</p><p>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p><h2 id="CanCommit-阶段"><a href="#CanCommit-阶段" class="headerlink" title="CanCommit 阶段"></a>CanCommit 阶段</h2><p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p><h2 id="PreCommit-阶段"><a href="#PreCommit-阶段" class="headerlink" title="PreCommit 阶段"></a>PreCommit 阶段</h2><p>协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。</p><p>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行</p><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><h2 id="doCommit-阶段"><a href="#doCommit-阶段" class="headerlink" title="doCommit 阶段"></a>doCommit 阶段</h2><p>该阶段进行真正的事务提交，主要包含 </p><p>1.协调者发送提交请求 </p><p>2.参与者提交事务 </p><p>3.参与者响应反馈（ 事务提交完之后，向协调者发送 Ack 响应。）</p><p>4.协调者确定完成事务。</p><h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><h2 id="一致性Consistency（C）："><a href="#一致性Consistency（C）：" class="headerlink" title="一致性Consistency（C）："></a>一致性Consistency（C）：</h2><ol><li>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li></ol><h2 id="可用性Availability（A）："><a href="#可用性Availability（A）：" class="headerlink" title="可用性Availability（A）："></a>可用性Availability（A）：</h2><ol start="2"><li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li></ol><h2 id="分区容忍性Partition-tolerance（P）："><a href="#分区容忍性Partition-tolerance（P）：" class="headerlink" title="分区容忍性Partition tolerance（P）："></a>分区容忍性Partition tolerance（P）：</h2><ol start="3"><li>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li></ol><p>翻译过来就是说系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务。</p><p>分区容错性和拓展性息息相关，因为越大的分布式系统越有可能出现机器宕机，网络阻塞等情况。即使这些意外情况发生，系统仍然能保持稳定是系统拓展的前提。在分布式系统当中出现的问题可能性很多，既可能出现部分机器宕机，也有可能出现内网阻隔，使得整个集群被拆分成互相不能通信的几个部分。分区容错性需要保证即使这些情况发生，系统也一样可以保证一致性和可用性。</p><p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p><h3 id="舍弃A，保留CP"><a href="#舍弃A，保留CP" class="headerlink" title="舍弃A，保留CP"></a>舍弃A，保留CP</h3><p>一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。</p><p>对于有些系统而言，一致性是安身立命之本，比如Hbase、Redis这种分布式存储，数据一致性是最基本的要求。不满足一致性的存储显然不会有用户愿意使用。</p><p>ZooKeeper也是一样，任何时候访问ZK都可以获得一致性的结果。它的职责就是保证管辖下的服务保持同步和一致，显然不可能放弃一致性。但是在极端情况下，ZK可能会丢弃调一些请求，消费者需要重新请求才能获得结果。</p><p>如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件，因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足</p><h3 id="舍弃C，保留AP"><a href="#舍弃C，保留AP" class="headerlink" title="舍弃C，保留AP"></a>舍弃C，保留AP</h3><p>这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。比如淘宝购物以及12306购票等等，前面说过淘宝可以做到全年可用性5个9的超高级别，但是此时就无法保证数据一致性了。</p><p>举个例子，我们在12306买票的时候就经常会遇到。在我们点击购买的时候，系统并没有提示没票。等我们输入了验证码，付款的时候才会告知，已经没有票了。这就是因为我们在点击购买的时候，数据没有达成一致性，在付款校验的时候才检验出余票不足。这种设计会牺牲一些用户体验，但是可以保证高可用，让用户不至于无法访问或者是长时间等待，也算是一种取舍吧。</p><h3 id="舍弃P，保留CA"><a href="#舍弃P，保留CA" class="headerlink" title="舍弃P，保留CA"></a>舍弃P，保留CA</h3><p>很遗憾，这种情况几乎不存在。因为分布式系统，网络分区是必然的。如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在的。</p><p>比如一般的关系型数据库，像是MySQL或者是Oracle，它们都保证了一致性和可用性，但是并不是分布式系统。从这点上来说CAP并不是等价的，我们并不能通过牺牲CA来提升P。要想提升分区容错性，只能通过提升基础设施的稳定性来达到。也就是说这并不是一个软件问题。</p><h1 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h1><h2 id="柔性事务-1"><a href="#柔性事务-1" class="headerlink" title="柔性事务"></a>柔性事务</h2><p>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。</p><h3 id="基本可用（Basically-Available）"><a href="#基本可用（Basically-Available）" class="headerlink" title="基本可用（Basically Available）"></a>基本可用（Basically Available）</h3><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p><p>响应时间上的损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。<br>功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><h3 id="柔性状态（Soft-State）"><a href="#柔性状态（Soft-State）" class="headerlink" title="柔性状态（Soft State）"></a>柔性状态（Soft State）</h3><p>什么是柔性状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>柔性状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>上面说柔性状态，然后不可能一直是柔性状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p><p>而在实际工程实践中，最终一致性分为5种：以下五种是从百科摘来的，仅供了解。</p><h4 id="因果一致性（Causal-consistency）"><a href="#因果一致性（Causal-consistency）" class="headerlink" title="因果一致性（Causal consistency）"></a>因果一致性（Causal consistency）</h4><p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p><h4 id="读己之所写（Read-your-writes）"><a href="#读己之所写（Read-your-writes）" class="headerlink" title="读己之所写（Read your writes）"></a>读己之所写（Read your writes）</h4><p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p><h4 id="会话一致性（Session-consistency）"><a href="#会话一致性（Session-consistency）" class="headerlink" title="会话一致性（Session consistency）"></a>会话一致性（Session consistency）</h4><p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p><h4 id="单调读一致性（Monotonic-read-consistency）"><a href="#单调读一致性（Monotonic-read-consistency）" class="headerlink" title="单调读一致性（Monotonic read consistency）"></a>单调读一致性（Monotonic read consistency）</h4><p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p><h4 id="单调写一致性（Monotonic-write-consistency）"><a href="#单调写一致性（Monotonic-write-consistency）" class="headerlink" title="单调写一致性（Monotonic write consistency）"></a>单调写一致性（Monotonic write consistency）</h4><p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p><p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p><p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p><p>通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。</p><h3 id="两阶段型"><a href="#两阶段型" class="headerlink" title="两阶段型"></a>两阶段型</h3><p>1、就是分布式事务两阶段提交，对应技术上的 XA、JTA/JTS。这是分布式环境下事务处理的典型模式。</p><h3 id="补偿型"><a href="#补偿型" class="headerlink" title="补偿型"></a>补偿型</h3><p>2、TCC 型事务（Try/Confirm/Cancel）可以归为补偿型</p><p>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成。</p><p>但是如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。</p><h3 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h3><p>3、通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。</p><h3 id="最大努力通知型（多次尝试）"><a href="#最大努力通知型（多次尝试）" class="headerlink" title="最大努力通知型（多次尝试）"></a>最大努力通知型（多次尝试）</h3><p>4、这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, 允许在达到最大重试次数之后正常结束事务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储引擎，索引，事务，锁等概念&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（负载均衡）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（负载均衡）/</id>
    <published>2022-01-05T13:12:12.000Z</published>
    <updated>2022-01-06T02:15:54.887Z</updated>
    
    <content type="html"><![CDATA[<p>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带<br>宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><a id="more"></a><p>[TOC]</p><h1 id="四层负载均衡-vs-七层负载均衡"><a href="#四层负载均衡-vs-七层负载均衡" class="headerlink" title="四层负载均衡 vs 七层负载均衡"></a>四层负载均衡 vs 七层负载均衡</h1><h2 id="四层负载均衡（目标地址和端口交换）"><a href="#四层负载均衡（目标地址和端口交换）" class="headerlink" title="四层负载均衡（目标地址和端口交换）"></a>四层负载均衡（目标地址和端口交换）</h2><p>主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>以常见的 TCP 为例，负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有：</p><p>F5：硬件负载均衡器，功能很好，但是成本很高。</p><p>lvs：重量级的四层负载软件。</p><p>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。</p><p>haproxy：模拟四层转发，较灵活。</p><h2 id="七层负载均衡（内容交换）"><a href="#七层负载均衡（内容交换）" class="headerlink" title="七层负载均衡（内容交换）"></a>七层负载均衡（内容交换）</h2><p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>七层应用负载的好处，是使得整个网络更智能化。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。实现七层负载均衡的软件有：</p><p>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；</p><p>nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多；</p><p>apache：功能较差</p><p>Mysql proxy：功能尚可。</p><h1 id="负载均衡算法-策略"><a href="#负载均衡算法-策略" class="headerlink" title="负载均衡算法/策略"></a>负载均衡算法/策略</h1><h2 id="轮循均衡（Round-Robin）"><a href="#轮循均衡（Round-Robin）" class="headerlink" title="轮循均衡（Round Robin）"></a>轮循均衡（Round Robin）</h2><p>每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p><h2 id="权重轮循均衡（Weighted-Round-Robin）"><a href="#权重轮循均衡（Weighted-Round-Robin）" class="headerlink" title="权重轮循均衡（Weighted Round Robin）"></a>权重轮循均衡（Weighted Round Robin）</h2><p>根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p><h2 id="随机均衡（Random）"><a href="#随机均衡（Random）" class="headerlink" title="随机均衡（Random）"></a>随机均衡（Random）</h2><p>把来自网络的请求随机分配给内部中的多个服务器。</p><h2 id="权重随机均衡（Weighted-Random）"><a href="#权重随机均衡（Weighted-Random）" class="headerlink" title="权重随机均衡（Weighted Random）"></a>权重随机均衡（Weighted Random）</h2><p>此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。</p><h2 id="响应速度均衡（Response-Time-探测时间）"><a href="#响应速度均衡（Response-Time-探测时间）" class="headerlink" title="响应速度均衡（Response Time 探测时间）"></a>响应速度均衡（Response Time 探测时间）</h2><p>负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</p><h2 id="最少连接数均衡（Least-Connection）"><a href="#最少连接数均衡（Least-Connection）" class="headerlink" title="最少连接数均衡（Least Connection）"></a>最少连接数均衡（Least Connection）</h2><p>最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。</p><h2 id="处理能力均衡（CPU、内存）"><a href="#处理能力均衡（CPU、内存）" class="headerlink" title="处理能力均衡（CPU、内存）"></a>处理能力均衡（CPU、内存）</h2><p>此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况下。</p><h2 id="DNS-响应均衡（Flash-DNS）"><a href="#DNS-响应均衡（Flash-DNS）" class="headerlink" title="DNS 响应均衡（Flash DNS）"></a>DNS 响应均衡（Flash DNS）</h2><p>在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，则客户端将以最先收到的域名解析IP地址来继续请求服务，而忽略其它的IP地址响应。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。</p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>一致性哈希一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><h2 id="IP-地址散列（保证客户端服务器对应关系稳定）"><a href="#IP-地址散列（保证客户端服务器对应关系稳定）" class="headerlink" title="IP 地址散列（保证客户端服务器对应关系稳定）"></a>IP 地址散列（保证客户端服务器对应关系稳定）</h2><p>通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p><h2 id="URL-散列"><a href="#URL-散列" class="headerlink" title="URL 散列"></a>URL 散列</h2><p>通过管理客户端请求 URL 信息的散列，将发送至相同 URL 的请求转发至同一服务器的算法。</p><h1 id="LVS-Linux-Virtual-Servers-Linux-虚拟服务器）"><a href="#LVS-Linux-Virtual-Servers-Linux-虚拟服务器）" class="headerlink" title="LVS (Linux Virtual Servers Linux 虚拟服务器）"></a>LVS (Linux Virtual Servers Linux 虚拟服务器）</h1><h2 id="LVS-原理"><a href="#LVS-原理" class="headerlink" title="LVS 原理"></a>LVS 原理</h2><h3 id="IPVS（IP-Virtual-ServerIP虚拟服务器）"><a href="#IPVS（IP-Virtual-ServerIP虚拟服务器）" class="headerlink" title="IPVS（IP Virtual ServerIP虚拟服务器）"></a>IPVS（IP Virtual ServerIP虚拟服务器）</h3><p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server列表中选取一个服务节点响应用户的请求。在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。</p><p>ipvs ： 工作于内核空间，主要用于使用户定义的策略生效</p><p>ipvsadm : 工作于用户空间，主要用于用户定义和管理集群服务的工具</p><p>ipvs 工作于内核空间的 INPUT 链上，当收到用户请求某集群服务时，经过 PREROUTING 链，经检查本机路由表，送往 INPUT 链；在进入 netfilter 的 INPUT 链时，ipvs 强行将请求报文通过ipvsadm 定义的集群服务策略的路径改为 FORWORD 链，将报文转发至后端真实提供服务的主机。</p><h2 id="LVS-NAT-模式（Network-Address-Translation，网络地址转换）"><a href="#LVS-NAT-模式（Network-Address-Translation，网络地址转换）" class="headerlink" title="LVS NAT 模式（Network Address Translation，网络地址转换）"></a>LVS NAT 模式（Network Address Translation，网络地址转换）</h2><p>①客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP),后面统称为 CIP)，目标地址为 VIP(负载均衡器前端地址，后面统称为 VIP)。</p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。</p><p>③.报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，并将响应报文返还给 LVS。</p><p>④.然后 lvs 将此报文的源地址修改为本机并发送给客户端。</p><p>注意：在 NAT 模式中，Real Server 的网关必须指向 LVS，否则报文无法送达客户端</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1、NAT 技术将请求的报文和响应的报文都需要通过 LB (load balance负载均衡) 进行地址改写，因此网站访问量比较大的时候 LB 负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点</p><p>2、只需要在 LB 上配置一个公网 IP 地址就可以了。</p><p>3、每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。</p><p>4、NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>集群中的物理服务器可以使用任何支持 TCP/IP 操作系统，只有负载均衡器需要一个合法的 IP 地址。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>扩展性有限。当服务器节点（普通 PC 服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！</p><h2 id="LVS-DR-模式（直接路由模式，局域网改写-mac-地址）"><a href="#LVS-DR-模式（直接路由模式，局域网改写-mac-地址）" class="headerlink" title="LVS DR 模式（直接路由模式，局域网改写 mac 地址）"></a>LVS DR 模式（直接路由模式，局域网改写 mac 地址）</h2><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。</p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的源MAC 地址改为自己 DIP 的 MAC 地址，目标 MAC 改为了 RIP 的 MAC 地址，并将此包发送给 RS。</p><p>③.RS 发现请求报文中的目的 MAC 是自己，就会将次报文接收下来，处理完请求报文后，将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。</p><p>注意：需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、通过在调度器 LB 上修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP，目的地址仍然是 VIP 地址。</p><p>2、请求的报文经过调度器，而 RS 响应处理后的报文无需经过调度器 LB，因此并发访问量大时使用效率很高（和 NAT 模式比）</p><p>3、因为 DR 模式是通过 MAC 地址改写机制实现转发，因此所有 RS 节点和调度器 LB 只能在一个局域网里面</p><p>4、RS 主机需要绑定 VIP 地址在 LO 接口（掩码 32 位）上，并且需要配置 ARP 抑制。</p><p>5、RS 节点的默认网关不需要配置成 LB，而是直接配置为上级路由的网关，能让 RS 直接出网就可以。</p><p>6、由于 DR 模式的调度器仅做 MAC 地址的改写，所以调度器 LB 就不能改写目标端口，那么 RS服务器就得使用和 VIP 相同的端口提供服务。</p><p>7、直接对外的业务比如 WEB 等，RS 的 IP 最好是使用公网 IP。对外的服务，比如数据库等最好使用内网 IP。</p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>和 TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与 VS-TUN 相比，VS-DR 这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。</p><p>DR 模式的效率很高，但是配置稍微复杂一点，因此对于访问量不是特别大的公司可以用haproxy/nginx取代。日1000-2000W PV或者并发请求1万一下都可以考虑用haproxy/nginx。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>所有 RS 节点和调度器 LB 只能在一个局域网里面</p><h2 id="LVS-TUN-模式（IP-封装、跨网段）"><a href="#LVS-TUN-模式（IP-封装、跨网段）" class="headerlink" title="LVS TUN 模式（IP 封装、跨网段）"></a>LVS TUN 模式（IP 封装、跨网段）</h2><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。</p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为 DIP，目标地址改为 RIP,并将此包发送给 RS。</p><p>③.RS 收到请求报文后，会首先拆开第一层封装,然后发现里面还有一层 IP 首部的目标地址是自己lo 接口上的 VIP，所以会处理次请求报文，并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。</p><p>注意：需要设置 lo 接口的 VIP 不能在公网上出现。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>1.TUNNEL 模式必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址</p><p>2.TUNNEL 模式的 vip ——&gt;realserver 的包通信通过 TUNNEL 模式，不管是内网和外网都能通信，所以不需要 lvs vip 跟 realserver 在同一个网段内。</p><p>3.TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了</p><p>4.TUNNEL 模式走的隧道模式，所以运维起来比较难，所以一般不用。</p><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><p>负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。</p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分 Linux 系统上。</p><h2 id="LVS-FULLNAT-模式"><a href="#LVS-FULLNAT-模式" class="headerlink" title="LVS FULLNAT 模式"></a>LVS FULLNAT 模式</h2><p>无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则LVS 无法作为 RS 的网关。这引发的两个问题是：</p><p>1、同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。</p><p>2、LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。</p><p>Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题，而跨 VLAN 问题解决后，LVS 和 RS不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。</p><p>Full-NAT 相比 NAT 的主要改进是，在 SNAT/DNAT 的基础上，加上另一种转换，转换过程如下：</p><ol><li>在包从 LVS 转到 RS 的过程中，源地址从客户端 IP 被替换成了 LVS 的内网 IP。内网 IP 之间可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.</li><li>当 RS 处理完接受到的包，处理完成后返回时，将目标地址修改为 LVS ip，原地址修改为 RSIP，最终将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。</li><li>LVS 收到包后，在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP,并将原地址修改为 VIP。</li></ol><p>Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段；</p></li><li><p>full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10%</p></li></ol><h1 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a>Keepalive</h1><p>keepalive 起初是为 LVS 设计的，专门用来监控lvs各个服务节点的状态，后来加入了vrrp的功能，因此除了lvs，也可以作为其他服务（nginx，haproxy）的高可用软件。VRRP 是 virtual router redundancy protocal（虚拟路由器冗余协议）的缩写。VRRP 的出现就是为了解决静态路由出现的单点故障，它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVS cluster node healthcheck 功能，另一方面也具有 LVS director failover。</p><h1 id="Nginx-反向代理负载均衡"><a href="#Nginx-反向代理负载均衡" class="headerlink" title="Nginx 反向代理负载均衡"></a>Nginx 反向代理负载均衡</h1><p>普通的负载均衡软件，如 LVS，其实现的功能只是对请求数据包的转发、传递，从负载均衡下的节点服务器来看，接收到的请求还是来自访问负载均衡器的客户端的真实用户；而反向代理就不一样了，反向代理服务器在接收访问用户请求后，会代理用户重新发起请求代理下的节点服务器，最后把数据返回给客户端用户。在节点服务器看来，访问的节点服务器的客户端用户就是反向代理服务器，而非真实的网站访问用户。</p><h2 id="upstream-module-和健康检测"><a href="#upstream-module-和健康检测" class="headerlink" title="upstream_module 和健康检测"></a>upstream_module 和健康检测</h2><p>ngx_http_upstream_module 是负载均衡模块，可以实现网站的负载均衡功能即节点的健康检查，upstream模块允许Nginx定义一组或多组节点服务器组，使用时可通过 proxy_pass 代理方式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。</p><h2 id="proxy-pass-请求转发"><a href="#proxy-pass-请求转发" class="headerlink" title="proxy_pass 请求转发"></a>proxy_pass 请求转发</h2><p>proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，在实际的反向代理工作中，会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的请求通过 proyx_pass 抛给定义好的 upstream 节点池。</p><h1 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带&lt;br&gt;宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>686. 重复叠加字符串匹配</title>
    <link href="http://yoursite.com/2022/01/05/686.%20%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2022/01/05/686. 重复叠加字符串匹配/</id>
    <published>2022-01-05T08:12:12.000Z</published>
    <updated>2022-01-05T09:34:24.958Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</p><a id="more"></a><p>[TOC]</p><p>注意：字符串 “abc” 重复叠加 0 次是 “”，重复叠加 1 次是 “abc”，重复叠加 2 次是 “abcabc”。</p><p>示例 1：</p><pre><code>输入：a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;输出：3解释：a 重复叠加三遍后为 &quot;abcdabcdabcd&quot;, 此时 b 是其子串。</code></pre><p>示例 2：</p><pre><code>输入：a = &quot;a&quot;, b = &quot;aa&quot;输出：2</code></pre><p>示例 3：</p><pre><code>输入：a = &quot;a&quot;, b = &quot;a&quot;输出：1</code></pre><p>示例 4：</p><pre><code>输入：a = &quot;abc&quot;, b = &quot;wxyz&quot;输出：-1</code></pre><p>提示：</p><pre><code>1 &lt;= a.length &lt;= 1041 &lt;= b.length &lt;= 104a 和 b 由小写英文字母组成</code></pre><h1 id="方法一：Rabin-Karp-算法-1"><a href="#方法一：Rabin-Karp-算法-1" class="headerlink" title="方法一：Rabin-Karp 算法^1"></a>方法一：Rabin-Karp 算法<a href="https://leetcode-cn.com/problems/repeated-string-match/solution/zhong-fu-die-jia-zi-fu-chuan-pi-pei-by-l-vnye/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k2 = <span class="number">1337</span>;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> kMod1 = rand() % k1 + k1;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> kMod2 = rand() % k2 + k2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> hash_needle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : needle) &#123;</span><br><span class="line">            hash_needle = (hash_needle * kMod2 + c) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> hash_haystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            extra = (extra * kMod2) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">            hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            <span class="keyword">if</span> (hash_haystack == hash_needle) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash_haystack = (hash_haystack - extra * haystack[(i - m + <span class="number">1</span>) % n]) % kMod1;</span><br><span class="line">            hash_haystack = (hash_haystack + kMod1) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.size(), bn = b.size();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> kMod1 = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> kMod2 = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.length(), bn = b.length();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">1000000009</span>;</span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">1337</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> kMod1 = random.nextInt(k1) + k1;</span><br><span class="line">        <span class="keyword">int</span> kMod2 = random.nextInt(k2) + k2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> hashNeedle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = needle.charAt(i);</span><br><span class="line">            hashNeedle = (hashNeedle * kMod2 + c) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> hashHaystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;</span><br><span class="line">            extra = (extra * kMod2) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;</span><br><span class="line">            <span class="keyword">if</span> (hashHaystack == hashNeedle) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashHaystack = (hashHaystack - extra * haystack.charAt((i - m + <span class="number">1</span>) % n)) % kMod1;</span><br><span class="line">            hashHaystack = (hashHaystack + kMod1) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RepeatedStringMatch(string a, string b) &#123;</span><br><span class="line">        int an = a.Length, bn = b.Length;</span><br><span class="line">        int index = StrStr(a, b);</span><br><span class="line">        if (index == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (an - index &gt;= bn) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (bn + index - an - 1) / an + 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int StrStr(string haystack, string needle) &#123;</span><br><span class="line">        int n = haystack.Length, m = needle.Length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int k1 = 1000000009;</span><br><span class="line">        int k2 = 1337;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        int kMod1 = random.Next(k1, k1 * 2);</span><br><span class="line">        int kMod2 = random.Next(k2, k2 * 2);</span><br><span class="line"></span><br><span class="line">        long hashNeedle = 0;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            char c = needle[i];</span><br><span class="line">            hashNeedle = (hashNeedle * kMod2 + c) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        long hashHaystack = 0, extra = 1;</span><br><span class="line">        for (int i = 0; i &lt; m - 1; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            extra = (extra * kMod2) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = m - 1; (i - m + 1) &lt; n; i++) &#123;</span><br><span class="line">            hashHaystack = (hashHaystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">            if (hashHaystack == hashNeedle) &#123;</span><br><span class="line">                return i - m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            hashHaystack = (hashHaystack - extra * haystack[(i - m + 1) % n]) % kMod1;</span><br><span class="line">            hashHaystack = (hashHaystack + kMod1) % kMod1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span> *haystack, <span class="keyword">int</span> n, <span class="keyword">char</span> *needle, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k2 = <span class="number">1337</span>;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> kMod1 = rand() % k1 + k1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> kMod2 = rand() % k2 + k2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> hash_needle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        hash_needle = (hash_needle * kMod2 + needle[i]) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> hash_haystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">        extra = (extra * kMod2) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">        hash_haystack = (hash_haystack * kMod2 + haystack[i % n]) % kMod1;</span><br><span class="line">        <span class="keyword">if</span> (hash_haystack == hash_needle) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_haystack = (hash_haystack - extra * haystack[(i - m + <span class="number">1</span>) % n]) % kMod1;</span><br><span class="line">        hash_haystack = (hash_haystack + kMod1) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="keyword">char</span> * a, <span class="keyword">char</span> * b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> an = <span class="built_in">strlen</span>(a), bn = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">int</span> index = strStr(a, an, b, bn);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> k1 <span class="keyword">int</span> = <span class="number">1000000000</span> + <span class="number">7</span></span><br><span class="line">    <span class="keyword">var</span> k2 <span class="keyword">int</span> = <span class="number">1337</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> kMod1 <span class="keyword">int64</span> = <span class="keyword">int64</span>(rand.Intn(k1)) + <span class="keyword">int64</span>(k1)</span><br><span class="line">    <span class="keyword">var</span> kMod2 <span class="keyword">int64</span> = <span class="keyword">int64</span>(rand.Intn(k2)) + <span class="keyword">int64</span>(k2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hash_needle <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        hash_needle = (hash_needle*kMod2 + <span class="keyword">int64</span>(needle[i])) % kMod1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hash_haystack <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> extra <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        hash_haystack = (hash_haystack*kMod2 + <span class="keyword">int64</span>(haystack[i%n])) % kMod1</span><br><span class="line">        extra = (extra * kMod2) % kMod1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++ &#123;</span><br><span class="line">        hash_haystack = (hash_haystack*kMod2 + <span class="keyword">int64</span>(haystack[i%n])) % kMod1</span><br><span class="line">        <span class="keyword">if</span> hash_haystack == hash_needle &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        hash_haystack = (hash_haystack - extra*<span class="keyword">int64</span>(haystack[(i-m+<span class="number">1</span>)%n])) % kMod1</span><br><span class="line">        hash_haystack = (hash_haystack + kMod1) % kMod1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedStringMatch</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    an, bn := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">    index := strStr(a, b)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> an-index &gt;= bn &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn+index-an<span class="number">-1</span>)/an + <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeatedStringMatch = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> an = a.length, bn = b.length;</span><br><span class="line">    <span class="keyword">const</span> index = strStr(a, b);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor((bn + index - an - <span class="number">1</span>) / an) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strStr = <span class="function">(<span class="params">haystack, needle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = haystack.length, m = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> k1 = <span class="number">1000000009</span>;</span><br><span class="line">    <span class="keyword">let</span> k2 = <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">let</span> kMod1 = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * k1) + k1;</span><br><span class="line">    <span class="keyword">let</span> kMod2 = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * k2) + k2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hashNeedle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = needle[i].charCodeAt();</span><br><span class="line">        hashNeedle = (hashNeedle * kMod2 + c) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> hashHaystack = <span class="number">0</span>, extra = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        hashHaystack = (hashHaystack * kMod2 + haystack[i % n].charCodeAt()) % kMod1;</span><br><span class="line">        extra = (extra * kMod2) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = m - <span class="number">1</span>; (i - m + <span class="number">1</span>) &lt; n; i++) &#123;</span><br><span class="line">        hashHaystack = (hashHaystack * kMod2 + haystack[i % n].charCodeAt()) % kMod1;</span><br><span class="line">        <span class="keyword">if</span> (hashHaystack === hashNeedle) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashHaystack = (hashHaystack - extra * haystack[(i - m + <span class="number">1</span>) % n].charCodeAt()) % kMod1;</span><br><span class="line">        hashHaystack = (hashHaystack + kMod1) % kMod1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strstr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        k1 = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        k2 = <span class="number">1337</span></span><br><span class="line">        mod1 = randrange(k1) + k1</span><br><span class="line">        mod2 = randrange(k2) + k2</span><br><span class="line"></span><br><span class="line">        hash_needle = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> needle:</span><br><span class="line">            hash_needle = (hash_needle * mod2 + ord(c)) % mod1</span><br><span class="line">        hash_haystack = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>):</span><br><span class="line">            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1</span><br><span class="line">        extra = pow(mod2, m - <span class="number">1</span>, mod1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, n + m - <span class="number">1</span>):</span><br><span class="line">            hash_haystack = (hash_haystack * mod2 + ord(haystack[i % n])) % mod1</span><br><span class="line">            <span class="keyword">if</span> hash_haystack == hash_needle:</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">            hash_haystack = (hash_haystack - extra * ord(haystack[(i - m + <span class="number">1</span>) % n])) % mod1</span><br><span class="line">            hash_haystack = (hash_haystack + mod1) % mod1</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedStringMatch</span><span class="params">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(a), len(b)</span><br><span class="line">        index = self.strstr(a, b)</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n - index &gt;= m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (m + index - n - <span class="number">1</span>) // n + <span class="number">2</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)</em>, 其中 <em>n</em> 为 <em>a</em> 的长度，<em>m</em> 为 <em>b</em> 的长度。Rabin-Karp 算法的时间复杂度为 <em>O(n + m)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。只需要常数空间保存参数。</p></li></ul><h1 id="方法二：Knuth-Morris-Pratt-算法"><a href="#方法二：Knuth-Morris-Pratt-算法" class="headerlink" title="方法二：Knuth-Morris-Pratt 算法"></a>方法二：Knuth-Morris-Pratt 算法</h1><p><strong>前言</strong></p><p>关于 Knuth-Morris-Pratt 算法的具体实现，读者可以参阅官方题解「<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/" target="_blank" rel="noopener">28. 实现 strStr()</a>」，笔者就不作详细介绍了。</p><p><strong>思路与算法</strong></p><p>类似于方法一，我们也可以使用 Knuth-Morris-Pratt 算法来实现字符串匹配的功能。在应用 Knuth-Morris-Pratt 算法时，被匹配字符串是循环叠加的字符串，所以下标要进行取余操作，并且匹配终止的条件为 <em>b</em> 开始匹配的位置超过第一个叠加的 <em>a</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> &amp;haystack, <span class="built_in">string</span> &amp;needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pi(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] != needle[j]) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.size(), bn = b.size();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> an = a.length(), bn = b.length();</span><br><span class="line">        <span class="keyword">int</span> index = strStr(a, b);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] pi = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i % n) != needle.charAt(j)) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i % n) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RepeatedStringMatch(string a, string b) &#123;</span><br><span class="line">        int an = a.Length, bn = b.Length;</span><br><span class="line">        int index = StrStr(a, b);</span><br><span class="line">        if (index == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (an - index &gt;= bn) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (bn + index - an - 1) / an + 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int StrStr(string haystack, string needle) &#123;</span><br><span class="line">        int n = haystack.Length, m = needle.Length;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] pi = new int[m];</span><br><span class="line">        for (int i = 1, j = 0; i &lt; m; i++) &#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0, j = 0; i - j &lt; n; i++) &#123; // b 开始匹配的位置是否超过第一个叠加的 a</span><br><span class="line">            while (j &gt; 0 &amp;&amp; haystack[i % n] != needle[j]) &#123; // haystack 是循环叠加的字符串，所以取 i % n</span><br><span class="line">                j = pi[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == m) &#123;</span><br><span class="line">                return i - m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span> * haystack, <span class="keyword">int</span> n, <span class="keyword">char</span> * needle, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pi[m];</span><br><span class="line">    pi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] != needle[j]) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="keyword">char</span> * a, <span class="keyword">char</span> * b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> an = <span class="built_in">strlen</span>(a), bn = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">int</span> index = strStr(a, an, b, bn);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn + index - an - <span class="number">1</span>) / an + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    pi := <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j] &#123;</span><br><span class="line">            j = pi[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> needle[i] == needle[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i-j &lt; n; i++ &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">        <span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; haystack[i%n] != needle[j] &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">            j = pi[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> haystack[i%n] == needle[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == m &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedStringMatch</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    an, bn := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">    index := strStr(a, b)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> an-index &gt;= bn &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (bn+index-an<span class="number">-1</span>)/an + <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeatedStringMatch = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> an = a.length, bn = b.length;</span><br><span class="line">    <span class="keyword">const</span> index = strStr(a, b);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (an - index &gt;= bn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor((bn + index - an - <span class="number">1</span>) / an) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strStr = <span class="function">(<span class="params">haystack, needle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = haystack.length, m = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> pi = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] !== needle[j]) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[i] === needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i - j &lt; n; i++) &#123; <span class="comment">// b 开始匹配的位置是否超过第一个叠加的 a</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i % n] !== needle[j]) &#123; <span class="comment">// haystack 是循环叠加的字符串，所以取 i % n</span></span><br><span class="line">            j = pi[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i % n] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strstr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        pi = [<span class="number">0</span>] * m</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = pi[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            pi[i] = j</span><br><span class="line"></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i - j &lt; n:</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i % n] != needle[j]:</span><br><span class="line">                j = pi[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i % n] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == m:</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedStringMatch</span><span class="params">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(a), len(b)</span><br><span class="line">        index = self.strstr(a, b)</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> n - index &gt;= m:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (m + index - n - <span class="number">1</span>) // n + <span class="number">2</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n + m)*，其中 *n</em> 为 <em>a</em> 的长度，<em>m</em> 为 <em>b</em> 的长度。Knuth-Morris-Pratt 算法的时间复杂度为 <em>O(n + m)</em>。</p></li><li><p>空间复杂度：<em>O(m)*。Knuth-Morris-Pratt 算法需要 *O(m)</em> 的空间来保存pi 数组。</p></li></ul><h1 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h1><p>一个完整的字符串s最终是要包含b的，所以a在只能有以下几种情况：</p><p>b出现了a中没有的字符，返回-1；</p><p>b和a包含的字符是一致的，此时又分为：</p><p>情况1：a = ‘abc’, b = ‘ab’，此时无需重复a，返回初始字符串；</p><p>情况2：a = ‘abcd’, b = ‘cdabcdab’，此时对a重复，返回重复的字符串，因为最差情况下b必然是起始使用了a的一部分，结尾使用了a的一部分；<br>可以使用repeat函数，计算初始要重复的次数ret = b.len() / a.len()，得出中间填充a的个数，情况一被规避，然后再分别在左、右添加一个a，情况2被规避。</p><details>    <summary>Go</summary><figure class="highlight go"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedStringMatch</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">m, n, exist := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b), <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> a &#123;</span><br><span class="line">exist[ch-<span class="string">'a'</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> b &#123;</span><br><span class="line"><span class="keyword">if</span> !(exist[ch-<span class="string">'a'</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := n / m</span><br><span class="line">str := strings.Repeat(a, ret)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(str, b) &#123;</span><br><span class="line"><span class="keyword">return</span> ret + i</span><br><span class="line">&#125;</span><br><span class="line">str += a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span>[] exist = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : a.toCharArray()) &#123;</span><br><span class="line">exist[ch - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : b.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!exist[ch - <span class="string">'a'</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = b.length() / a.length();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(a.repeat(ret));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sb.toString().contains(b)) &#123;</span><br><span class="line"><span class="keyword">return</span> ret + i;</span><br><span class="line">&#125;</span><br><span class="line">sb.append(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="String Matching" scheme="http://yoursite.com/tags/String-Matching/"/>
    
      <category term="KMP Algorithm" scheme="http://yoursite.com/tags/KMP-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Cassandra）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Cassandra%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（Cassandra）/</id>
    <published>2022-01-05T08:12:12.000Z</published>
    <updated>2022-01-05T12:51:48.440Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL（non-relationa非关系型）数据库。Cassandra旨在处理多商品服务器上的大量数据，提供高可用性而无需担心单点故障。</p><a id="more"></a><p>[TOC]</p><p>此篇有很多细节讲的不够清楚，看的有些迷糊。如果需要进一步学习还需要再看其它资料。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="Key-Space（对应-SQL-数据库中的-database）"><a href="#Key-Space（对应-SQL-数据库中的-database）" class="headerlink" title="Key Space（对应 SQL 数据库中的 database）"></a>Key Space（对应 SQL 数据库中的 database）</h2><ol><li>一个 Key Space 中可包含若干个 CF，如同 SQL 数据库中一个 database 可包含多个 table</li></ol><h2 id="Key（对应-SQL-数据库中的主键）"><a href="#Key（对应-SQL-数据库中的主键）" class="headerlink" title="Key（对应 SQL 数据库中的主键）"></a>Key（对应 SQL 数据库中的主键）</h2><ol start="2"><li>在 Cassandra 中，每一行数据记录是以 key/value 的形式存储的，其中 key 是唯一标识。</li></ol><h2 id="column（对应-SQL-数据库中的列）"><a href="#column（对应-SQL-数据库中的列）" class="headerlink" title="column（对应 SQL 数据库中的列）"></a>column（对应 SQL 数据库中的列）</h2><ol start="3"><li>Cassandra 中每个 key/value 对中的 value 又称为 column，它是一个三元组，即：name，value 和 timestamp，其中 name 需要是唯一的。</li></ol><h2 id="super-column（SQL-数据库不支持）"><a href="#super-column（SQL-数据库不支持）" class="headerlink" title="super column（SQL 数据库不支持）"></a>super column（SQL 数据库不支持）</h2><ol start="4"><li>cassandra 允许 key/value 中的 value 是一个 map(key/value_list)，即某个 column 有多个子列。</li></ol><h2 id="Standard-Column-Family（相对应-SQL-数据库中的-table）"><a href="#Standard-Column-Family（相对应-SQL-数据库中的-table）" class="headerlink" title="Standard Column Family（相对应 SQL 数据库中的 table）"></a>Standard Column Family（相对应 SQL 数据库中的 table）</h2><ol start="5"><li>每个 CF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 column。</li></ol><h2 id="Super-Column-Family（SQL-数据库不支持）"><a href="#Super-Column-Family（SQL-数据库不支持）" class="headerlink" title="Super Column Family（SQL 数据库不支持）"></a>Super Column Family（SQL 数据库不支持）</h2><ol start="6"><li>每个 SCF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 super column</li></ol><h1 id="Cassandra-一致-Hash-和虚拟节点"><a href="#Cassandra-一致-Hash-和虚拟节点" class="headerlink" title="Cassandra 一致 Hash 和虚拟节点"></a>Cassandra 一致 Hash 和虚拟节点</h1><h2 id="一致性-Hash（多米诺-down-机）"><a href="#一致性-Hash（多米诺-down-机）" class="headerlink" title="一致性 Hash（多米诺 down 机）"></a>一致性 Hash（多米诺 down 机）</h2><p>为每个节点分配一个 token，根据这个 token 值来决定节点在集群中的位置以及这个节点所存储的数据范围。</p><h2 id="虚拟节点（down-机多节点托管）"><a href="#虚拟节点（down-机多节点托管）" class="headerlink" title="虚拟节点（down 机多节点托管）"></a>虚拟节点（down 机多节点托管）</h2><p>由于这种方式会造成数据分布不均的问题，在 Cassandra1.2 以后采用了虚拟节点的思想：不需要为每个节点分配token，把圆环分成更多部分，让每个节点负责多个部分的数据，这样一个节点移除后，它所负责的多个 token 会托管给多个节点处理，这种思想解决了数据分布不均的问题。</p><p>如图所示，上面部分是标准一致性哈希，每个节点负责圆环中连续的一段，如果 Node2 突然down 掉，Node2 负责的数据托管给 Node1，即 Node1 负责 EFAB 四段，如果 Node1 里面有很多热点用户产生的数据导致 Node1 已经有点撑不住了，恰巧 B 也是热点用户产生的数据，这样一来 Node1 可能会接着 down 机，Node1down 机，Node6 还 hold 住吗？</p><p>下面部分是虚拟节点实现，每个节点不再负责连续部分，且圆环被分为更多的部分。如果 Node2突然 down 掉，Node2 负责的数据不全是托管给 Node1，而是托管给多个节点。而且也保持了一致性哈希的特点。</p><h1 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h1><p>Gossip 算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此 Gossip 有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。Gossip的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。因为Gossip不要求节点知道所有其他节点，因此又具有去中心化的特点，节点之间完全对等，不需要任何的中心节点。实际上 Gossip 可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。</p><h2 id="Gossip-节点的通信方式及收敛性"><a href="#Gossip-节点的通信方式及收敛性" class="headerlink" title="Gossip 节点的通信方式及收敛性"></a>Gossip 节点的通信方式及收敛性</h2><h3 id="Gossip-两个节点（A、B）之间存在三种通信方式（push、pull、push-amp-pull）"><a href="#Gossip-两个节点（A、B）之间存在三种通信方式（push、pull、push-amp-pull）" class="headerlink" title="Gossip 两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）"></a>Gossip 两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）</h3><ol><li>push: A 节点将数据(key,value,version)及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。</li><li>pull：A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据（Key,value,version）推送给 A，A 更新本地。</li><li>push/pull：与 pull 类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地。</li></ol><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push 需通信 1 次，pull 需 2 次，push/pull 则需 3 次，从效果上来讲，push/pull 最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull 的收敛速度是最快的。</p><h3 id="gossip-的协议和-seed-list（防止集群分列）"><a href="#gossip-的协议和-seed-list（防止集群分列）" class="headerlink" title="gossip 的协议和 seed list（防止集群分列）"></a>gossip 的协议和 seed list（防止集群分列）</h3><p>cassandra 使用称为 gossip 的协议来发现加入C集群中的其他节点的位置和状态信息。gossip进程每秒都在进行，并与至多三个节点交换状态信息。节点交换他们自己和所知道的信息，于是所有的节点很快就能学习到整个集群中的其他节点的信息。gossip 信息有一个相关的版本号，于是在一次 gossip 信息交换中，旧的信息会被新的信息覆盖重写。要阻止分区进行gossip交流，那么在集群中的所有节点中使用相同的 seed list，种子节点的指定除了启动起gossip进程外，没有其他的目的。种子节点不是一个单点故障，他们在集群操作中也没有其他的特殊目的，除了引导节点以外</p><h1 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h1><h2 id="Partitioners（计算-primary-key-token-的-hash-函数）"><a href="#Partitioners（计算-primary-key-token-的-hash-函数）" class="headerlink" title="Partitioners（计算 primary key token 的 hash 函数）"></a>Partitioners（计算 primary key token 的 hash 函数）</h2><p>在 Cassandra 中，table 的每行由唯一的 primarykey 标识，partitioner 实际上为一 hash 函数用以计算 primary key 的 token。Cassandra 依据这个 token 值在集群中放置对应的行</p><h2 id="两种可用的复制策略："><a href="#两种可用的复制策略：" class="headerlink" title="两种可用的复制策略："></a>两种可用的复制策略：</h2><h3 id="SimpleStrategy：仅用于单数据中心，"><a href="#SimpleStrategy：仅用于单数据中心，" class="headerlink" title="SimpleStrategy：仅用于单数据中心，"></a>SimpleStrategy：仅用于单数据中心，</h3><p>将第一个 replica 放在由 partitioner 确定的节点中，其余的 replicas 放在上述节点顺时针方向的后续节点中。</p><h3 id="NetworkTopologyStrategy：可用于较复杂的多数据中心。"><a href="#NetworkTopologyStrategy：可用于较复杂的多数据中心。" class="headerlink" title="NetworkTopologyStrategy：可用于较复杂的多数据中心。"></a>NetworkTopologyStrategy：可用于较复杂的多数据中心。</h3><p>可以指定在每个数据中心分别存储多少份 replicas。</p><p>复制策略在创建 keyspace 时指定，如</p><pre><code>CREATE KEYSPACE Excelsior WITH REPLICATION = { &apos;class&apos; :&apos;SimpleStrategy&apos;,&apos;replication_factor&apos; : 3 };CREATE KEYSPACE Excalibur WITH REPLICATION = {&apos;class&apos; :&apos;NetworkTopologyStrategy&apos;,&apos;dc1&apos; : 3, &apos;dc2&apos; : 2};</code></pre><h1 id="数据写请求和协调者"><a href="#数据写请求和协调者" class="headerlink" title="数据写请求和协调者"></a>数据写请求和协调者</h1><h2 id="协调者-coordinator"><a href="#协调者-coordinator" class="headerlink" title="协调者(coordinator)"></a>协调者(coordinator)</h2><p>协调者(coordinator)将 write 请求发送到拥有对应 row 的所有 replica 节点，只要节点可用便获取并执行写请求。写一致性级别(write consistency level)确定要有多少个 replica 节点必须返回成功的确认信息。成功意味着数据被正确写入了 commit log 和 memtable。</p><p>其中 dc1、dc2 这些数据中心名称要与 snitch 中配置的名称一致.上面的拓扑策略表示在 dc1 配置3 个副本,在 dc2 配置 2 个副本</p><h1 id="数据读请求和后台修复"><a href="#数据读请求和后台修复" class="headerlink" title="数据读请求和后台修复"></a>数据读请求和后台修复</h1><ol><li><p>协调者首先与一致性级别确定的所有 replica 联系，被联系的节点返回请求的数据。</p></li><li><p>若多个节点被联系，则来自各 replica 的 row 会在内存中作比较，若不一致，则协调者使用含最新数据的 replica 向 client 返回结果。那么比较操作过程中只需要传递时间戳就可以,因为要比较的只是哪个副本数据是最新的。</p></li><li><p>协调者在后台联系和比较来自其余拥有对应 row 的 replica 的数据，若不一致，会向过时的replica 发写请求用最新的数据进行更新 read repair。</p></li></ol><h1 id="数据存储（CommitLog、MemTable、SSTable）"><a href="#数据存储（CommitLog、MemTable、SSTable）" class="headerlink" title="数据存储（CommitLog、MemTable、SSTable）"></a>数据存储（CommitLog、MemTable、SSTable）</h1><p>写请求分别到 CommitLog 和 MemTable, 并且 MemTable 的数据会刷写到磁盘 SSTable 上. 除了写数据,还有索引也会保存到磁盘上.</p><p>先将数据写到磁盘中的 commitlog，同时追加到中内存中的数据结构 memtable 。这个时候就会返回客户端状态 ， memtable 内 容 超 出 指 定 容 量 后 会 被 放 进 将 被 刷 入 磁 盘 的 队 列(memtable_flush_queue_size 配置队列长度)。若将被刷入磁盘的数据超出了队列长度，将内存<br>数据刷进磁盘中的 SSTable,之后 commit log 被清空。</p><h2 id="SSTable-文件构成（BloomFilter、index、data、static）"><a href="#SSTable-文件构成（BloomFilter、index、data、static）" class="headerlink" title="SSTable 文件构成（BloomFilter、index、data、static）"></a>SSTable 文件构成（BloomFilter、index、data、static）</h2><p>SSTable 文件有 fileer（判断数据 key 是否存在，这里使用了BloomFilter提高效率），index（寻找对应column值所在data文件位置）文件，data（存储真实数据）文件，static（存储和统计column 和 row 大小）文件。</p><h1 id="二级索引（对要索引的-value-摘要，生成-RowKey）"><a href="#二级索引（对要索引的-value-摘要，生成-RowKey）" class="headerlink" title="二级索引（对要索引的 value 摘要，生成 RowKey）"></a>二级索引（对要索引的 value 摘要，生成 RowKey）</h1><p>在 Cassandra 中，数据都是以 Key-value 的形式保存的。</p><p>KeysIndex 所创建的二级索引也被保存在一张 ColumnFamily 中。在插入数据时，对需要进行索引的 value进行摘要，生成独一无二的key，将其作为 RowKey保存在索引的 ColumnFamily 中；</p><p>同时在 RowKey 上添加一个 Column，将插入数据的 RowKey 作为 name 域的值，value 域则赋空值，timestamp 域则赋为插入数据的时间戳。</p><p>如果有相同的 value 被索引了，则会在索引 ColumnFamily 中相同的 RowKey 后再添加新的Column。如果有新的 value 被索引，则会在索引 ColumnFamily 中添加新的 RowKey 以及对应新的 Column。</p><p>当对 value 进行查询时，只需计算该 value 的 RowKey，在索引 ColumnFamily 中的查找该RowKey，对其 Columns 进行遍历就能得到该 value 所有数据的 RowKey。</p><h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="数据写入和更新（数据追加）"><a href="#数据写入和更新（数据追加）" class="headerlink" title="数据写入和更新（数据追加）"></a>数据写入和更新（数据追加）</h2><p>Cassandra 的设计思路与这些系统不同，无论是 insert 还是 remove 操作，都是在已有的数据后面进行追加，而不修改已有的数据。这种设计称为 Log structured 存储，顾名思义就是系统中的数据是以日志的形式存在的，所以只会将新的数据追加到已有数据的后面。Log structured 存储</p><p>系统有两个主要优点：</p><h2 id="数据的写和删除效率极高"><a href="#数据的写和删除效率极高" class="headerlink" title="数据的写和删除效率极高"></a>数据的写和删除效率极高</h2><p> 传统的存储系统需要更新元信息和数据，因此磁盘的磁头需要反复移动，这是一个比较耗时的操作，而 Log structured的系统则是顺序写，可以充分利用文件系统的 cache，所以效率很高。</p><h2 id="错误恢复简单"><a href="#错误恢复简单" class="headerlink" title="错误恢复简单"></a>错误恢复简单</h2><p> 由于数据本身就是以日志形式保存，老的数据不会被覆盖，所以在设计 journal 的时候不需要考虑 undo，简化了错误恢复。</p><h2 id="读的复杂度高"><a href="#读的复杂度高" class="headerlink" title="读的复杂度高"></a>读的复杂度高</h2><p> 但是，Log structured 的存储系统也引入了一个重要的问题：读的复杂度和性能。理论上说，读操作需要从后往前扫描数据，以找到某个记录的最新版本。相比传统的存储系统，这是比较耗时的。</p><p>参考：<a href="https://blog.csdn.net/fs1360472174/article/details/55005335" target="_blank" rel="noopener">https://blog.csdn.net/fs1360472174/article/details/55005335</a></p><h2 id="数据删除（column-的墓碑）"><a href="#数据删除（column-的墓碑）" class="headerlink" title="数据删除（column 的墓碑）"></a>数据删除（column 的墓碑）</h2><p>如果一次删除操作在一个节点上失败了（总共 3 个节点，副本为 3， RF=3).整个删除操作仍然被认为成功的（因为有两个节点应答成功，使用 CL.QUORUM 一致性）。接下来如果读发生在该节点上就会变的不明确，因为结果返回是空，还是返回数据，没有办法确定哪一种是正确的。</p><p>Cassandra 总是认为返回数据是对的，那就会发生删除的数据又出现了的事情，这些数据可以叫”僵尸”，并且他们的表现是不可预见的。</p><h2 id="墓碑"><a href="#墓碑" class="headerlink" title="墓碑"></a>墓碑</h2><p>删除一个 column 其实只是插入一个关于这个 column 的墓碑（tombstone），并不直接删除原有的 column。该墓碑被作为对该 CF 的一次修改记录在 Memtable 和 SSTable 中。墓碑的内容是删除请求被执行的时间，该时间是接受客户端请求的存储节点在执行该请求时的本地时间（local delete time），称为本地删除时间。需要注意区分本地删除时间和时间戳，每个 CF 修改记录都有一个时间戳，这个时间戳可以理解为该 column 的修改时间，是由客户端给定的。</p><h2 id="垃圾回收-compaction"><a href="#垃圾回收-compaction" class="headerlink" title="垃圾回收 compaction"></a>垃圾回收 compaction</h2><p>由于被删除的 column 并不会立即被从磁盘中删除，所以系统占用的磁盘空间会越来越大，这就需要有一种垃圾回收的机制，定期删除被标记了墓碑的 column。垃圾回收是在 compaction 的过程中完成的。</p><h2 id="数据读取（memtable-SStables）"><a href="#数据读取（memtable-SStables）" class="headerlink" title="数据读取（memtable+SStables）"></a>数据读取（memtable+SStables）</h2><p>为了满足读 cassandra 读取的数据是 memtable 中的数据和 SStables 中数据的合并结果。读取SSTables 中的数据就是查找到具体的哪些的 SSTables 以及数据在这些 SSTables 中的偏移量(SSTables 是按主键排序后的数据块)。首先如果 row cache enable 了话，会检测缓存。缓存命中<br>直接返回数据，没有则查找 Bloom filter，查找可能的 SSTable。然后有一层 Partition key cache，找 partition key 的位置。如果有根据找到的 partition 去压缩偏移量映射表找具体的数据块。如果缓存没有，则要经过 Partition summary,Partition index 去找 partition key。然后经过压缩偏移<br>量映射表找具体的数据块。</p><ol><li>检查 memtable</li><li>如果 enabled 了,检查 row cache</li><li>检查 Bloom filter</li><li>如果 enable 了,检查 partition key 缓存</li><li>如果在 partition key 缓存中找到了 partition key,直接去 compression offset 命中，如果没<br>有，检查 partition summary</li><li>根据 compression offset map 找到数据位置</li><li>从磁盘的 SSTable 中取出数据</li></ol><p>MemTable：如果 memtable 有目标分区数据，这个数据会被读出来并且和从 SSTables 中读出来的数据进行合并。SSTable 的数据访问如下面所示的步骤。</p><h2 id="Row-Cache（SSTables-中频繁被访问的数据）"><a href="#Row-Cache（SSTables-中频繁被访问的数据）" class="headerlink" title="Row Cache（SSTables 中频繁被访问的数据）"></a>Row Cache（SSTables 中频繁被访问的数据）</h2><p>在 Cassandra2.2+，它们被存储在堆外内存，使用全新的实现避免造成垃圾回收对 JVM 造成压力。存在在 row cache 的子集数据可以在特定的一段时间内配置一定大小的内存。row cache 使用LRU(least-recently-userd)进行回收在申请内存。存储在 row cache 中的数据是 SSTables 中频繁被访问的数据。存储到row cache中后，数据就可以被后续的查询访问。row cache不是写更新。如果写某行了，这行的缓存就会失效，并且不会被继续缓存，直到这行被读到。类似的，如果一个partition更新了，整个partition的cache都会被移除，但目标的数据在row cache中找不到，就会去检查 Bloom filter。</p><h2 id="Bloom-Filter（查找数据可能对应的-SSTable）"><a href="#Bloom-Filter（查找数据可能对应的-SSTable）" class="headerlink" title="Bloom Filter（查找数据可能对应的 SSTable）"></a>Bloom Filter（查找数据可能对应的 SSTable）</h2><p>首先，Cassandra 检查 Bloom filter 去发现哪个 SSTables 中有可能有请求的分区数据。Bloom filter 是存储在堆外内存。每个 SSTable 都有一个关联的 Bloom filter。一个 Bloom filter 可以建立一个 SSTable 没有包含的特定的分区数据。同样也可以找到分区数据存在 SSTable 中的可能性。它可以加速查找 partition key 的查找过程。然而，因为 Bloom filter 是一个概率函数，所以可能会得到错误的结果，并不是所有的 SSTables 都可以被 Bloom filter 识别出是否有数据。如果Bloom filter 不能够查找到 SSTable，Cassandra 会检查 partition key cache。Bloom filter 大小增长很适宜，每 10 亿数据 1~2GB。在极端情况下，可以一个分区一行。都可以很轻松的将数十亿的 entries 存储在单个机器上。Bloom filter 是可以调节的，如果你愿意用内存来换取性能。</p><h2 id="Partition-Key-Cache（查找数据可能对应的-Partition-key）"><a href="#Partition-Key-Cache（查找数据可能对应的-Partition-key）" class="headerlink" title="Partition Key Cache（查找数据可能对应的 Partition key）"></a>Partition Key Cache（查找数据可能对应的 Partition key）</h2><p>partition key 缓存如果开启了，将 partition index 存储在堆外内存。key cache 使用一小块可配置大小的内存。在读的过程中，每个”hit”保存一个检索。如果在 key cache 中找到了 partition key。就直接到 compression offset map 中招对应的块。partition key cache 热启动后工作的更好，相比较冷启动，有很大的性能提升。如果一个节点上的内存非常受限制，可能的话，需要限<br>制保存在 key cache 中的 partition key 数目。如果一个在 key cache 中没有找到 partition key。就会去partition summary中去找。partition key cache 大小是可以配置的，意义就是存储在key cache 中的 partition keys 数目。</p><h2 id="Partition-Summary（内存中存储一些-partition-index-的样本）"><a href="#Partition-Summary（内存中存储一些-partition-index-的样本）" class="headerlink" title="Partition Summary（内存中存储一些 partition index 的样本）"></a>Partition Summary（内存中存储一些 partition index 的样本）</h2><p>partition summary 是存储在堆外内存的结构，存储一些 partition index 的样本。如果一个partition index 包含所有的 partition keys。鉴于一个partition summary 从每 X 个 keys 中取样，然后将每 X 个 key map 到 index 文件中。例如，如果一个 partition summary 设置了 20keys<br>进行取样。它就会存储 SSTable file 开始的一个 key,20th 个 key，以此类推。尽管并不知道partition key 的具体位置，partition summary 可以缩短找到 partition 数据位置。当找到了partition key 值可能的范围后，就会去找 partition index。通过配置取样频率，你可以用内存来换取性能，当 partition summary 包含的数据越多，使用的内存越多。可以通过表定义的 index interval 属性来改变样本频率。固定大小的内存可以通过 index_summary_capacity_in_mb 属性来设置，默认是堆大小的 5%。</p><h2 id="Partition-Index（磁盘中）"><a href="#Partition-Index（磁盘中）" class="headerlink" title="Partition Index（磁盘中）"></a>Partition Index（磁盘中）</h2><p>partition index 驻扎在磁盘中，索引所有 partition keys 和偏移量的映射。如果 partition summary 已经查到 partition keys 的范围，现在的检索就是根据这个范围值来检索目标 partitionkey。需要进行单次检索和顺序读。根据找到的信息。然后去 compression offset map 中去找磁<br>盘中有这个数据的块。如果 partition index 必须要被检索，则需要检索两次磁盘去找到目标数据。</p><h2 id="Compression-offset-map（磁盘中）"><a href="#Compression-offset-map（磁盘中）" class="headerlink" title="Compression offset map（磁盘中）"></a>Compression offset map（磁盘中）</h2><p>compression offset map 存储磁盘数据准确位置的指针。存储在堆外内存，可以被 partition key cache 或者 partition index 访问。一旦 compression offset map 识别出来磁盘中的数据位置，就会从正确的 SStable(s)中取出数据。查询就会收到结果集。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL（non-relationa非关系型）数据库。Cassandra旨在处理多商品服务器上的大量数据，提供高可用性而无需担心单点故障。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Cassandra" scheme="http://yoursite.com/tags/Cassandra/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（MongoDB）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88MongoDB%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（MongoDB）/</id>
    <published>2022-01-05T07:12:12.000Z</published>
    <updated>2022-01-05T07:37:26.957Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><a id="more"></a><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li> MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</li><li> 你可以在 MongoDB 记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。</li><li> 你可以通过本地或者网络创建数据镜像，这使得 MongoDB 有更强的扩展性。</li><li> 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li><li> Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li> MongoDb 使用 update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li><li> Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。</li><li> Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传给 Reduce 函数进行处理。</li><li> Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapreduce 命令来执行 MapReduce 操作。</li><li> GridFS 是 MongoDB 中的一个内置功能，可以用于存放大量小文件。</li><li> MongoDB 允许在服务端执行脚本，可以用 Javascript 编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Hbase）</title>
    <link href="http://yoursite.com/2022/01/05/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Hbase%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/05/JAVA 学习笔记（Hbase）/</id>
    <published>2022-01-05T02:12:12.000Z</published>
    <updated>2022-01-05T07:32:42.603Z</updated>
    
    <content type="html"><![CDATA[<p>base 是分布式、面向列的开源数据库（其实准确的说是面向列族）</p><a id="more"></a><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存<br>储和读取的分布式数据库解决方案。</p><h1 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h1><p>列方式所带来的重要好处之一就是，由于查询中的选择规则是通过列来定义的，因此整个数据库是自动索引化的。</p><p>这里的列式存储其实说的是列族存储，Hbase 是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。为了加深对 Hbase 列族的理解，下面是一个简单的关系型数据库的表和 Hbase 数据库的表：</p><h1 id="Hbase-核心概念"><a href="#Hbase-核心概念" class="headerlink" title="Hbase 核心概念"></a>Hbase 核心概念</h1><h2 id="Column-Family-列族"><a href="#Column-Family-列族" class="headerlink" title="Column Family 列族"></a>Column Family 列族</h2><p>Column Family 又叫列族，Hbase 通过列族划分数据的存储，列族下面可以包含任意多的列，实现灵活的数据存取。Hbase 表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须指定具体的列是一样的。Hbase 的列族不是越多越好，官方推荐的是列族最好小于或者等于 3。我们使用的场景一般是 1 个列族。</p><h2 id="Rowkey（Rowkey-查询，Rowkey-范围扫描，全表扫描）"><a href="#Rowkey（Rowkey-查询，Rowkey-范围扫描，全表扫描）" class="headerlink" title="Rowkey（Rowkey 查询，Rowkey 范围扫描，全表扫描）"></a>Rowkey（Rowkey 查询，Rowkey 范围扫描，全表扫描）</h2><p>Rowkey 的概念和 mysql 中的主键是完全一样的，Hbase 使用 Rowkey 来唯一的区分某一行的数据。Hbase 只支持 3 种查询方式：基于 Rowkey 的单行查询，基于 Rowkey 的范围扫描，全表扫描。</p><h2 id="Region-分区"><a href="#Region-分区" class="headerlink" title="Region 分区"></a>Region 分区</h2><p> Region：Region 的概念和关系型数据库的分区或者分片差不多。Hbase 会将一个大表的数据基于 Rowkey 的不同范围分配到不通的 Region 中，每个 Region 负责一定范围的数据访问和存储。这样即使是一张巨大的表，由于被切割到不通的 region，访问起来的时延也很低。</p><h2 id="TimeStamp-多版本"><a href="#TimeStamp-多版本" class="headerlink" title="TimeStamp 多版本"></a>TimeStamp 多版本</h2><p> TimeStamp 是实现 Hbase 多版本的关键。在Hbase中使用不同的timestame来标识相同rowkey行对应的不同版本的数据。在写入数据的时候，如果用户没有指定对应的timestamp，Hbase 会自动添加一个 timestamp，timestamp 和服务器时间保持一致。在Hbase 中，相同 rowkey 的数据按照 timestamp 倒序排列。默认查询的是最新的版本，用户可同指定 timestamp 的值来读取旧版本的数据。</p><h2 id="Hbase-核心架构"><a href="#Hbase-核心架构" class="headerlink" title="Hbase 核心架构"></a>Hbase 核心架构</h2><p>Hbase 是由 Client、Zookeeper、Master、HRegionServer、HDFS 等几个组建组成。</p><h2 id="Client："><a href="#Client：" class="headerlink" title="Client："></a>Client：</h2><p> Client 包含了访问 Hbase 的接口，另外 Client 还维护了对应的 cache 来加速 Hbase 的访问，比如 cache 的.META.元数据的信息。</p><p>元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。</p><h2 id="Zookeeper："><a href="#Zookeeper：" class="headerlink" title="Zookeeper："></a>Zookeeper：</h2><p> Hbase 通过 Zookeeper 来做 master 的高可用、RegionServer 的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：</p><ol><li>通过 Zoopkeeper 来保证集群中只有 1 个 master 在运行，如果 master 异常，会通过竞争机制产生新的 master 提供服务</li><li>通过 Zoopkeeper 来监控 RegionServer 的状态，当 RegionSevrer 有异常的时候，通过回调的形式通知 Master RegionServer 上下限的信息</li><li>通过 Zoopkeeper 存储元数据的统一入口地址。</li></ol><h2 id="Hmaster"><a href="#Hmaster" class="headerlink" title="Hmaster"></a>Hmaster</h2><p> master 节点的主要职责如下：</p><ol><li>为 RegionServer 分配 Region</li><li>维护整个集群的负载均衡</li><li>维护集群的元数据信息发现失效的 Region，并将失效的 Region 分配到正常RegionServer 上当 RegionSever 失效的时候，协调对应 Hlog 的拆分</li></ol><h2 id="HregionServer"><a href="#HregionServer" class="headerlink" title="HregionServer"></a>HregionServer</h2><p> HregionServer 直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如<br>下：</p><ol><li>管理 master 为其分配的 Region</li><li>处理来自客户端的读写请求</li><li>负责和底层 HDFS 的交互，存储数据到 HDFS</li><li>负责 Region 变大以后的拆分</li><li>负责 Storefile 的合并工作</li></ol><h2 id="Region-寻址方式（通过-zookeeper-META）"><a href="#Region-寻址方式（通过-zookeeper-META）" class="headerlink" title="Region 寻址方式（通过 zookeeper .META）"></a>Region 寻址方式（通过 zookeeper .META）</h2><p>第 1 步：Client 请求 ZK 获取.META.所在的 RegionServer 的地址。</p><p>第 2 步：Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。</p><p>第 3 步：Client 请求数据所在的 RegionServer，获取所需要的数据。</p><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p> HDFS 为 Hbase 提供最终的底层数据存储服务，同时为 Hbase 提供高可用（Hlog 存储在 HDFS）的支持。</p><h1 id="Hbase-的写逻辑"><a href="#Hbase-的写逻辑" class="headerlink" title="Hbase 的写逻辑"></a>Hbase 的写逻辑</h1><h2 id="Hbase-的写入流程"><a href="#Hbase-的写入流程" class="headerlink" title="Hbase 的写入流程"></a>Hbase 的写入流程</h2><h3 id="获取-RegionServer"><a href="#获取-RegionServer" class="headerlink" title="获取 RegionServer"></a>获取 RegionServer</h3><p>第 1 步：Client 获取数据写入的 Region 所在的 RegionServer</p><h3 id="请求写-Hlog"><a href="#请求写-Hlog" class="headerlink" title="请求写 Hlog"></a>请求写 Hlog</h3><p>第 2 步：请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来恢复数据。</p><h3 id="请求写-MemStore"><a href="#请求写-MemStore" class="headerlink" title="请求写 MemStore"></a>请求写 MemStore</h3><p>第 3 步：请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。MemStore 后续会逐渐刷到 HDFS 中。</p><h2 id="MemStore-刷盘"><a href="#MemStore-刷盘" class="headerlink" title="MemStore 刷盘"></a>MemStore 刷盘</h2><p>为了提高 Hbase 的写入性能，当写请求写入MemStore后，不会立即刷盘。而是会等到一定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢？总结成如下的几个场景：</p><h3 id="全局内存控制"><a href="#全局内存控制" class="headerlink" title="全局内存控制"></a>全局内存控制</h3><ol><li>这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比例的时候，会触发刷盘的操作。这个参数是hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个heap 内存的 35%。当flush到所有memstore占整个heap内存的比率为35%的时候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的目的。</li></ol><h3 id="MemStore-达到上限"><a href="#MemStore-达到上限" class="headerlink" title="MemStore 达到上限"></a>MemStore 达到上限</h3><ol start="2"><li>当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷盘，默认 128M 大小</li></ol><h3 id="RegionServer-的-Hlog-数量达到上限"><a href="#RegionServer-的-Hlog-数量达到上限" class="headerlink" title="RegionServer 的 Hlog 数量达到上限"></a>RegionServer 的 Hlog 数量达到上限</h3><ol start="3"><li>前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。</li></ol><h3 id="手工触发"><a href="#手工触发" class="headerlink" title="手工触发"></a>手工触发</h3><ol start="4"><li>可以通过 hbase shell 或者 java api 手工触发 flush 的操作。</li></ol><h3 id="关闭-RegionServer-触发"><a href="#关闭-RegionServer-触发" class="headerlink" title="关闭 RegionServer 触发"></a>关闭 RegionServer 触发</h3><ol start="5"><li>在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢复数据。</li></ol><h3 id="Region-使用-HLOG-恢复完数据后触发"><a href="#Region-使用-HLOG-恢复完数据后触发" class="headerlink" title="Region 使用 HLOG 恢复完数据后触发"></a>Region 使用 HLOG 恢复完数据后触发</h3><ol start="6"><li>：当 RegionServer 出现故障的时候，其上面的Region会迁移到其他正常的RegionServer上，在恢复完Region的数据后，会触发刷盘，当刷盘完成后才会提供给业务访问。</li></ol><h2 id="HBase-vs-Cassandra"><a href="#HBase-vs-Cassandra" class="headerlink" title="HBase vs Cassandra"></a>HBase vs Cassandra</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;base 是分布式、面向列的开源数据库（其实准确的说是面向列族）&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Hbase" scheme="http://yoursite.com/tags/Hbase/"/>
    
  </entry>
  
  <entry>
    <title>459. 重复的子字符串</title>
    <link href="http://yoursite.com/2022/01/04/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/01/04/459. 重复的子字符串/</id>
    <published>2022-01-04T10:12:12.000Z</published>
    <updated>2022-01-04T13:09:00.800Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</code></pre><p>示例 2:</p><pre><code>输入: &quot;aba&quot;输出: False</code></pre><p>示例 3:</p><pre><code>输入: &quot;abcabcabcabc&quot;</code></pre><p>输出: True</p><pre><code>解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</code></pre><h1 id="方法一：枚举-1"><a href="#方法一：枚举-1" class="headerlink" title="方法一：枚举^1"></a>方法一：枚举<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>如果一个长度为 <em>n</em> 的字符串 <em>s</em> 可以由它的一个长度为 <em>n’</em> 的子串 <em>s’</em> 重复多次构成，那么：</p><ul><li><p><em>n</em> 一定是 <em>n’</em> 的倍数；</p></li><li><p><em>s’</em> 一定是 <em>s</em> 的前缀；</p></li><li><p>对于任意的 i in [n’,n)，有 <em>s[i] = s[i-n’]</em>。</p></li></ul><p>也就是说，<em>s</em> 中长度为 <em>n’</em> 的前缀就是 <em>s’<em>，并且在这之后的每一个位置上的字符 *s[i]</em>，都需要与它之前的第 *n’</em> 个字符 <em>s[i-n’]</em> 相同。</p><p>因此，我们可以从小到大枚举 <em>n’*，并对字符串 *s</em> 进行遍历，进行上述的判断。注意到一个小优化是，因为子串至少需要重复一次，所以 <em>n’</em> 不会大于 <em>n</em> 的一半，我们只需要在 [1,n/2] 的范围内枚举 <em>n’</em> 即可。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(j) != s.charAt(j - i)) &#123;</span><br><span class="line">                        match = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> all(s[j] == s[j - i] <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span> &#123;</span><br><span class="line">            match := <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> s[j] != s[j - i] &#123;</span><br><span class="line">                    match = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> match &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                    match = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是字符串 <em>s</em> 的长度。枚举 <em>i</em> 的时间复杂度为 <em>O(n)*，遍历 *s</em> 的时间复杂度为 <em>O(n)</em>，相乘即为总时间复杂度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：字符串匹配"><a href="#方法二：字符串匹配" class="headerlink" title="方法二：字符串匹配"></a>方法二：字符串匹配</h1><p><strong>思路与算法</strong></p><p>我们可以把字符串 <em>s</em> 写成</p><p>s’s’…s’s’</p><p>的形式，总计 n/n’  个 <em>s’*。但我们如何在不枚举 *n’</em> 的情况下，判断 <em>s</em> 是否能写成上述的形式呢？</p><p>如果我们移除字符串 <em>s</em> 的前 <em>n’</em> 个字符（即一个完整的 <em>s’<em>），再将这些字符保持顺序添加到剩余字符串的末尾，那么得到的字符串仍然是 *s</em>。由于 1&lt; = n’&lt;n ，那么如果将两个 *s</em> 连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含 <em>s</em>，即 <em>s</em> 是它的一个子串。</p><p>因此我们可以考虑这种方法：我们将两个 <em>s</em> 连在一起，并移除第一个和最后一个字符。如果 <em>s</em> 是该字符串的子串，那么 <em>s</em> 就满足题目要求。</p><p>注意到我们证明的是<strong>如果 <em>s</em> 满足题目要求，那么 <em>s</em> 有这样的性质</strong>，而我们使用的方法却是<strong>如果 <em>s</em> 有这样的性质，那么 <em>s</em> 满足题目要求</strong>。因此，只证明了充分性是远远不够的，我们还需要证明必要性。</p><blockquote><p>题解区的很多题解都忽略了这一点，但它是非常重要的。</p></blockquote><p>证明需要使用一些同余运算的小技巧，可以见方法三之后的「正确性证明」部分。这里先假设我们已经完成了证明，这样就可以使用非常简短的代码完成本题。在下面的代码中，我们可以从位置 <em>1</em> 开始查询，并希望查询结果不为位置 <em>n</em>，这与移除字符串的第一个和最后一个字符是等价的。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (s + s).indexOf(s, <span class="number">1</span>) != s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != len(s)</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">char</span> k[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">    k[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(k + <span class="number">1</span>, s) - k != n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>由于我们使用了语言自带的字符串查找函数，因此这里不深入分析其时空复杂度。</p><h1 id="方法三：KMP-算法"><a href="#方法三：KMP-算法" class="headerlink" title="方法三：KMP 算法"></a>方法三：KMP 算法</h1><p><strong>思路与算法</strong></p><p>在方法二中，我们使用了语言自带的字符串查找函数。同样我们也可以自己实现这个函数，例如使用比较经典的 KMP 算法。</p><p>读者需要注意以下几点：</p><ul><li><p>KMP 算法虽然有着良好的理论时间复杂度上限，但大部分语言自带的字符串查找函数并不是用 KMP 算法实现的。这是因为在实现 API 时，我们需要在平均时间复杂度和最坏时间复杂度二者之间权衡。普通的暴力匹配算法以及优化的 BM 算法拥有比 KMP 算法更为优秀的平均时间复杂度；</p></li><li><p>学习 KMP 算法时，一定要理解其本质。如果放弃阅读晦涩难懂的材料（即使大部分讲解 KMP 算法的材料都包含大量的图，但图毕竟只能描述特殊而非一般情况）而是直接去阅读代码，是永远无法学会 KMP 算法的。读者甚至无法理解 KMP 算法关键代码中的任意一行。</p></li></ul><p>由于本题就是在一个字符串中查询另一个字符串是否出现，可以直接套用 KMP 算法。因此这里对 KMP 算法本身不再赘述。读者可以自行查阅资料进行学习。这里留了三个思考题，读者可以在学习完毕后尝试回答这三个问题，检验自己的学习成果：</p><ul><li><p>设查询串的的长度为 <em>n</em>，模式串的长度为 <em>m</em>，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？</p></li><li><p>如果有多个查询串，平均长度为 <em>n</em>，数量为 <em>k</em>，那么总时间复杂度是多少？</p></li><li><p>在 KMP 算法中，对于模式串，我们需要预处理出一个 fail  数组（有时也称为next  数组、pi 数组等）。这个数组到底表示了什么？</p></li></ul><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; query, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = query.size();</span><br><span class="line">        <span class="keyword">int</span> m = pattern.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail(m, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s + s, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">(String query, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = query.length();</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; pattern.charAt(j + <span class="number">1</span>) != pattern.charAt(i)) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(j + <span class="number">1</span>) == pattern.charAt(i)) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> match = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (match != -<span class="number">1</span> &amp;&amp; pattern.charAt(match + <span class="number">1</span>) != query.charAt(i)) &#123;</span><br><span class="line">                match = fail[match];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(match + <span class="number">1</span>) == query.charAt(i)) &#123;</span><br><span class="line">                ++match;</span><br><span class="line">                <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(query: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">            n, m = len(query), len(pattern)</span><br><span class="line">            fail = [<span class="number">-1</span>] * m</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                j = fail[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">while</span> j != <span class="number">-1</span> <span class="keyword">and</span> pattern[j + <span class="number">1</span>] != pattern[i]:</span><br><span class="line">                    j = fail[j]</span><br><span class="line">                <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i]:</span><br><span class="line">                    fail[i] = j + <span class="number">1</span></span><br><span class="line">            match = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> match != <span class="number">-1</span> <span class="keyword">and</span> pattern[match + <span class="number">1</span>] != query[i]:</span><br><span class="line">                    match = fail[match]</span><br><span class="line">                <span class="keyword">if</span> pattern[match + <span class="number">1</span>] == query[i]:</span><br><span class="line">                    match += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> match == m - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kmp(s + s, s)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> kmp(s + s, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(query, pattern <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(query), <span class="built_in">len</span>(pattern)</span><br><span class="line">    fail := <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        fail[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        j := fail[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i] &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    match := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i] &#123;</span><br><span class="line">            match = fail[match]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pattern[match + <span class="number">1</span>] == query[i] &#123;</span><br><span class="line">            match++</span><br><span class="line">            <span class="keyword">if</span> match == m - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>* query, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(query);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="keyword">int</span> fail[m];</span><br><span class="line">    <span class="built_in">memset</span>(fail, <span class="number">-1</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">            j = fail[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (match != <span class="number">-1</span> &amp;&amp; pattern[match + <span class="number">1</span>] != query[i]) &#123;</span><br><span class="line">            match = fail[match];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[match + <span class="number">1</span>] == query[i]) &#123;</span><br><span class="line">            ++match;</span><br><span class="line">            <span class="keyword">if</span> (match == m - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">char</span> k[<span class="number">2</span> * n + <span class="number">1</span>];</span><br><span class="line">    k[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="built_in">strcat</span>(k, s);</span><br><span class="line">    <span class="keyword">return</span> kmp(k, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是字符串 <em>s</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n)</em>。</p></li></ul><h2 id="正确性证明-1"><a href="#正确性证明-1" class="headerlink" title="正确性证明^1"></a>正确性证明<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></h2><p>一方面，如果长度为 <em>n</em> 的字符串 <em>s</em> 是字符串 <em>t=s+s</em> 的子串，并且 <em>s</em> 在 <em>t</em> 中的起始位置不为 <em>0</em> 或 <em>n</em>，那么 <em>s</em> 就满足题目的要求。证明过程如下：</p><ul><li>我们设 <em>s</em> 在 <em>t</em> 中的起始位置为 <em>i</em>，i in (0,n) 。也就是说，<em>t</em> 中从位置 <em>i</em> 开始的 <em>n</em> 个连续的字符，恰好就是字符串 <em>s</em>。那么我们有：</li></ul><p>s[0:n-1] = t[i:n+i-1]</p><p>由于 <em>t</em> 是由两个 <em>s</em> 拼接而成的，我们可以将 <em>t[i:n+i-1]</em> 分成位置 <em>n-1</em> 左侧和右侧两部分：</p><p>每一部分都可以对应回 <em>s</em>：</p><p>这说明，<em>s</em> 是一个「可旋转」的字符串：将 <em>s</em> 的前 <em>i</em> 个字符保持顺序，移动到 <em>s</em> 的末尾，得到的新字符串与 <em>s</em> 相同。也就是说，<strong>在模 <em>n</em> 的意义下</strong>，</p><p>s[j] = s[j+i]</p><p>对于任意的 <em>j</em> 恒成立。</p><blockquote><p>「在模 <em>n</em> 的意义下」可以理解为，所有的加法运算的结果都需要对 <em>n</em> 取模，使得结果保持在 <em>[0, n)</em> 中，这样加法就自带了「旋转」的效果。</p></blockquote><p>另一方面，如果 <em>s</em> 满足题目的要求，那么 <em>s</em> 包含若干个「部分」，<em>t=s+s</em> 包含两倍数量的「部分」，因此 <em>s</em> 显然是 <em>t</em> 的子串，并且起始位置可以不为 <em>0</em> 或 <em>n</em>：我们只需要选择 <em>t</em> 中第一个「部分」的起始位置即可。</p><p>综上所述，我们证明了：长度为 <em>n</em> 的字符串 <em>s</em> 是字符串 <em>t=s+s</em> 的子串，并且 <em>s</em> 在 <em>t</em> 中的起始位置不为 <em>0</em> 或 <em>n</em>，<strong>当且仅当</strong> <em>s</em> 满足题目的要求。因此，</p><h2 id="另一种证明方法-2"><a href="#另一种证明方法-2" class="headerlink" title="另一种证明方法^2"></a>另一种证明方法<a href="https://writings.sh/post/algorithm-repeated-string-pattern" target="_blank" rel="noopener">^2</a></h2><h2 id="思考题答案"><a href="#思考题答案" class="headerlink" title="思考题答案"></a>思考题答案</h2><ul><li><p>设查询串的的长度为 <em>n</em>，模式串的长度为 <em>m</em>，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？</p><ul><li><p>时间复杂度为 <em>O(n+m)</em>，用到了均摊分析（摊还分析）的方法。</p></li><li><p>具体地，无论在预处理过程还是查询过程中，虽然匹配失败时，指针会不断地根据 fail 数组向左回退，看似时间复杂度会很高。但考虑匹配成功时，指针会向右移动一个位置，这一部分对应的时间复杂度为 <em>O(n+m)</em>。又因为向左移动的次数不会超过向右移动的次数，因此总时间复杂度仍然为 <em>O(n+m)</em>。</p></li></ul></li><li><p>如果有多个查询串，平均长度为 <em>n</em>，数量为 <em>k</em>，那么总时间复杂度是多少？</p><ul><li>时间复杂度为 <em>O(nk+m)</em>。模式串只需要预处理一次。</li></ul></li><li><p>在 KMP 算法中，对于模式串，我们需要预处理出一个 fail 数组（有时也称为 next  数组、pi 数组等）。这个数组到底表示了什么？</p><ul><li>fail 等于满足下述要求的 <em>x</em> 的最大值：<em>s[0:i]</em> 具有长度为 <em>x+1</em> 的完全相同的前缀和后缀。这也是 KMP 算法最重要的一部分。</li></ul></li></ul><h1 id="方法四：优化的-KMP-算法"><a href="#方法四：优化的-KMP-算法" class="headerlink" title="方法四：优化的 KMP 算法"></a>方法四：优化的 KMP 算法</h1><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pattern.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kmp(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; pattern.charAt(j + <span class="number">1</span>) != pattern.charAt(i)) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(j + <span class="number">1</span>) == pattern.charAt(i)) &#123;</span><br><span class="line">                fail[i] = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fail[n - <span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol4-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(pattern: str)</span> -&gt; bool:</span></span><br><span class="line">            n = len(pattern)</span><br><span class="line">            fail = [<span class="number">-1</span>] * n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                j = fail[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">while</span> j != <span class="number">-1</span> <span class="keyword">and</span> pattern[j + <span class="number">1</span>] != pattern[i]:</span><br><span class="line">                    j = fail[j]</span><br><span class="line">                <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i]:</span><br><span class="line">                    fail[i] = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> <span class="keyword">and</span> n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kmp(s)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol4-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> kmp(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(pattern)</span><br><span class="line">    fail := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fail[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        j := fail[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pattern[j + <span class="number">1</span>] == pattern[i] &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol4-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="keyword">int</span> fail[n];</span><br><span class="line">    <span class="built_in">memset</span>(fail, <span class="number">-1</span>, <span class="keyword">sizeof</span>(fail));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; pattern[j + <span class="number">1</span>] != pattern[i]) &#123;</span><br><span class="line">            j = fail[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j + <span class="number">1</span>] == pattern[i]) &#123;</span><br><span class="line">            fail[i] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[n - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kmp(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是字符串 <em>s</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n)</em>。</p></li></ul><h1 id="KMP算法简洁解释"><a href="#KMP算法简洁解释" class="headerlink" title="KMP算法简洁解释"></a>KMP算法简洁解释</h1><p>受到 题目28. 实现 strStr()的启发使用KMP算法来解决。</p><ol><li>先用next数组构造前缀表</li><li>经过对所有重复字符串的前缀表进行验证，他们的前缀表最后一位都不会为0，所以如果next[len - 1] == 0，就说明s是不重复的。</li><li>如果len % (len - (next[len - 1]) ) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被数组的长度整除，说明有该字符串有重复的子字符串。</li></ol><p>数组长度 - 最长相同前后缀的长度相当于是第一个周期的长度，如果这个周期可以被len整除，就说明整个数组就是这个周期的循环。</p><details>    <summary>KMP</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean repeatedSubstringPattern(String s) &#123;</span><br><span class="line"></span><br><span class="line">        int len = s.length();</span><br><span class="line">        //先使用KMP算法求出next数组，通过next数组的元素判断</span><br><span class="line">        int[] next = getNext(s);</span><br><span class="line">        /*</span><br><span class="line">        要判断字符串是否可以由它的一个子串重复多次构成。 </span><br><span class="line">        1. next[len-1]!=0</span><br><span class="line">        - next数组长度为len，如果最后一个元素的值为0，则该字符串不可能是由重复的小字符串构成的，</span><br><span class="line">        所以：</span><br><span class="line">        2. 字符串总长度 % 最小重复单元的长度 == 0</span><br><span class="line">        - len-next[len-1]的值表示的含义为该字符串中的最小重复单元的长度</span><br><span class="line">        */</span><br><span class="line">        if (next[len - 1] != 0 &amp;&amp; len % (len - next[len - 1]) == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private int[] getNext(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int[] next = new int[len];</span><br><span class="line">         for (int i = 1, j = 0; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s.charAt(j) != s.charAt(i)) &#123;</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s.charAt(j) == s.charAt(i)) j ++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="String Matching" scheme="http://yoursite.com/tags/String-Matching/"/>
    
      <category term="KMP Algorithm" scheme="http://yoursite.com/tags/KMP-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（Kafka）</title>
    <link href="http://yoursite.com/2022/01/04/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Kafka%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/04/JAVA 学习笔记（Kafka）/</id>
    <published>2022-01-04T07:12:12.000Z</published>
    <updated>2022-01-04T15:12:41.749Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。</p><a id="more"></a><p>[TOC]</p><ol><li>broker：Kafka 服务器，负责消息存储和转发</li><li>topic：消息类别，Kafka 按照 topic 来分类消息</li><li>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个partition 上</li><li>offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号</li><li>Producer：消息生产者</li><li>Consumer：消息消费者</li><li>Consumer Group：消费者分组，每个 Consumer 必须属于一个 group</li><li>Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能</li></ol><h1 id="Kafka-数据存储设计"><a href="#Kafka-数据存储设计" class="headerlink" title="Kafka 数据存储设计"></a>Kafka 数据存储设计</h1><h2 id="partition-的数据文件（offset，MessageSize，data）"><a href="#partition-的数据文件（offset，MessageSize，data）" class="headerlink" title="partition 的数据文件（offset，MessageSize，data）"></a>partition 的数据文件（offset，MessageSize，data）</h2><p>partition 中的每条 Message 包含了以下三个属性：offset，MessageSize，data，其中 offset 表示 Message 在这个 partition 中的偏移量，offset 不是该 Message 在 partition 数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了 partition 中的一条 Message，可以认为 offset 是partition 中 Message 的 id；MessageSize 表示消息内容 data 的大小；data 为 Message 的具体内容。</p><h2 id="数据文件分段-segment（顺序读写、分段命令、二分查找）"><a href="#数据文件分段-segment（顺序读写、分段命令、二分查找）" class="headerlink" title="数据文件分段 segment（顺序读写、分段命令、二分查找）"></a>数据文件分段 segment（顺序读写、分段命令、二分查找）</h2><p>partition 物理上由多个 segment 文件组成，每个segment大小相等，顺序读写。每个segment数据文件以该段中最小的offset命名，文件扩展名为.log。这样在查找指定 offset 的 Message 的时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。</p><h2 id="数据文件索引（分段索引、稀疏存储）"><a href="#数据文件索引（分段索引、稀疏存储）" class="headerlink" title="数据文件索引（分段索引、稀疏存储）"></a>数据文件索引（分段索引、稀疏存储）</h2><p>Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。</p><h1 id="生产者设计"><a href="#生产者设计" class="headerlink" title="生产者设计"></a>生产者设计</h1><h2 id="负载均衡（partition-会均衡分布到不同-broker-上）"><a href="#负载均衡（partition-会均衡分布到不同-broker-上）" class="headerlink" title="负载均衡（partition 会均衡分布到不同 broker 上）"></a>负载均衡（partition 会均衡分布到不同 broker 上）</h2><p>由于消息 topic 由多个 partition 组成，且 partition 会均衡分布到不同 broker 上，因此，为了有效利用 broker 集群的性能，提高消息的吞吐量，producer 可以通过随机或者 hash 等方式，将消息平均发送到多个 partition 上，以实现负载均衡。</p><h2 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h2><p>是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，以一次请求的方式发送了批量的消息给 broker，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性，相当于以时延代价，换取更好的吞吐量。</p><h2 id="压缩（GZIP-或-Snappy）"><a href="#压缩（GZIP-或-Snappy）" class="headerlink" title="压缩（GZIP 或 Snappy）"></a>压缩（GZIP 或 Snappy）</h2><p>Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer端进行压缩之后，在Consumer端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是 CPU（压缩和解压会耗掉部分 CPU 资源）。</p><h1 id="消费者设计"><a href="#消费者设计" class="headerlink" title="消费者设计"></a>消费者设计</h1><h2 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h2><p>同一 Consumer Group 中的多个 Consumer 实例，不同时消费同一个 partition，等效于队列模式。partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 学习笔记（日志）</title>
    <link href="http://yoursite.com/2022/01/04/JAVA%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%97%A5%E5%BF%97%EF%BC%89/"/>
    <id>http://yoursite.com/2022/01/04/JAVA 学习笔记（日志）/</id>
    <published>2022-01-04T04:12:12.000Z</published>
    <updated>2022-01-04T07:27:19.877Z</updated>
    
    <content type="html"><![CDATA[<p>日志</p><a id="more"></a><p>[TOC]</p><h1 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h1><p>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带<br>的 java.util.logging.Logger 等。</p><h1 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h1><p>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。<br>Log4j 由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。</p><p>1.Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</p><p>2.Appenders : 指定了日志将打印到控制台还是文件中</p><p>3.Layout : 控制日志信息的显示格式</p><p>Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为DEBUG、INFO、WARN、ERROR和FATAL，当输出时，只有级别高过配置中规定的级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。</p><p>Log4j最近爆出了一个严重漏洞，可以自行搜索其漏洞产生原因</p><h1 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h1><p>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。</p><p>Logback 主要由三个模块组成：logback-core，logback-classic。logback-access</p><p>logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的通用机制。</p><p>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J；</p><p>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与HTTP 访问相关的功能</p><h2 id="Logback-优点"><a href="#Logback-优点" class="headerlink" title="Logback 优点"></a>Logback 优点</h2><ul><li> 同样的代码路径，Logback 执行更快</li><li> 更充分的测试</li><li> 原生实现了 SLF4J API（Log4J 还需要有一个中间转换层）</li><li> 内容更丰富的文档</li><li> 支持 XML 或者 Groovy 方式配置</li><li> 配置文件自动热加载</li><li> 从 IO 错误中优雅恢复</li><li> 自动删除日志归档</li><li> 自动压缩日志成为归档文件</li><li> 支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件</li><li> 支持配置文件中加入条件判断来适应不同的环境</li><li> 更强大的过滤器</li><li> 支持 SiftingAppender（可筛选 Appender）</li><li> 异常栈信息带有包信息</li></ul><h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><p>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。</p><p> Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。</p><p> Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。</p><p> Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志&lt;/p&gt;
    
    </summary>
    
      <category term="2022年1月" scheme="http://yoursite.com/categories/2022%E5%B9%B41%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
</feed>
