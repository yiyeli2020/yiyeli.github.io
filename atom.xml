<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-18T08:27:50.292Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="http://yoursite.com/2020/11/18/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/11/18/128. 最长连续序列/</id>
    <published>2020-11-18T07:20:12.000Z</published>
    <updated>2020-11-18T08:27:50.292Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><a id="more"></a><p>要求算法的时间复杂度为 O(n)。</p><p>示例:</p><pre><code>输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></pre><h1 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h1><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>排序</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max 最终结果, curr 当前长度, last 上个数字</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>, curr = <span class="number">1</span>, last = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == last) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == last + <span class="number">1</span>) curr++; <span class="comment">// 符合连续，长度 +1</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curr); <span class="comment">// 连不上了，记录长度</span></span><br><span class="line">            curr = <span class="number">1</span>; <span class="comment">// 重新开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        last = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, curr); <span class="comment">// 别忘了最后一段的连续区间</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<em>O(nlog(n))</em></li><li>空间复杂度：<em>O(1)</em><ul><li>副作用：影响原数组</li></ul></li></ul><hr><h1 id="方法二：集合"><a href="#方法二：集合" class="headerlink" title="方法二：集合"></a>方法二：集合</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用 <em>O(1)</em> 时间复杂度「查询是否有下一个」</li><li>优化：如果有比自己小一点的，那自己不查，让小的去查（详见代码）<ul><li>贪心思想？</li></ul></li></ul><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>集合</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length, max = <span class="number">1</span>;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) set.add(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) &#123;</span><br><span class="line">        <span class="comment">// 技巧：如果有比自己小一点的，那自己不查，让小的去查</span></span><br><span class="line">        <span class="keyword">if</span> (set.contains(v - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = v; <span class="comment">// r: right 表示「以 v 开头，能连续到多少」</span></span><br><span class="line">        <span class="keyword">while</span> (set.contains(r + <span class="number">1</span>)) r++; <span class="comment">// 逐个查看</span></span><br><span class="line">        max = Math.max(max, r - v + <span class="number">1</span>); <span class="comment">// 记录区间 [v, r] 长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<em>O(n)</em><ul><li>虽 <code>for</code> 内有 <code>while</code>，但每个元素最多被查 <code>2</code> 次</li><li>第一次在 <code>set.contains(v - 1)</code>，如元素 <code>5</code> 被 <code>6</code> 查</li><li>第二次在 <code>set.contains(r + 1)</code>，如元素 <code>5</code> 被 <code>4</code> 查</li></ul></li><li>空间复杂度：<em>O(n)</em></li></ul><hr><h1 id="方法三：哈希表"><a href="#方法三：哈希表" class="headerlink" title="方法三：哈希表"></a>方法三：哈希表</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>虽然代码结构与上述 「方法二：集合」十分相似，但思路由差异，值得提及</li><li>少了方法二的优化：只对小的执行查询</li><li>利用前面已知的右边界，快速找到当前需要的右边界（详见代码）<ul><li>记忆化</li></ul></li></ul><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>哈希表</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 记录区间 [v, r]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) map.put(v, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = v;</span><br><span class="line">        <span class="keyword">while</span> (map.containsKey(r + <span class="number">1</span>))</span><br><span class="line">            r = map.get(r + <span class="number">1</span>); <span class="comment">// 利用前面已知的右边界，快速找到当前需要的右边界</span></span><br><span class="line">        map.put(v, r);</span><br><span class="line">        max = Math.max(max, r - v + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<em>O(n)</em></li><li>空间复杂度：<em>O(n)</em></li></ul><hr><h1 id="方法四：并查集"><a href="#方法四：并查集" class="headerlink" title="方法四：并查集"></a>方法四：并查集</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ul><li>初始：所有元素各自为战</li><li>首次遍历：所有元素 <code>x</code> 向各自邻居 <code>x + 1</code>，发起结盟，并「以大者为领队」<ul><li>若有邻居，才结盟成功</li><li>领队，即 区间右边界</li><li>不只是元素 <code>x</code> 与邻居 <code>x + 1</code> 结盟，而是整个 <code>x</code> 所在队伍与整个 <code>x + 1</code> 所在队伍结盟<ul><li>如 <code>[1, 2, 3]</code> 与 <code>[4, 5]</code> 两个队伍结盟</li></ul></li></ul></li><li>二次遍历：记录所有人与其领队距离<ul><li>距离，即 区间右边界 - 当前元素 + 1</li></ul></li></ul><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><details>    <summary>并查集</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首次遍历，与邻居结盟</span></span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums)</span><br><span class="line">        uf.union(v, v + <span class="number">1</span>); <span class="comment">// uf.union() 结盟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二次遍历，记录领队距离</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : nums)</span><br><span class="line">        max = Math.max(max, uf.find(v) - v + <span class="number">1</span>); <span class="comment">// uf.find() 查找领队</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>并查集定义，放在一起即可通过</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//还剩几支队伍</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; parent; <span class="comment">// (curr, leader)</span></span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        count = arr.length;</span><br><span class="line">        parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : arr)</span><br><span class="line">            parent.put(v, v); <span class="comment">// 初始时，各自为战，自己是自己的领队</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结盟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不只是 p 与 q 结盟，而是整个 p 所在队伍 与 q 所在队伍结盟</span></span><br><span class="line">        <span class="comment">// 结盟需各领队出面，而不是小弟出面</span></span><br><span class="line">        Integer rootP = find(p), rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rootP == <span class="keyword">null</span> || rootQ == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结盟</span></span><br><span class="line">        parent.put(rootP, rootQ); <span class="comment">// 谁大听谁</span></span><br><span class="line">        <span class="comment">// 应取 max，而本题已明确 p &lt; q 才可这么写</span></span><br><span class="line">        <span class="comment">// 当前写法有损封装性，算法题可不纠结</span></span><br><span class="line"></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找领队</span></span><br><span class="line">    <span class="function">Integer <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!parent.containsKey(p))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归向上找领队</span></span><br><span class="line">        <span class="keyword">int</span> root = p;</span><br><span class="line">        <span class="keyword">while</span> (root != parent.get(root))</span><br><span class="line">            root = parent.get(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 路径压缩：扁平化管理，避免日后找领队层级过深</span></span><br><span class="line">        <span class="keyword">while</span> (p != parent.get(p)) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = p;</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">            parent.put(curr, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<em>O(n)</em></li><li>空间复杂度：<em>O(n)</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年8月" scheme="http://yoursite.com/categories/2020%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>60. 排列序列</title>
    <link href="http://yoursite.com/2020/11/13/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/11/13/60. 排列序列/</id>
    <published>2020-11-13T13:30:12.000Z</published>
    <updated>2020-11-18T07:26:53.125Z</updated>
    
    <content type="html"><![CDATA[<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”</p><p>给定 n 和 k，返回第 k 个排列。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：n = 3, k = 3输出：&quot;213&quot;</code></pre><p>示例 2：</p><pre><code>输入：n = 4, k = 9输出：&quot;2314&quot;</code></pre><p>示例 3：</p><pre><code>输入：n = 3, k = 1输出：&quot;123&quot;</code></pre><p>提示：</p><pre><code>1 &lt;= n &lt;= 91 &lt;= k &lt;= n!</code></pre><h1 id="方法一：数学-缩小问题规模"><a href="#方法一：数学-缩小问题规模" class="headerlink" title="方法一：数学 + 缩小问题规模"></a>方法一：数学 + 缩小问题规模</h1><p><strong>思路</strong></p><p>见<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，这道题还是有一定难度的，我只想到了最初的几步，后面的就推导不出来了，看了好久才有思路。后面还得仔细再看看。</p><p><strong>代码</strong></p><details>    <summary>数学 + 缩小问题规模C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factorial(n);</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --k;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; valid(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> order = k / factorial[n - i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                order -= valid[j];</span><br><span class="line">                <span class="keyword">if</span> (!order) &#123;</span><br><span class="line">                    ans += (j + <span class="string">'0'</span>);</span><br><span class="line">                    valid[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= factorial[n - i];</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> ans;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学 + 缩小问题规模Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --k;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span>[] valid = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(valid, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> order = k / factorial[n - i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                order -= valid[j];</span><br><span class="line">                <span class="keyword">if</span> (order == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.append(j);</span><br><span class="line">                    valid[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= factorial[n - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学 + 缩小问题规模Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        factorial = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            factorial.append(factorial[<span class="number">-1</span>] * i)</span><br><span class="line">        </span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        ans = list()</span><br><span class="line">        valid = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            order = k // factorial[n - i] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                order -= valid[j]</span><br><span class="line">                <span class="keyword">if</span> order == <span class="number">0</span>:</span><br><span class="line">                    ans.append(str(j))</span><br><span class="line">                    valid[j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            k %= factorial[n - i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ans)</span><br></pre></td></tr></table></figure></details><details>    <summary>数学 + 缩小问题规模Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPermutation</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    factorial := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    factorial[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        factorial[i] = factorial[i - <span class="number">1</span>] * i</span><br><span class="line">    &#125;</span><br><span class="line">    k--</span><br><span class="line"></span><br><span class="line">    ans := <span class="string">""</span></span><br><span class="line">    valid := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(valid); i++ &#123;</span><br><span class="line">        valid[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        order := k / factorial[n - i] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            order -= valid[j]</span><br><span class="line">            <span class="keyword">if</span> order == <span class="number">0</span> &#123;</span><br><span class="line">                ans += strconv.Itoa(j)</span><br><span class="line">                valid[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= factorial[n - i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学 + 缩小问题规模C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factorial[n];</span><br><span class="line">    factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --k;</span><br><span class="line">    <span class="keyword">char</span>* ans = <span class="built_in">malloc</span>(n + <span class="number">1</span>);</span><br><span class="line">    ans[n] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> valid[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        valid[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> order = k / factorial[n - i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            order -= valid[j];</span><br><span class="line">            <span class="keyword">if</span> (!order) &#123;</span><br><span class="line">                ans[i - <span class="number">1</span>] = j + <span class="string">'0'</span>;</span><br><span class="line">                valid[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= factorial[n - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)</em>。</p></li><li><p>空间复杂度：<em>O(n)</em>。</p></li></ul><p><strong>思考题</strong></p><p>对于给定的排列 a1,a2,…,an ，你能求出 <em>k</em> 吗？</p><p>解答见<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。&lt;/p&gt;
&lt;p&gt;按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：&lt;/p&gt;
&lt;p&gt;“123”&lt;br&gt;“132”&lt;br&gt;“213”&lt;br&gt;“231”&lt;br&gt;“312”&lt;br&gt;“321”&lt;/p&gt;
&lt;p&gt;给定 n 和 k，返回第 k 个排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>674. 最长连续递增序列</title>
    <link href="http://yoursite.com/2020/11/13/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/11/13/674. 最长连续递增序列/</id>
    <published>2020-11-13T06:45:12.000Z</published>
    <updated>2020-11-13T06:54:57.161Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </code></pre><p>示例 2：</p><pre><code>输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。</code></pre><p>提示：</p><pre><code>0 &lt;= nums.length &lt;= 104-109 &lt;= nums[i] &lt;= 109</code></pre><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>比较容易想到的就是二次循环，只要注意对空数组判断的情况就可以了</p><details>    <summary>循环</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">        int global = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int local = 1, j = i + 1;</span><br><span class="line">            while (j &lt; nums.length) &#123;</span><br><span class="line">                if (nums[j] &lt;= nums[j-1]) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    local++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            global = Math.max(global, local);</span><br><span class="line">        &#125;</span><br><span class="line">        return global;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><strong>算法：</strong></p><ul><li>每个（连续）增加的子序列是不相交的，并且每当 <code>nums[i-1]&gt;=nums[i]</code> 时，每个此类子序列的边界都会出现。当它这样做时，它标志着在 <code>nums[i]</code> 处开始一个新的递增子序列，我们将这样的 <code>i</code> 存储在变量 <code>anchor</code> 中。 </li><li>例如，如果 <code>nums=[7，8，9，1，2，3]</code>，那么 <code>anchor</code> 从 <code>0</code> 开始（<code>nums[anchor]=7</code>），并再次设置为 <code>anchor=3</code>（<code>nums[anchor]=1</code>）。无论 <code>anchor</code> 的值如何，我们都会记录 <code>i-anchor+1</code> 的候选答案、子数组 <code>nums[anchor]、nums[anchor+1]、…、nums[i]</code> 的长度，并且我们的答案会得到适当的更新。 <details>  <summary>滑动窗口Python</summary></details></li></ul><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        ans = anchor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i<span class="number">-1</span>] &gt;= nums[i]: anchor = i</span><br><span class="line">            ans = max(ans, i - anchor + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><details>    <summary>滑动窗口Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] &gt;= nums[i]) anchor = i;</span><br><span class="line">            ans = Math.max(ans, i - anchor + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 是 <code>nums</code> 的长度。我们通过 <code>nums</code> 执行一个循环。 </li><li>空间复杂度：<em>O(1)</em>，<code>anchor</code> 和 <code>ans</code> 使用了常数级空间。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。&lt;/p&gt;
&lt;p&gt;连续递增的子序列 可以由两个下标 l 和 r（l &amp;lt; r）确定，如果对于每个 l &amp;lt;= i &amp;lt; r，都有 nums[i] &amp;lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>81. 搜索旋转排序数组 II</title>
    <link href="http://yoursite.com/2020/11/13/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/"/>
    <id>http://yoursite.com/2020/11/13/81. 搜索旋转排序数组 II/</id>
    <published>2020-11-13T03:45:12.000Z</published>
    <updated>2020-11-18T08:25:27.091Z</updated>
    
    <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: nums = [2,5,6,0,0,1,2], target = 0输出: true</code></pre><p>示例 2:</p><pre><code>输入: nums = [2,5,6,0,0,1,2], target = 3输出: false</code></pre><p>进阶:</p><pre><code>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？  </code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p>本题和33.搜索旋转排序数组基本相同，多了重复元素的例子，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    测试用例:[1,3,1,1,1]</span><br><span class="line">3</span><br><span class="line">期望结果:true</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">如何处理`nums[start] == nums[mid]`的情况是关键。</span><br><span class="line"></span><br><span class="line">本题是需要使用二分查找，怎么分是关键，举个例子：</span><br><span class="line">* 第一类 </span><br><span class="line">*10111* 和 *11101* 这种。此种情况下 `nums[start] == nums[mid]`，分不清到底是前面有序还是后面有序，此时 `start++` 即可。相当于去掉一个重复的干扰项。</span><br><span class="line">* 第二类 </span><br><span class="line">*2* *3* *4* *5* *6* *7* *1* 这种，也就是 `nums[start] &lt; nums[mid]`。此例子中就是 `2 &lt; 5`；</span><br><span class="line">这种情况下，前半部分有序。因此如果 `nums[start] &lt;=target&lt;nums[mid]`，则在前半部分找，否则去后半部分找。</span><br><span class="line">* 第三类 </span><br><span class="line">*6* *7* *1* *2* *3* *4* *5* 这种，也就是 `nums[start] &gt; nums[mid]`。此例子中就是 `6 &gt; 2`；</span><br><span class="line">这种情况下，后半部分有序。因此如果 `nums[mid] &lt;target&lt;=nums[end]`。则在后半部分找，否则去前半部分找。</span><br><span class="line"></span><br><span class="line">## 代码:</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;二分查找Java&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">```Java [ ]</span><br><span class="line">public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        if (nums == null || nums.length == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = nums.length - 1;</span><br><span class="line">        int mid;</span><br><span class="line">        while (start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / 2;</span><br><span class="line">            if (nums[mid] == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[start] == nums[mid]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //前半部分有序</span><br><span class="line">            if (nums[start] &lt; nums[mid]) &#123;</span><br><span class="line">                //target在前半部分</span><br><span class="line">                if (nums[mid] &gt; target &amp;&amp; nums[start] &lt;= target) &#123;</span><br><span class="line">                    end = mid - 1;</span><br><span class="line">                &#125; else &#123;  //否则，去后半部分找</span><br><span class="line">                    start = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //后半部分有序</span><br><span class="line">                //target在后半部分</span><br><span class="line">                if (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123;</span><br><span class="line">                    start = mid + 1;</span><br><span class="line">                &#125; else &#123;  //否则，去后半部分找</span><br><span class="line">                    end = mid - 1;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //一直没找到，返回false</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。&lt;/p&gt;
&lt;p&gt;编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="http://yoursite.com/2020/11/11/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/11/11/33. 搜索旋转排序数组/</id>
    <published>2020-11-11T08:43:12.000Z</published>
    <updated>2020-11-12T06:59:50.541Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个升序排列的整数数组 nums ，和一个整数 target 。</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。</p><p>请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums = [4,5,6,7,0,1,2], target = 0输出：4</code></pre><p>示例 2：</p><pre><code>输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1</code></pre><p>示例 3：</p><pre><code>输入：nums = [1], target = 0输出：-1</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 5000-10^4 &lt;= nums[i] &lt;= 10^4nums 中的每个值都 独一无二nums 肯定会在某个点上旋转-10^4 &lt;= target &lt;= 10^4</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><p>我首先用二分搜索遇到的问题是以下几个测试用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   测试用例:[1,0]</span><br><span class="line">0</span><br><span class="line">期望结果:1</span><br><span class="line"></span><br><span class="line">测试用例:[0]</span><br><span class="line">0</span><br><span class="line">期望结果:0</span><br><span class="line"></span><br><span class="line">测试用例:[1,3,5]</span><br><span class="line">3</span><br><span class="line">期望结果:1</span><br></pre></td></tr></table></figure><p>所以用以下方法来解</p><details>    <summary>二分搜索Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int index = -1;</span><br><span class="line">        int i = 0, j = nums.length - 1;</span><br><span class="line"></span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            int mid = (i + j) / 2;</span><br><span class="line">            if (nums[mid] &lt; nums[i]) &#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                i = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] == target) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index == -1) &#123;</span><br><span class="line">            for (int k = 0; k &lt; nums.length; k++) &#123;</span><br><span class="line">                if (nums[k] == target) &#123;</span><br><span class="line">                    return k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>但这种算法最后要遍历一遍，所以复杂度为O(n)</p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p><strong>思路和算法</strong></p><p>题目要求算法时间复杂度必须是O(logn)   的级别，这提示我们可以使用二分搜索的方法。</p><p>但是数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分搜索吗？答案是可以的。</p><p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 <code>6</code> 这个位置分开以后数组变成了 <code>[4, 5, 6]</code> 和 <code>[7, 0, 1, 2]</code> 两个部分，其中左边 <code>[4, 5, 6]</code> 这个部分的数组是有序的，其他也是如此。</p><p>这启示我们可以在常规二分搜索的时候查看当前 <code>mid</code> 为分割位置分割出来的两个部分 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code> 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分搜索的上下界，因为我们能够根据有序的那部分判断出 <code>target</code> 在不在这个部分：</p><ul><li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足[nums[l],nums[mid])，则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li><li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足(nums[mid+1],nums[r]] ，则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在 <code>[l, mid - 1]</code> 中寻找。</li></ul><p><a href="https://assets.leetcode-cn.com/solution-static/33/33_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>需要注意的是，二分的写法有很多种，所以在判断 <code>target</code> 大小与有序部分的关系的时候可能会出现细节上的差别。</p><details>    <summary>二分搜索C++</summary><figure class="highlight c++"><figcaption><span>[solution1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分搜索Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分搜索Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[len(nums) - <span class="number">1</span>]:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： O(logn) ，其中 <em>n</em> 为 nums 数组的大小。整个算法时间复杂度即为二分搜索的时间复杂度 O(logn)。</p></li><li><p>空间复杂度： <em>O(1)</em> 。我们只需要常数级别的空间存放变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个升序排列的整数数组 nums ，和一个整数 target 。&lt;/p&gt;
&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。&lt;/p&gt;
&lt;p&gt;请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>695. 岛屿的最大面积</title>
    <link href="http://yoursite.com/2020/11/11/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/11/11/695. 岛屿的最大面积/</id>
    <published>2020-11-11T08:43:12.000Z</published>
    <updated>2020-11-11T13:10:38.467Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><a id="more"></a><p>示例 1:</p><pre><code>[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]</code></pre><p>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><p>示例 2:</p><pre><code>[[0,0,0,0,0,0,0,0]]</code></pre><p>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><p>好久没做这种题了，但还是没看答案就搞定了，啪的一下，很快啊hh。</p><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p><strong>算法</strong></p><ul><li><p>我们想知道网格中每个连通形状的面积，然后取最大值。</p></li><li><p>如果我们在一个土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。</p></li><li><p>为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。</p><details>  <summary>深度优先搜索Python3</summary></details></li></ul><figure class="highlight plain"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def dfs(self, grid, cur_i, cur_j):</span><br><span class="line">        if cur_i &lt; 0 or cur_j &lt; 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:</span><br><span class="line">            return 0</span><br><span class="line">        grid[cur_i][cur_j] = 0</span><br><span class="line">        ans = 1</span><br><span class="line">        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:</span><br><span class="line">            next_i, next_j = cur_i + di, cur_j + dj</span><br><span class="line">            ans += self.dfs(grid, next_i, next_j)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        ans = 0</span><br><span class="line">        for i, l in enumerate(grid):</span><br><span class="line">            for j, n in enumerate(l):</span><br><span class="line">                ans = max(self.dfs(grid, i, j), ans)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure><details>    <summary>深度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> cur_i, <span class="keyword">int</span> cur_j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.size() || cur_j == grid[<span class="number">0</span>].size() || grid[cur_i][cur_j] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dj[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">            ans += dfs(grid, next_i, next_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].size(); ++j) &#123;</span><br><span class="line">                ans = max(ans, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                ans = Math.max(ans, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> cur_i, <span class="keyword">int</span> cur_j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.length || cur_j == grid[<span class="number">0</span>].length || grid[cur_i][cur_j] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] di = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dj = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">            ans += dfs(grid, next_i, next_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(R * C)*。其中 *R</em> 是给定网格中的行数，<em>C</em> 是列数。我们访问每个网格最多一次。</p></li><li><p>空间复杂度：<em>O(R * C)*，递归的深度最大可能是整个网格的大小，因此最大可能使用 *O(R * C)</em> 的栈空间。</p></li></ul><h2 id="方法二：深度优先搜索-栈"><a href="#方法二：深度优先搜索-栈" class="headerlink" title="方法二：深度优先搜索 + 栈"></a>方法二：深度优先搜索 + 栈</h2><p><strong>算法</strong></p><p>我们可以用栈来实现深度优先搜索算法。这种方法本质与方法一相同，唯一的区别是：</p><ul><li><p>方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。</p></li><li><p>访问每一片土地时，我们将对围绕它四个方向进行探索，找到还未访问的土地，加入到栈 <code>stack</code> 中；</p></li><li><p>另外，只要栈 <code>stack</code> 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。</p></li></ul><details>    <summary>深度优先搜索 + 栈Python3</summary><figure class="highlight plain"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        ans = 0</span><br><span class="line">        for i, l in enumerate(grid):</span><br><span class="line">            for j, n in enumerate(l):</span><br><span class="line">                cur = 0</span><br><span class="line">                stack = [(i, j)]</span><br><span class="line">                while stack:</span><br><span class="line">                    cur_i, cur_j = stack.pop()</span><br><span class="line">                    if cur_i &lt; 0 or cur_j &lt; 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:</span><br><span class="line">                        continue</span><br><span class="line">                    cur += 1</span><br><span class="line">                    grid[cur_i][cur_j] = 0</span><br><span class="line">                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:</span><br><span class="line">                        next_i, next_j = cur_i + di, cur_j + dj</span><br><span class="line">                        stack.append((next_i, next_j))</span><br><span class="line">                ans = max(ans, cur)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索 + 栈C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stacki;</span><br><span class="line">                <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackj;</span><br><span class="line">                stacki.push(i);</span><br><span class="line">                stackj.push(j);</span><br><span class="line">                <span class="keyword">while</span> (!stacki.empty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cur_i = stacki.top(), cur_j = stackj.top();</span><br><span class="line">                    stacki.pop();</span><br><span class="line">                    stackj.pop();</span><br><span class="line">                    <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.size() || cur_j == grid[<span class="number">0</span>].size() || grid[cur_i][cur_j] != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++cur;</span><br><span class="line">                    grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> dj[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">                        <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">                        stacki.push(next_i);</span><br><span class="line">                        stackj.push(next_j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索 + 栈Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                Deque&lt;Integer&gt; stacki = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">                Deque&lt;Integer&gt; stackj = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">                stacki.push(i);</span><br><span class="line">                stackj.push(j);</span><br><span class="line">                <span class="keyword">while</span> (!stacki.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cur_i = stacki.pop(), cur_j = stackj.pop();</span><br><span class="line">                    <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.length || cur_j == grid[<span class="number">0</span>].length || grid[cur_i][cur_j] != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++cur;</span><br><span class="line">                    grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span>[] di = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span>[] dj = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">                        <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">                        stacki.push(next_i);</span><br><span class="line">                        stackj.push(next_j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(R * C)*。其中 *R</em> 是给定网格中的行数，<em>C</em> 是列数。我们访问每个网格最多一次。</p></li><li><p>空间复杂度：<em>O(R * C)*，栈中最多会存放所有的土地，土地的数量最多为 *R * C</em> 块，因此使用的空间为 <em>O(R * C)</em>。</p></li></ul><h2 id="方法三：广度优先搜索"><a href="#方法三：广度优先搜索" class="headerlink" title="方法三：广度优先搜索"></a>方法三：广度优先搜索</h2><p><strong>算法</strong></p><p>我们把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。</p><details>    <summary>广度优先搜索Python3</summary><figure class="highlight plain"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        ans = 0</span><br><span class="line">        for i, l in enumerate(grid):</span><br><span class="line">            for j, n in enumerate(l):</span><br><span class="line">                cur = 0</span><br><span class="line">                q = collections.deque([(i, j)])</span><br><span class="line">                while q:</span><br><span class="line">                    cur_i, cur_j = q.popleft()</span><br><span class="line">                    if cur_i &lt; 0 or cur_j &lt; 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:</span><br><span class="line">                        continue</span><br><span class="line">                    cur += 1</span><br><span class="line">                    grid[cur_i][cur_j] = 0</span><br><span class="line">                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:</span><br><span class="line">                        next_i, next_j = cur_i + di, cur_j + dj</span><br><span class="line">                        q.append((next_i, next_j))</span><br><span class="line">                ans = max(ans, cur)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queuei;</span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queuej;</span><br><span class="line">                queuei.push(i);</span><br><span class="line">                queuej.push(j);</span><br><span class="line">                <span class="keyword">while</span> (!queuei.empty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cur_i = queuei.front(), cur_j = queuej.front();</span><br><span class="line">                    queuei.pop();</span><br><span class="line">                    queuej.pop();</span><br><span class="line">                    <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.size() || cur_j == grid[<span class="number">0</span>].size() || grid[cur_i][cur_j] != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++cur;</span><br><span class="line">                    grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> dj[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">                        <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">                        queuei.push(next_i);</span><br><span class="line">                        queuej.push(next_j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>广度优先搜索Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != grid.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                Queue&lt;Integer&gt; queuei = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">                Queue&lt;Integer&gt; queuej = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">                queuei.offer(i);</span><br><span class="line">                queuej.offer(j);</span><br><span class="line">                <span class="keyword">while</span> (!queuei.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cur_i = queuei.poll(), cur_j = queuej.poll();</span><br><span class="line">                    <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.length || cur_j == grid[<span class="number">0</span>].length || grid[cur_i][cur_j] != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++cur;</span><br><span class="line">                    grid[cur_i][cur_j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span>[] di = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span>[] dj = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">4</span>; ++index) &#123;</span><br><span class="line">                        <span class="keyword">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class="line">                        queuei.offer(next_i);</span><br><span class="line">                        queuej.offer(next_j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(R * C)*。其中 *R</em> 是给定网格中的行数，<em>C</em> 是列数。我们访问每个网格最多一次。</p></li><li><p>空间复杂度：<em>O(R * C)*，队列中最多会存放所有的土地，土地的数量最多为 *R * C</em> 块，因此使用的空间为 <em>O(R * C)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 grid 。&lt;/p&gt;
&lt;p&gt;一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。&lt;/p&gt;
&lt;p&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>16. 最接近的三数之和</title>
    <link href="http://yoursite.com/2020/10/22/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/10/22/16. 最接近的三数之和/</id>
    <published>2020-10-22T08:16:12.000Z</published>
    <updated>2020-10-22T08:44:18.164Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包括n 个整数的数组nums和 一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><a id="more"></a><p>示例：</p><pre><code>输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</code></pre><p>提示：</p><pre><code>3 &lt;= nums.length &lt;= 10^3-10^3 &lt;= nums[i] &lt;= 10^3-10^4 &lt;= target &lt;= 10^4</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题与 <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a> 非常类似，可以使用「双指针」的方法来解决。但基于题解的独立性，这里还是会从零开始讲解。</p><h2 id="精简版代码"><a href="#精简版代码" class="headerlink" title="精简版代码"></a>精简版代码</h2><p>我首先想到的写法是下面这种，又适当精简了一下。效率较下面的版本要高</p><details>    <summary>排序 + 双指针Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; i &amp;&amp; right &gt; i) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = nums[left] + nums[i] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (min &gt; Math.abs(value - target)) &#123;</span><br><span class="line">                    min = Math.abs(value - target);</span><br><span class="line">                    res = value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (value &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序 + 双指针"></a>排序 + 双指针</h1><p><strong>思路与算法</strong></p><p>题目要求找到与目标值 target 最接近的三元组，这里的「最接近」即为差值的绝对值最小。我们可以考虑直接使用三重循环枚举三元组，找出与目标值最接近的作为答案，时间复杂度为 <em>O(N^3)*。然而本题的 *N</em> 最大为 <em>1000</em>，会超出时间限制。</p><p>那么如何进行优化呢？我们首先考虑枚举第一个元素 <em>a</em>，对于剩下的两个元素 <em>b</em> 和 <em>c</em>，我们希望它们的和最接近 target-a。对于 <em>b</em> 和 <em>c</em>，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来：</p><ul><li><p>假设数组的长度为 <em>n</em>，我们先枚举 <em>a</em>，它在数组中的位置为 <em>i</em>；</p></li><li><p>为了防止重复枚举，我们在位置 <em>[i+1, n)</em> 的范围内枚举 <em>b</em> 和 <em>c</em>。</p></li></ul><p>当我们知道了 <em>b</em> 和 <em>c</em> 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？</p><p>答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 <em>p_b</em> 和 <em>p_c</em> 分别表示指向 <em>b</em> 和 <em>c</em> 的指针，初始时，<em>p_b</em> 指向位置 <em>i+1<em>，即左边界；</em>p_c</em> 指向位置 <em>n-1*，即右边界。在每一步枚举的过程中，我们用 *a+b+c</em> 来更新答案，并且：</p><ul><li><p>如果 a+b+c&gt;=target，那么就将 <em>p_c</em> 向左移动一个位置；</p></li><li><p>如果 a+b+c&lt;=target ，那么就将 <em>p_b</em> 向右移动一个位置。</p></li></ul><p>这是为什么呢？我们对 a+b+c&gt;=target 的情况进行一个详细的分析：</p><blockquote><p>如果 a+b+c&gt;=target ，并且我们知道 <em>p_b</em> 到 <em>p_c</em> 这个范围内的所有数是按照升序排序的，那么如果 <em>p_c</em> 不变而 <em>p_b</em> 向右移动，那么 <em>a+b+c</em> 的值就会不断地增加，显然就不会成为最接近 target 的值了。因此，我们可以知道在固定了 <em>p_c</em> 的情况下，此时的 <em>p_b</em> 就可以得到一个最接近 target 的值，那么我们以后就不用再考虑 <em>p_c</em> 了，就可以将 <em>p_c</em> 向左移动一个位置。</p></blockquote><p>同样地，在 a+b+c&lt;target   时：</p><blockquote><p>如果  a+b+c&lt;target   ，并且我们知道 <em>p_b</em> 到 <em>p_c</em> 这个范围内的所有数是按照升序排序的，那么如果 <em>p_b</em> 不变而 <em>p_c</em> 向左移动，那么 <em>a+b+c</em> 的值就会不断地减小，显然就不会成为最接近 target 的值了。因此，我们可以知道在固定了 <em>p_b</em> 的情况下，此时的 <em>p_c</em> 就可以得到一个最接近 target 的值，那么我们以后就不用再考虑 <em>p_b</em> 了，就可以将 <em>p_b</em> 向右移动一个位置。</p></blockquote><p>实际上，<em>p_b</em> 和 <em>p_c</em> 就表示了我们当前<strong>可以选择的数的范围</strong>，而每一次枚举的过程中，我们<strong>尝试边界上的两个元素</strong>，根据它们与target 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a> 中的双指针解法也是类似的。</p><p><strong>小优化</strong></p><p>本题也有一些可以减少运行时间（但不会减少时间复杂度）的小优化。当我们枚举到恰好等于target 的 <em>a+b+c</em> 时，可以直接返回target 作为答案，因为不会有再比这个更接近的值了。</p><p>另一个优化与 <a href="https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/" target="_blank" rel="noopener">15. 三数之和的官方题解</a> 中提到的类似。当我们枚举 <em>a, b, c</em> 中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举到的不相同的元素，减少枚举的次数。</p><details>    <summary>排序 + 双指针C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">        <span class="keyword">auto</span> update = [&amp;](<span class="keyword">int</span> cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(cur - target) &lt; <span class="built_in">abs</span>(best - target)) &#123;</span><br><span class="line">                best = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                update(sum);</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> k0 = k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> j0 = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序 + 双指针Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(best - target)) &#123;</span><br><span class="line">                    best = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> k0 = k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> j0 = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序 + 双指针Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        best = <span class="number">10</span>**<span class="number">7</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据差值的绝对值来更新答案</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> best</span><br><span class="line">            <span class="keyword">if</span> abs(cur - target) &lt; abs(best - target):</span><br><span class="line">                best = cur</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 使用双指针枚举 b 和 c</span></span><br><span class="line">            j, k = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="comment"># 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> s == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                update(s)</span><br><span class="line">                <span class="keyword">if</span> s &gt; target:</span><br><span class="line">                    <span class="comment"># 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    k0 = k - <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k0 <span class="keyword">and</span> nums[k0] == nums[k]:</span><br><span class="line">                        k0 -= <span class="number">1</span></span><br><span class="line">                    k = k0</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    j0 = j + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> j0 &lt; k <span class="keyword">and</span> nums[j0] == nums[j]:</span><br><span class="line">                        j0 += <span class="number">1</span></span><br><span class="line">                    j = j0</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best</span><br></pre></td></tr></table></figure></details><details>    <summary>排序 + 双指针Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        best = math.MaxInt32</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">    update := <span class="function"><span class="keyword">func</span><span class="params">(cur <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> abs(cur - target) &lt; abs(best - target) &#123;</span><br><span class="line">            best = cur</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">        j, k := i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">            sum := nums[i] + nums[j] + nums[k]</span><br><span class="line">            <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">            <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">                <span class="keyword">return</span> target</span><br><span class="line">            &#125;</span><br><span class="line">            update(sum)</span><br><span class="line">            <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">                <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                k0 := k - <span class="number">1</span></span><br><span class="line">                <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                <span class="keyword">for</span> j &lt; k0 &amp;&amp; nums[k0] == nums[k] &#123;</span><br><span class="line">                    k0--</span><br><span class="line">                &#125; </span><br><span class="line">                k = k0</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                j0 := j + <span class="number">1</span></span><br><span class="line">                <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                <span class="keyword">for</span> j0 &lt; k &amp;&amp; nums[j0] == nums[j] &#123;</span><br><span class="line">                    j0++</span><br><span class="line">                &#125;</span><br><span class="line">                j = j0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> * x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序 + 双指针C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numsSize;</span><br><span class="line">    qsort(nums, n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), comp);</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - target) &lt; <span class="built_in">abs</span>(best - target)) &#123;</span><br><span class="line">                best = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                <span class="keyword">int</span> k0 = k - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                    --k0;</span><br><span class="line">                &#125;</span><br><span class="line">                k = k0;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                <span class="keyword">int</span> j0 = j + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                    ++j0;</span><br><span class="line">                &#125;</span><br><span class="line">                j = j0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N^2)*，其中 *N</em> 是数组 nums 的长度。我们首先需要O(NlogN) 的时间对数组进行排序，随后在枚举的过程中，使用一重循环 <em>O(N)</em> 枚举 <em>a</em>，双指针 <em>O(N)</em> 枚举 <em>b</em> 和 <em>c</em>，故一共是 <em>O(N^2)</em>。</p></li><li><p>空间复杂度：O(logN)。排序需要使用 O(logN) 的空间。然而我们修改了输入的数组nums ，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums的副本并进行排序，此时空间复杂度为 <em>O(N)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包括n 个整数的数组nums和 一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。假定每组输入只存在唯一答案。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>923. 三数之和的多种可能</title>
    <link href="http://yoursite.com/2020/10/22/923.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E8%83%BD/"/>
    <id>http://yoursite.com/2020/10/22/923. 三数之和的多种可能/</id>
    <published>2020-10-22T08:16:12.000Z</published>
    <updated>2020-11-11T08:40:00.244Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组A，以及一个整数target作为目标值，返回满足 i &lt; j &lt; k 且A[i] + A[j] + A[k] == target的元组i, j, k的数量。</p><p>由于结果会非常大，请返回 结果除以 10^9 + 7 的余数。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：A = [1,1,2,2,3,3,4,4,5,5], target = 8输出：20解释：按值枚举（A[i]，A[j]，A[k]）：(1, 2, 5) 出现 8 次；(1, 3, 4) 出现 8 次；(2, 2, 4) 出现 2 次；(2, 3, 3) 出现 2 次。</code></pre><p>示例 2：</p><pre><code>输入：A = [1,1,2,2,2,2], target = 5输出：12解释：A[i] = 1，A[j] = A[k] = 2 出现 12 次：我们从 [1,1] 中选择一个 1，有 2 种情况，从 [2,2,2,2] 中选出两个 2，有 6 种情况。</code></pre><p>提示：</p><pre><code>3 &lt;= A.length &lt;= 30000 &lt;= A[i] &lt;= 1000 &lt;= target &lt;= 300</code></pre><h1 id="方法须知"><a href="#方法须知" class="headerlink" title="方法须知"></a>方法须知</h1><p>下面讲的方法跟用双指针来做 <code>&quot;两数之和&quot;</code> 有异曲同工之妙，先来看一下 <code>&quot;两数之和&quot;</code> 这道题。</p><p>假设有一个有序数组，同时这个数组中元素唯一，想知道有多少对 <code>i</code>，<code>j</code>，满足 <code>i &lt; j</code> 且 <code>A[i] + A[j] == target</code>。</p><p><code>&quot;两数之和&quot;</code> 可以在线性时间解决的，定义两个指针 <code>i</code>，<code>j</code>，初始分别指向数组的头尾，<code>i</code> 逐渐递增，<code>j</code> 逐渐递减，来找出所有满足 <code>A[i] + A[j] == target</code> 的组合。</p><details>    <summary>两数之和</summary><figure class="highlight python"><figcaption><span>[solution0-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(A, target)</span>:</span></span><br><span class="line">    <span class="comment"># Assume A already sorted</span></span><br><span class="line">    i, j = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> A[i] + A[j] &lt; target:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> A[i] + A[j] &gt; target:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><h1 id="方法一：-三指针"><a href="#方法一：-三指针" class="headerlink" title="方法一： 三指针"></a>方法一： 三指针</h1><p><strong>思路和算法</strong></p><p>先将数组进行排序，遍历数组下标，对于每个 <code>i</code>，设 <code>T = target - A[i]</code> 作为剩余要凑成的目标数。接着用双指针来完成 <code>A[j] + A[k] == T</code> 的子任务。</p><p>考虑到有些元素是重复的，需要小心处理边界条件。在特殊的情况下，比如说 <code>target = 8</code>，数组为 <code>[2,2,2,2,3,3,4,4,4,5,5,5,6,6]</code>，这个数组就有大量的重复元素可以组成 <code>target</code>，下面来分析一下这种情况该怎么处理。</p><p>只要 <code>A[j] + A[k] == T</code>，就要算上这一对 <code>j</code>, <code>k</code> 组合。在这个例子里面，当 <code>A[j] == 2</code>，<code>A[k] == 6</code>，有 <code>4 * 2 = 8</code> 种组合方式。</p><p>在特殊情况下，如果 <code>A[j] == A[k]</code>，比如最后剩下的 <code>[4,4,4]</code>，这里有 <code>3</code> 对。一般情况下，如果 <code>A[j] == A[k]</code>，我们有  M*(M-1)/2 对 <code>(j,k)</code>（满足 <code>j &lt; k</code> 且 <code>A[j] + A[k] == T</code>）。</p><details>    <summary>三指针Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumMulti</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// We'll try to find the number of i &lt; j &lt; k</span></span><br><span class="line">            <span class="comment">// with A[j] + A[k] == T, where T = target - A[i].</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// The below is a "two sum with multiplicity".</span></span><br><span class="line">            <span class="keyword">int</span> T = target - A[i];</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>, k = A.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="comment">// These steps proceed as in a typical two-sum.</span></span><br><span class="line">                <span class="keyword">if</span> (A[j] + A[k] &lt; T)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (A[j] + A[k] &gt; T)</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (A[j] != A[k]) &#123;  <span class="comment">// We have A[j] + A[k] == T.</span></span><br><span class="line">                    <span class="comment">// Let's count "left": the number of A[j] == A[j+1] == A[j+2] == ...</span></span><br><span class="line">                    <span class="comment">// And similarly for "right".</span></span><br><span class="line">                    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (j+<span class="number">1</span> &lt; k &amp;&amp; A[j] == A[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (k-<span class="number">1</span> &gt; j &amp;&amp; A[k] == A[k-<span class="number">1</span>]) &#123;</span><br><span class="line">                        right++;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ans += left * right;</span><br><span class="line">                    ans %= MOD;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// M = k - j + 1</span></span><br><span class="line">                    <span class="comment">// We contributed M * (M-1) / 2 pairs.</span></span><br><span class="line">                    ans += (k-j+<span class="number">1</span>) * (k-j) / <span class="number">2</span>;</span><br><span class="line">                    ans %= MOD;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>三指针Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumMulti</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        A.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="comment"># We'll try to find the number of i &lt; j &lt; k</span></span><br><span class="line">            <span class="comment"># with A[j] + A[k] == T, where T = target - A[i].</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># The below is a "two sum with multiplicity".</span></span><br><span class="line">            T = target - A[i]</span><br><span class="line">            j, k = i+<span class="number">1</span>, len(A) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="comment"># These steps proceed as in a typical two-sum.</span></span><br><span class="line">                <span class="keyword">if</span> A[j] + A[k] &lt; T:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> A[j] + A[k] &gt; T:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># These steps differ:</span></span><br><span class="line">                <span class="keyword">elif</span> A[j] != A[k]: <span class="comment"># We have A[j] + A[k] == T.</span></span><br><span class="line">                    <span class="comment"># Let's count "left": the number of A[j] == A[j+1] == A[j+2] == ...</span></span><br><span class="line">                    <span class="comment"># And similarly for "right".</span></span><br><span class="line">                    left = right = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j + <span class="number">1</span> &lt; k <span class="keyword">and</span> A[j] == A[j+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> k - <span class="number">1</span> &gt; j <span class="keyword">and</span> A[k] == A[k<span class="number">-1</span>]:</span><br><span class="line">                        right += <span class="number">1</span></span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># We contributed left * right many pairs.</span></span><br><span class="line">                    ans += left * right</span><br><span class="line">                    ans %= MOD</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># M = k - j + 1</span></span><br><span class="line">                    <span class="comment"># We contributed M * (M-1) / 2 pairs.</span></span><br><span class="line">                    ans += (k-j+<span class="number">1</span>) * (k-j) / <span class="number">2</span></span><br><span class="line">                    ans %= MOD</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(N^2)*，其中 *N</em> 为 <code>A</code> 的长度。</p></li><li><p>空间复杂度： <em>O(1)</em>。</p></li></ul><h1 id="方法二：-数学法"><a href="#方法二：-数学法" class="headerlink" title="方法二： 数学法"></a>方法二： 数学法</h1><p><strong>思路和算法</strong></p><p>设 <code>count[x]</code> 为数组 <code>A</code> 中 <code>x</code> 出现的次数。对于每种 <code>x+y+z == target</code>，可以数一下有多少种可能的组合，这里可以看几个例子：</p><ul><li><p>如果 <code>x</code>，<code>y</code>，<code>z</code> 各不相同，有 <code>count[x] * count[y] * count[z]</code> 中组合。</p></li><li><p>如果 <code>x == y != z</code>，有  <code>(count[x] * (count[x]-1)/2) * count[z]</code> 种组合。</p></li><li><p>如果 <code>x != y == z</code>，有 <code>count[z] * (count[y] * (count[y]-1)/2)</code>  种组合。</p></li><li><p>如果 <code>x == y == z</code>，有 (count[x] * (count[x]-1) * (count[x]-2)/6) 中组合。</p></li></ul><details>    <summary>数学法Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumMulti</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="keyword">long</span>[] count = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A)</span><br><span class="line">            count[x]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// All different</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">100</span>; ++x)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = x+<span class="number">1</span>; y &lt;= <span class="number">100</span>; ++y) &#123;</span><br><span class="line">                <span class="keyword">int</span> z = target - x - y;</span><br><span class="line">                <span class="keyword">if</span> (y &lt; z &amp;&amp; z &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    ans += count[x] * count[y] * count[z];</span><br><span class="line">                    ans %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x == y != z</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">100</span>; ++x) &#123;</span><br><span class="line">            <span class="keyword">int</span> z = target - <span class="number">2</span>*x;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; z &amp;&amp; z &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                ans += count[x] * (count[x] - <span class="number">1</span>) / <span class="number">2</span> * count[z];</span><br><span class="line">                ans %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x != y == z</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">100</span>; ++x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target % <span class="number">2</span> == x % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = (target - x) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; y &amp;&amp; y &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    ans += count[x] * count[y] * (count[y] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    ans %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x == y == z</span></span><br><span class="line">        <span class="keyword">if</span> (target % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = target / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                ans += count[x] * (count[x] - <span class="number">1</span>) * (count[x] - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">                ans %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>数学法Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumMulti</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">101</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            count[x] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># All different</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">101</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> xrange(x+<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">                z = target - x - y</span><br><span class="line">                <span class="keyword">if</span> y &lt; z &lt;= <span class="number">100</span>:</span><br><span class="line">                    ans += count[x] * count[y] * count[z]</span><br><span class="line">                    ans %= MOD</span><br><span class="line"></span><br><span class="line">        <span class="comment"># x == y</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">101</span>):</span><br><span class="line">            z = target - <span class="number">2</span>*x</span><br><span class="line">            <span class="keyword">if</span> x &lt; z &lt;= <span class="number">100</span>:</span><br><span class="line">                ans += count[x] * (count[x] - <span class="number">1</span>) / <span class="number">2</span> * count[z]</span><br><span class="line">                ans %= MOD</span><br><span class="line"></span><br><span class="line">        <span class="comment"># y == z</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">101</span>):</span><br><span class="line">            <span class="keyword">if</span> (target - x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                y = (target - x) / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> x &lt; y &lt;= <span class="number">100</span>:</span><br><span class="line">                    ans += count[x] * count[y] * (count[y] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                    ans %= MOD</span><br><span class="line"></span><br><span class="line">        <span class="comment"># x == y == z</span></span><br><span class="line">        <span class="keyword">if</span> target % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            x = target / <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt;= <span class="number">100</span>:</span><br><span class="line">                ans += count[x] * (count[x] - <span class="number">1</span>) * (count[x] - <span class="number">2</span>) / <span class="number">6</span></span><br><span class="line">                ans %= MOD</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(N + W^2)*，其中 *N</em> 为 <code>A</code> 的长度，<em>W</em> 为 <code>A[i]</code> 中最大的数。</p></li><li><p>空间复杂度： <em>O(W)</em>。</p></li></ul><h1 id="方法三：-变种的三数之和"><a href="#方法三：-变种的三数之和" class="headerlink" title="方法三： 变种的三数之和"></a>方法三： 变种的三数之和</h1><p><strong>思路和算法那</strong></p><p>在 <em>方法二</em> 中，<code>count[x]</code> 为 <code>A</code> 中 <code>x</code> 出现的次数。同时，让 <code>keys</code> 为数组 <code>A</code> 中所有元素只出现一次的有序数组。接着用三数之和的方法来处理 <code>keys</code>。</p><p>举个例子，如果 <code>A = [1,1,2,2,3,3,4,4,5,5]</code>，<code>target = 8</code>，得到 <code>keys = [1,2,3,4,5]</code>。当对 <code>keys</code> 做三数之和的时候，会遇到一些组合使得三数相加为 <code>target</code>，比如 <code>(x,y,z) = (1,2,5), (1,3,4), (2,2,4), (2,3,3)</code>。接着用 <code>count</code> 来算每种组合有多少次。</p><details>    <summary>变种的三数之和Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumMulti</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initializing as long saves us the trouble of</span></span><br><span class="line">        <span class="comment">// managing count[x] * count[y] * count[z] overflowing later.</span></span><br><span class="line">        <span class="keyword">long</span>[] count = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">int</span> uniq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) &#123;</span><br><span class="line">            count[x]++;</span><br><span class="line">            <span class="keyword">if</span> (count[x] == <span class="number">1</span>)</span><br><span class="line">                uniq++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] keys = <span class="keyword">new</span> <span class="keyword">int</span>[uniq];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>)</span><br><span class="line">                keys[t++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Now, let's do a 3sum on "keys", for i &lt;= j &lt;= k.</span></span><br><span class="line">        <span class="comment">// We will use count to add the correct contribution to ans.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = keys[i];</span><br><span class="line">            <span class="keyword">int</span> T = target - x;</span><br><span class="line">            <span class="keyword">int</span> j = i, k = keys.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = keys[j], z = keys[k];</span><br><span class="line">                <span class="keyword">if</span> (y + z &lt; T) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y + z &gt; T) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// # x+y+z == T, now calc the size of the contribution</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; j &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                        ans += count[x] * count[y] * count[z];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == j &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                        ans += count[x] * (count[x] - <span class="number">1</span>) / <span class="number">2</span> * count[z];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; j &amp;&amp; j == k) &#123;</span><br><span class="line">                        ans += count[x] * count[y] * (count[y] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// i == j == k</span></span><br><span class="line">                        ans += count[x] * (count[x] - <span class="number">1</span>) * (count[x] - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ans %= MOD;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>变种的三数之和Python</summary><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumMulti</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        count = collections.Counter(A)</span><br><span class="line">        keys = sorted(count)</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now, let's do a 3sum on "keys", for i &lt;= j &lt;= k.</span></span><br><span class="line">        <span class="comment"># We will use count to add the correct contribution to ans.</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(keys):</span><br><span class="line">            T = target - x</span><br><span class="line">            j, k = i, len(keys) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= k:</span><br><span class="line">                y, z = keys[j], keys[k]</span><br><span class="line">                <span class="keyword">if</span> y + z &lt; T:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> y + z &gt; T:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># x+y+z == T, now calculate the size of the contribution</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; j &lt; k:</span><br><span class="line">                        ans += count[x] * count[y] * count[z]</span><br><span class="line">                    <span class="keyword">elif</span> i == j &lt; k:</span><br><span class="line">                        ans += count[x] * (count[x] - <span class="number">1</span>) / <span class="number">2</span> * count[z]</span><br><span class="line">                    <span class="keyword">elif</span> i &lt; j == k:</span><br><span class="line">                        ans += count[x] * count[y] * (count[y] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:  <span class="comment"># i == j == k</span></span><br><span class="line">                        ans += count[x] * (count[x] - <span class="number">1</span>) * (count[x] - <span class="number">2</span>) / <span class="number">6</span></span><br><span class="line"></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(N^2)*，其中 *N</em> 是 <code>A</code> 的长度。</p></li><li><p>空间复杂度： <em>O(N)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组A，以及一个整数target作为目标值，返回满足 i &amp;lt; j &amp;lt; k 且A[i] + A[j] + A[k] == target的元组i, j, k的数量。&lt;/p&gt;
&lt;p&gt;由于结果会非常大，请返回 结果除以 10^9 + 7 的余数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>15. 三数之和</title>
    <link href="http://yoursite.com/2020/10/22/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/10/22/15. 三数之和/</id>
    <published>2020-10-22T05:52:12.000Z</published>
    <updated>2020-10-22T06:17:07.364Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><a id="more"></a><p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><pre><code>给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="84ef7c67-225f-451f-9296-c5dd0a04e6f0">15. 三数之和.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题与 <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a> 类似，是非常经典的面试题，但是做法不尽相同。</p><h2 id="方法一：排序-双指针"><a href="#方法一：排序-双指针" class="headerlink" title="方法一：排序 + 双指针"></a>方法一：排序 + 双指针</h2><p>题目中要求找到所有「不重复」且和为 <em>0</em> 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 <em>0</em>，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 0, 0, 0, ..., 0, 0, 0]</span><br></pre></td></tr></table></figure><p>任意一个三元组的和都为 <em>0</em>。如果我们直接使用三重循环枚举三元组，会得到 <em>O(N^3)</em> 个满足题目要求的三元组（其中 <em>N</em> 是数组的长度）时间复杂度至少为 <em>O(N^3)</em>。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p><p>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p><ul><li><p>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</p></li><li><p>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</p></li></ul><p>也就是说，我们枚举的三元组 <em>(a, b, c)</em> 满足 a&lt;=b&lt;=c ，保证了只有 <em>(a, b, c)</em> 这个顺序会被枚举到，而 <em>(b, a, c)*、</em>(c, b, a)* 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p><p>同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 2, 2, 3]</span><br><span class="line"> ^  ^  ^</span><br></pre></td></tr></table></figure><p>我们使用三重循环枚举到的第一个三元组为 <em>(0, 1, 2)</em>，如果第三重循环继续枚举下一个元素，那么仍然是三元组 <em>(0, 1, 2)</em>，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 <em>3</em>，枚举三元组 <em>(0, 1, 3)</em>。</p><p>下面给出了改进的方法的伪代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">for first = 0 .. n-1</span><br><span class="line">    // 只有和上一次枚举的元素不相同，我们才会进行枚举</span><br><span class="line">    if first == 0 or nums[first] != nums[first-1] then</span><br><span class="line">        for second = first+1 .. n-1</span><br><span class="line">            if second == first+1 or nums[second] != nums[second-1] then</span><br><span class="line">                for third = second+1 .. n-1</span><br><span class="line">                    if third == second+1 or nums[third] != nums[third-1] then</span><br><span class="line">                        // 判断是否有 a+b+c==0</span><br><span class="line">                        check(first, second, third)</span><br></pre></td></tr></table></figure><p>这种方法的时间复杂度仍然为 <em>O(N^3)*，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 *a</em> 和 <em>b</em>，那么只有唯一的 <em>c</em> 满足 <em>a+b+c=0*。当第二重循环往后枚举一个元素 *b’</em> 时，由于 <em>b’ &gt; b*，那么满足 *a+b’+c’=0</em> 的 <em>c’</em> 一定有 <em>c’ &lt; c*，即 *c’</em> 在数组中一定出现在 <em>c</em> 的左侧。也就是说，我们可以从小到大枚举 <em>b</em>，<strong>同时</strong>从大到小枚举 <em>c</em>，即<strong>第二重循环和第三重循环实际上是并列的关系</strong>。</p><p>有了这样的发现，我们就可以保持第二重循环不变，而将<strong>第三重循环变成一个从数组最右端开始向左移动的指针</strong>，从而得到下面的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">for first = 0 .. n-1</span><br><span class="line">    if first == 0 or nums[first] != nums[first-1] then</span><br><span class="line">        // 第三重循环对应的指针</span><br><span class="line">        third = n-1</span><br><span class="line">        for second = first+1 .. n-1</span><br><span class="line">            if second == first+1 or nums[second] != nums[second-1] then</span><br><span class="line">                // 向左移动指针，直到 a+b+c 不大于 0</span><br><span class="line">                while nums[first]+nums[second]+nums[third] &gt; 0</span><br><span class="line">                    third = third-1</span><br><span class="line">                // 判断是否有 a+b+c==0</span><br><span class="line">                check(first, second, third)</span><br></pre></td></tr></table></figure><p>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 <em>O(N^2)</em> 减少至 <em>O(N)*。为什么是 *O(N)</em> 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 <em>b</em>），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 <em>O(N)</em>，<strong>均摊下来</strong>，每次也向左移动一个位置，因此时间复杂度为 <em>O(N)</em>。</p><p>注意到我们的伪代码中还有第一重循环，时间复杂度为 <em>O(N)</em>，因此枚举的总时间复杂度为 <em>O(N^2)</em>。由于排序的时间复杂度为 O(NlogN) ，在渐进意义下小于前者，因此算法的总时间复杂度为 <em>O(N^2)</em>。</p><p>上述的伪代码中还有一些细节需要补充，例如我们需要保持左指针一直在右指针的左侧（即满足 b&lt;=c，具体可以参考下面的代码，均给出了详细的注释。</p><details>    <summary>排序 + 双指针C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            <span class="keyword">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">// 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">                <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                    --third;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                    ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序 + 双指针Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = list()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            third = n - <span class="number">1</span></span><br><span class="line">            target = -nums[first]</span><br><span class="line">            <span class="comment"># 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> range(first + <span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> second &gt; first + <span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> second &lt; third <span class="keyword">and</span> nums[second] + nums[third] &gt; target:</span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment"># 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> second == third:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[second] + nums[third] == target:</span><br><span class="line">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>排序 + 双指针Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            <span class="keyword">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">// 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">                <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                    --third;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[first]);</span><br><span class="line">                    list.add(nums[second]);</span><br><span class="line">                    list.add(nums[third]);</span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>排序 + 双指针Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">        third := n - <span class="number">1</span></span><br><span class="line">        target := <span class="number">-1</span> * nums[first]</span><br><span class="line">        <span class="comment">// 枚举 b</span></span><br><span class="line">        <span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123;</span><br><span class="line">                third--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">            <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> second == third &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nums[second] + nums[third] == target &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="keyword">int</span>&#123;nums[first], nums[second], nums[third]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N^2)*，其中 *N</em> 是数组 nums  的长度。</p></li><li><p>空间复杂度：O(logN) 。我们忽略存储答案的空间，额外的排序的空间复杂度为O(logN)。然而我们修改了输入的数组 nums ，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 <em>O(N)</em>。</p></li></ul><h2 id="方法二：排序-双指针-哈希表"><a href="#方法二：排序-双指针-哈希表" class="headerlink" title="方法二：排序+双指针+哈希表"></a>方法二：排序+双指针+哈希表</h2><details>    <summary>排序 + 双指针+哈希表Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> HashSet&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;nums.length-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; i &amp;&amp; right &gt; i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[i] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[i] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    temp.add(nums[left]);</span><br><span class="line">                    temp.add(nums[i]);</span><br><span class="line">                    temp.add(nums[right]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line"></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : res) &#123;</span><br><span class="line">            ans.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>93. 复原IP地址</title>
    <link href="http://yoursite.com/2020/10/13/93.%20%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2020/10/13/93. 复原IP地址/</id>
    <published>2020-10-13T02:52:12.000Z</published>
    <updated>2020-10-15T02:52:05.381Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><a id="more"></a><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1" target="_blank" rel="noopener">192.168@1.1</a>“ 是 无效的 IP 地址。</p><p>示例 1：</p><pre><code>输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;]</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;1111&quot;输出：[&quot;1.1.1.1&quot;]</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;010010&quot;输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</code></pre><p>示例 5：</p><pre><code>输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code></pre><p>提示：</p><pre><code>0 &lt;= s.length &lt;= 3000s 仅由数字组成</code></pre><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法事实上就是在一个树形问题上做深度优先遍历，因此 <strong>首先需要把问题转换为树形问题</strong>。这里请大家一定要拿起纸和笔，模拟一下如何通过指定的字符串 <code>s</code> 生成 IP 地址的过程，把树形图画出来（这一点很重要）。</p><p>下面这张图我没有画完（如果画完，枝叶太多），请读者尽量不看我画的这张图，自己动手尝试一下这个问题的树形图应该怎么画。</p><p>在画树形图的过程中，你一定会发现有些枝叶是没有必要的，把没有必要的枝叶剪去的操作就是剪枝，在代码中一般通过 <code>break</code> 或者 <code>contine</code> 和 <code>return</code> （表示递归终止）实现。</p><p><a href="https://pic.leetcode-cn.com/b581bdde1cef982f0af3182af17fc3c41960c76a7445af0dcfd445c89b4c2eaa-%E3%80%8C%E5%8A%9B%E6%89%A3%E3%80%8D%E7%AC%AC%2093%20%E9%A2%98%EF%BC%9A%E5%A4%8D%E5%8E%9F%20IP%20%E5%9C%B0%E5%9D%80-1.png" target="_blank" rel="noopener">「力扣」第 93 题：复原 IP 地址-1.png</a></p><p>分析剪枝条件（下面只写出一些我想到的要点，有些点能想到，但是编码很复杂，我就没有写了）：</p><p>1、一开始，字符串的长度小于 4 或者大于 12 ，一定不能拼凑出合法的 ip 地址（这一点可以一般化到中间结点的判断中，以产生剪枝行为）；</p><p>2、每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支；</p><p>根据截取出来的字符串判断是否是合理的 ip 段，这里写法比较多，可以先截取，再转换成 int ，再判断。我采用的做法是先转成 int，是合法的 ip 段数值以后，再截取。</p><p>3、由于 ip 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一；</p><p>4、每一个结点表示了求解这个问题的不同阶段，需要的状态变量有：</p><ul><li><code>splitTimes</code>：已经分割出多少个 ip 段；</li><li><code>begin</code>：截取 ip 段的起始位置；</li><li><code>path</code>：记录从根结点到叶子结点的一个路径（回溯算法常规变量，是一个栈）；</li><li><code>res</code>：记录结果集的变量，常规变量。</li></ul><blockquote><p>总结：这个问题思想不难，但是细节比较繁琐，什么时候递归终止，如何手动截取字符串，再转换成 int 类型，还有如何在中间结点发现可以剪枝，这些细节需要在编码的时候考虑清楚。</p></blockquote><p>有一些编码细节写在代码注释中，供大家参考，可能还有漏掉的地方，欢迎大家给出意见。我给出的代码执行时间也不是很好。</p><p><strong>参考代码 1</strong>： 这一版代码比较慢，原因有可能是剪枝判断太多了，也有可能是 <code>ipSegment + &quot;&quot;</code> 这个操作耗时。</p><details>    <summary>回溯算法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 如果长度不够，不搜索</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">4</span> || len &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> splitTimes = <span class="number">0</span>;</span><br><span class="line">        dfs(s, len, splitTimes, <span class="number">0</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断 s 的子区间 [left, right] 是否能够成为一个 ip 段</span></span><br><span class="line"><span class="comment">     * 判断的同时顺便把类型转了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judgeIfIpSegment</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大于 1 位的时候，不能以 0 开头</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">1</span> &amp;&amp; s.charAt(left) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转成 int 类型</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> split, <span class="keyword">int</span> begin, Deque&lt;String&gt; path, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (split == <span class="number">4</span>) &#123;</span><br><span class="line">                res.add(String.join(<span class="string">"."</span>, path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看到剩下的不够了，就退出（剪枝），len - begin 表示剩余的还未分割的字符串的位数</span></span><br><span class="line">        <span class="keyword">if</span> (len - begin &lt; (<span class="number">4</span> - split) || len - begin &gt; <span class="number">3</span> * (<span class="number">4</span> - split)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin + i &gt;= len) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ipSegment = judgeIfIpSegment(s, begin, begin + i);</span><br><span class="line">            <span class="keyword">if</span> (ipSegment != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 在判断是 ip 段的情况下，才去做截取</span></span><br><span class="line">                path.addLast(ipSegment + <span class="string">""</span>);</span><br><span class="line">                dfs(s, len, split + <span class="number">1</span>, begin + i + <span class="number">1</span>, path, res);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>回溯算法Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        size = len(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">4</span> <span class="keyword">or</span> size &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        path = []</span><br><span class="line">        res = []</span><br><span class="line">        self.__dfs(s, size, <span class="number">0</span>, <span class="number">0</span>, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span><span class="params">(self, s, size, split_times, begin, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> begin == size:</span><br><span class="line">            <span class="keyword">if</span> split_times == <span class="number">4</span>:</span><br><span class="line">                res.append(<span class="string">'.'</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> size - begin &lt; (<span class="number">4</span> - split_times) <span class="keyword">or</span> size - begin &gt; <span class="number">3</span> * (<span class="number">4</span> - split_times):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> begin + i &gt;= size:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            ip_segment = self.__judge_if_ip_segment(s, begin, begin + i)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ip_segment != <span class="number">-1</span>:</span><br><span class="line">                path.append(str(ip_segment))</span><br><span class="line">                self.__dfs(s, size, split_times + <span class="number">1</span>, begin + i + <span class="number">1</span>, path, res)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__judge_if_ip_segment</span><span class="params">(self, s, left, right)</span>:</span></span><br><span class="line">        size = right - left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> size &gt; <span class="number">1</span> <span class="keyword">and</span> s[left] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        res = int(s[left:right + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res &gt; <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><p><strong>参考代码 2</strong>：（与参考代码 1 不同之处只在于剪枝少判断，而且也是先判断截取的 ip 段是否合法，然后用截取函数截取字符串，执行结果上会快一些）</p><details>    <summary>回溯算法Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">12</span> || len &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        dfs(s, len, <span class="number">0</span>, <span class="number">4</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要一个变量记录剩余多少段还没被分割</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> begin, <span class="keyword">int</span> residue, Deque&lt;String&gt; path, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (residue == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(String.join(<span class="string">"."</span>, path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; begin + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (residue * <span class="number">3</span> &lt; len - i) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (judgeIpSegment(s, begin, i)) &#123;</span><br><span class="line">                String currentIpSegment = s.substring(begin, i + <span class="number">1</span>);</span><br><span class="line">                path.addLast(currentIpSegment);</span><br><span class="line"></span><br><span class="line">                dfs(s, len, i + <span class="number">1</span>, residue - <span class="number">1</span>, path, res);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgeIpSegment</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">1</span> &amp;&amp; s.charAt(left) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + s.charAt(left) - <span class="string">'0'</span>;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">0</span> &amp;&amp; res &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：因为这个问题限制在有效 IP 段内，因此需要截取和检查的次数有上限，分析清楚这个复杂度在我的能力范围之外（欢迎大家指导）。很多回溯问题的复杂度分析都比较 “复杂”，所以我选择暂时搁浅。</li><li>空间复杂度：<em>O(h)</em>，也是由于这个问题限制在有效 IP 段内，树最多 <code>4</code> 层，保存的结果集也是有限个，基于一般性，需要记录递归过程的信息，这个空间大小是递归树的高度 <em>h</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>71. 简化路径</title>
    <link href="http://yoursite.com/2020/10/13/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/10/13/71. 简化路径/</id>
    <published>2020-10-13T02:51:12.000Z</published>
    <updated>2020-10-13T02:52:03.306Z</updated>
    
    <content type="html"><![CDATA[<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p><a id="more"></a><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p><p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p><p>示例 1：</p><pre><code>输入：&quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。</code></pre><p>示例 2：</p><pre><code>输入：&quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</code></pre><p>示例 3：</p><pre><code>输入：&quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</code></pre><p>示例 4：</p><pre><code>输入：&quot;/a/./b/../../c/&quot;输出：&quot;/c&quot;</code></pre><p>示例 5：</p><pre><code>输入：&quot;/a/../../b/../c//.//&quot;输出：&quot;/c&quot;</code></pre><p>示例 6：</p><pre><code>输入：&quot;/a//b////c/d//././/..&quot;输出：&quot;/a/b/c&quot;</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题使用了三种容器来求解绝对路径</p><ul><li><p>首先定义栈用来存储<strong>路径信息</strong>，定义字符数组 <code>str</code> 来<strong>分隔字符串</strong></p></li><li><p>依次遍历字符数组内容，这里使用<strong>增强型</strong> <code>for</code> 循环，如果是 <code>“..”</code> 还要<strong>再判断是否为空</strong>才能弹出栈,这里是从根目录向上一级</p></li><li><p>如果不为空也不为 <code>“.”</code> 这说明当前元素<strong>是路径信息</strong>，入栈即可</p></li><li><p>最后遍历完之后，先判断栈中<strong>是否有元素</strong>，没有则返回 <code>“/”</code></p></li><li><p>如果有元素，则使用 <code>StringBuilder</code> 来存放<strong>可变字符串</strong>，最后返回 <code>ans</code> 即可。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 首先将字符串以 “/” 分隔存储到新的字符数组 str 中</span></span><br><span class="line">        String[] str = path.split(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : str) &#123;</span><br><span class="line">            <span class="comment">// 如果访问到的是 “..” 则说明要返回上一级,要将当前元素出栈</span></span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">".."</span>) ) &#123;</span><br><span class="line">                <span class="comment">// 还需判断栈是否为空,否则会报错</span></span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty() ) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;                </span><br><span class="line">            <span class="comment">// 如果数组非空并且当前元素不是 “.” 说明当前元素是路径信息，要入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.equals(<span class="string">""</span>) &amp;&amp; !s.equals(<span class="string">"."</span>)) &#123;</span><br><span class="line">                stack.push(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈内没有元素说明没有路径信息，返回 “/” 即可</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里用到 StringBuilder 操作字符串，效率高</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 这里从栈底开始拿元素</span></span><br><span class="line">            ans.append( <span class="string">"/"</span> + stack.get(i) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 以 / 分割路径并存储到 str 字符串数组中</span></span><br><span class="line">        String[] str = path.split(<span class="string">"/"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 除去每个字符串两边的空格</span></span><br><span class="line">            String cur = str[i].trim();</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="keyword">null</span> || cur.length() == <span class="number">0</span> || cur.equals(<span class="string">"."</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">                <span class="comment">// 必须要判断栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 巧妙的反向构建结果</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ans = <span class="string">"/"</span> + stack.pop() + ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后还要判断是否为空</span></span><br><span class="line">        <span class="keyword">return</span> ans.length() == <span class="number">0</span> ? <span class="string">"/"</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>151. 翻转字符串里的单词</title>
    <link href="http://yoursite.com/2020/10/12/151.%20%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2020/10/12/151. 翻转字符串里的单词/</id>
    <published>2020-10-12T08:35:12.000Z</published>
    <updated>2020-10-12T09:13:12.441Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，逐个翻转字符串中的每个单词。</p><a id="more"></a><p>说明：</p><pre><code>无空格字符构成一个单词 。输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><p>示例 1：</p><pre><code>输入：&quot;the sky is blue&quot;输出：&quot;blue is sky the&quot;</code></pre><p>示例 2：</p><pre><code>输入：&quot;  hello world!  &quot;输出：&quot;world! hello&quot;解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</code></pre><p>示例 3：</p><pre><code>输入：&quot;a good   example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;  Bob    Loves  Alice   &quot;输出：&quot;Alice Loves Bob&quot;</code></pre><p>示例 5：</p><pre><code>输入：s = &quot;Alice does not even like bob&quot;输出：&quot;bob like even not does Alice&quot;</code></pre><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 104s 包含英文大小写字母、数字和空格 &apos; &apos;s 中 至少存在一个 单词</code></pre><p>进阶：</p><p>请尝试使用 O(1) 额外空间复杂度的原地解法。</p><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="ce25c066-61cc-4629-aff8-1fccdb42816d">151. 翻转字符串里的单词.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：使用语言特性"><a href="#方法一：使用语言特性" class="headerlink" title="方法一：使用语言特性"></a>方法一：使用语言特性</h2><p><strong>思路和算法</strong></p><p>很多语言对字符串提供了 <code>split</code>（拆分），<code>reverse</code>（翻转）和 <code>join</code>（连接）等方法，因此我们可以简单的调用内置的 API 完成操作：</p><ol><li>使用 <code>split</code> 将字符串按空格分割成字符串数组；</li><li>使用 <code>reverse</code> 将字符串数组进行反转；</li><li>使用 <code>join</code> 方法将字符串数组拼成一个字符串。</li></ol><p><a href="https://pic.leetcode-cn.com/Figures/151/fun2.png" target="_blank" rel="noopener">fig</a></p><details>    <summary>使用语言特性Python3</summary><figure class="highlight python"><figcaption><span>[solution1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(reversed(s.split()))</span><br></pre></td></tr></table></figure></details><details>    <summary>使用语言特性Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 除去开头和末尾的空白字符</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="comment">// 正则匹配连续的空白字符作为分隔符分割</span></span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">"\\s+"</span>));</span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">" "</span>, wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>使用语言特性JavaScript</summary><figure class="highlight javascript"><figcaption><span>[solution1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="regexp">/\s+/</span>).reverse().join(<span class="string">' '</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)</em>，其中 N 为输入字符串的长度。</p></li><li><p>空间复杂度：<em>O(N)</em>，用来存储字符串分割之后的结果。</p></li></ul><h2 id="方法二：自行编写对应的函数"><a href="#方法二：自行编写对应的函数" class="headerlink" title="方法二：自行编写对应的函数"></a>方法二：自行编写对应的函数</h2><p><strong>思路和算法</strong></p><p>我们也可以不使用语言中的 API，而是自己编写对应的函数。在不同语言中，这些函数实现是不一样的，主要的差别是有些语言的字符串不可变（如 Java 和 Python)，有些语言的字符串可变（如 C++)。</p><p>对于字符串不可变的语言，首先得把字符串转化成其他可变的数据结构，同时还需要在转化的过程中去除空格。</p><p><a href="https://pic.leetcode-cn.com/Figures/151/reverse_whole2.png" target="_blank" rel="noopener">fig</a></p><p>对于字符串可变的语言，就不需要再额外开辟空间了，直接在字符串上原地实现。在这种情况下，反转字符和去除空格可以一起完成。</p><p><a href="https://pic.leetcode-cn.com/Figures/151/mutable2.png" target="_blank" rel="noopener">fig</a></p><details>    <summary>自行编写对应的函数Python3</summary><figure class="highlight python"><figcaption><span>[solution2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trim_spaces</span><span class="params">(self, s: str)</span> -&gt; list:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> s[left] == <span class="string">' '</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> s[right] == <span class="string">' '</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将字符串间多余的空白字符去除</span></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != <span class="string">' '</span>:</span><br><span class="line">                output.append(s[left])</span><br><span class="line">            <span class="keyword">elif</span> output[<span class="number">-1</span>] != <span class="string">' '</span>:</span><br><span class="line">                output.append(s[left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, l: list, left: int, right: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            l[left], l[right] = l[right], l[left]</span><br><span class="line">            left, right = left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_each_word</span><span class="params">(self, l: list)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(l)</span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> start &lt; n:</span><br><span class="line">            <span class="comment"># 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> end &lt; n <span class="keyword">and</span> l[end] != <span class="string">' '</span>:</span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 翻转单词</span></span><br><span class="line">            self.reverse(l, start, end - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        l = self.trim_spaces(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 翻转字符串</span></span><br><span class="line">        self.reverse(l, <span class="number">0</span>, len(l) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 翻转每个单词</span></span><br><span class="line">        self.reverse_each_word(l)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(l)</span><br></pre></td></tr></table></figure></details><details>    <summary>自行编写对应的函数Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">trimSpaces</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">' '</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">' '</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">' '</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">' '</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>自行编写对应的函数C++</summary><figure class="highlight c++"><figcaption><span>[solution2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; ++start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[start] != <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="comment">// 填一个空白字符然后将idx移动到下一个单词的开头位置</span></span><br><span class="line">                <span class="keyword">if</span> (idx != <span class="number">0</span>) s[idx++] = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环遍历至单词的末尾</span></span><br><span class="line">                <span class="keyword">int</span> end = start;</span><br><span class="line">                <span class="keyword">while</span> (end &lt; n &amp;&amp; s[end] != <span class="string">' '</span>) s[idx++] = s[end++];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反转整个单词</span></span><br><span class="line">                reverse(s.begin() + idx - (end - start), s.begin() + idx);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.erase(s.begin() + idx, s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)</em>，其中 N 为输入字符串的长度。</p></li><li><p>空间复杂度：<code>Java</code> 和 <code>Python</code> 的方法需要 <em>O(N)</em> 的空间来存储字符串，而 <code>C++</code> 方法只需要 <code>O(1)</code> 的额外空间来存放若干变量。</p></li></ul><h2 id="方法三：双端队列"><a href="#方法三：双端队列" class="headerlink" title="方法三：双端队列"></a>方法三：双端队列</h2><p><strong>思路和算法</strong></p><p>由于双端队列支持从队列头部插入的方法，因此我们可以沿着字符串一个一个单词处理，然后将单词压入队列的头部，再将队列转成字符串即可。</p><p><a href="https://pic.leetcode-cn.com/Figures/151/deque2.png" target="_blank" rel="noopener">fig</a></p><details>    <summary>双端队列Python3</summary><figure class="highlight python"><figcaption><span>[solution3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> s[left] == <span class="string">' '</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> s[right] == <span class="string">' '</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        d, word = collections.deque(), []</span><br><span class="line">        <span class="comment"># 将单词 push 到队列的头部</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == <span class="string">' '</span> <span class="keyword">and</span> word:</span><br><span class="line">                d.appendleft(<span class="string">''</span>.join(word))</span><br><span class="line">                word = []</span><br><span class="line">            <span class="keyword">elif</span> s[left] != <span class="string">' '</span>:</span><br><span class="line">                word.append(s[left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        d.appendleft(<span class="string">''</span>.join(word))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(d)</span><br></pre></td></tr></table></figure></details><details>    <summary>双端队列Java</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">' '</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">' '</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; d = <span class="keyword">new</span> ArrayDeque&lt;String&gt;();</span><br><span class="line">        StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line">            <span class="keyword">if</span> ((word.length() != <span class="number">0</span>) &amp;&amp; (c == <span class="string">' '</span>)) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.offerFirst(word.toString());</span><br><span class="line">                word.setLength(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">                word.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.offerFirst(word.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">" "</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>双端队列C++</summary><figure class="highlight c++"><figcaption><span>[solution3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">' '</span>) ++left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">' '</span>) --right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; d;</span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[left];</span><br><span class="line">            <span class="keyword">if</span> (word.size() &amp;&amp; c == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.push_front(move(word));</span><br><span class="line">                word = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">                word += c;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.push_front(move(word));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (!d.empty()) &#123;</span><br><span class="line">            ans += d.front();</span><br><span class="line">            d.pop_front();</span><br><span class="line">            <span class="keyword">if</span> (!d.empty()) ans += <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)</em>，其中 N 为输入字符串的长度。</p></li><li><p>空间复杂度：<em>O(N)*，双端队列存储单词需要 *O(N)</em> 的空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>415. 字符串相加</title>
    <link href="http://yoursite.com/2020/10/12/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2020/10/12/415. 字符串相加/</id>
    <published>2020-10-12T07:00:12.000Z</published>
    <updated>2020-10-12T07:18:34.336Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><a id="more"></a><p>提示：</p><pre><code>num1 和num2 的长度都小于 5100num1 和num2 都只包含数字 0-9num1 和num2 都不包含任何前导零你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</code></pre><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p><strong>思路与算法</strong></p><p>本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 <em>10</em>，则向高位进一位？因此我们只要将这个过程用代码写出来即可。</p><p><a href="https://assets.leetcode-cn.com/solution-static/415/1.png" target="_blank" rel="noopener">fig1</a></p><p>具体实现也不复杂，我们定义两个指针 <em>i</em> 和 <em>j</em> 分别指向 num1 和num2  的末尾，即最低位，同时定义一个变量add 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 <em>0</em>，等价于<strong>对位数较短的数字进行了补零操作</strong>，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码。</p><details>    <summary>模拟C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.push_back(<span class="string">'0'</span> + result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">            ans.append(result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="keyword">string</span>, num2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    add := <span class="number">0</span></span><br><span class="line">    ans := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>; i, j = i - <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            x = <span class="keyword">int</span>(num1[i] - <span class="string">'0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            y = <span class="keyword">int</span>(num2[j] - <span class="string">'0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result := x + y + add</span><br><span class="line">        ans = strconv.Itoa(result%<span class="number">10</span>) + ans</span><br><span class="line">        add = result / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addStrings = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = num1.length - <span class="number">1</span>, j = num2.length - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> result = x + y + add;</span><br><span class="line">        ans.push(result % <span class="number">10</span>);</span><br><span class="line">        add = <span class="built_in">Math</span>.floor(result / <span class="number">10</span>);</span><br><span class="line">        i -= <span class="number">1</span>;</span><br><span class="line">        j -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>模拟C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">addStrings</span><span class="params">(<span class="keyword">char</span>* num1, <span class="keyword">char</span>* num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">strlen</span>(num1) - <span class="number">1</span>, j = <span class="built_in">strlen</span>(num2) - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ans = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (fmax(i, j) + <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">        ans[len++] = <span class="string">'0'</span> + result % <span class="number">10</span>;</span><br><span class="line">        add = result / <span class="number">10</span>;</span><br><span class="line">        i--, j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">2</span> * i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = ans[i];</span><br><span class="line">        ans[i] = ans[len - i - <span class="number">1</span>], ans[len - i - <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[len++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(max(len1,len2)，其中len1=num1.length ，len2=num2.length 。竖式加法的次数取决于较大数的位数。</li><li>空间复杂度：<em>O(1)</em>。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer，故 Java 解法的空间复杂度为 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>43. 字符串相乘</title>
    <link href="http://yoursite.com/2020/10/12/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>http://yoursite.com/2020/10/12/43. 字符串相乘/</id>
    <published>2020-10-12T02:12:12.000Z</published>
    <updated>2020-10-12T07:25:57.066Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;</code></pre><p>示例 2:</p><pre><code>输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;</code></pre><p>说明：</p><pre><code>num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</code></pre><h2 id="方法一：普通竖式"><a href="#方法一：普通竖式" class="headerlink" title="方法一：普通竖式"></a>方法一：普通竖式</h2><p><strong>思路</strong></p><p>竖式运算思想，以 <code>num1</code> 为 <code>123</code>，<code>num2</code> 为 <code>456</code> 为例分析：</p><p><a href="https://pic.leetcode-cn.com/d24bf3174a878890e1273fbe35426ecdfa932c33efb464ed3602f4d149ed343a" target="_blank" rel="noopener">分析</a></p><p>遍历 <code>num2</code> 每一位与 <code>num1</code> 进行相乘，将每一步的结果进行累加。</p><p><strong>注意：</strong></p><ul><li><code>num2</code> 除了第一位的其他位与 <code>num1</code> 运算的结果需要 <strong>补0</strong></li><li>计算字符串数字累加其实就是 <a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></li></ul><p><strong>实现</strong></p><details>    <summary>普通竖式Java</summary><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算形式</span></span><br><span class="line"><span class="comment">    *    num1</span></span><br><span class="line"><span class="comment">    *  x num2</span></span><br><span class="line"><span class="comment">    *  ------</span></span><br><span class="line"><span class="comment">    *  result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存计算结果</span></span><br><span class="line">        String res = <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// num2 逐位与 num1 相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 保存 num2 第i位数字与 num1 相乘的结果</span></span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 补 0 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                temp.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// num2 的第 i 位数字 n2 与 num1 相乘</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num1.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> n1 = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = (n1 * n2 + carry) % <span class="number">10</span>;</span><br><span class="line">                temp.append(product);</span><br><span class="line">                carry = (n1 * n2 + carry) / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前结果与新计算的结果求和作为新的结果</span></span><br><span class="line">            res = addStrings(res, temp.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对两个字符串数字进行相加，返回字符串形式的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>;</span><br><span class="line">             i--, j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (x + y + carry) % <span class="number">10</span>;</span><br><span class="line">            builder.append(sum);</span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O</em>(<em>M N</em>)。<em>M,N</em> 分别为 <code>num1</code> 和 <code>num2</code> 的长度。</li><li>空间复杂度：<em>O</em>(M+N)。用于存储计算结果。</li></ul><h2 id="方法二：优化竖式"><a href="#方法二：优化竖式" class="headerlink" title="方法二：优化竖式"></a>方法二：优化竖式</h2><p>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p><ul><li>乘数 <code>num1</code> 位数为 <em>M</em>，被乘数 <code>num2</code> 位数为 <em>N</em>， <code>num1 x num2</code> 结果 <code>res</code> 最大总位数为 <strong>M+N</strong></li><li><code>num1[i] x num2[j]</code> 的结果为 <code>tmp</code>(位数为两位，”0x”,”xy”的形式)，其第一位位于 <code>res[i+j]</code>，第二位位于 <code>res[i+j+1]</code>。</li></ul><p>结合下图更容易理解</p><p><a href="https://pic.leetcode-cn.com/171cad48cd0c14f565f2a0e5aa5ccb130e4562906ee10a84289f12e4460fe164-image.png" target="_blank" rel="noopener">图</a></p><details>    <summary>优化竖式Java</summary><figure class="highlight java"><figcaption><span>[-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            result.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O</em>(<em>M N</em>)<em>。</em>M,N* 分别为 <code>num1</code> 和 <code>num2</code> 的长度。</li><li>空间复杂度：<em>O</em>(M+N)*。用于存储计算结果。</li></ul><h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><table><thead><tr><th align="left">算法</th><th align="left">提交结果</th><th align="left">执行用时</th><th align="left">内存消耗</th><th align="left">语言</th></tr></thead><tbody><tr><td align="left">普通竖式</td><td align="left">通过</td><td align="left">48 ms</td><td align="left">43.8 MB</td><td align="left">Java</td></tr><tr><td align="left">优化竖式</td><td align="left">通过</td><td align="left">4 ms</td><td align="left">36.6 MB</td><td align="left">Java</td></tr></tbody></table><p><strong>虽然两者时间复杂度和空间复杂度相同，但优化竖式执行速度提高很明显，普通竖式耗时主要还是对每步计算的字符串相加这个过程。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典.面试题08.08.有重复字符串的排列组合</title>
    <link href="http://yoursite.com/2020/10/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.%E9%9D%A2%E8%AF%95%E9%A2%9808.08.%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2020/10/10/程序员面试金典.面试题08.08.有重复字符串的排列组合/</id>
    <published>2020-10-10T09:17:12.000Z</published>
    <updated>2020-10-10T09:37:37.606Z</updated>
    
    <content type="html"><![CDATA[<p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p><a id="more"></a><p>示例1:</p><pre><code>输入：S = &quot;qqe&quot;输出：[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</code></pre><p>示例2:</p><pre><code>输入：S = &quot;ab&quot;输出：[&quot;ab&quot;, &quot;ba&quot;]</code></pre><p>提示:</p><pre><code>字符都是英文字母。字符串长度在[1, 9]之间。</code></pre><p>这道题和<strong>剑指 offer38.字符串的排列</strong>完全一致，但我在重写的过程中还是出错了，有几个小细节需要注意一下。</p><p>首先是返回字符串数组的定义方法一开始没有写对<code>return res.toArray(new String[res.size()]);</code></p><p>然后在近乎于默写的写完了答案后发现咦？居然出错了</p><details>    <summary>第一版错误代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    char[] c;</span><br><span class="line">    public String[] permutation(String S) &#123;</span><br><span class="line">        c = S.toCharArray();</span><br><span class="line">        dfs(0);</span><br><span class="line">        return res.toArray(new String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int x) &#123;</span><br><span class="line">        if (x == c.length - 1) &#123;</span><br><span class="line">            res.add(String.valueOf(c));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">            if (set.contains(c[x])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c[x]);</span><br><span class="line">            swap(i, x);</span><br><span class="line">            dfs(x+1);</span><br><span class="line">            swap(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int i, int j) &#123;</span><br><span class="line">        char tmp = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><pre><code>测试用例:&quot;qqe&quot;测试结果:[&quot;qqe&quot;,&quot;qeq&quot;,&quot;qqe&quot;,&quot;qeq&quot;,&quot;eqq&quot;,&quot;eqq&quot;]期望结果:[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</code></pre><p>这个一看就是HashSet出了问题，发现是HashSet定义在了循环内。所以没有起到剪枝的作用<br>挪到了循环外再执行</p><pre><code>测试用例:&quot;qqe&quot;测试结果:[&quot;qqe&quot;]期望结果:[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</code></pre><p>检查了半天才发现是这句出错了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (set.contains(c[x])) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次塞进HashSet的应该是c[i]而非c[x]</p><p>改了下又报错了：</p><pre><code>测试用例:&quot;OSS&quot;测试结果:[&quot;OSS&quot;,&quot;SOS&quot;,&quot;SSO&quot;,&quot;SSO&quot;,&quot;SOS&quot;]期望结果:[&quot;OSS&quot;,&quot;SOS&quot;,&quot;SSO&quot;]</code></pre><p>嗨呀，原来是光改了判断的逻辑，没改<code>set.add(c[x]);</code>这句，都改了下就ok了</p><details>    <summary>正确代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    char[] c;</span><br><span class="line">    public String[] permutation(String S) &#123;</span><br><span class="line">        c = S.toCharArray();</span><br><span class="line">        dfs(0);</span><br><span class="line">        return res.toArray(new String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int x) &#123;</span><br><span class="line">        if (x == c.length - 1) &#123;</span><br><span class="line">            res.add(String.valueOf(c));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (int i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            if (set.contains(c[i])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x);</span><br><span class="line">            dfs(x+1);</span><br><span class="line">            swap(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int i, int j) &#123;</span><br><span class="line">        char tmp = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>所以即使刚刚做过一遍，如果没有充分理解如何使用HashSet剪枝和如何利用回溯的方法来全排列还是很难一次性解决的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Cracking the Coding Interview" scheme="http://yoursite.com/tags/Cracking-the-Coding-Interview/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典.面试题08.07.无重复字符串的排列组合</title>
    <link href="http://yoursite.com/2020/10/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.%E9%9D%A2%E8%AF%95%E9%A2%9808.07.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2020/10/10/程序员面试金典.面试题08.07.无重复字符串的排列组合/</id>
    <published>2020-10-10T08:40:12.000Z</published>
    <updated>2020-10-10T09:19:43.587Z</updated>
    
    <content type="html"><![CDATA[<p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p><a id="more"></a><p>示例1:</p><pre><code>输入：S = &quot;qwe&quot;输出：[&quot;qwe&quot;, &quot;qew&quot;, &quot;wqe&quot;, &quot;weq&quot;, &quot;ewq&quot;, &quot;eqw&quot;]</code></pre><p>示例2:</p><pre><code>输入：S = &quot;ab&quot;输出：[&quot;ab&quot;, &quot;ba&quot;]</code></pre><p>提示:</p><pre><code>字符都是英文字母。字符串长度在[1, 9]之间。</code></pre><p><strong>此题是剑指 offer38.字符串的排列的简单版，因为字符串每个字符均不相同，所以可以去掉原来算法中的剪枝部分。</strong></p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p><strong>排列方案数量：</strong> 对于一个长度为 <em>n</em> 的字符串（假设字符互不重复），其排列共有 n<em>(n-1)</em>(n-2)<em>…</em>2*1种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 <em>1</em> 位字符（ <em>n</em> 种情况）、再固定第 <em>2</em> 位字符（ <em>n-1</em> 种情况）、… 、最后固定第 <em>n</em> 位字符（ <em>1</em> 种情况）。</p><p><a href="https://pic.leetcode-cn.com/dc4659dbda6d54f50a8c897647fb7c52e2b8200e741c4d6e25306dfe51f93bb6-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><a href="https://pic.leetcode-cn.com/edbbe4db611791ca63e582e8b0c754261e8d7464edace38420ce3087eb96d9a5-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><h2 id="递归解析："><a href="#递归解析：" class="headerlink" title="递归解析："></a>递归解析：</h2><ol><li><strong>终止条件：</strong> 当 <em>x = len(c) - 1</em>  时，代表所有位已固定（最后一位只有 <em>1</em> 种情况），则将当前组合 <code>c</code> 转化为字符串并加入 <code>res</code>，并返回；</li><li><strong>递推参数：</strong> 当前固定位 <em>x</em> ；</li><li><strong>递推工作：</strong> 初始化一个 Set ，用于排除重复的字符；将第 <em>x</em> 位字符与 i∈[x,len(c)]  字符分别交换，并进入下层递归；<ol><li><strong>剪枝：</strong> 若 <em>c[i]</em> 在 Set​ 中，代表其是重复字符，因此“剪枝”；</li><li>将 <em>c[i]</em> 加入 Set​ ，以便之后遇到重复字符时剪枝；</li><li><strong>固定字符：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换，即固定 <em>c[i]</em> 为当前位字符；</li><li><strong>开启下层递归：</strong> 调用 <em>dfs(x + 1)</em> ，即开始固定第 <em>x + 1</em> 个字符；</li><li><strong>还原交换：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换（还原之前的交换）；</li></ol></li></ol><blockquote><p>下图中 <code>list</code> 对应文中的列表 <em>c</em> 。</p></blockquote><p> <a href="https://pic.leetcode-cn.com/03ef0cdb9aa977a26d66bac91c5aa4b8bcaf612c7a90d47afd5b2774d2e7c63f-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/23190801938902294ce223fdec6e2b14b57c0050341dd2cd9909e5388d4fa4b6-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> <a href="https://pic.leetcode-cn.com/5c71c17efa89114eee4d31678af45cefac82b0fad2a78c3887662463d10cfc83-Picture5.png" target="_blank" rel="noopener">Picture5.png</a> <a href="https://pic.leetcode-cn.com/a9d78bf7bdd7356d5c87392b731a98dc7012bb07c8a2bcde983abe7957bfde0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/546998a83a0832f3eed25ee69d1186ebcc23d238d0f45892feb02afd02bcaae9-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/405326ab9eccefe10fa18255704d0820ade5dd9b328a73b061634cfde8d059bd-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/59159c4b72187e1a4a52bebcd2b225a602badba483ef563114c9b1a7d694b0bf-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/d0e959953dcf93557e14cc037a0a1b62e60b3c0e3e38ca6b01f8acd06d4e5ea4-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/f34d4f405b2fb355fcad12d2c7818716b02ff78504e82be2343a1f7e75424eb3-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> <a href="https://pic.leetcode-cn.com/58700b824790d48fe907fa6740f53d747e01cdd6d9c4b01cd60cad0135278d99-Picture12.png" target="_blank" rel="noopener">Picture12.png</a> <a href="https://pic.leetcode-cn.com/83dabfa3d9c04601ee53989ba410069153e841403584739140a499e8c4f3d8e1-Picture13.png" target="_blank" rel="noopener">Picture13.png</a> <a href="https://pic.leetcode-cn.com/337e2cdad2bcf4fd801ae2d4e5ab8a1c3ef8f30008d2b0fadde6aad7c87fd640-Picture14.png" target="_blank" rel="noopener">Picture14.png</a> <a href="https://pic.leetcode-cn.com/ba18b921c78d58e1f1c6fa55a939cbd4a2a9652c31f6c3088219565b70dc3b19-Picture15.png" target="_blank" rel="noopener">Picture15.png</a> <a href="https://pic.leetcode-cn.com/25d13a660956672f9d3b3a1fa87ddac8194fda6e58d7c354799d6421c61fab61-Picture16.png" target="_blank" rel="noopener">Picture16.png</a> <a href="https://pic.leetcode-cn.com/3efd2969a04b993303229c7e58a635fe3d018a84086b36e486f458d8f87d54cf-Picture17.png" target="_blank" rel="noopener">Picture17.png</a> </p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N!)</em> ：</strong> <em>N</em> 为字符串 <code>s</code> 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为n<em>(n-1)</em>(n-2)<em>…<em>2</em>1 ，因此复杂度为 *O(N!)</em> 。</li><li><strong>空间复杂度 <em>O(N^2)</em> ：</strong> 全排列的递归深度为 <em>N</em> ，系统累计使用栈空间大小为 <em>O(N)</em> ；递归中辅助 Set 累计存储的字符数量最多为 <em>N + (N-1) + … + 2 + 1 = (N+1)N/2</em> ，即占用 <em>O(N^2)</em> 的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c)) <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment"># 重复，因此剪枝</span></span><br><span class="line">                dic.add(c[i])</span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复交换</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c)); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x); <span class="comment">// 交换，将 c[i] 固定在第 x 位 </span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x); <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Cracking the Coding Interview" scheme="http://yoursite.com/tags/Cracking-the-Coding-Interview/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer38.字符串的排列</title>
    <link href="http://yoursite.com/2020/10/10/%E5%89%91%E6%8C%87%20offer38.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/10/剑指 offer38.字符串的排列/</id>
    <published>2020-10-10T08:20:12.000Z</published>
    <updated>2020-10-10T08:45:01.402Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个字符串，打印出该字符串中字符的所有排列。</p><a id="more"></a><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><pre><code>输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></pre><p>限制：</p><pre><code>1 &lt;= s 的长度 &lt;= 8</code></pre><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><p><strong>排列方案数量：</strong> 对于一个长度为 <em>n</em> 的字符串（假设字符互不重复），其排列共有 n<em>(n-1)</em>(n-2)<em>…</em>2*1种方案。</p><p><strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 <em>1</em> 位字符（ <em>n</em> 种情况）、再固定第 <em>2</em> 位字符（ <em>n-1</em> 种情况）、… 、最后固定第 <em>n</em> 位字符（ <em>1</em> 种情况）。</p><p><a href="https://pic.leetcode-cn.com/dc4659dbda6d54f50a8c897647fb7c52e2b8200e741c4d6e25306dfe51f93bb6-Picture1.png" target="_blank" rel="noopener">Picture1.png</a></p><p><strong>重复方案与剪枝：</strong> 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p><p><a href="https://pic.leetcode-cn.com/edbbe4db611791ca63e582e8b0c754261e8d7464edace38420ce3087eb96d9a5-Picture2.png" target="_blank" rel="noopener">Picture2.png</a></p><h2 id="递归解析："><a href="#递归解析：" class="headerlink" title="递归解析："></a>递归解析：</h2><ol><li><strong>终止条件：</strong> 当 <em>x = len(c) - 1</em>  时，代表所有位已固定（最后一位只有 <em>1</em> 种情况），则将当前组合 <code>c</code> 转化为字符串并加入 <code>res</code>，并返回；</li><li><strong>递推参数：</strong> 当前固定位 <em>x</em> ；</li><li><strong>递推工作：</strong> 初始化一个 Set ，用于排除重复的字符；将第 <em>x</em> 位字符与 i∈[x,len(c)]  字符分别交换，并进入下层递归；<ol><li><strong>剪枝：</strong> 若 <em>c[i]</em> 在 Set​ 中，代表其是重复字符，因此“剪枝”；</li><li>将 <em>c[i]</em> 加入 Set​ ，以便之后遇到重复字符时剪枝；</li><li><strong>固定字符：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换，即固定 <em>c[i]</em> 为当前位字符；</li><li><strong>开启下层递归：</strong> 调用 <em>dfs(x + 1)</em> ，即开始固定第 <em>x + 1</em> 个字符；</li><li><strong>还原交换：</strong> 将字符 <em>c[i]</em> 和 <em>c[x]</em> 交换（还原之前的交换）；</li></ol></li></ol><blockquote><p>下图中 <code>list</code> 对应文中的列表 <em>c</em> 。</p></blockquote><p> <a href="https://pic.leetcode-cn.com/03ef0cdb9aa977a26d66bac91c5aa4b8bcaf612c7a90d47afd5b2774d2e7c63f-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/23190801938902294ce223fdec6e2b14b57c0050341dd2cd9909e5388d4fa4b6-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> <a href="https://pic.leetcode-cn.com/5c71c17efa89114eee4d31678af45cefac82b0fad2a78c3887662463d10cfc83-Picture5.png" target="_blank" rel="noopener">Picture5.png</a> <a href="https://pic.leetcode-cn.com/a9d78bf7bdd7356d5c87392b731a98dc7012bb07c8a2bcde983abe7957bfde0a-Picture6.png" target="_blank" rel="noopener">Picture6.png</a> <a href="https://pic.leetcode-cn.com/546998a83a0832f3eed25ee69d1186ebcc23d238d0f45892feb02afd02bcaae9-Picture7.png" target="_blank" rel="noopener">Picture7.png</a> <a href="https://pic.leetcode-cn.com/405326ab9eccefe10fa18255704d0820ade5dd9b328a73b061634cfde8d059bd-Picture8.png" target="_blank" rel="noopener">Picture8.png</a> <a href="https://pic.leetcode-cn.com/59159c4b72187e1a4a52bebcd2b225a602badba483ef563114c9b1a7d694b0bf-Picture9.png" target="_blank" rel="noopener">Picture9.png</a> <a href="https://pic.leetcode-cn.com/d0e959953dcf93557e14cc037a0a1b62e60b3c0e3e38ca6b01f8acd06d4e5ea4-Picture10.png" target="_blank" rel="noopener">Picture10.png</a> <a href="https://pic.leetcode-cn.com/f34d4f405b2fb355fcad12d2c7818716b02ff78504e82be2343a1f7e75424eb3-Picture11.png" target="_blank" rel="noopener">Picture11.png</a> <a href="https://pic.leetcode-cn.com/58700b824790d48fe907fa6740f53d747e01cdd6d9c4b01cd60cad0135278d99-Picture12.png" target="_blank" rel="noopener">Picture12.png</a> <a href="https://pic.leetcode-cn.com/83dabfa3d9c04601ee53989ba410069153e841403584739140a499e8c4f3d8e1-Picture13.png" target="_blank" rel="noopener">Picture13.png</a> <a href="https://pic.leetcode-cn.com/337e2cdad2bcf4fd801ae2d4e5ab8a1c3ef8f30008d2b0fadde6aad7c87fd640-Picture14.png" target="_blank" rel="noopener">Picture14.png</a> <a href="https://pic.leetcode-cn.com/ba18b921c78d58e1f1c6fa55a939cbd4a2a9652c31f6c3088219565b70dc3b19-Picture15.png" target="_blank" rel="noopener">Picture15.png</a> <a href="https://pic.leetcode-cn.com/25d13a660956672f9d3b3a1fa87ddac8194fda6e58d7c354799d6421c61fab61-Picture16.png" target="_blank" rel="noopener">Picture16.png</a> <a href="https://pic.leetcode-cn.com/3efd2969a04b993303229c7e58a635fe3d018a84086b36e486f458d8f87d54cf-Picture17.png" target="_blank" rel="noopener">Picture17.png</a> </p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(N!)</em> ：</strong> <em>N</em> 为字符串 <code>s</code> 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为n<em>(n-1)</em>(n-2)<em>…<em>2</em>1 ，因此复杂度为 *O(N!)</em> 。</li><li><strong>空间复杂度 <em>O(N^2)</em> ：</strong> 全排列的递归深度为 <em>N</em> ，系统累计使用栈空间大小为 <em>O(N)</em> ；递归中辅助 Set 累计存储的字符数量最多为 <em>N + (N-1) + … + 2 + 1 = (N+1)N/2</em> ，即占用 <em>O(N^2)</em> 的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c)) <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment"># 重复，因此剪枝</span></span><br><span class="line">                dic.add(c[i])</span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复交换</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c)); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i, x); <span class="comment">// 交换，将 c[i] 固定在第 x 位 </span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(i, x); <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个字符串，打印出该字符串中字符的所有排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Coding Interviews" scheme="http://yoursite.com/tags/Coding-Interviews/"/>
    
  </entry>
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="http://yoursite.com/2020/10/09/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://yoursite.com/2020/10/09/14. 最长公共前缀/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-09T09:20:41.843Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;</code></pre><p>示例 2:</p><pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p>说明:</p><pre><code>所有输入只包含小写字母 a-z 。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="8edae0a8-6480-4128-8244-9f10b83e7cf6">14 最长公共前缀.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：横向扫描"><a href="#方法一：横向扫描" class="headerlink" title="方法一：横向扫描"></a>方法一：横向扫描</h2><p>用 LCP(S1,…,Sn) 表示字符串S1,…,Sn 的最长公共前缀。</p><p>可以得到以下结论：</p><pre><code>LCP(S1,...,Sn)=LCP(LCP(LCP(S1,S2),S3),...Sn)</code></pre><p>基于该结论，可以得到一种查找字符串数组中的最长公共前缀的简单方法。依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。</p><details>    <summary>横向扫描Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (!prefix.size()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = min(str1.size(), str2.size());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1[index] == str2[index]) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substr(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        prefix, count = strs[<span class="number">0</span>], len(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count):</span><br><span class="line">            prefix = self.lcp(prefix, strs[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prefix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcp</span><span class="params">(self, str1, str2)</span>:</span></span><br><span class="line">        length, index = min(len(str1), len(str2)), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; length <span class="keyword">and</span> str1[index] == str2[index]:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str1[:index]</span><br></pre></td></tr></table></figure></details><details>    <summary>横向扫描Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    prefix := strs[<span class="number">0</span>]</span><br><span class="line">    count := <span class="built_in">len</span>(strs)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; count; i++ &#123;</span><br><span class="line">        prefix = lcp(prefix, strs[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prefix) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lcp</span><span class="params">(str1, str2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    length := min(<span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2))</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index &lt; length &amp;&amp; str1[index] == str2[index] &#123;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1[:index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul><h2 id="方法二：纵向扫描"><a href="#方法二：纵向扫描" class="headerlink" title="方法二：纵向扫描"></a>方法二：纵向扫描</h2><p>方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig2.png" target="_blank" rel="noopener">fig2</a></p><details>    <summary>纵向扫描Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].size() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        length, count = len(strs[<span class="number">0</span>]), len(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            c = strs[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">if</span> any(i == len(strs[j]) <span class="keyword">or</span> strs[j][i] != c <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, count)):</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>纵向扫描Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strs[<span class="number">0</span>]); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(strs[j]) || strs[j][i] != strs[<span class="number">0</span>][i] &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul><h2 id="方法三：分治"><a href="#方法三：分治" class="headerlink" title="方法三：分治"></a>方法三：分治</h2><p>注意到 LCP 的计算满足结合律，有以下结论：</p><pre><code>LCP(S1,...,Sn)=LCP(LCP(S1...SK) , LCP(SK+1...Sn))</code></pre><p>其中 LCP(S1,…,Sn) 是字符串 S1,…,Sn 的最长公共前缀，<em>1 &lt; k &lt; n</em>。</p><p>基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题LCP(Si…Sj) ，可以分解成两个子问题 LCP(si…Smid)与LCP(Smid+1…Sj)，其中 mid=(i+j)/2 。对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即为原问题的解。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig3.png" target="_blank" rel="noopener">fig3</a></p><details>    <summary>分治Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">            String lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">            String lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">commonPrefix</span><span class="params">(String lcpLeft, String lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = Math.min(lcpLeft.length(), lcpRight.length());       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft.charAt(i) != lcpRight.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">            <span class="built_in">string</span> lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpLeft, <span class="keyword">const</span> <span class="built_in">string</span>&amp; lcpRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = min(lcpLeft.size(), lcpRight.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lcpLeft[i] != lcpRight[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft.substr(<span class="number">0</span>, minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lcp</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> strs[start]</span><br><span class="line"></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            lcpLeft, lcpRight = lcp(start, mid), lcp(mid + <span class="number">1</span>, end)</span><br><span class="line">            minLength = min(len(lcpLeft), len(lcpRight))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(minLength):</span><br><span class="line">                <span class="keyword">if</span> lcpLeft[i] != lcpRight[i]:</span><br><span class="line">                    <span class="keyword">return</span> lcpLeft[:i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lcpLeft[:minLength]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> <span class="keyword">not</span> strs <span class="keyword">else</span> lcp(<span class="number">0</span>, len(strs) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> lcp <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">lcp</span> = <span class="title">func</span><span class="params">(start, end <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == end &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[start]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (start + end) / <span class="number">2</span></span><br><span class="line">        lcpLeft, lcpRight := lcp(start, mid), lcp(mid + <span class="number">1</span>, end)</span><br><span class="line">        minLength := min(<span class="built_in">len</span>(lcpLeft), <span class="built_in">len</span>(lcpRight))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; minLength; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> lcpLeft[i] != lcpRight[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> lcpLeft[:i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcpLeft[:minLength]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcp(<span class="number">0</span>, <span class="built_in">len</span>(strs)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。时间复杂度的递推式是 T(n)=2T(n/2)+O(m)，通过计算可得 <em>T(n)=O(mn)</em>。</p></li><li><p>空间复杂度：O(mlogn) ，其中 <em>m</em> 是字符串数组中的字符串的平均长度，<em>n</em> 是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为 logn，每层需要 <em>m</em> 的空间存储返回结果。</p></li></ul><h2 id="方法四：二分查找"><a href="#方法四：二分查找" class="headerlink" title="方法四：二分查找"></a>方法四：二分查找</h2><p>显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用 minLength表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为 mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于 mid ，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。</p><p><a href="https://assets.leetcode-cn.com/solution-static/14/14_fig4.png" target="_blank" rel="noopener">fig4</a></p><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol4-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            minLength = Math.min(minLength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0.charAt(j) != str.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol4-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = min_element(strs.begin(), strs.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; t) &#123;<span class="keyword">return</span> s.size() &lt; t.size();&#125;)-&gt;size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCommonPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str0 = strs[<span class="number">0</span>].substr(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0[j] != str[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol4-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isCommonPrefix</span><span class="params">(length)</span>:</span></span><br><span class="line">            str0, count = strs[<span class="number">0</span>][:length], len(strs)</span><br><span class="line">            <span class="keyword">return</span> all(strs[i][:length] == str0 <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        minLength = min(len(s) <span class="keyword">for</span> s <span class="keyword">in</span> strs)</span><br><span class="line">        low, high = <span class="number">0</span>, minLength</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (high - low + <span class="number">1</span>) // <span class="number">2</span> + low</span><br><span class="line">            <span class="keyword">if</span> isCommonPrefix(mid):</span><br><span class="line">                low = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:low]</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol4-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isCommonPrefix := <span class="function"><span class="keyword">func</span><span class="params">(length <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        str0, count := strs[<span class="number">0</span>][:length], <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; count; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> strs[i][:length] != str0 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    minLength := <span class="built_in">len</span>(strs[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; minLength &#123;</span><br><span class="line">            minLength = <span class="built_in">len</span>(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    low, high := <span class="number">0</span>, minLength</span><br><span class="line">    <span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">        mid := (high - low + <span class="number">1</span>) / <span class="number">2</span> + low</span><br><span class="line">        <span class="keyword">if</span> isCommonPrefix(mid) &#123;</span><br><span class="line">            low = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>][:low]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>**复杂度分析**<ul><li><p>时间复杂度：O(mnlogm)，其中 <em>m</em> 是字符串数组中的字符串的最小长度，<em>n</em> 是字符串的数量。二分查找的迭代执行次数是 O(logm)  ，每次迭代最多需要比较 <em>mn</em> 个字符，因此总时间复杂度是O(mnlogm) 。</p></li><li><p>空间复杂度：<em>O(1)</em>。使用的额外空间复杂度为常数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="http://yoursite.com/2020/10/09/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/09/567. 字符串的排列/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-10T07:12:25.325Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><a id="more"></a><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><pre><code>输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></pre><p>示例2:</p><pre><code>输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False</code></pre><p>注意：</p><pre><code>输入的字符串只包含小写字母两个字符串的长度都在 [1, 10,000] 之间</code></pre><h1 id="方法一-暴力-超过时间限制"><a href="#方法一-暴力-超过时间限制" class="headerlink" title="方法一 暴力 [超过时间限制]"></a>方法一 暴力 [超过时间限制]</h1><p><strong>算法</strong></p><p>最简单的方法是生成短字符串的所有排列，并检查生成的排列是否是较长字符串的子字符串。</p><p>为了生成所有可能的配对，我们使用函数<code>permute（string_1，string_2，current_index）</code>。此函数创建短字符串 <em>s1</em> 的所有可能排列。</p><p>为此，permute将当前元素 <em>current_index</em> 的索引作为参数之一。然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。完成交换后，它会再次调用置换，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。</p><p>因此，当我们到达数组的末尾时，会生成数组元素的新排序。以下动画描述了生成排列的过程。</p><p> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide1.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide2.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide3.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide4.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide5.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide6.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide7.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide8.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide9.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide10.PNG" target="_blank" rel="noopener">1200</a> <a href="https://pic.leetcode-cn.com/Figures/561_ArraySlide11.PNG" target="_blank" rel="noopener">1200</a> </p><details>    <summary>暴力</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        permute(s1, s2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">swap</span><span class="params">(String s, <span class="keyword">int</span> i0, <span class="keyword">int</span> i1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i0 == i1)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String s1 = s.substring(<span class="number">0</span>, i0);</span><br><span class="line">        String s2 = s.substring(i0 + <span class="number">1</span>, i1);</span><br><span class="line">        String s3 = s.substring(i1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(String s1, String s2, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == s1.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.indexOf(s1) &gt;= <span class="number">0</span>)</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; s1.length(); i++) &#123;</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">                permute(s1, s2, l + <span class="number">1</span>);</span><br><span class="line">                s1 = swap(s1, l, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n!)*。我们将 *s1</em> 的短字符串 <em>s1</em> 的所有排列与 <em>s2</em> 匹配。这里，<em>n</em> 指的是 <em>s1</em> 的长度。</p></li><li><p>空间复杂度：<em>O(n^2)<em>。递归树的深度是 *n</em>（*n</em> 是指短字符串 <em>s1</em> 的长度）。递归树的每个节点都包含一个 max 的字符串。长度 <em>n</em>。</p></li></ul><hr><h2 id="方法二-排序-超过时间限制"><a href="#方法二-排序-超过时间限制" class="headerlink" title="方法二 排序 [超过时间限制]:"></a>方法二 排序 [超过时间限制]:</h2><p><strong>算法</strong></p><p>这种方法背后的想法是，只有当两个字符串包含相同次数的相同字符时，一个字符串才是另一个字符串的排列。只有<em>sorted(x)= sorted(y)<em>时，一个字符串</em>x*才​​是其他字符串 *y</em> 的排列。</p><p>为了检查这一点，我们可以对两个字符串进行排序并进行比较。我们对短字符串 <em>s1</em> 和 <em>s2</em> 的所有子字符串进行排序，对它们进行排序并将它们与排序的 <em>s1</em> 字符串进行比较。如果两者完全匹配，<em>s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>排序</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(l1log(l1)+(l2-l1)l1log(l1))。其中 <em>l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(l_1)*。使用了 *t</em> 数组。</p></li></ul><hr><h2 id="方法三-使用哈希表-超过时间限制"><a href="#方法三-使用哈希表-超过时间限制" class="headerlink" title="方法三 使用哈希表 [超过时间限制]"></a>方法三 使用哈希表 [超过时间限制]</h2><p><strong>算法</strong></p><p>如上所述，只有当两个字符串包含具有相同频率的相同字符时，一个字符串才是另一个字符串的排列。我们可以考虑与 <em>s1</em> 长度相同的长字符串 <em>s2</em> 中的每个可能的子字符串，并检查出现在两者中的字符出现的频率。如果每个字母的频率完全匹配，则只有 <em>s1</em> 的排列可以是 <em>s2</em> 的子字符串。</p><p>为了实现这种方法，我们不使用排序然后比较元素的相等性，而是使用一个哈希表 <em>s1map*来存储短字符串 *s1</em> 中所有字符的出现频率。我们考虑 <em>s2</em> 的每个可能的子串，其长度与 <em>s1</em> 的长度相同，也可以找到相应的哈希表，即 <em>s2map*。因此，所考虑的子字符串可以被视为一个长度窗口，如 *s1</em> 迭代超过 <em>s2*。如果获得的两个哈希表对于任何这样的窗口是相同的，我们可以得出结论 *s1</em> 的排列是 <em>s2</em> 的子字符串，否则不是。</p><details>    <summary>使用哈希表</summary><figure class="highlight java"><figcaption><span>[solution3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        s1 = sort(s1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.equals(sort(s2.substring(i, i + s1.length()))))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t = s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(l_1+26*l_1</em>(l_2-l_1))<em>。这个哈希表包含最多26个键。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</li><li>空间复杂度：<em>O(1)</em>。表包含最多 26 个键值对。</li></ul><hr><h2 id="方法四-使用数组-通过"><a href="#方法四-使用数组-通过" class="headerlink" title="方法四 使用数组 [通过]"></a>方法四 使用数组 [通过]</h2><p><strong>算法</strong></p><p>我们可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。给定字符串仅包含小写字母（’a’到’z’）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution-4]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++)</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s1.length(); j++) &#123;</span><br><span class="line">                s2map[s2.charAt(i + j) - <span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li><p>时间复杂度：<em>O(l_1+26*l_1</em>(l_2-l_1))<em>。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)*。使用 *s1map</em> 和 <em>s2map</em>，大小为 26。</p></li></ul><hr><h2 id="方法五-滑动窗口-通过"><a href="#方法五-滑动窗口-通过" class="headerlink" title="方法五 滑动窗口  [通过]:"></a>方法五 滑动窗口  [通过]:</h2><p><strong>算法</strong></p><p>我们可以为 <em>s2</em> 中的第一个窗口创建一次哈希表，而不是为 <em>s2</em> 中考虑的每个窗口重新生成哈希表。然后，稍后当我们滑动窗口时，我们知道我们添加了一个前面的字符并将新的后续字符添加到所考虑的新窗口中。因此，我们可以通过仅更新与这两个字符相关联的索引来更新哈希表。同样，对于每个更新的哈希表，我们将哈希表的所有元素进行比较以获得所需的结果。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution5-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度分析：<em>O(l_1+26</em>(l_2-l_1))<em>。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。常数级空间。</p></li></ul><hr><h2 id="方法六-优化的滑动窗口-通过"><a href="#方法六-优化的滑动窗口-通过" class="headerlink" title="方法六 优化的滑动窗口 [通过]:"></a>方法六 优化的滑动窗口 [通过]:</h2><p><strong>算法</strong></p><p>上一种方法可以优化，如果不是比较每个更新的 <em>s2map</em> 的哈希表的所有元素，而是对应于 <em>s2</em> 考虑的每个窗口，我们会跟踪先前哈希表中已经匹配的元素数量当我们向右移动窗口时，只更新匹配元素的数量。</p><p>为此，我们维护一个 <em>count</em> 变量，该变量存储字符数（26个字母表中的数字），这些字符在 <em>s1</em> 中具有相同的出现频率，当前窗口在 <em>s2</em> 中。当我们滑动窗口时，如果扣除最后一个元素并添加新元素导致任何字符的新频率匹配，我们将 <em>count</em> 递增1.如果不是，我们保持 <em>count</em> 完整。但是，如果添加频率相同的字符（添加和删除之前）相同的字符，现在会导致频率不匹配，这会通过递减相同的 <em>count</em> 变量来考虑。如果在移动窗口后，<em>count</em> 的计算结果为26，则表示所有字符的频率完全匹配。所以，我们立即返回一个True。</p><details>    <summary>使用数组</summary><figure class="highlight java"><figcaption><span>[solution6-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] == s2map[i])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = s2.charAt(i + s1.length()) - <span class="string">'a'</span>, l = s2.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">26</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            s2map[r]++;</span><br><span class="line">            <span class="keyword">if</span> (s2map[r] == s1map[r])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[r] == s1map[r] + <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">            s2map[l]--;</span><br><span class="line">            <span class="keyword">if</span> (s2map[l] == s1map[l])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2map[l] == s1map[l] - <span class="number">1</span>)</span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(l_1+(l_2-l_1))*。其中 *l_1</em> 是字符串 <em>l_1</em> 的长度，<em>l_2</em> 是字符串 <em>l_2</em> 的长度。</p></li><li><p>空间复杂度：<em>O(1)</em>。常数级的空间。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>784. 字母大小写全排列</title>
    <link href="http://yoursite.com/2020/10/09/784.%20%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2020/10/09/784. 字母大小写全排列/</id>
    <published>2020-10-09T07:52:12.000Z</published>
    <updated>2020-10-12T02:55:37.143Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><a id="more"></a><p>示例：<br>    输入：S = “a1b2”<br>    输出：[“a1b2”, “a1B2”, “A1b2”, “A1B2”]</p><pre><code>输入：S = &quot;3z4&quot;输出：[&quot;3z4&quot;, &quot;3Z4&quot;]输入：S = &quot;12345&quot;输出：[&quot;12345&quot;]</code></pre><p>提示：</p><pre><code>S 的长度不超过12。S 仅由数字和字母组成。</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="回溯【超时】"><a href="#回溯【超时】" class="headerlink" title="回溯【超时】"></a>回溯【超时】</h2><p>我首先想到参考全排列的回溯方法来做，但是超时了，因为没有很好的剪枝。</p><details>    <summary>回溯Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    char[] c;</span><br><span class="line">    public List&lt;String&gt; letterCasePermutation(String S) &#123;</span><br><span class="line">        c = S.toCharArray();</span><br><span class="line">        dfs(0);</span><br><span class="line">        for (String s : set) &#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int x) &#123;</span><br><span class="line">        for (int i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            if (i == c.length - 1) &#123;</span><br><span class="line">                set.add(String.valueOf(c));</span><br><span class="line">                letterCase(i);</span><br><span class="line">                set.add(String.valueOf(c));</span><br><span class="line">            &#125;</span><br><span class="line">            letterCase(i);</span><br><span class="line">            dfs(x + 1);</span><br><span class="line">            letterCase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void letterCase(int i) &#123;</span><br><span class="line">        if (Character.isDigit(c[i])) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Character.isLowerCase(c[i])) &#123;</span><br><span class="line">            c[i] = Character.toUpperCase(c[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            c[i] = Character.toLowerCase(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="递归【通过】"><a href="#递归【通过】" class="headerlink" title="递归【通过】"></a>递归【通过】</h2><p><strong>思路</strong></p><p>从左往右依次遍历字符，过程中保持 <code>ans</code> 为已遍历过字符的字母大小全排列。</p><p>例如，当 <code>S = &quot;abc&quot;</code> 时，考虑字母 <code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;</code>，初始令 <code>ans = [&quot;&quot;]</code>，依次更新 <code>ans = [&quot;a&quot;, &quot;A&quot;]</code>， <code>ans = [&quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;, &quot;AB&quot;]</code>， <code>ans = [&quot;abc&quot;, &quot;Abc&quot;, &quot;aBc&quot;, &quot;ABc&quot;, &quot;abC&quot;, &quot;AbC&quot;, &quot;aBC&quot;, &quot;ABC&quot;]</code>。</p><p><strong>算法</strong></p><p>如果下一个字符 <code>c</code> 是字母，将当前已遍历过的字符串全排列复制两份，在第一份的每个字符串末尾添加 <code>lowercase(c)</code>，在第二份的每个字符串末尾添加 <code>uppercase(c)</code>。</p><p>如果下一个字符 <code>c</code> 是数字，将 <code>c</code> 直接添加到每个字符串的末尾。</p><details>    <summary>递归Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;StringBuilder&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ans.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ans.size();</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(c)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="comment">//将当前已遍历过的字符串全排列复制两份</span></span><br><span class="line">                    ans.add(<span class="keyword">new</span> StringBuilder(ans.get(i)));</span><br><span class="line">                    <span class="comment">//在第一份的每个字符串末尾添加 lowercase(c)</span></span><br><span class="line">                    ans.get(i).append(Character.toLowerCase(c));</span><br><span class="line">                    <span class="comment">//在第二份的每个字符串末尾添加 uppercase(c)</span></span><br><span class="line">                    ans.get(n + i).append(Character.toUpperCase(c));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    ans.get(i).append(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; finalans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder sb : ans) &#123;</span><br><span class="line">            finalans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>递归Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        ans = [[]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> S:</span><br><span class="line">            n = len(ans)</span><br><span class="line">            <span class="keyword">if</span> char.isalpha():</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                    ans.append(ans[i][:])</span><br><span class="line">                    ans[i].append(char.lower())</span><br><span class="line">                    ans[n+i].append(char.upper())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                    ans[i].append(char)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map(<span class="string">""</span>.join, ans)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(2^{N} * N)*，其中 *N</em> 是 <code>S</code> 的长度。</p></li><li><p>空间复杂度：<em>O(2^N * N)</em>。</p></li></ul><h2 id="二分掩码【通过】"><a href="#二分掩码【通过】" class="headerlink" title="二分掩码【通过】"></a>二分掩码【通过】</h2><p><strong>思路</strong></p><p>假设字符串 <code>S</code> 有 <em>B</em> 个字母，那么全排列就有 <em>2^B</em> 个字符串，且可以用位掩码 <code>bits</code> 唯一地表示。</p><p>例如，可以用 <code>00</code> 表示 <code>a7b</code>， <code>01</code> 表示 <code>a7B</code>， <code>10</code> 表示 <code>A7b</code>， <code>11</code> 表示 <code>A7B</code>。注意数字不是掩码的一部分。</p><p><strong>算法</strong></p><p>根据位掩码，构造正确的全排列结果。如果下一个字符是字母，则根据位掩码添加小写或大写字母。 否则添加对应的数字。</p><details>    <summary>二分掩码Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray())</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(c))</span><br><span class="line">                B++;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bits = <span class="number">0</span>; bits &lt; <span class="number">1</span>&lt;&lt;B; bits++) &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> letter: S.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.isLetter(letter)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((bits &gt;&gt; b++) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                        word.append(Character.toLowerCase(letter));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        word.append(Character.toUpperCase(letter));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    word.append(letter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.add(word.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分掩码Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        B = sum(letter.isalpha() <span class="keyword">for</span> letter <span class="keyword">in</span> S)</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> bits <span class="keyword">in</span> xrange(<span class="number">1</span> &lt;&lt; B):</span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">            word = []</span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> S:</span><br><span class="line">                <span class="keyword">if</span> letter.isalpha():</span><br><span class="line">                    <span class="keyword">if</span> (bits &gt;&gt; b) &amp; <span class="number">1</span>:</span><br><span class="line">                        word.append(letter.lower())</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        word.append(letter.upper())</span><br><span class="line"></span><br><span class="line">                    b += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    word.append(letter)</span><br><span class="line"></span><br><span class="line">            ans.append(<span class="string">""</span>.join(word))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间和空间复杂度：<em>O(2^{N} * N)</em>，与方法一分析相同。</li></ul><h2 id="内置函数库【通过】"><a href="#内置函数库【通过】" class="headerlink" title="内置函数库【通过】"></a>内置函数库【通过】</h2><p><strong>思路和算法</strong></p><p>集合的笛卡尔乘积是从所有集合中选择每种可能的组合。例如 <code>{1, 2} x {a, b, c} = {1a, 1b, 1c, 2a, 2b, 2c}</code>。</p><p>对于具有内置函数来计算笛卡尔积的语言，可以直接调用内置函数减少工作量。</p><figure class="highlight python"><figcaption><span>[solution3-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        f = <span class="keyword">lambda</span> x: (x.lower(), x.upper()) <span class="keyword">if</span> x.isalpha() <span class="keyword">else</span> x</span><br><span class="line">        <span class="keyword">return</span> map(<span class="string">""</span>.join, itertools.product(*map(f, S)))</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间和空间复杂度：<em>O(2^{N} * N)</em>，与方法一分析相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年10月" scheme="http://yoursite.com/categories/2020%E5%B9%B410%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
</feed>
