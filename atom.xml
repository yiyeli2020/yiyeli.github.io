<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-19T12:24:53.918Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1206. 设计跳表</title>
    <link href="http://yoursite.com/2021/05/07/1206.%20%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/05/07/1206. 设计跳表/</id>
    <published>2021-05-07T07:12:12.000Z</published>
    <updated>2021-05-19T12:24:53.918Z</updated>
    
    <content type="html"><![CDATA[<p>不使用任何库函数，设计一个跳表。</p><p>跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><a id="more"></a><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90]，然后增加 80、45 到跳表中，以下图的方式操作：</p><p>Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons</p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>在本题中，你的设计应该要包含这些函数：</p><p>bool search(int target) : 返回target是否存在于跳表中。<br>void add(int num): 插入一个元素到跳表。<br>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。<br>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Skip_list</a></p><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><p>样例:</p><pre><code>Skiplist skiplist = new Skiplist();skiplist.add(1);skiplist.add(2);skiplist.add(3);skiplist.search(0);   // 返回 falseskiplist.add(4);skiplist.search(1);   // 返回 trueskiplist.erase(0);    // 返回 false，0 不在跳表中skiplist.erase(1);    // 返回 trueskiplist.search(1);   // 返回 false，1 已被擦除</code></pre><p>约束条件:</p><p>0 &lt;= num, target &lt;= 20000</p><p>最多调用 50000 次 search, add, 以及 erase操作。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>跳表实现的主要难度在于插入(add)算法。只要把add方法搞明白之后，一切都迎刃而解了。</p><p>关于跳表的插入，一张图即可描述出来，<br><a href="https://pic.leetcode-cn.com/1612247342-QjALhY-skiplist_insertions.png" target="_blank" rel="noopener">skiplist_insertions.png</a></p><blockquote><p>图片来自 <a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">http://zhangtielei.com/posts/blog-redis-skiplist.html</a></p></blockquote><p>通过这张图，可以先确定跳表中每个节点的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Integer value; <span class="comment">//节点值</span></span><br><span class="line">    Node[] next; <span class="comment">// 节点在不同层的下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer value,<span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">// 用size表示当前节点在跳表中索引几层</span></span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">new</span> Node[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就需要考虑：我插入一个节点Node，它到底应该是索引到第几层呢？</p><p>一开始我还想着如何准确的维护上一层是下一层的1/2，发现越想越复杂；然后通过相关资料，发现人家早就给出一个解决方案：随机出来一个层数。</p><p>这里有一个疑惑：就凭随机出来的一个层数，能保证查询与插入性能吗？</p><blockquote><p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：<br>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。<br>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。<br>节点最大的层数不允许超过一个最大值，记为MaxLevel。<br>这个计算随机层数的伪码如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> level </span>= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Math.random()&lt;p &amp;&amp; level&lt;MaxLevel)&#123;</span><br><span class="line">        level ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br></pre></td></tr></table></figure><blockquote><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure><blockquote><p>from : <a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">http://zhangtielei.com/posts/blog-redis-skiplist.html</a></p></blockquote><p>知道了层数，这下就好办了。思路如下：</p><ol><li><p>先随机出来一个层数，new要插入的节点，先叫做插入节点newNode；</p></li><li><p>根据跳表实际的总层数从上往下分析，要插入一个节点newNode时，先找到节点在该层的位置：因为是链表，所以需要一个节点node，满足插入插入节点newNode的值刚好不大于node的下一个节点值，当然，如果node的下个节点为空，那么也是满足的。</p></li></ol><p>我们先把找节点在某一层位置的方法封装起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 找到level层 value 刚好不小于node 的节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 从哪个节点开始找</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> levelIndex 所在层</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value 要插入的节点值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findClosest</span><span class="params">(Node node,<span class="keyword">int</span> levelIndex,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((node.next[levelIndex])!=<span class="keyword">null</span> &amp;&amp; value &gt;node.next[levelIndex].value)&#123;</span><br><span class="line">        node = node.next[levelIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>确定插入节点newNode在该层的位置后，先判断下newNode的随机层数是否小于当前跳表的总层数，如果是，则用链表的插入方法将newNode插入即可。</p></li><li><p>如此循环，直到最底层插入newNode完毕。</p></li><li><p>循环完毕后，还需要判断下newNode随机出来的层数是否比跳表的实际层数还要大，如果是，直接将超过实际层数的跳表的头节点指向newNode即可，该跳表的实际层数也就变为newNode的随机层数了。</p></li></ol><p>以上就是插入的算法。</p><p>理解了插入算法后，查找跟删除就简单多了。</p><p>不管是插入、查找还是删除，均是从跳表上层往下层分析，复用上面的findClosest方法，找到要查询的值 在该层closest的节点。比如查询，只需要判断findClosest出来的节点值是否等于该查询值即可，是就返回，不是则继续往下层判断。删除方法思想也是一致的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最大层数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 随机层数概率，也就是随机出的层数，在 第1层以上(不包括第一层)的概率，层数不超过maxLevel，层数的起始号为1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> DEFAULT_P_FACTOR = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,DEFAULT_MAX_LEVEL); <span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentLevel = <span class="number">1</span>; <span class="comment">//表示当前nodes的实际层数，它从1开始</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Skiplist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            Node searchNode = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                searchNode = findClosest(searchNode, i, target);</span><br><span class="line">                <span class="keyword">if</span> (searchNode.next[i]!=<span class="keyword">null</span> &amp;&amp; searchNode.next[i].value == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">            Node updateNode = head;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(num,level);</span><br><span class="line">            <span class="comment">// 计算出当前num 索引的实际层数，从该层开始添加索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//找到本层最近离num最近的list</span></span><br><span class="line">                updateNode = findClosest(updateNode,i,num);</span><br><span class="line">                <span class="keyword">if</span> (i&lt;level)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (updateNode.next[i]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                        updateNode.next[i] = newNode;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        Node temp = updateNode.next[i];</span><br><span class="line">                        updateNode.next[i] = newNode;</span><br><span class="line">                        newNode.next[i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (level &gt; currentLevel)&#123; <span class="comment">//如果随机出来的层数比当前的层数还大，那么超过currentLevel的head 直接指向newNode</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel; i &lt; level; i++) &#123;</span><br><span class="line">                    head.next[i] = newNode;</span><br><span class="line">                &#125;</span><br><span class="line">                currentLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            Node searchNode = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = currentLevel-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                searchNode = findClosest(searchNode, i, num);</span><br><span class="line">                <span class="keyword">if</span> (searchNode.next[i]!=<span class="keyword">null</span> &amp;&amp; searchNode.next[i].value == num)&#123;</span><br><span class="line">                    <span class="comment">//找到该层中该节点</span></span><br><span class="line">                    searchNode.next[i] = searchNode.next[i].next[i];</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 找到level层 value 大于node 的节点</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> levelIndex</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">findClosest</span><span class="params">(Node node,<span class="keyword">int</span> levelIndex,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span> ((node.next[levelIndex])!=<span class="keyword">null</span> &amp;&amp; value &gt;node.next[levelIndex].value)&#123;</span><br><span class="line">                node = node.next[levelIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 随机一个层数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Math.random()&lt;DEFAULT_P_FACTOR &amp;&amp; level&lt;DEFAULT_MAX_LEVEL)&#123;</span><br><span class="line">                level ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Integer value;</span><br><span class="line">            Node[] next;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer value,<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.next = <span class="keyword">new</span> Node[size];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用任何库函数，设计一个跳表。&lt;/p&gt;
&lt;p&gt;跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年5月" scheme="http://yoursite.com/categories/2021%E5%B9%B45%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>707. 设计链表</title>
    <link href="http://yoursite.com/2021/04/26/707.%20%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/04/26/707. 设计链表/</id>
    <published>2021-04-26T03:12:12.000Z</published>
    <updated>2021-05-06T09:49:49.812Z</updated>
    
    <content type="html"><![CDATA[<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><a id="more"></a><p>在链表类中实现这些功能：</p><pre><code>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</code></pre><p>示例：</p><pre><code>MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3linkedList.get(1);            //返回2linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3linkedList.get(1);            //返回3</code></pre><p>提示：</p><pre><code>所有val值都在 [1, 1000] 之内。操作次数将在  [1, 1000] 之内。请不要使用内置的 LinkedList 库。</code></pre><h1 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h1><p>链表时一个包含零个或多个元素的数据结构。每个元素都包含一个值和到另一个元素的链接。根据链接数的不同，可以分为单链表，双链表和多重链表。</p><p>单链表是最简单的一种，它提供了在常数时间内的 <code>addAtHead</code> 操作和在线性时间内的 <code>addAtTail</code> 的操作。双链表是最常用的一种，因为它提供了在常数时间内的 <code>addAtHead</code> 和 <code>addAtTail</code> 操作，并且优化的插入和删除。</p><p>双链表在 Java 中的实现为 LinkedList，在 Python 中为 list。这些结构都比较常用，有两个要点：</p><ul><li>哨兵节点：</li></ul><p>哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。</p><p>我们将使用伪头来简化我们简化插入和删除。在接下来的两种方法中应用此方法。</p><ul><li>双链表的双向搜索：我们可以从头部或尾部进行搜索。</li></ul><h1 id="方法一：单链表"><a href="#方法一：单链表" class="headerlink" title="方法一：单链表"></a>方法一：单链表</h1><p>让我们从最简单的链表开始。</p><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[init1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)  <span class="comment"># sentinel node as pseudo-head</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[init1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  ListNode head;  <span class="comment">// sentinel node as pseudo-head</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>哨兵节点被用作伪头始终存在，这样结构中永远不为空，它将至少包含一个伪头。MyLinkedList 中所有节点均包含：值 + 链接到下一个元素的指针。</p><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[ListNode1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[ListNode1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><code>addAtIndex</code>，<code>addAtHead</code> 和 <code>addAtTail</code>：<br>我们首先讨论 <code>addAtIndex</code>，因为伪头的关系 <code>addAtHead</code> 和 <code>addAtTail</code> 可以使用 <code>addAtIndex</code> 来完成。</p><p>这个想法很简单：</p><ul><li>找到要插入位置节点的前驱节点。如果要在头部插入，则它的前驱节点就是伪头。如果要在尾部插入节点，则前驱节点就是尾节点。</li><li>通过改变 <code>next</code> 来插入节点。<details>  <summary>单链表</summary></details></li></ul><figure class="highlight python"><figcaption><span>[add1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to_add.next = pred.next</span><br><span class="line">pred.next = to_add</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[add1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toAdd.next = pred.next;</span><br><span class="line">pred.next = toAdd;</span><br></pre></td></tr></table></figure><p><code>deleteAtIndex</code>：<br>和插入同样的道理。</p><ul><li>找到要删除节点的前驱节点。</li><li>通过改变 <code>next</code> 来删除节点。</li></ul><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[delete2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete pred.next </span></span><br><span class="line">pred.next = pred.next.next</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[delete2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete pred.next </span></span><br><span class="line">pred.next = pred.next.next;</span><br></pre></td></tr></table></figure></details><p><code>get</code>：<br>从伪头节点开始，向前走 <code>index+1</code> 步。</p><details>    <summary>单链表</summary><figure class="highlight python"><figcaption><span>[get1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index steps needed </span></span><br><span class="line"><span class="comment"># to move from sentinel node to wanted index</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">    curr = curr.next</span><br><span class="line"><span class="keyword">return</span> curr.val</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[get1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index steps needed </span></span><br><span class="line"><span class="comment">// to move from sentinel node to wanted index</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line"><span class="keyword">return</span> curr.val;</span><br></pre></td></tr></table></figure></details><p><strong>全部代码：</strong></p><details>    <summary>单链表Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)  <span class="comment"># sentinel node as pseudo-head</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if index is invalid</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        curr = self.head</span><br><span class="line">        <span class="comment"># index steps needed </span></span><br><span class="line">        <span class="comment"># to move from sentinel node to wanted index</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> curr.val</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># If index is greater than the length, </span></span><br><span class="line">        <span class="comment"># the node will not be inserted.</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [so weird] If index is negative, </span></span><br><span class="line">        <span class="comment"># the node will be inserted at the head of the list.</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># find predecessor of the node to be added</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">            pred = pred.next</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># node to be added</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        <span class="comment"># insertion itself</span></span><br><span class="line">        to_add.next = pred.next</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if the index is invalid, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># find predecessor of the node to be deleted</span></span><br><span class="line">        pred = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">            pred = pred.next</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># delete pred.next </span></span><br><span class="line">        pred.next = pred.next.next</span><br></pre></td></tr></table></figure></details><details>    <summary>单链表Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  ListNode head;  <span class="comment">// sentinel node as pseudo-head</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// index steps needed </span></span><br><span class="line">    <span class="comment">// to move from sentinel node to wanted index</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(size, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be added</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node to be added</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    toAdd.next = pred.next;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be deleted</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    pred.next = pred.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>空间复杂度：所有的操作都是 <em>O(1)</em>。</li></ul><h1 id="方法二：双链表"><a href="#方法二：双链表" class="headerlink" title="方法二：双链表"></a>方法二：双链表</h1><p>双链表比单链表快得多，测试用例花费的时间比单链表快了两倍。但是它更加复杂，它包含了 <code>size</code>，记录链表元素个数，和伪头伪尾。</p><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[init2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">        self.head, self.tail = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>) </span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[init2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">  ListNode head, tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>伪头和伪尾总是存在，MyLinkedList 中所有节点都包含：值 + 指向前一个节点的指针 + 指向后一个节点的指针。</p><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[ListNode2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[ListNode2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode prev;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><code>addAtIndex</code>，<code>addAtHead</code> 和 <code>addAtTail</code>：</p><ul><li>找到要插入节点的前驱节点和后继节点。如果要在头部插入节点，则它的前驱结点是伪头。如果要在尾部插入节点，则它的后继节点是伪尾。</li><li>通过改变前驱结点和后继节点的链接关系添加元素。</li></ul><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[add2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">to_add.prev = pred</span><br><span class="line">to_add.next = succ</span><br><span class="line">pred.next = to_add</span><br><span class="line">succ.prev = to_add</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[add2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toAdd.prev = pred</span><br><span class="line">toAdd.next = succ</span><br><span class="line">pred.next = toAdd</span><br><span class="line">succ.prev = toAdd</span><br></pre></td></tr></table></figure></details><p><code>deleteAtIndex</code>：<br>和插入同样的道理。</p><ul><li>找到要删除节点的前驱结点和后继节点。</li><li>通过改变前驱结点和后继节点的链接关系删除元素。</li></ul><details>    <summary>双链表</summary><figure class="highlight python"><figcaption><span>[delete2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pred.next = succ</span><br><span class="line">succ.prev = pred</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>[delete2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pred.next = succ</span><br><span class="line">succ.prev = pred</span><br></pre></td></tr></table></figure></details><p><code>get</code>：</p><ul><li>通过比较 <code>index</code> 和 <code>size - index</code> 的大小判断从头开始较快还是从尾巴开始较快。</li><li>从较快的方向开始。 </li></ul><details>    <summary>双链表Python</summary><figure class="highlight python"><figcaption><span>[get2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># choose the fastest way: to move from the head</span></span><br><span class="line"><span class="comment"># or to move from the tail</span></span><br><span class="line"><span class="keyword">if</span> index + <span class="number">1</span> &lt; self.size - index:</span><br><span class="line">    curr = self.head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">        curr = curr.next</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    curr = self.tail</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index):</span><br><span class="line">        curr = curr.prev</span><br></pre></td></tr></table></figure></details><details>    <summary>双链表Java</summary><figure class="highlight java"><figcaption><span>[get2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choose the fastest way: to move from the head</span></span><br><span class="line"><span class="comment">// or to move from the tail</span></span><br><span class="line">ListNode curr = head;</span><br><span class="line"><span class="keyword">if</span> (index + <span class="number">1</span> &lt; size - index)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  curr = tail;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) curr = curr.prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>全部代码：</strong></p><details>    <summary>双链表Python</summary><figure class="highlight python"><figcaption><span>[solution2-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next, self.prev = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">        self.head, self.tail = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>) </span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if index is invalid</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># choose the fastest way: to move from the head</span></span><br><span class="line">        <span class="comment"># or to move from the tail</span></span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">1</span> &lt; self.size - index:</span><br><span class="line">            curr = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(index + <span class="number">1</span>):</span><br><span class="line">                curr = curr.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curr = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index):</span><br><span class="line">                curr = curr.prev</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> curr.val</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pred, succ = self.head, self.head.next</span><br><span class="line">        </span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.prev = pred</span><br><span class="line">        to_add.next = succ</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        succ.prev = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        succ, pred = self.tail, self.tail.prev</span><br><span class="line">        </span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.prev = pred</span><br><span class="line">        to_add.next = succ</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        succ.prev = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># If index is greater than the length, </span></span><br><span class="line">        <span class="comment"># the node will not be inserted.</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [so weird] If index is negative, </span></span><br><span class="line">        <span class="comment"># the node will be inserted at the head of the list.</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find predecessor and successor of the node to be added</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; self.size - index:</span><br><span class="line">            pred = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">                pred = pred.next</span><br><span class="line">            succ = pred.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            succ = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index):</span><br><span class="line">                succ = succ.prev</span><br><span class="line">            pred = succ.prev</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># insertion itself</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.prev = pred</span><br><span class="line">        to_add.next = succ</span><br><span class="line">        pred.next = to_add</span><br><span class="line">        succ.prev = to_add</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if the index is invalid, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find predecessor and successor of the node to be deleted</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; self.size - index:</span><br><span class="line">            pred = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(index):</span><br><span class="line">                pred = pred.next</span><br><span class="line">            succ = pred.next.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            succ = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size - index - <span class="number">1</span>):</span><br><span class="line">                succ = succ.prev</span><br><span class="line">            pred = succ.prev.prev</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># delete pred.next </span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        pred.next = succ</span><br><span class="line">        succ.prev = pred</span><br></pre></td></tr></table></figure></details><details>    <summary>双链表Java</summary><figure class="highlight java"><figcaption><span>[solution2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode prev;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">  ListNode head, tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// choose the fastest way: to move from the head</span></span><br><span class="line">    <span class="comment">// or to move from the tail</span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">if</span> (index + <span class="number">1</span> &lt; size - index)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      curr = tail;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) curr = curr.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode pred = head, succ = head.next;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode succ = tail, pred = tail.prev;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be added</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be deleted</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index - <span class="number">1</span>; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    --size;</span><br><span class="line">    pred.next = succ;</span><br><span class="line">    succ.prev = pred;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>706. 设计哈希映射</title>
    <link href="http://yoursite.com/2021/04/09/706.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/"/>
    <id>http://yoursite.com/2021/04/09/706. 设计哈希映射/</id>
    <published>2021-04-09T10:12:12.000Z</published>
    <updated>2021-04-10T16:53:00.872Z</updated>
    
    <content type="html"><![CDATA[<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><a id="more"></a><p>实现 MyHashMap 类：</p><p>MyHashMap() 用空映射初始化对象<br>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。<br>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。<br>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</p><p>示例：</p><p>输入：</p><pre><code>[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;][[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]</code></pre><p>输出：</p><pre><code>[null, null, null, 1, -1, null, 1, null, -1]</code></pre><p>解释：</p><pre><code>MyHashMap myHashMap = new MyHashMap();myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</code></pre><p>提示：</p><pre><code>0 &lt;= key, value &lt;= 106最多调用 104 次 put、get 和 remove 方法</code></pre><p>进阶：你能否不使用内置的 HashMap 库解决此问题？</p><h1 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h1><p>我们假定读者已经完成了「<a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a>」这一题目。</p><p>「设计哈希映射」与「设计哈希集合」解法接近，唯一的区别在于我们存储的不是 key本身，而是 key,value 对。除此之外，代码基本是类似的。</p><details>    <summary>链地址法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashMap(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(make_pair(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Pair&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Pair pair = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKey() == key) &#123;</span><br><span class="line">                pair.setValue(value);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].offerLast(<span class="keyword">new</span> Pair(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Pair pair = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKey() == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Pair pair = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                data[h].remove(pair);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base = <span class="number">769</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    key, value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyHashMap</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyHashMap&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">hash</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">Put</span><span class="params">(key, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h := m.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := m.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> et := e.Value.(entry); et.key == key &#123;</span><br><span class="line">            e.Value = entry&#123;key, value&#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m.data[h].PushBack(entry&#123;key, value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    h := m.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := m.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> et := e.Value.(entry); et.key == key &#123;</span><br><span class="line">            <span class="keyword">return</span> et.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHashMap)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h := m.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := m.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Value.(entry).key == key &#123;</span><br><span class="line">            m.data[h].Remove(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyHashMap = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.BASE).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.put = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            it[<span class="number">1</span>] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.data[h].push([key, value]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> it <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            <span class="keyword">const</span> idx = <span class="keyword">this</span>.data[h].indexOf(it);</span><br><span class="line">            <span class="keyword">this</span>.data[h].splice(idx, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashMap.prototype.hash = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="keyword">this</span>.BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listPush</span><span class="params">(struct List* head, <span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">List</span>));</span></span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelete</span><span class="params">(struct List* head, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">it</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct List* <span class="title">listFind</span><span class="params">(struct List* head, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listFree</span><span class="params">(struct List* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashMap;</span><br><span class="line"></span><br><span class="line"><span class="function">MyHashMap* <span class="title">myHashMapCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyHashMap* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashMap));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].key = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashMapPut</span><span class="params">(MyHashMap* obj, <span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> = <span class="title">listFind</span>(&amp;(<span class="title">obj</span>-&gt;<span class="title">data</span>[<span class="title">h</span>]), <span class="title">key</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rec-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myHashMapGet</span><span class="params">(MyHashMap* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> = <span class="title">listFind</span>(&amp;(<span class="title">obj</span>-&gt;<span class="title">data</span>[<span class="title">h</span>]), <span class="title">key</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashMapRemove</span><span class="params">(MyHashMap* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashMapFree</span><span class="params">(MyHashMap* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>空间复杂度：<em>O(n+b)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用任何内建的哈希表库设计一个哈希映射（HashMap）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>705. 设计哈希集合</title>
    <link href="http://yoursite.com/2021/04/09/705.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2021/04/09/705. 设计哈希集合/</id>
    <published>2021-04-09T10:10:12.000Z</published>
    <updated>2021-04-10T16:53:07.037Z</updated>
    
    <content type="html"><![CDATA[<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><a id="more"></a><p>实现 MyHashSet 类：</p><p>void add(key) 向哈希集合中插入值 key 。<br>bool contains(key) 返回哈希集合中是否存在这个值 key 。<br>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p><p>示例：</p><p>输入：</p><pre><code>[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;][[], [1], [2], [1], [3], [2], [2], [2], [2]]</code></pre><p>输出：</p><pre><code>[null, null, null, true, false, null, true, null, false]</code></pre><p>解释：</p><pre><code>MyHashSet myHashSet = new MyHashSet();myHashSet.add(1);      // set = [1]myHashSet.add(2);      // set = [1, 2]myHashSet.contains(1); // 返回 TruemyHashSet.contains(3); // 返回 False ，（未找到）myHashSet.add(2);      // set = [1, 2]myHashSet.contains(2); // 返回 TruemyHashSet.remove(2);   // set = [1]myHashSet.contains(2); // 返回 False ，（已移除）</code></pre><p>提示：</p><pre><code>0 &lt;= key &lt;= 106最多调用 104 次 add、remove 和 contains 。</code></pre><p>进阶：你可以不使用内建的哈希集合库解决此问题吗？</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：</p><ul><li>哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</li><li>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：<ul><li>链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</li><li>开放地址法：当发现哈希值 <em>h</em> 处产生冲突时，根据某种策略，从 <em>h</em> 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3… 这些整数对应的位置。</li><li>再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</li></ul></li><li>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</li></ul><p>以上内容读者可以自行翻阅数据结构的教材，本题解不再阐述，而是直接给出一个最简单的哈希表实现。</p><h1 id="方法一：链地址法"><a href="#方法一：链地址法" class="headerlink" title="方法一：链地址法"></a>方法一：链地址法</h1><p>设哈希表的大小为 base ，则可以设计一个简单的哈希函数：hash(x)=x%base。</p><p>我们开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 base  取为一个质数。在这里，我们取 base=769。</p><p><strong>代码</strong></p><details>    <summary>链地址法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].offerLast(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                data[h].remove(element);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyHashSet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.BASE).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element === key) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.data[h].push(key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">const</span> it = <span class="keyword">this</span>.data[h];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; it.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it[i] === key) &#123;</span><br><span class="line">            it.splice(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.contains = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> <span class="keyword">this</span>.data[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyHashSet.prototype.hash = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="keyword">this</span>.BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base = <span class="number">769</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyHashSet</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyHashSet&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">hash</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !s.Contains(key) &#123;</span><br><span class="line">        h := s.hash(key)</span><br><span class="line">        s.data[h].PushBack(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h := s.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := s.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Value.(<span class="keyword">int</span>) == key &#123;</span><br><span class="line">            s.data[h].Remove(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MyHashSet)</span> <span class="title">Contains</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    h := s.hash(key)</span><br><span class="line">    <span class="keyword">for</span> e := s.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Value.(<span class="keyword">int</span>) == key &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>链地址法C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listPush</span><span class="params">(struct List* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">List</span>));</span></span><br><span class="line">    tmp-&gt;val = x;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelete</span><span class="params">(struct List* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">it</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listContains</span><span class="params">(struct List* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (struct List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listFree</span><span class="params">(struct List* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashSet;</span><br><span class="line"></span><br><span class="line"><span class="function">MyHashSet* <span class="title">myHashSetCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyHashSet* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashSet));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashSetAdd</span><span class="params">(MyHashSet* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!listContains(&amp;(obj-&gt;data[h]), key)) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashSetRemove</span><span class="params">(MyHashSet* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myHashSetContains</span><span class="params">(MyHashSet* obj, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">return</span> listContains(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myHashSetFree</span><span class="params">(MyHashSet* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不使用任何内建的哈希表库设计一个哈希集合（HashSet）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>LCP 29. 乐团站位</title>
    <link href="http://yoursite.com/2021/04/07/LCP%2029.%20%E4%B9%90%E5%9B%A2%E7%AB%99%E4%BD%8D/"/>
    <id>http://yoursite.com/2021/04/07/LCP 29. 乐团站位/</id>
    <published>2021-04-07T02:00:12.000Z</published>
    <updated>2021-04-10T16:53:13.832Z</updated>
    
    <content type="html"><![CDATA[<p>某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。</p><p>为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，…，9 循环重复排列。</p><a id="more"></a><p>请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。</p><p>示例 1：</p><p>输入：num = 3, Xpos = 0, Ypos = 2</p><p>输出：3</p><p>解释：</p><pre><code>1 2 38 9 47 6 5</code></pre><p>示例 2：</p><p>输入：num = 4, Xpos = 1, Ypos = 2</p><p>输出：5</p><p>解释：</p><pre><code>1 2 3 43 4 5 52 7 6 61 9 8 7</code></pre><p>提示：</p><p>1 &lt;= num &lt;= 10^9</p><p>0 &lt;= Xpos, Ypos &lt; num</p><h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解^1"></a>题解<a href="https://leetcode-cn.com/problems/SNJvJP/solution/shu-xue-yi-ge-gong-shi-ji-ke-by-ivon_shi-mo6a/" target="_blank" rel="noopener">^1</a></h1><p>1.获取所求点在第几层（此处根据所求点的位置，层数k可能会多算一层）</p><p>2.第<code>0，1...k</code>层的数量 与 所求点相对第k层左上角元素的位置做<code>+</code>或<code>-</code>运算，求得所求点的绝对次序（从起始点到所求点经过的长度）</p><p>记：<code>k(0,1,2...n/2</code>(往上取整))<br><code>C(K)</code>=第k层的方块数目,如图<code>C(0)=16,C(1)=8,C(2)=1</code>;<br><code>T(K)</code>=第k层及以外的方块 数目，如图<code>T(0)=16,T(1)=16+8=24,T(2)=16+8+1=25;</code><br>但是具体怎么计算呢 可以用补集的思想<br><code>T(K)=n*n-(n-2k)*(n-2k)=4*k*(n-k)</code></p><p>但是怎么求<code>(i,j)</code>点所在层 已经遍历过的数目呢 。<br>1.求所在的层数<code>k</code><br><code>k=min(x,n-1-x,y,n-1-y)</code>(后续由于要分类讨论，k的求取可以直接通过其中某两个值求最小值即可); 即看该点距离哪个边界更近，所求的最小值就是第几层，如图 <code>k=min(2,2,3,1)</code>,即处于第一层。那么我们也就知道了该层以外的橙色数目<code>T(k)</code>。<br>2.求所求点<code>(x,y)</code>相对该层左上角点的相对路径长度</p><p>2.1 对于<code>x&lt;=y</code>，我们可以知道<code>dl=(x-k)+(y-k)+1</code><br>故 绝对路径长度为 <code>T(k)+dl</code></p><p>2.2 但是对于<code>x&gt;y</code>呢，如果我们采用相同的方法，就会导致对称的两个<code>(i,j)</code>与<code>(j,i)</code>相对路径相同。故才用另外一种方法</p><p>在计算层数k的时候 多计算一层，再从下一层的入口处回退dl个路径<br>此时绝对路径长度为 <code>T(k+1)-dl</code> ,注意dl计算时，仍用其真正所处的层数k-1来计算。即：<code>dl=(x-(k-1))+(y-(k-1))+1</code></p><p>(至于为何此处可直接-dl，可以看下图，下一层的入口点与上一层的入口点是右下和左上关系，按照螺旋顺序到<code>(i,j)</code>点的路径长度是相同的。)</p><p>最后， 就是把相应的路径长度<code>len</code>转化为<code>1-9</code>的数字即可，<code>index=(len-1)%9+1</code>。</p><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int orchestraLayout(int num, int xPos, int yPos) &#123;</span><br><span class="line">        long long x=xPos,y=yPos,n=num;</span><br><span class="line">        if  (x &lt;= y) &#123;</span><br><span class="line">            long long  k= min(x, n-1-y);</span><br><span class="line">            return  (4*k*(n-k)+1+(x+y-k*2)-1)%9+1;</span><br><span class="line">        &#125;</span><br><span class="line">        long long  k =min(y, n-1-x)+1 ; </span><br><span class="line">        return   (4*k*(n-k)+ 1-(x+y-(k-1)*2 )-1)%9+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>Java这里就是直接定成k是从1开始计数的。x和y是从0开始计数的。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int orchestraLayout(int num, int xPos, int yPos) &#123;</span><br><span class="line">        //根据x，y计算k</span><br><span class="line">        int k = Math.min(Math.min(xPos,yPos),Math.min(num-xPos-1,num-yPos-1)) + 1; //1,2,3</span><br><span class="line">        long total_distance = 0;</span><br><span class="line">        long distance = 0;</span><br><span class="line">        if(xPos&lt;=yPos)&#123;</span><br><span class="line">            distance = (xPos-(k-1))+(yPos-(k-1))+1; //1,2...</span><br><span class="line">            total_distance  = T(num,k-1)+distance;</span><br><span class="line">            return total_distance%9==0?9:(int)(total_distance%9);</span><br><span class="line">        &#125;</span><br><span class="line">        //当前层的个数减去0，1，2等</span><br><span class="line">        distance = T(num,k) - T(num,k-1) - (Math.abs(xPos-k)+Math.abs(yPos-(k-1))) ;</span><br><span class="line">        total_distance = T(num,k-1)+distance;</span><br><span class="line">        return total_distance%9==0?9:(int)(total_distance%9);</span><br><span class="line">    &#125;</span><br><span class="line">    public long T(long n,long k)&#123; //k=1,2,3</span><br><span class="line">        if(k&lt;=0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return 4*k*(n-k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。&lt;/p&gt;
&lt;p&gt;为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，…，9 循环重复排列。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LCP 28. 采购方案</title>
    <link href="http://yoursite.com/2021/04/05/LCP%2028.%20%E9%87%87%E8%B4%AD%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2021/04/05/LCP 28. 采购方案/</id>
    <published>2021-04-05T07:00:12.000Z</published>
    <updated>2021-04-10T16:52:53.992Z</updated>
    
    <content type="html"><![CDATA[<p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1</p><a id="more"></a><p>示例 1：</p><pre><code>输入：nums = [2,5,3,5], target = 6输出：1解释：预算内仅能购买 nums[0] 与 nums[2]。</code></pre><p>示例 2：</p><pre><code>输入：nums = [2,2,1,9], target = 10输出：4解释：符合预算的采购方案如下：nums[0] + nums[1] = 4nums[0] + nums[2] = 3nums[1] + nums[2] = 3nums[2] + nums[3] = 10</code></pre><p>提示：</p><pre><code>2 &lt;= nums.length &lt;= 10^51 &lt;= nums[i], target &lt;= 10^5</code></pre><p>这道题是leetcode周赛的题目，一开始用双循环或TreeMap存储的办法来做都是超时。<br>先，为了便于计算，我们先对 numsnums 做升序排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums：[<span class="number">2</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">9</span>]     target: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>首先，获取两个数，求和之后再和某个数做比较，这个题其实和 <a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/shuang-zhi-zhen-he-wei-sde-liang-ge-shu-wy7r4/" target="_blank" rel="noopener">剑指 Offer 57. 和为s的两个数字</a> 极为相似，不知道的小伙伴可以先行看看这道题熟悉一下思路。</p><p>首先，为了便于计算，我们先对 <em>nums</em> 做升序排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums：[<span class="number">1</span>，<span class="number">2</span>，<span class="number">2</span>，<span class="number">9</span>]     target: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>然后，创建一个指针 <em>i</em> 指针指向 <em>nums</em> 首位，再创建一个指针 <em>j</em> 指向 <em>nums</em> 末位，然后通过遍历，找到符合 <em>nums[i] + nums[j] &lt;= target</em> 条件的 <em>i</em>，<em>j</em> 区间范围。</p><p>既然该范围的边界值之和都满足了条件，那么代表该区间内的所有数字和 <em>nums[i]</em> 相加都满足条件，所以，我们可以通过 <em>j - i</em> 来获取到当前有多少个数，可以和 <em>nums[i]</em> 相加后满足条件！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">i：<span class="number">0</span>    j：<span class="number">3</span>    nums[<span class="number">0</span>] + nums[<span class="number">3</span>] = <span class="number">10</span>，满足条件 &lt;= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">所以，当 i = <span class="number">0</span> 时，存在 j - i = <span class="number">3</span> 种方案，即：[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">然后 i 指针右移一位，如下所示：</span><br><span class="line"></span><br><span class="line">i：<span class="number">1</span>    j：<span class="number">3</span>    nums[<span class="number">1</span>] + nums[<span class="number">3</span>] = <span class="number">11</span>，不满足条件 &lt;= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">所以 j 指针左移一位，如下所示：</span><br><span class="line"></span><br><span class="line">i：<span class="number">1</span>    j：<span class="number">2</span>    nums[<span class="number">1</span>] + nums[<span class="number">2</span>] = <span class="number">4</span>，满足条件 &lt;= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">所以，当 i = <span class="number">1</span> 时，存在 j - i = <span class="number">1</span> 种方案，即：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">最后，满足条件的方案总共就是 [<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>] 这 <span class="number">4</span> 种方案！</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><details>    <summary>Javascript</summary><figure class="highlight javascript"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> purchasePlans = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + nums[j] &gt; target) j--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += j - i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % <span class="number">1000000007</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) right--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += right - left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[i]+nums[j]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            res += j-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    qsort(nums,numsSize,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),comp);</span><br><span class="line">    <span class="keyword">unsigned</span> left = <span class="number">0</span>,right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[left] + nums[right]) &gt; target)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum += right - left;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum%(<span class="number">1000000007</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">purchasePlans</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line">j := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> ; j &gt; i; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j] &lt;= target &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt; i &#123;</span><br><span class="line">ans = ans + (j - i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % <span class="number">1000000007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight plain"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def purchasePlans(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = 0</span><br><span class="line">        i = 0</span><br><span class="line">        j = len(nums)-1</span><br><span class="line">        while i &lt; j:</span><br><span class="line">            if nums[i] + nums[j] &gt; target:</span><br><span class="line">                j -= 1</span><br><span class="line">            else:</span><br><span class="line">                ans += (j-i)</span><br><span class="line">                i += 1</span><br><span class="line">        if ans&lt;=1000000007:</span><br><span class="line">            return ans</span><br><span class="line">        else:</span><br><span class="line">            return ans%1000000007</span><br></pre></td></tr></table></figure></details><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。&lt;/p&gt;
&lt;p&gt;注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1&lt;/p&gt;
    
    </summary>
    
      <category term="2021年4月" scheme="http://yoursite.com/categories/2021%E5%B9%B44%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Simulation" scheme="http://yoursite.com/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>294 · 简化链表</title>
    <link href="http://yoursite.com/2021/03/31/294%20%C2%B7%20%E7%AE%80%E5%8C%96%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/03/31/294 · 简化链表/</id>
    <published>2021-03-31T13:31:12.000Z</published>
    <updated>2021-04-01T00:00:20.757Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个字符链表，对其进行简化。<br>简化的过程为，保留链表的头尾节点，用数字代替掉中间的部分。数字也要用字符链表表示。</p><a id="more"></a><p>输入的字符链表用一个整型链表表示，链表的每个节点的值都是其对应的ASCII码。<br>输入的字符链表的节点数为 n，3≤n≤10^4</p><p>说明</p><pre><code>原链表是 &apos;h&apos;-&gt;&apos;e&apos;-&gt;&apos;l&apos;-&gt;&apos;l&apos;-&gt;&apos;o&apos;-&gt;null。简化后变为 &apos;h&apos;-&gt;&apos;3&apos;-&gt;&apos;o&apos;-&gt;null。第二组样例中：原链表是 &apos;a&apos;-&gt;&apos;b&apos;-&gt;...-&gt;&apos;z&apos;-&gt;null。简化后变为 &apos;a&apos;-&gt;&apos;2&apos;-&gt;&apos;4&apos;-&gt;&apos;z&apos;-&gt;null。</code></pre><p>样例</p><pre><code>输入1：    104-&gt;101-&gt;108-&gt;108-&gt;111-&gt;null输出1：    104-&gt;51-&gt;111-&gt;null输入2：    97-&gt;98-&gt;...-&gt;122-&gt;null输出2：    97-&gt;50-&gt;52-&gt;122-&gt;null</code></pre><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for ListNode</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param head: the linked list to be simplify.</span><br><span class="line">     * @return: return the linked list after simplifiction.</span><br><span class="line">     */</span><br><span class="line">    public ListNode simplify(ListNode head) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        ListNode cur=head.next;</span><br><span class="line">        if(head == null || cur == null || cur.next == null)&#123;</span><br><span class="line">          return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        while(cur.next!=null)&#123;</span><br><span class="line">          cur=cur.next;</span><br><span class="line">          cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        if(cnt!=0)&#123;</span><br><span class="line">            ListNode p = new ListNode(Integer.valueOf(&apos;0&apos;)+cnt%10);</span><br><span class="line">            cnt/=10;</span><br><span class="line">            p.next = cur;</span><br><span class="line">            while(cnt != 0)&#123;</span><br><span class="line">              ListNode temp=p;</span><br><span class="line">              p = new ListNode(Integer.valueOf(&apos;0&apos;)+cnt%10);</span><br><span class="line">              p.next=temp;</span><br><span class="line">              cnt/=10;</span><br><span class="line">          &#125;</span><br><span class="line">          head.next=p;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个字符链表，对其进行简化。&lt;br&gt;简化的过程为，保留链表的头尾节点，用数字代替掉中间的部分。数字也要用字符链表表示。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Simulation" scheme="http://yoursite.com/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>711. 不同岛屿的数量II</title>
    <link href="http://yoursite.com/2021/03/31/711.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8FII/"/>
    <id>http://yoursite.com/2021/03/31/711. 不同岛屿的数量II/</id>
    <published>2021-03-31T09:31:12.000Z</published>
    <updated>2021-03-31T10:24:31.270Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个0和1的非空的二维数组网格，一个岛是一个1(表示陆地)的组，4个方向(水平或垂直)连接。你可以假设网格的所有四条边都被水包围。</p><p>计算不同岛屿的数量。当一个岛被认为与另一个岛相同时，它们有相同的形状，或在旋转后的形状相同(90,180，或270度)或翻转(左/右方向或向上/向下方向)。</p><a id="more"></a><p>样例</p><p>Example 1:</p><pre><code>11000100000000100011</code></pre><p>给定上述网格，返回1。<br>注意:</p><pre><code>111</code></pre><p>和</p><pre><code> 111</code></pre><p>被认为是相同的岛屿形状。因为如果我们在第一个岛上顺时针旋转180度，那么两个岛就会有相同的形状。</p><p>Example 2:</p><pre><code>11100100010100101110</code></pre><p>给定上述网格，返回2。<br>以下是两个不同的岛屿:</p><pre><code>1111</code></pre><p>和</p><pre><code>11</code></pre><p>注意：</p><pre><code>1111</code></pre><p>和</p><pre><code>1111</code></pre><p>被认为是相同的岛屿形状。因为如果我们在向上/向下的方向上翻转第一个数组，那么它们的形状是相同的<br>参见Lintcode<a href="https://www.lintcode.com/problem/804/?utm_source=sc-qingbaozhan-sy" target="_blank" rel="noopener">^1</a></p><h2 id="题解BFS"><a href="#题解BFS" class="headerlink" title="题解BFS"></a>题解BFS</h2><p>先用dfs或者bfs把每个岛屿都找出来，然后进行旋转比较。1·</p><details>    <summary>BFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: the 2D grid</span><br><span class="line">     * @return: the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    private final int[] dir = &#123;-1, 0, 1, 0, -1&#125;;</span><br><span class="line">    private final int[][] ref1 = &#123;&#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;</span><br><span class="line">    public int numDistinctIslands2(int[][] grid) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Point&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    bfs(grid, i, j, list);</span><br><span class="line">                &#125;</span><br><span class="line">                if (list.size() &gt; 0) &#123;</span><br><span class="line">                    set.add(norm(list));</span><br><span class="line">                    list.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void bfs(int[][] grid, int row, int col, List&lt;Point&gt; list) &#123;</span><br><span class="line">        Queue&lt;Point&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">        Point start = new Point(row, col);</span><br><span class="line">        queue.add(start);</span><br><span class="line">        list.add(start);</span><br><span class="line">        grid[row][col] = 2;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                int r = p.x + dir[i], c = p.y + dir[i + 1];</span><br><span class="line">                if (r &lt; 0 || r &gt;= grid.length || c &lt; 0 || c &gt;= grid[0].length || grid[r][c] != 1) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[r][c] = 2;</span><br><span class="line">                Point next = new Point(r, c);</span><br><span class="line">                list.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String norm(List&lt;Point&gt; list) &#123;</span><br><span class="line">        List&lt;Point&gt;[] comb = new List[8];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            comb[i] = new ArrayList&lt;Point&gt;();</span><br><span class="line">            comb[i + 4] = new ArrayList&lt;Point&gt;();</span><br><span class="line">            for (Point p : list) &#123;</span><br><span class="line">                comb[i].add(new Point(p.x * ref1[i][0], p.y * ref1[i][1]));</span><br><span class="line">                comb[i + 4].add(new Point(p.y * ref1[i][1], p.x * ref1[i][0]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            Collections.sort(comb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] s = new String[8];</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            int x0 = comb[i].get(0).x, y0 = comb[i].get(0).y;</span><br><span class="line">            for (Point p : comb[i]) &#123;</span><br><span class="line">                sb.append(p.x - x0).append(&apos;,&apos;).append(p.y - y0).append(&apos;!&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            s[i] = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        return s[0];</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Point implements Comparable&lt;Point&gt; &#123;</span><br><span class="line">        int x;</span><br><span class="line">        int y;</span><br><span class="line"></span><br><span class="line">        public Point(int x, int y) &#123;</span><br><span class="line">            this.x = x;</span><br><span class="line">            this.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int compareTo(Point p) &#123;</span><br><span class="line">            return this.x - p.x == 0 ? this.y - p.y : this.x - p.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="题解DFS"><a href="#题解DFS" class="headerlink" title="题解DFS"></a>题解DFS</h2><details>    <summary>DFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">    public int x, y;</span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: the 2D grid</span><br><span class="line">     * @return: the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    public int numDistinctIslands2(int[][] grid) &#123;</span><br><span class="line">        if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = grid.length, n = grid[0].length;</span><br><span class="line">        Set&lt;String&gt;  res = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    List&lt;Point&gt; island = new ArrayList&lt;&gt;();</span><br><span class="line">                    dfs(grid, i, j, island);</span><br><span class="line">                    res.add(getUnique(island));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(int[][]grid, int x, int y, List&lt;Point&gt; island) &#123;</span><br><span class="line">        int m = grid.length, n = grid[0].length;</span><br><span class="line"></span><br><span class="line">        island.add(new Point(x, y));</span><br><span class="line">        grid[x][y] = 0;</span><br><span class="line"></span><br><span class="line">        int[] dirs = &#123;-1, 0, 1, 0, -1&#125;;</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            int _x = x + dirs[i], _y = y + dirs[i + 1];</span><br><span class="line">            if (_x &gt;= 0  &amp;&amp; _x &lt; m  &amp;&amp; _y &gt;= 0  &amp;&amp; _y &lt; n  &amp;&amp; grid[_x][_y] == 1) &#123;</span><br><span class="line">                dfs(grid, _x, _y, island);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getUnique(List&lt;Point&gt; island) &#123;</span><br><span class="line">        List&lt;String&gt; sameIslands = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int[][] trans=&#123;&#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            List&lt;Point&gt; l1 = new ArrayList&lt;&gt;(), l2 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for (Point point : island) &#123;</span><br><span class="line">                int x = point.x, y = point.y;</span><br><span class="line">                l1.add(new Point(x * trans[i][0], y * trans[i][1]));</span><br><span class="line">                l2.add(new Point(y * trans[i][0], x * trans[i][1]));</span><br><span class="line">            &#125;</span><br><span class="line">            sameIslands.add(getStr(l1));</span><br><span class="line">            sameIslands.add(getStr(l2));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(sameIslands);</span><br><span class="line">        return sameIslands.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getStr(List&lt;Point&gt; island) &#123;</span><br><span class="line"></span><br><span class="line">        Collections.sort(island, new Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            public int compare(Point a, Point b) &#123;</span><br><span class="line">                if (a.x != b.x) &#123;</span><br><span class="line">                    return a.x - b.x;</span><br><span class="line">                &#125;</span><br><span class="line">                return a.y - b.y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        int x = island.get(0).x, y = island.get(0).y;</span><br><span class="line"></span><br><span class="line">        for (Point point : island) &#123;</span><br><span class="line">            sb.append((point.x - x) + &quot; &quot; + (point.y - y) + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个0和1的非空的二维数组网格，一个岛是一个1(表示陆地)的组，4个方向(水平或垂直)连接。你可以假设网格的所有四条边都被水包围。&lt;/p&gt;
&lt;p&gt;计算不同岛屿的数量。当一个岛被认为与另一个岛相同时，它们有相同的形状，或在旋转后的形状相同(90,180，或270度)或翻转(左/右方向或向上/向下方向)。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bread-first Search" scheme="http://yoursite.com/tags/Bread-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>694. 不同岛屿的数量</title>
    <link href="http://yoursite.com/2021/03/31/694.%20%E4%B8%8D%E5%90%8C%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>http://yoursite.com/2021/03/31/694. 不同岛屿的数量/</id>
    <published>2021-03-31T03:31:12.000Z</published>
    <updated>2021-03-31T09:12:36.395Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。</p><p>请你计算这个网格中共有多少个形状不同的岛屿。<br>两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p><a id="more"></a><p>样例 1:</p><pre><code>11000110000001100011</code></pre><p>给定上图，返回结果 1。</p><p>样例 2:</p><pre><code>11011100000000111011</code></pre><p>给定上图，返回结果 3。</p><p>注意:</p><pre><code>111</code></pre><p>和</p><pre><code> 111</code></pre><p>是不同的岛屿，因为我们不考虑旋转、翻转操作。</p><p>注释 :  二维数组每维的大小都不会超过50。</p><p>参见Lintcode<a href="https://www.lintcode.com/problem/860/" target="_blank" rel="noopener">^1</a></p><h2 id="题解BFS"><a href="#题解BFS" class="headerlink" title="题解BFS"></a>题解BFS</h2><p>我们可以通过BFS/DFS得到每一个岛屿，然后把每个岛屿的形状放到set里，最后set的大小就是答案。</p><p>那么问题的关键在于如何描述一个岛屿的形状。</p><p>有以下两个基本思路：</p><ol><li>记录一个岛屿所有点相对于左上角的点的相对位置。</li><li>记录一个岛屿的bfs/dfs轨迹</li></ol><p>方法1涉及细节较少，但是可能复杂度相对较高，不过50*50的数据范围不会超时。</p><p>方法1也有多种实现方法，比如一个岛屿形状可以用set记录，也可以将所有点的相对坐标排序后转换成字符串。</p><p>方法2需要注意一个细节：不能仅仅存储下来dfs/bfs移动的方向，因为涉及到回溯等问题，可以加上一定的间隔符，或者除方向之外额外记录一个位置信息。</p><details>    <summary>BFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if(grid.empty() || grid[0].empty()) return 0;</span><br><span class="line">        int m = grid.size(), n = grid[0].size(), i, j, k, x, y, x0, y0, nx, ny;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">        set&lt;vector&lt;vector&lt;int&gt;&gt;&gt; s;</span><br><span class="line">        for(i = 0; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        for(j = 0; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">        if(grid[i][j] == 0)</span><br><span class="line">        continue;</span><br><span class="line">        x0 = i, y0 = j;</span><br><span class="line">        queue&lt;vector&lt;int&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; path;</span><br><span class="line">        q.push(&#123;x0, y0&#125;);</span><br><span class="line">        grid[x0][y0] = 0;//访问过</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        x = q.front()[0];</span><br><span class="line">        y = q.front()[1];</span><br><span class="line">        path.push_back(&#123;x-x0, y-y0&#125;);//路径记录相对坐标</span><br><span class="line">        q.pop();</span><br><span class="line">        for(k = 0; k &lt; 4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">        nx = x + dir[k][0];</span><br><span class="line">        ny = y + dir[k][1];</span><br><span class="line">        if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny])</span><br><span class="line">        &#123;</span><br><span class="line">        q.push(&#123;nx, ny&#125;);</span><br><span class="line">        grid[nx][ny] = 0;//访问过</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(path);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="题解DFS"><a href="#题解DFS" class="headerlink" title="题解DFS"></a>题解DFS</h2><details>    <summary>DFS</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    int m, n;</span><br><span class="line">    set&lt;vector&lt;vector&lt;int&gt;&gt;&gt; s;</span><br><span class="line">public:</span><br><span class="line">    int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if(grid.empty() || grid[0].empty()) return 0;</span><br><span class="line">        m = grid.size(), n = grid[0].size();</span><br><span class="line">        for(int i = 0, j; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(j = 0; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[i][j] == 0)</span><br><span class="line">                    continue;</span><br><span class="line">                vector&lt;vector&lt;int&gt;&gt; path;</span><br><span class="line">                grid[i][j] = 0;//访问过</span><br><span class="line">                DFS(grid,i,j,i,j,path);</span><br><span class="line">                s.insert(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x0, int y0, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; path)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(&#123;x-x0, y-y0&#125;);//路径记录相对坐标</span><br><span class="line">        int k, nx, ny;</span><br><span class="line">        for(k = 0; k &lt; 4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            nx = x + dir[k][0];</span><br><span class="line">            ny = y + dir[k][1];</span><br><span class="line">            if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny])</span><br><span class="line">            &#123;</span><br><span class="line">                grid[nx][ny] = 0;//访问过</span><br><span class="line">                DFS(grid, x0, y0, nx, ny, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>DFS II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    /**</span><br><span class="line">     * @param grid: a list of lists of integers</span><br><span class="line">     * @return: return an integer, denote the number of distinct islands</span><br><span class="line">     */</span><br><span class="line">    int n, m, ix, iy;</span><br><span class="line">    set&lt;string&gt; S;</span><br><span class="line">    string temp;</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; vis;</span><br><span class="line">    int fx[4]=&#123;</span><br><span class="line">        1, -1, 0, 0</span><br><span class="line">    &#125;;</span><br><span class="line">    int fy[4]=&#123;</span><br><span class="line">        0, 0, 1, -1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int numberofDistinctIslands(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        n = grid.size();</span><br><span class="line">        m = grid[0].size();</span><br><span class="line">        vector&lt;bool&gt; p;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            p.push_back(false);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            vis.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1 &amp;&amp; !vis[i][j]) &#123;</span><br><span class="line">                    ix = i;</span><br><span class="line">                    iy = j;</span><br><span class="line">                    temp = &quot;&quot;;</span><br><span class="line">                    dfs(i, j, grid);</span><br><span class="line">                    S.insert(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return S.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        vis[x][y] = true;</span><br><span class="line">        temp += to_string(x - ix) + &quot;&quot; + to_string(y - iy);</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int nx = x + fx[i], ny = y + fy[i];</span><br><span class="line">            if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny] || grid[nx][ny] == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(nx, ny, grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。&lt;/p&gt;
&lt;p&gt;请你计算这个网格中共有多少个形状不同的岛屿。&lt;br&gt;两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bread-first Search" scheme="http://yoursite.com/tags/Bread-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>305. 岛屿数量 II</title>
    <link href="http://yoursite.com/2021/03/30/305.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%20II/"/>
    <id>http://yoursite.com/2021/03/30/305. 岛屿数量 II/</id>
    <published>2021-03-30T09:47:12.000Z</published>
    <updated>2021-03-31T03:29:02.064Z</updated>
    
    <content type="html"><![CDATA[<p>假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。</p><p>起始的时候，每个格子的地形都被默认标记为「水」。<br>我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。</p><p>你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。</p><a id="more"></a><p>注意：一个岛的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。<br>你可以假设地图网格的四边均被无边无际的「水」所包围。</p><p>请仔细阅读下方示例与解析，更加深入了解岛屿的判定。</p><p>示例:</p><pre><code>输入: m = 3, n = 3,     positions = [[0,0], [0,1], [1,2], [2,1]]输出: [1,1,2,3]解析:起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）0 0 00 0 00 0 0操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。1 0 00 0 0   Number of islands = 10 0 0操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。1 1 00 0 0   岛屿的数量为 10 0 0操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。1 1 00 0 1   岛屿的数量为 20 0 0操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。1 1 00 0 1   岛屿的数量为 30 1 0拓展：你是否能在 O(k log mn) 的时间复杂度程度内完成每次的计算？（k 表示 positions 的长度）</code></pre><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>题目在Lintcode上也有，参见<a href="https://www.lintcode.com/problem/434/" target="_blank" rel="noopener">^1</a></p><h1 id="题解（超时）"><a href="#题解（超时）" class="headerlink" title="题解（超时）"></a>题解（超时）</h1><p>将矩阵的每个位置看成并查集中的一个点，每次加入一个岛屿，把四周是1的点合并掉</p><p>计算集团个数</p><details>    <summary>题解（超时）</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class dsu</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; f;</span><br><span class="line"></span><br><span class="line">    dsu(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)</span><br><span class="line">            f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        int fa = find(a);</span><br><span class="line">        int fb = find(b);</span><br><span class="line">        f[fa] = fb;</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        int origin = a;</span><br><span class="line">        while(a != f[a])</span><br><span class="line">            a = f[a];</span><br><span class="line">        return f[origin] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    int countUni(vector&lt;vector&lt;int&gt;&gt; &amp;grid)</span><br><span class="line">    &#123;</span><br><span class="line">        int count = 0, x, y, n = grid[0].size();</span><br><span class="line">        for(int i = 0; i &lt; f.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = i/n, y = i-x*n;</span><br><span class="line">            if(i == find(i) &amp;&amp; grid[x][y]==1)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    int N = m*n, pos, x, y;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(m,vector&lt;int&gt;(n,0));</span><br><span class="line">    dsu u(N);</span><br><span class="line">    vector&lt;int&gt; ans(positions.size());</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    for(int i = 0, k; i &lt; positions.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            grid[positions[i][0]][positions[i][1]] = 1;//标记为岛屿</span><br><span class="line">            pos = positions[i][0]*n+positions[i][1];//对应并查集中的位置</span><br><span class="line">    for(k = 0; k &lt; 4; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">    x = positions[i][0] + dir[k][0];</span><br><span class="line">                y = positions[i][1] + dir[k][1];//周围坐标x,y</span><br><span class="line">    if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; grid[x][y]==1)</span><br><span class="line">    u.merge(pos, x*n+y);//合并</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = u.countUni(grid);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h1 id="题解（改进仍不能通过）"><a href="#题解（改进仍不能通过）" class="headerlink" title="题解（改进仍不能通过）"></a>题解（改进仍不能通过）</h1><p>并查集merge 函数返回是否被合并了，合并了数量就减1</p><p>注意有重复岛屿，不能算</p><p>这种算法改进后在lintcode上运行了一次还是超时，只能通过30%的样例</p><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class dsu</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; f;</span><br><span class="line">    dsu(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        f.resize(n);</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)</span><br><span class="line">            f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    bool merge(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        int fa = find(a);</span><br><span class="line">        int fb = find(b);</span><br><span class="line">        if(fa != fb)</span><br><span class="line">        &#123;</span><br><span class="line">            f[fa] = fb;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//返回是否被合并了</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        int origin = a;</span><br><span class="line">        while(a != f[a])</span><br><span class="line">            a = f[a];</span><br><span class="line">        return f[origin] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numIslands2(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123;</span><br><span class="line">    int N = m*n, pos, x, y;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(m,vector&lt;int&gt;(n,0));</span><br><span class="line">    dsu u(N);</span><br><span class="line">    vector&lt;int&gt; ans(positions.size());</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">        unordered_set&lt;int&gt; s;//有重复的岛屿！！！</span><br><span class="line">    for(int i = 0, k; i &lt; positions.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            ans[i] = (i&gt;0 ? ans[i-1] : 0 )+1;//先把这个岛屿算作孤立+1</span><br><span class="line">            grid[positions[i][0]][positions[i][1]] = 1;//标记为岛屿</span><br><span class="line">            pos = positions[i][0]*n+positions[i][1];//对应并查集中的位置</span><br><span class="line">            if(s.count(pos))//有该岛屿了，重复添加</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i]--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(pos);</span><br><span class="line">    for(k = 0; k &lt; 4; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">    x = positions[i][0] + dir[k][0];</span><br><span class="line">                y = positions[i][1] + dir[k][1];//周围坐标x,y</span><br><span class="line">    if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; grid[x][y]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(u.merge(pos, x*n+y))//合并了</span><br><span class="line">                        ans[i]--;//减1</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h1 id="题解（通过）"><a href="#题解（通过）" class="headerlink" title="题解（通过）"></a>题解（通过）</h1><p>构建数组nums表示所有位置对应岛屿的数字，初始化为0。遍历数组并将岛屿的值初始化为位置的值，此时岛屿数目+1，之后遍历此位置的邻接位置，若已经编号的岛屿，则将改岛屿的编号改为邻接岛屿编号，由于岛屿融合，岛屿的总数目-1。</p><details>    <summary>岛屿数量 II</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#ifndef C434_H</span><br><span class="line">#define C434_H</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">* 岛屿的个数II</span><br><span class="line">*</span><br><span class="line">* 给定 n，m，分别代表一个2D矩阵的行数和列数，同时，给定一个大小为 k 的二元数组A。起初，2D矩阵的行数和列数均为 0，即该矩阵中只有海洋。二元数组有 k 个运算符，每个运算符有 2 个整数 A[i].x, A[i].y，你可通过改变矩阵网格中的A[i].x]，[A[i].y] 来将其由海洋改为岛屿。请在每次运算后，返回矩阵中岛屿的数量。</span><br><span class="line">* 注意事项</span><br><span class="line">* 0 代表海，1 代表岛。如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</span><br><span class="line">* 样例</span><br><span class="line">* 给定 n = 3, m = 3， 二元数组 A = [(0,0),(0,1),(2,2),(2,1)].</span><br><span class="line">* 返回 [1,1,2,2].</span><br><span class="line">*/</span><br><span class="line">struct Point&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    Point() :x(0), y(0)&#123;&#125;</span><br><span class="line">    Point(int a, int b) :x(a), y(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">    * @param n: An integer</span><br><span class="line">    * @param m: An integer</span><br><span class="line">    * @param operators: an array of point</span><br><span class="line">    * @return: an integer array</span><br><span class="line">    */</span><br><span class="line">    vector&lt;int&gt; numIslands2(int n, int m, vector&lt;Point&gt; &amp;operators) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (n &lt;= 0 || m &lt;= 0 || operators.empty())</span><br><span class="line">            return res;</span><br><span class="line">        vector&lt;int&gt; nums(n*m + 1, 0);//下标表示岛屿位置</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dic&#123; &#123; 1, 0 &#125;, &#123; -1, 0 &#125;, &#123; 0, 1 &#125;, &#123; 0, -1 &#125; &#125;;//方便遍历上下左右四个位置</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (auto c : operators)</span><br><span class="line">        &#123;</span><br><span class="line">            int pos = c.x*m + c.y + 1;</span><br><span class="line">            //若nums[pos]不为0,则岛屿已经出现过,直接返回现有的岛屿数目</span><br><span class="line">            if (nums[pos] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //初始化nums[pos]为pos,表示pos最高层的岛屿是本身,此时岛屿数+1</span><br><span class="line">            nums[pos] = pos;</span><br><span class="line">            count++;</span><br><span class="line">            for (auto t : dic)</span><br><span class="line">            &#123;</span><br><span class="line">                int a = c.x + t[0];</span><br><span class="line">                int b = c.y + t[1];</span><br><span class="line">                int tmp = a*m + b + 1;</span><br><span class="line">                if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || nums[tmp] == 0)</span><br><span class="line">                    continue;</span><br><span class="line">                //tmp表示pos的相邻位置,root为tmp的最高层岛屿</span><br><span class="line">                //root!=pos表示pos与root并不属于同一个大岛屿,把pos并入root所在的大岛,</span><br><span class="line">                //nums[pos]=root,并将pos置为root避免重复计算,此时岛屿数目-1</span><br><span class="line">                int root = unionSearch(tmp, nums);</span><br><span class="line">                if (root != pos)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[pos] = root;</span><br><span class="line">                    pos = root;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(count);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //寻找root的最高层岛屿</span><br><span class="line">    int unionSearch(int root, vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        while (root != nums[root])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[root] = nums[nums[root]];</span><br><span class="line">            root = nums[root];</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。&lt;/p&gt;
&lt;p&gt;起始的时候，每个格子的地形都被默认标记为「水」。&lt;br&gt;我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。&lt;/p&gt;
&lt;p&gt;你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>572. 另一个树的子树</title>
    <link href="http://yoursite.com/2021/03/29/572.%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>http://yoursite.com/2021/03/29/572. 另一个树的子树/</id>
    <published>2021-03-29T12:55:12.000Z</published>
    <updated>2021-03-29T13:17:08.112Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><a id="more"></a><p>示例 1:</p><p>给定的树 s:</p><pre><code>    3   / \  4   5 / \1   2</code></pre><p>给定的树 t：</p><pre><code>   4   / \ 1   2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</code></pre><p>示例 2:</p><p>给定的树 s：</p><pre><code>    3   / \  4   5 / \1   2   /  0</code></pre><p>给定的树 t：</p><pre><code>   4  / \ 1   2返回 false。</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：深度优先搜索暴力匹配"><a href="#方法一：深度优先搜索暴力匹配" class="headerlink" title="方法一：深度优先搜索暴力匹配"></a>方法一：深度优先搜索暴力匹配</h2><p><strong>思路和算法</strong></p><p>这是一种最朴素的方法——深度优先搜索枚举 <em>s</em> 中的每一个节点，判断这个点的子树是否和 <em>t</em> 相等。如何判断一个节点的子树是否和 <em>t</em> 相等呢，我们又需要做一次深度优先搜索来检查，即让两个指针一开始先指向该节点和 <em>t</em> 的根，然后「同步移动」两根指针来「同步遍历」这两棵树，判断对应位置是否相等。</p><details>    <summary>深度优先搜索暴力匹配C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o &amp;&amp; !t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((o &amp;&amp; !t) || (!o &amp;&amp; t) || (o-&gt;val != t-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(o-&gt;left, t-&gt;left) &amp;&amp; check(o-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(o, t) || dfs(o-&gt;left, t) || dfs(o-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索暴力匹配Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s, t) || dfs(s.left, t) || dfs(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.val != t.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(s.left, t.left) &amp;&amp; check(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>深度优先搜索暴力匹配Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(a, b *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &amp;&amp; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> || b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a.Val == b.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> check(a.Left, b.Left) &amp;&amp; check(a.Right, b.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法二：深度优先搜索序列上做串匹配"><a href="#方法二：深度优先搜索序列上做串匹配" class="headerlink" title="方法二：深度优先搜索序列上做串匹配"></a>方法二：深度优先搜索序列上做串匹配</h2><p><strong>思路和算法</strong></p><p>这个方法需要我们先了解一个「小套路」：一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的。了解了这个「小套路」之后，我们可以确定解决这个问题的方向就是：把 <em>s</em> 和 <em>t</em> 先转换成深度优先搜索序列，然后看 <em>t</em> 的深度优先搜索序列是否是 <em>s</em> 的深度优先搜索序列的「子串」。</p><p><strong>这样做正确吗？</strong> 假设 <em>s</em> 由两个点组成，<em>1</em> 是根，<em>2</em> 是 <em>1</em> 的左孩子；<em>t</em> 也由两个点组成，<em>1</em> 是根，<em>2</em> 是 <em>1</em> 的右孩子。这样一来 <em>s</em> 和 <em>t</em> 的深度优先搜索序列相同，可是 <em>t</em> 并不是 <em>s</em> 的某一棵子树。由此可见「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」是「<em>t</em> 是 <em>s</em> 子树」的<strong>必要不充分条件</strong>，所以单纯这样做是不正确的。</p><p>为了解决这个问题，我们可以引入两个空值 <code>lNull</code> 和 <code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样深度优先搜索序列就唯一对应一棵树。处理完之后，就可以通过判断「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」来判断答案。</p><p><a href="https://assets.leetcode-cn.com/solution-static/572/572_fig1.png" target="_blank" rel="noopener">fig1</a></p><p>在判断「<em>s</em> 的深度优先搜索序列包含 <em>t</em> 的深度优先搜索序列」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法，在使用Rabin-Karp算法的时候，要注意串中可能有负值。</p><p>这里给出用KMP判断的代码实现。</p><details><summary>深度优先搜索序列上做串匹配C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sOrder, tOrder;</span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode *o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxElement = max(maxElement, o-&gt;val);</span><br><span class="line">        getMaxElement(o-&gt;left);</span><br><span class="line">        getMaxElement(o-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode *o, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar.push_back(o-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            getDfsOrder(o-&gt;left, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.push_back(lNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            getDfsOrder(o-&gt;right, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.push_back(rNull);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fail(tOrder.size(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; tOrder[i] != tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tOrder[i] == tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sOrder[i] != tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sOrder[i] == tOrder[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        maxElement = INT_MIN;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>深度优先搜索序列上做串匹配Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;Integer&gt; tOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        maxElement = Integer.MIN_VALUE;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxElement = Math.max(maxElement, t.val);</span><br><span class="line">        getMaxElement(t.left);</span><br><span class="line">        getMaxElement(t.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode t, List&lt;Integer&gt; tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar.add(t.val);</span><br><span class="line">        <span class="keyword">if</span> (t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getDfsOrder(t.left, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.add(lNull);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getDfsOrder(t.right, tar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tar.add(rNull);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[tOrder.size()];</span><br><span class="line">        Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = -<span class="number">1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; !(sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>)))) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sOrder.get(i).equals(tOrder.get(j + <span class="number">1</span>))) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>深度优先搜索序列上做串匹配Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    maxEle := math.MinInt32</span><br><span class="line">    getMaxElement(s, &amp;maxEle)</span><br><span class="line">    getMaxElement(t, &amp;maxEle)</span><br><span class="line">    lNull := maxEle + <span class="number">1</span>;</span><br><span class="line">    rNull := maxEle + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sl, tl := getDfsOrder(s, []<span class="keyword">int</span>&#123;&#125;, lNull, rNull), getDfsOrder(t, []<span class="keyword">int</span>&#123;&#125;, lNull, rNull)</span><br><span class="line">    <span class="keyword">return</span> kmp(sl, tl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(s, t []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sLen, tLen := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">    fail := <span class="built_in">make</span>([]<span class="keyword">int</span>, sLen)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sLen; i++ &#123;</span><br><span class="line">        fail[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">-1</span>; i &lt; tLen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; t[i] != t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> t[i] == t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        fail[i] = j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">-1</span>; i &lt; sLen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j != <span class="number">-1</span> &amp;&amp; s[i] != t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j = fail[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i] == t[j+<span class="number">1</span>] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == tLen - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDfsOrder</span><span class="params">(t *TreeNode, list []<span class="keyword">int</span>, lNull, rNull <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">    list = <span class="built_in">append</span>(list, t.Val)</span><br><span class="line">    <span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        list = getDfsOrder(t.Left, list, lNull, rNull)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, lNull)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        list = getDfsOrder(t.Right, list, lNull, rNull)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="built_in">append</span>(list, rNull)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxElement</span><span class="params">(t *TreeNode, maxEle *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.Val &gt; *maxEle &#123;</span><br><span class="line">        *maxEle = t.Val</span><br><span class="line">    &#125;</span><br><span class="line">    getMaxElement(t.Left, maxEle)</span><br><span class="line">    getMaxElement(t.Right, maxEle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="方法三：树哈希"><a href="#方法三：树哈希" class="headerlink" title="方法三：树哈希"></a>方法三：树哈希</h2><p><strong>思路和算法</strong></p><p>考虑把每个子树都映射成一个唯一的数，如果 <em>t</em> 对应的数字和 <em>s</em> 中任意一个子树映射的数字相等，则 <em>t</em> 是 <em>s</em> 的某一棵子树。如何映射呢？我们可以定义这样的哈希函数：</p><details><summary>树哈希C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1E9</span>) + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> p[MAX_N], tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>; tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) p[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> f, s; <span class="comment">// f 为哈希值 | s 为子树大小</span></span><br><span class="line">        Status(<span class="keyword">int</span> f_ = <span class="number">0</span>, <span class="keyword">int</span> s_ = <span class="number">0</span>) </span><br><span class="line">            : f(f_), s(s_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; hS, hT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *o, <span class="built_in">unordered_map</span> &lt;TreeNode *, Status&gt; &amp;h)</span> </span>&#123;</span><br><span class="line">        h[o] = Status(o-&gt;val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!o-&gt;left &amp;&amp; !o-&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) &#123;</span><br><span class="line">            dfs(o-&gt;left, h);</span><br><span class="line">            h[o].s += h[o-&gt;left].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">31L</span>L * h[o-&gt;left].f * p[h[o-&gt;left].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) &#123;</span><br><span class="line">            dfs(o-&gt;right, h);</span><br><span class="line">            h[o].s += h[o-&gt;right].s;</span><br><span class="line">            h[o].f = (h[o].f + (<span class="number">179L</span>L * h[o-&gt;right].f * p[h[o-&gt;right].s]) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT[t].f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: hS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.f == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>树哈希Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_N = <span class="number">1005</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_N];</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; hS = <span class="keyword">new</span> HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt;();</span><br><span class="line">    Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; hT = <span class="keyword">new</span> HashMap&lt;TreeNode, <span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        getPrime();</span><br><span class="line">        dfs(s, hS);</span><br><span class="line">        dfs(t, hT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tHash = hT.get(t)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;TreeNode, <span class="keyword">int</span>[]&gt; entry : hS.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()[<span class="number">0</span>] == tHash) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                p[++tot] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt; MAX_N; ++j) &#123;</span><br><span class="line">                vis[i * p[j]] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode o, Map&lt;TreeNode, <span class="keyword">int</span>[]&gt; h)</span> </span>&#123;</span><br><span class="line">        h.put(o, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;o.val, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span> (o.left == <span class="keyword">null</span> &amp;&amp; o.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(o.left, h);</span><br><span class="line">            <span class="keyword">int</span>[] val = h.get(o);</span><br><span class="line">            val[<span class="number">1</span>] += h.get(o.left)[<span class="number">1</span>];</span><br><span class="line">            val[<span class="number">0</span>] = (<span class="keyword">int</span>) ((val[<span class="number">0</span>] + (<span class="number">31L</span> * h.get(o.left)[<span class="number">0</span>] * p[h.get(o.left)[<span class="number">1</span>]]) % MOD) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(o.right, h);</span><br><span class="line">            <span class="keyword">int</span>[] val = h.get(o);</span><br><span class="line">            val[<span class="number">1</span>] += h.get(o.right)[<span class="number">1</span>];</span><br><span class="line">            val[<span class="number">0</span>] = (<span class="keyword">int</span>) ((val[<span class="number">0</span>] + (<span class="number">179L</span> * h.get(o.right)[<span class="number">0</span>] * p[h.get(o.right)[<span class="number">1</span>]]) % MOD) % MOD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="http://yoursite.com/2021/03/27/491.%20%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/27/491. 递增子序列/</id>
    <published>2021-03-27T13:17:12.000Z</published>
    <updated>2021-03-28T01:00:59.596Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。</p><a id="more"></a><p>示例：</p><pre><code>输入：[4, 6, 7, 7]输出：[[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</code></pre><p>提示：</p><pre><code>给定数组的长度不会超过15。数组中的整数范围是 [-100,100]。给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</code></pre><h1 id="方法一：二进制枚举-哈希"><a href="#方法一：二进制枚举-哈希" class="headerlink" title="方法一：二进制枚举 + 哈希"></a>方法一：二进制枚举 + 哈希</h1><p>这个方法比较难理解，可以参见<a href="https://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/" target="_blank" rel="noopener">^1</a>，</p><h1 id="方法二：递归枚举-减枝"><a href="#方法二：递归枚举-减枝" class="headerlink" title="方法二：递归枚举 + 减枝"></a>方法二：递归枚举 + 减枝</h1><p><strong>思路与算法</strong></p><p>我们也可以用递归的方法实现二进制枚举，像「方法一」那样枚举出所有的子序列，然后判断是否合法。直接把方法一变成递归形式，我们可以得到这样的代码：</p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.size()) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.push_back(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.add(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这是一个递归枚举子序列的通用模板.</p><p>当然，如果我们简单地这样枚举，对于每一个子序列，我们还需要做一次 <em>O(n)</em> 的合法性检查和哈希判重复，在执行整个程序的过程中，我们还需要使用一个空间代价 <em>O(2^n)</em> 的哈希表来维护已经出现的子序列的哈希值。我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的都是合法的并且不重复：</p><ul><li><p>使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的</p></li><li><p>那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：</p><ol><li><p>前者被选择，后者被选择</p></li><li><p>前者被选择，后者不被选择</p></li><li><p>前者不被选择，后者被选择</p></li><li><p>前者不被选择，后者不被选择</p><p>其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。</p></li></ol></li></ul><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">            temp.push_back(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, INT_MIN, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, Integer.MIN_VALUE, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">            temp.add(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** ans;</span><br><span class="line"><span class="keyword">int</span> ansSize;</span><br><span class="line"><span class="keyword">int</span>* temp;</span><br><span class="line"><span class="keyword">int</span> tempSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempSize &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ans[ansSize] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * tempSize);</span><br><span class="line">            <span class="built_in">memcpy</span>(ans[ansSize], temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * tempSize);</span><br><span class="line">            (*returnColumnSizes)[ansSize++] = tempSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">        temp[tempSize++] = nums[cur];</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums[cur], nums, numsSize, returnColumnSizes);</span><br><span class="line">        tempSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[cur] != last) &#123;</span><br><span class="line">        dfs(cur + <span class="number">1</span>, last, nums, numsSize, returnColumnSizes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">findSubsequences</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">32768</span>);</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">32768</span>);</span><br><span class="line">    temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    ansSize = tempSize = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, INT_MIN, nums, numsSize, returnColumnSizes);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    temp []<span class="keyword">int</span></span><br><span class="line">    ans [][]<span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubsequences</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ans = [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, math.MinInt32, nums)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(cur, last <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> cur == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            t := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(temp))</span><br><span class="line">            <span class="built_in">copy</span>(t, temp)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, t)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[cur] &gt;= last &#123;</span><br><span class="line">        temp = <span class="built_in">append</span>(temp, nums[cur])</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums[cur], nums)</span><br><span class="line">        temp = temp[:<span class="built_in">len</span>(temp)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[cur] != last &#123;</span><br><span class="line">        dfs(cur + <span class="number">1</span>, last, nums)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(2^n * n)  。仍然需要对子序列做二进制枚举，枚举出的序列虽然省去了判断合法性和哈希的过程，但是仍然需要 <em>O(n)</em> 的时间添加到答案中。</li><li>空间复杂度：<em>O(n)</em>。这里临时数组的空间代价是 <em>O(n)</em>，递归使用的栈空间的空间代价也是 <em>O(n)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Depth-first Search" scheme="http://yoursite.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="http://yoursite.com/2021/03/27/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://yoursite.com/2021/03/27/304. 二维区域和检索 - 矩阵不可变/</id>
    <published>2021-03-27T01:17:12.000Z</published>
    <updated>2021-03-27T02:09:08.055Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。</p><a id="more"></a><p>上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。</p><p>示例：</p><pre><code>给定 matrix = [  [3, 0, 1, 4, 2],  [5, 6, 3, 2, 1],  [1, 2, 0, 1, 5],  [4, 1, 0, 1, 7],  [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12</code></pre><p>提示：</p><pre><code>你可以假设矩阵不可变。会多次调用 sumRegion 方法。你可以假设 row1 ≤ row2 且 col1 ≤ col2 。</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看完题目要求先想到的当然就是双重循环直接求和了，而且还能通过。再一细想，其实可以直接计算每个点上以其作为左上角的到大矩阵右下角的矩形面积，保存起来后每次要求给定坐标的矩形面积时只需要把上下左右四个角的点保存的面积做个加减就可以了,但这样写完却在调用sumRegion方法很多的用例那里超时了。</p><details>    <summary>预处理左上角面积（超时）</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix &#123;</span><br><span class="line"></span><br><span class="line">    public int[][] sum;</span><br><span class="line">    public NumMatrix(int[][] matrix) &#123;</span><br><span class="line">        sum = new int[matrix.length][matrix[0].length];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; matrix[0].length; j++) &#123;</span><br><span class="line">                for (int k = i; k &lt; matrix.length; k++) &#123;</span><br><span class="line">                    for (int l = j; l &lt; matrix[0].length; l++) &#123;</span><br><span class="line">                        sum[i][j] += matrix[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">//                System.out.printf(&quot;%d &quot;, sum[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">//            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumRegion(int row1, int col1, int row2, int col2) &#123;</span><br><span class="line"></span><br><span class="line">        int leftBottom,rightTop,rightBottom;</span><br><span class="line">        leftBottom = (row2 + 1 &lt; sum.length) ? sum[row2 + 1][col1] : 0;</span><br><span class="line">        rightTop = (col2 + 1 &lt; sum[0].length) ? sum[row1][col2 + 1] : 0;</span><br><span class="line">        rightBottom = ((row2 + 1 &lt; sum.length) &amp;&amp; (col2 + 1 &lt; sum[0].length)) ? sum[row2 + 1][col2 + 1] : 0;</span><br><span class="line">        return sum[row1][col1] - leftBottom - rightTop + rightBottom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>考虑一下更好的方法可以保存一维前缀和或者二维前缀和<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/" target="_blank" rel="noopener">^1</a></p><p>这里的核心思想是保存以每个点作为右下角的位置，这样初识构造时循环时避免了四重循环，其实我上面的做法逆向循环也可以避免四重循环。更为重要的是，我上面的算法里之所以超时是因为在sumRegion里每次都要判断是否越界，所以可以定义一个大一号的数组来保存，这样就把判断的操作挪到读数组元素里了，用空间换时间。</p><details>    <summary>二维前缀和(预处理左上角面积)</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix &#123;</span><br><span class="line">    public int[][] sum;</span><br><span class="line">    public NumMatrix(int[][] matrix) &#123;</span><br><span class="line">        sum = new int[matrix.length+1][matrix[0].length+1];</span><br><span class="line">        for (int i = matrix.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = matrix[0].length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                sum[i][j] = matrix[i][j] + sum[i + 1][j] + sum[i][j + 1] - sum[i + 1][j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sumRegion(int row1, int col1, int row2, int col2) &#123;</span><br><span class="line">        return sum[row1][col1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row2 + 1][col2 + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>456. 132 模式</title>
    <link href="http://yoursite.com/2021/03/25/456.%20132%20%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/03/25/456. 132 模式/</id>
    <published>2021-03-25T07:29:12.000Z</published>
    <updated>2021-03-25T10:23:58.543Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</p><p>如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</p><a id="more"></a><p>进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？</p><p>示例 1：</p><pre><code>输入：nums = [1,2,3,4]输出：false解释：序列中不存在 132 模式的子序列。</code></pre><p>示例 2：</p><pre><code>输入：nums = [3,1,4,2]输出：true解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</code></pre><p>示例 3：</p><pre><code>输入：nums = [-1,3,2,0]输出：true解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</code></pre><p>提示：</p><pre><code>n == nums.length1 &lt;= n &lt;= 104-10^9 &lt;= nums[i] &lt;= 10^9</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于本题中 <em>n</em> 的最大值可以到 <em>15000*，因此对于一个满足 *132</em> 模式的三元组下标 <em>(i, j, k)*，枚举其中的 *2</em> 个下标时间复杂度为 <em>O(n^2)</em>，很容易超出时间限制。</p><p>因此我们可以考虑枚举其中的 <em>1</em> 个下标，并使用合适的数据结构维护另外的 <em>2</em> 个下标的可能值。</p><h1 id="方法一：枚举-3"><a href="#方法一：枚举-3" class="headerlink" title="方法一：枚举 3"></a>方法一：枚举 <em>3</em></h1><p><strong>思路与算法</strong></p><p>枚举 <em>3</em> 是容易想到并且也是最容易实现的。由于 <em>3</em> 是模式中的最大值，并且其出现在 <em>1</em> 和 <em>2</em> 的中间，因此我们只需要从左到右枚举 <em>3</em> 的下标 <em>j</em>，那么：</p><ul><li><p>由于 <em>1</em> 是模式中的最小值，因此我们在枚举 <em>j</em> 的同时，维护数组 <em>a</em> 中左侧元素 <em>a[0..j-1]</em> 的最小值，即为 <em>1</em> 对应的元素 <em>a[i]*。需要注意的是，只有 *a[i] &lt; a[j]</em> 时，<em>a[i]</em> 才能作为 <em>1</em> 对应的元素；</p></li><li><p>由于 <em>2</em> 是模式中的次小值，因此我们可以使用一个有序集合（例如平衡树）维护数组 <em>a</em> 中右侧元素 <em>a[j+1..n-1]</em> 中的所有值。当我们确定了 <em>a[i]</em> 和 <em>a[j]</em> 之后，只需要在有序集合中查询严格比 <em>a[i]</em> 大的那个最小的元素，即为 <em>a[k]*。需要注意的是，只有 *a[k] &lt; a[j]</em> 时，<em>a[k]</em> 才能作为 <em>3</em> 对应的元素。</p></li></ul><p><strong>代码</strong></p><p>下面的 Python 代码需要手动导入 sortedcontainers  库。</p><details>    <summary>枚举3 C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左侧最小值</span></span><br><span class="line">        <span class="keyword">int</span> left_min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 右侧所有元素</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; right_all;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            right_all.insert(nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left_min &lt; nums[j]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = right_all.upper_bound(left_min);</span><br><span class="line">                <span class="keyword">if</span> (it != right_all.end() &amp;&amp; *it &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left_min = min(left_min, nums[j]);</span><br><span class="line">            right_all.erase(right_all.find(nums[j + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举3 Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左侧最小值</span></span><br><span class="line">        <span class="keyword">int</span> leftMin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 右侧所有元素</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; rightAll = <span class="keyword">new</span> TreeMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            rightAll.put(nums[k], rightAll.getOrDefault(nums[k], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMin &lt; nums[j]) &#123;</span><br><span class="line">                Integer next = rightAll.ceilingKey(leftMin + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            leftMin = Math.min(leftMin, nums[j]);</span><br><span class="line">            rightAll.put(nums[j + <span class="number">1</span>], rightAll.get(nums[j + <span class="number">1</span>]) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (rightAll.get(nums[j + <span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">                rightAll.remove(nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举3 Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左侧最小值</span></span><br><span class="line">        left_min = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 右侧所有元素</span></span><br><span class="line">        right_all = SortedList(nums[<span class="number">2</span>:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> left_min &lt; nums[j]:</span><br><span class="line">                index = right_all.bisect_right(left_min)</span><br><span class="line">                <span class="keyword">if</span> index &lt; len(right_all) <span class="keyword">and</span> right_all[index] &lt; nums[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            left_min = min(left_min, nums[j])</span><br><span class="line">            right_all.remove(nums[j + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>枚举3 Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    ch       [<span class="number">2</span>]*node</span><br><span class="line">    priority <span class="keyword">int</span></span><br><span class="line">    val      <span class="keyword">int</span></span><br><span class="line">    cnt      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *node)</span> <span class="title">cmp</span><span class="params">(b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b &lt; o.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> b &gt; o.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *node)</span> <span class="title">rotate</span><span class="params">(d <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    x := o.ch[d^<span class="number">1</span>]</span><br><span class="line">    o.ch[d^<span class="number">1</span>] = x.ch[d]</span><br><span class="line">    x.ch[d] = o</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> treap <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> _<span class="title">put</span><span class="params">(o *node, val <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;node&#123;priority: rand.Int(), val: val, cnt: <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d := o.cmp(val); d &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        o.ch[d] = t._put(o.ch[d], val)</span><br><span class="line">        <span class="keyword">if</span> o.ch[d].priority &gt; o.priority &#123;</span><br><span class="line">            o = o.rotate(d ^ <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o.cnt++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> <span class="title">put</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t.root = t._put(t.root, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> _<span class="title">delete</span><span class="params">(o *node, val <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d := o.cmp(val); d &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        o.ch[d] = t._delete(o.ch[d], val)</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> o.cnt &gt; <span class="number">1</span> &#123;</span><br><span class="line">        o.cnt--</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> o.ch[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.ch[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> o.ch[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.ch[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    d := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> o.ch[<span class="number">0</span>].priority &gt; o.ch[<span class="number">1</span>].priority &#123;</span><br><span class="line">        d = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    o = o.rotate(d)</span><br><span class="line">    o.ch[d] = t._delete(o.ch[d], val)</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> <span class="title">delete</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t.root = t._delete(t.root, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *treap)</span> <span class="title">upperBound</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(ub *node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> o := t.root; o != <span class="literal">nil</span>; &#123;</span><br><span class="line">        <span class="keyword">if</span> o.cmp(val) == <span class="number">0</span> &#123;</span><br><span class="line">            ub = o</span><br><span class="line">            o = o.ch[<span class="number">0</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = o.ch[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find132pattern</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftMin := nums[<span class="number">0</span>]</span><br><span class="line">    rights := &amp;treap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums[<span class="number">2</span>:] &#123;</span><br><span class="line">        rights.put(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; leftMin &#123;</span><br><span class="line">            ub := rights.upperBound(leftMin)</span><br><span class="line">            <span class="keyword">if</span> ub != <span class="literal">nil</span> &amp;&amp; ub.val &lt; nums[j] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftMin = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">        rights.<span class="built_in">delete</span>(nums[j+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogn)  。在初始化时，我们需要 O(nlogn)  的时间将数组元素 <em>a[2..n-1]</em> 加入有序集合中。在枚举 <em>j</em> 时，维护左侧元素最小值的时间复杂度为 <em>O(1)*，将 *a[j+1]</em> 从有序集合中删除的时间复杂度为 O(logn)，总共需要枚举的次数为 <em>O(n)</em>，因此总时间复杂度为 O(nlogn) 。</p></li><li><p>空间复杂度：<em>O(n)</em>，即为有序集合存储右侧所有元素需要使用的空间。</p></li></ul><h1 id="方法二：枚举-1"><a href="#方法二：枚举-1" class="headerlink" title="方法二：枚举 1"></a>方法二：枚举 <em>1</em></h1><p><strong>思路与算法</strong></p><p>如果我们从左到右枚举 <em>1</em> 的下标 <em>i</em>，那么 <em>j, k</em> 的下标范围都是减少的，这样就不利于对它们进行维护。因此我们可以考虑从右到左枚举 <em>i</em>。</p><p>那么我们应该如何维护 <em>j, k</em> 呢？在 <em>132</em> 模式中，如果 <em>1&lt;2</em> 并且 <em>2&lt;3<em>，那么根据传递性，</em>1&lt;3</em> 也是成立的，那么我们可以使用下面的方法进行维护：</p><ul><li><p>我们使用一种数据结构维护所有遍历过的元素，它们作为 <em>2</em> 的候选元素。每当我们遍历到一个新的元素时，就将其加入数据结构中；</p></li><li><p>在遍历到一个新的元素的同时，我们可以考虑其是否可以作为 <em>3</em>。如果它作为 <em>3</em>，那么<strong>数据结构中所有严格小于它的元素都可以作为 <em>2</em></strong>，我们将这些元素全部从数据结构中移除，并且使用一个变量维护<strong>所有被移除的元素的最大值</strong>。这些被移除的元素都是可以真正作为 <em>2</em> 的，并且元素的值越大，那么我们之后找到 <em>1</em> 的机会也就越大。</p></li></ul><p>那么这个「数据结构」是什么样的数据结构呢？我们尝试提取出它进行的操作：</p><ul><li><p>它需要支持添加一个元素；</p></li><li><p>它需要支持移除所有严格小于给定阈值的所有元素；</p></li><li><p>上面两步操作是「依次进行」的，即我们先用给定的阈值移除元素，再将该阈值加入数据结构中。</p></li></ul><p>这就是「单调栈」。在单调栈中，从栈底到栈顶的元素是严格单调递减的。当给定阈值 <em>x</em> 时，我们只需要不断地弹出栈顶的元素，直到栈为空或者 <em>x</em> 严格小于栈顶元素。此时我们再将 <em>x</em> 入栈，这样就维护了栈的单调性。</p><p>因此，我们可以使用单调栈作为维护 <em>2</em> 的数据结构，并给出下面的算法：</p><ul><li><p>我们用单调栈维护所有可以作为 <em>2</em> 的候选元素。初始时，单调栈中只有唯一的元素a[n-1] 。我们还需要使用一个变量 max_k 记录所有可以真正作为 <em>2</em> 的元素的最大值；</p></li><li><p>随后我们从 <em>n-2</em> 开始从右到左枚举元素 <em>a[i]</em>：</p><ul><li><p>首先我们判断 <em>a[i]</em> 是否可以作为 <em>1</em>。如果 [a[i]&lt;max_k ，那么它就可以作为 <em>1</em>，我们就找到了一组满足 <em>132</em> 模式的三元组；</p></li><li><p>随后我们判断 <em>a[i]</em> 是否可以作为 <em>3</em>，以此找出哪些可以真正作为 <em>2</em> 的元素。我们将 <em>a[i]</em> 不断地与单调栈栈顶的元素进行比较，如果 <em>a[i]</em> 较大，那么栈顶元素可以真正作为 <em>2</em>，将其弹出并更新 max_k；</p></li><li><p>最后我们将 <em>a[i]</em> 作为 <em>2</em> 的候选元素放入单调栈中。这里可以进行一个优化，即如果a[i] &lt;= max_k ，那么我们也没有必要将 <em>a[i]</em> 放入栈中，因为即使它在未来被弹出，也不会将 max_k  更新为更大的值。</p></li></ul></li><li><p>在枚举完所有的元素后，如果仍未找到满足 <em>132</em> 模式的三元组，那就说明其不存在。</p></li></ul><h2 id="我的思路总结"><a href="#我的思路总结" class="headerlink" title="我的思路总结"></a>我的思路总结</h2><p>这个解法我看了几遍还是感觉很抽象，用自己的话总结一下就是用maxK来保存作为2的元素，单调栈里从栈顶到栈底是越来越大的，在while循环中的主要目的是找到一个nums[i]右侧比它小的最大元素，用它来作为2的元素maxK。这样后面的遍历中只要遇到一个比maxK小的元素就说明有了一个132的序列，while循环后把nums[i]放进单调栈，因为之前的while循环中已经把比maxK小的数都弹出栈了，所以这里放进单调栈就可以保证栈的顺序是单调的。后面的优化判断增大了阅读难度，一开始可以略去这个判断。</p><p><strong>代码</strong></p><details>    <summary>枚举1 C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; candidate_k;</span><br><span class="line">        candidate_k.push(nums[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> max_k = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; max_k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!candidate_k.empty() &amp;&amp; nums[i] &gt; candidate_k.top()) &#123;</span><br><span class="line">                max_k = candidate_k.top();</span><br><span class="line">                candidate_k.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max_k) &#123;</span><br><span class="line">                candidate_k.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; candidateK = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        candidateK.push(nums[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> maxK = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; maxK) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!candidateK.isEmpty() &amp;&amp; nums[i] &gt; candidateK.peek()) &#123;</span><br><span class="line">                maxK = candidateK.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxK) &#123;</span><br><span class="line">                candidateK.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        candidate_k = [nums[n - <span class="number">1</span>]]</span><br><span class="line">        max_k = float(<span class="string">"-inf"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; max_k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">while</span> candidate_k <span class="keyword">and</span> nums[i] &gt; candidate_k[<span class="number">-1</span>]:</span><br><span class="line">                max_k = candidate_k[<span class="number">-1</span>]</span><br><span class="line">                candidate_k.pop()</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; max_k:</span><br><span class="line">                candidate_k.append(nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find132pattern = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> candidate_k = [nums[n - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">let</span> max_k = -<span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; max_k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (candidate_k.length &amp;&amp; nums[i] &gt; candidate_k[candidate_k.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            max_k = candidate_k[candidate_k.length - <span class="number">1</span>];</span><br><span class="line">            candidate_k.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max_k) &#123;</span><br><span class="line">            candidate_k.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find132pattern</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    candidateK := []<span class="keyword">int</span>&#123;nums[n<span class="number">-1</span>]&#125;</span><br><span class="line">    maxK := math.MinInt64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; maxK &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(candidateK) &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; candidateK[<span class="built_in">len</span>(candidateK)<span class="number">-1</span>] &#123;</span><br><span class="line">            maxK = candidateK[<span class="built_in">len</span>(candidateK)<span class="number">-1</span>]</span><br><span class="line">            candidateK = candidateK[:<span class="built_in">len</span>(candidateK)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; maxK &#123;</span><br><span class="line">            candidateK = <span class="built_in">append</span>(candidateK, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举1 C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numsSize;</span><br><span class="line">    <span class="keyword">int</span> candidate_k[n], top = <span class="number">0</span>;</span><br><span class="line">    candidate_k[top++] = nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max_k = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; max_k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; nums[i] &gt; candidate_k[top - <span class="number">1</span>]) &#123;</span><br><span class="line">            max_k = candidate_k[--top];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max_k) &#123;</span><br><span class="line">            candidate_k[top++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，枚举 *i</em> 的次数为 <em>O(n)</em>，由于每一个元素最多被加入和弹出单调栈各一次，因此操作单调栈的时间复杂度一共为 <em>O(n)</em>，总时间复杂度为 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(n)</em>，即为单调栈需要使用的空间。</p></li></ul><h1 id="方法三：枚举-2"><a href="#方法三：枚举-2" class="headerlink" title="方法三：枚举 2"></a>方法三：枚举 <em>2</em></h1><p><strong>说明</strong></p><p>方法三思路难度较大，需要在单调栈上进行二分查找。建议读者在完全理解方法二之后，再尝试阅读该方法。</p><p><strong>思路与算法</strong></p><p>当我们枚举 <em>2</em> 的下标 <em>k</em> 时，与方法二相反，从左到右进行枚举的方法是十分合理的：在枚举的过程中，<em>i, j</em> 的下标范围都是增加的。</p><p>由于我们需要保证 <em>1&lt;2</em> 并且 <em>2&lt;3*，那么我们需要维护一系列尽可能小的元素作为 *1</em> 的候选元素，并且维护一系列尽可能大的元素作为 <em>3</em> 的候选元素。</p><p>我们可以分情况进行讨论，假设当前有一个小元素 <em>x_i</em> 以及一个大元素 <em>x_j</em> 表示一个二元组，而我们当前遍历到了一个新的元素 <em>x=a[k]</em>，那么：</p><ul><li><p>如果 <em>x &gt; x_j*，那么让 *x</em> 作为 <em>3</em> 显然是比 <em>x_j</em> 作为 <em>3</em> 更优，因此我们可以用 <em>x</em> 替代 <em>x_j</em>；</p></li><li><p>如果 <em>x &lt; x_i*，那么让 *x</em> 作为 <em>1</em> 显然是比 <em>x_i</em> 作为 <em>3</em> 更优，然而我们必须要满足 <em>132</em> 模式中的顺序，即 <em>1</em> 出现在 <em>3</em> 之前，这里如果我们简单地用 <em>x</em> 替代 <em>x_i*，那么 *x_i=x</em> 作为 <em>1</em> 是出现在 <em>x_j</em> 作为 <em>3</em> 之后的，这并不满足要求。因此我们需要为 <em>x</em> 找一个新的元素作为 <em>3</em>。由于我们还没有遍历到后面的元素，因此可以简单地将 <em>x</em> 同时看作一个二元组的 <em>x_i</em> 和 <em>x_j</em>；</p></li><li><p>对于其它的情况，xi&lt;=x&lt;=xj ，<em>x</em> 无论作为 <em>1</em> 还是 <em>3</em> 都没有当前二元组对应的要优，因此我们可以不用考虑 <em>x</em> 作为 <em>1</em> 或者 <em>3</em> 的情况。</p></li></ul><p>这样一来，与方法二类似，我们使用两个单调递减的单调栈维护一系列二元组 <em>(x_i, x_j)*，表示一个可以选择的 *1-3</em> 区间，并且从栈底到栈顶 <em>x_i</em> 和 <em>x_j</em> 分别严格单调递减，因为根据上面的讨论，我们只有在 <em>x &lt; x_i</em> 时才会增加一个新的二元组。</p><p>然而与方法二不同的是，如果我们想让 <em>x</em> 作为 <em>2</em>，那么我们并不知道到底应该选择单调栈中的哪个 <em>1-3</em> 区间，因此我们只能根据单调性进行二分查找：</p><ul><li><p>对于单调栈中的 <em>x_i*，我们需要找出第一个满足 *x_i &lt; x</em> 的位置 idx_i ，这样从该位置到栈顶的所有二元组都满足 <em>x_i &lt; x</em>；</p></li><li><p>对于单调栈中的 <em>x_j*，我们需要找出最后一个满足 *x_j &gt; x</em> 的位置 idx_j ，这样从栈底到该位置的所有二元组都满足 <em>x_j &gt; x</em>；</p></li><li><p>如果 idx_i  和 idx_j  都存在，并且idx_i&lt;idx_j ，那么就存在至少一个二元组 <em>(x_i, x_j)</em> 满足 <em>x_i &lt; x &lt; x_j<em>，</em>x</em> 就可以作为 <em>2</em>，我们就找到了一组满足 <em>132</em> 模式的三元组。</p></li></ul><p>在枚举完所有的元素后，如果仍未找到满足 <em>132</em> 模式的三元组，那就说明其不存在。</p><p><strong>代码</strong></p><p>需要注意的是，我们是在<strong>单调递减的栈上进行二分查找</strong>，因此大部分语言都需要实现一个自定义比较函数，或者将栈中的元素取相反数后再使用默认的比较函数。</p><details>    <summary>枚举2 C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidate_i = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidate_j = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it_i = upper_bound(candidate_i.begin(), candidate_i.end(), nums[k], greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">auto</span> it_j = lower_bound(candidate_j.begin(), candidate_j.end(), nums[k], greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">if</span> (it_i != candidate_i.end() &amp;&amp; it_j != candidate_j.begin()) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx_i = it_i - candidate_i.begin();</span><br><span class="line">                <span class="keyword">int</span> idx_j = it_j - candidate_j.begin() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (idx_i &lt;= idx_j) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; candidate_i.back()) &#123;</span><br><span class="line">                candidate_i.push_back(nums[k]);</span><br><span class="line">                candidate_j.push_back(nums[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidate_j.back()) &#123;</span><br><span class="line">                <span class="keyword">int</span> last_i = candidate_i.back();</span><br><span class="line">                <span class="keyword">while</span> (!candidate_j.empty() &amp;&amp; nums[k] &gt; candidate_j.back()) &#123;</span><br><span class="line">                    candidate_i.pop_back();</span><br><span class="line">                    candidate_j.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                candidate_i.push_back(last_i);</span><br><span class="line">                candidate_j.push_back(nums[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; candidateI = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        candidateI.add(nums[<span class="number">0</span>]);</span><br><span class="line">        List&lt;Integer&gt; candidateJ = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        candidateJ.add(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> idxI = binarySearchFirst(candidateI, nums[k]);</span><br><span class="line">            <span class="keyword">int</span> idxJ = binarySearchLast(candidateJ, nums[k]);</span><br><span class="line">            <span class="keyword">if</span> (idxI &gt;= <span class="number">0</span> &amp;&amp; idxJ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (idxI &lt;= idxJ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; candidateI.get(candidateI.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                candidateI.add(nums[k]);</span><br><span class="line">                candidateJ.add(nums[k]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidateJ.get(candidateJ.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastI = candidateI.get(candidateI.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (!candidateJ.isEmpty() &amp;&amp; nums[k] &gt; candidateJ.get(candidateJ.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                    candidateI.remove(candidateI.size() - <span class="number">1</span>);</span><br><span class="line">                    candidateJ.remove(candidateJ.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                candidateI.add(lastI);</span><br><span class="line">                candidateJ.add(nums[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(List&lt;Integer&gt; candidate, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = candidate.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (candidate.get(high) &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">int</span> num = candidate.get(mid);</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(List&lt;Integer&gt; candidate, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = candidate.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (candidate.get(low) &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">int</span> num = candidate.get(mid);</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 Python</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        candidate_i, candidate_j = [-nums[<span class="number">0</span>]], [-nums[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            idx_i = bisect.bisect_right(candidate_i, -v)</span><br><span class="line">            idx_j = bisect.bisect_left(candidate_j, -v)</span><br><span class="line">            <span class="keyword">if</span> idx_i &lt; idx_j:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> v &lt; -candidate_i[<span class="number">-1</span>]:</span><br><span class="line">                candidate_i.append(-v)</span><br><span class="line">                candidate_j.append(-v)</span><br><span class="line">            <span class="keyword">elif</span> v &gt; -candidate_j[<span class="number">-1</span>]:</span><br><span class="line">                last_i = -candidate_i[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">while</span> candidate_j <span class="keyword">and</span> v &gt; -candidate_j[<span class="number">-1</span>]:</span><br><span class="line">                    candidate_i.pop()</span><br><span class="line">                    candidate_j.pop()</span><br><span class="line">                candidate_i.append(-last_i)</span><br><span class="line">                candidate_j.append(-v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find132pattern = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> candidateI = [nums[<span class="number">0</span>]], candidateJ = [nums[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">const</span> idxI = binarySearchFirst(candidateI, nums[k]);</span><br><span class="line">        <span class="keyword">const</span> idxJ = binarySearchLast(candidateJ, nums[k]);</span><br><span class="line">        <span class="keyword">if</span> (idxI &gt;= <span class="number">0</span> &amp;&amp; idxJ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idxI &lt;= idxJ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[k] &lt; candidateI[candidateI.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            candidateI.push(nums[k]);</span><br><span class="line">            candidateJ.push(nums[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidateJ[candidateJ.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> lastI = candidateI[candidateI.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (candidateJ.length &amp;&amp; nums[k] &gt; candidateJ[candidateJ.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                candidateI.pop();</span><br><span class="line">                candidateJ.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            candidateI.push(lastI);</span><br><span class="line">            candidateJ.push(nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> binarySearchFirst = <span class="function">(<span class="params">candidate, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>, high = candidate.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (candidate[high] &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((high - low) / <span class="number">2</span>) + low;</span><br><span class="line">        <span class="keyword">const</span> num = candidate[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> binarySearchLast = <span class="function">(<span class="params">candidate, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>, high = candidate.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (candidate[low] &lt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((high - low + <span class="number">1</span>) / <span class="number">2</span>) + low;</span><br><span class="line">        <span class="keyword">const</span> num = candidate[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 Golang</summary><figure class="highlight go"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find132pattern</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    candidateI, candidateJ := []<span class="keyword">int</span>&#123;-nums[<span class="number">0</span>]&#125;, []<span class="keyword">int</span>&#123;-nums[<span class="number">0</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        idxI := sort.SearchInts(candidateI, <span class="number">1</span>-v)</span><br><span class="line">        idxJ := sort.SearchInts(candidateJ, -v)</span><br><span class="line">        <span class="keyword">if</span> idxI &lt; idxJ &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v &lt; -candidateI[<span class="built_in">len</span>(candidateI)<span class="number">-1</span>] &#123;</span><br><span class="line">            candidateI = <span class="built_in">append</span>(candidateI, -v)</span><br><span class="line">            candidateJ = <span class="built_in">append</span>(candidateJ, -v)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> v &gt; -candidateJ[<span class="built_in">len</span>(candidateJ)<span class="number">-1</span>] &#123;</span><br><span class="line">            lastI := -candidateI[<span class="built_in">len</span>(candidateI)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">len</span>(candidateJ) &gt; <span class="number">0</span> &amp;&amp; v &gt; -candidateJ[<span class="built_in">len</span>(candidateJ)<span class="number">-1</span>] &#123;</span><br><span class="line">                candidateI = candidateI[:<span class="built_in">len</span>(candidateI)<span class="number">-1</span>]</span><br><span class="line">                candidateJ = candidateJ[:<span class="built_in">len</span>(candidateJ)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            candidateI = <span class="built_in">append</span>(candidateI, -lastI)</span><br><span class="line">            candidateJ = <span class="built_in">append</span>(candidateJ, -v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>枚举2 C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span>* vec, <span class="keyword">int</span> vecSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = vecSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (vec[high] &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">int</span> num = vec[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>* vec, <span class="keyword">int</span> vecSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = vecSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (vec[low] &lt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">int</span> num = vec[mid];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numsSize;</span><br><span class="line">    <span class="keyword">int</span> candidate_i[n], top_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> candidate_j[n], top_j = <span class="number">0</span>;</span><br><span class="line">    candidate_i[top_i++] = nums[<span class="number">0</span>];</span><br><span class="line">    candidate_j[top_j++] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> it_i = upper_bound(candidate_i, top_i, nums[k]);</span><br><span class="line">        <span class="keyword">int</span> it_j = lower_bound(candidate_j, top_j, nums[k]);</span><br><span class="line">        <span class="keyword">if</span> (it_i != <span class="number">-1</span> &amp;&amp; it_j != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it_i &lt;= it_j) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[k] &lt; candidate_i[top_i - <span class="number">1</span>]) &#123;</span><br><span class="line">            candidate_i[top_i++] = nums[k];</span><br><span class="line">            candidate_j[top_j++] = nums[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] &gt; candidate_j[top_j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> last_i = candidate_i[top_i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (top_j &amp;&amp; nums[k] &gt; candidate_j[top_j - <span class="number">1</span>]) &#123;</span><br><span class="line">                top_j--, top_i--;</span><br><span class="line">            &#125;</span><br><span class="line">            candidate_i[top_i++] = last_i;</span><br><span class="line">            candidate_j[top_j++] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlogn) ，枚举 <em>i</em> 的次数为 <em>O(n)</em>，由于每一个元素最多被加入和弹出单调栈各一次，因此操作单调栈的时间复杂度一共为 <em>O(n)</em>。二分查找的单次时间为 O(logn)  ，一共为 O(nlogn)，总时间复杂度为O(nlogn) 。</p></li><li><p>空间复杂度：<em>O(n)</em>，即为单调栈需要使用的空间。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在上面的三种方法中，方法二的时间复杂度为 <em>O(n)</em>，最优秀。而剩余的两种时间复杂度为O(nlogn)  的方法中，方法一相较于方法三，无论从理解还是代码编写层面来说都更容易一些。那么为什么还要介绍方法三呢？这里我们可以发现方法一和方法二的不足：</p><ul><li><p>方法一需要提前知道整个数组，否则就无法使用有序集合维护右侧元素了；</p></li><li><p>方法二是从后向前遍历的，本质上也同样需要提前知道整个数组。</p></li></ul><p>而方法三是从前向后遍历的，并且维护的数据结构不依赖于后续未知的元素，因此如果数组是以「数据流」的形式给出的，那么方法三是唯一可以继续使用的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &amp;lt; j &amp;lt; k 和 nums[i] &amp;lt; nums[k] &amp;lt; nums[j] 。&lt;/p&gt;
&lt;p&gt;如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>1188 设计有限阻塞队列</title>
    <link href="http://yoursite.com/2021/03/18/1188%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/18/1188 设计有限阻塞队列/</id>
    <published>2021-03-18T08:52:12.000Z</published>
    <updated>2021-03-25T07:30:56.051Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个拥有如下方法的线程安全有限阻塞队列：</p><a id="more"></a><ul><li>BoundedBlockingQueue(int capacity) 构造方法初始化队列，其中capacity代表队列长度上限。</li><li>void enqueue(int element) 在队首增加一个element. 如果队列满，调用线程被阻塞直到队列非满。</li><li>int dequeue() 返回队尾元素并从队列中将其删除. 如果队列为空，调用线程被阻塞直到队列非空。</li><li>int size() 返回当前队列元素个数。</li></ul><p>你的实现将会被多线程同时访问进行测试。每一个线程要么是一个只调用enqueue方法的生产者线程，要么是一个只调用dequeue方法的消费者线程。size方法将会在每一个测试用例之后进行调用。<br>请不要使用内置的有限阻塞队列实现，否则面试将不会通过。</p><p>示例 1:</p><p>输入:</p><pre><code>11[“BoundedBlockingQueue”,“enqueue”,“dequeue”,“dequeue”,“enqueue”,“enqueue”,“enqueue”,“enqueue”,“dequeue”][[2],[1],[],[],[0],[2],[3],[4],[]]</code></pre><p>输出:</p><pre><code>[1,0,2,2]</code></pre><p>解释:</p><pre><code>生产者线程数目 = 1消费者线程数目 = 1BoundedBlockingQueue queue = new BoundedBlockingQueue(2); // 使用capacity = 2初始化队列。queue.enqueue(1); // 生产者线程将1插入队列。queue.dequeue(); // 消费者线程调用dequeue并返回1。queue.dequeue(); // 由于队列为空，消费者线程被阻塞。queue.enqueue(0); // 生产者线程将0插入队列。消费者线程被解除阻塞同时将0弹出队列并返回。queue.enqueue(2); // 生产者线程将2插入队列。queue.enqueue(3); // 生产者线程将3插入队列。queue.enqueue(4); // 生产者线程由于队列长度已达到上限2而被阻塞。queue.dequeue(); // 消费者线程将2从队列弹出并返回。生产者线程解除阻塞同时将4插入队列。queue.size(); // 队列中还有2个元素。size()方法在每组测试用例最后调用。</code></pre><p>示例 2:<br>输入:</p><pre><code>34[“BoundedBlockingQueue”,“enqueue”,“enqueue”,“enqueue”,“dequeue”,“dequeue”,“dequeue”,“enqueue”][[3],[1],[0],[2],[],[],[],[3]]</code></pre><p>输出:</p><pre><code>[1,0,2,1]</code></pre><p>解释:</p><pre><code>生产者线程数目 = 3消费者线程数目 = 4BoundedBlockingQueue queue = new BoundedBlockingQueue(3); // 使用capacity = 3初始化队列。queue.enqueue(1); // 生产者线程P1将1插入队列。queue.enqueue(0); // 生产者线程P2将0插入队列。queue.enqueue(2); // 生产者线程P3将2插入队列。queue.dequeue(); // 消费者线程C1调用dequeue。queue.dequeue(); // 消费者线程C2调用dequeue。queue.dequeue(); // 消费者线程C3调用dequeue。queue.enqueue(3); // 其中一个生产者线程将3插入队列。queue.size(); // 队列中还有1个元素。由于生产者/消费者线程的数目可能大于1，我们并不知道线程如何被操作系统调度，即使输入看上去隐含了顺序。因此任意一种输出[1,0,2]或[1,2,0]或[0,1,2]或[0,2,1]或[2,0,1]或[2,1,0]都可被接受。</code></pre><details><summary>示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBlockingQueue &#123;</span><br><span class="line"></span><br><span class="line">    public BoundedBlockingQueue(int capacity) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void enqueue(int element) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int dequeue() throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int size() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><details><summary>题解</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBlockingQueue &#123;</span><br><span class="line">    </span><br><span class="line">    private final LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 队列是否为空的条件</span><br><span class="line">    private final Condition notEmpty = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    // 队列是否已满的条件</span><br><span class="line">    private final Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedBlockingQueue(int capacity) &#123;</span><br><span class="line">        queue = new LinkedList&lt;&gt;();</span><br><span class="line">        this.count = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      public int size() &#123;</span><br><span class="line">        return queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enqueue(Integer e) throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == queue.size())</span><br><span class="line">                notFull.await();</span><br><span class="line">            queue.addFirst(e);</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dequeue() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (queue.size() == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Integer e = queue.removeLast();</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个拥有如下方法的线程安全有限阻塞队列：&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1242.多线程网页爬虫</title>
    <link href="http://yoursite.com/2021/03/18/1242.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2021/03/18/1242.多线程网页爬虫/</id>
    <published>2021-03-18T06:52:12.000Z</published>
    <updated>2021-03-19T08:26:46.154Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个初始地址 startUrl 和一个 HTML 解析器接口 HtmlParser，请你实现一个 多线程的网页爬虫，用于获取与 startUrl 有 相同主机名 的所有链接。 </p><p>以 任意 顺序返回爬虫获取的路径。</p><p>爬虫应该遵循：</p><p>从 startUrl 开始<br>调用 HtmlParser.getUrls(url) 从指定网页路径获得的所有路径。<br>不要抓取相同的链接两次。<br>仅浏览与 startUrl 相同主机名 的链接。</p><a id="more"></a><p>如上图所示，主机名是 example.org 。简单起见，你可以假设所有链接都采用 http 协议，并且没有指定 端口号。举个例子，链接 <a href="http://leetcode.com/problems" target="_blank" rel="noopener">http://leetcode.com/problems</a> 和链接 <a href="http://leetcode.com/contest" target="_blank" rel="noopener">http://leetcode.com/contest</a> 属于同一个 主机名， 而 <a href="http://example.org/test" target="_blank" rel="noopener">http://example.org/test</a> 与 <a href="http://example.com/abc" target="_blank" rel="noopener">http://example.com/abc</a> 并不属于同一个 主机名。</p><p>HtmlParser 的接口定义如下：</p><pre><code>interface HtmlParser {  // Return a list of all urls from a webpage of given url.  // This is a blocking call, that means it will do HTTP request and return when this request is finished.  public List&lt;String&gt; getUrls(String url);}</code></pre><p>注意一点，getUrls(String url) 模拟执行一个HTTP的请求。 你可以将它当做一个阻塞式的方法，直到请求结束。 getUrls(String url) 保证会在 15ms 内返回所有的路径。 单线程的方案会超过时间限制，你能用多线程方案做的更好吗？</p><p>对于问题所需的功能，下面提供了两个例子。为了方便自定义测试，你可以声明三个变量 urls，edges 和 startUrl。但要注意你只能在代码中访问 startUrl，并不能直接访问 urls 和 edges。</p><p>拓展问题：</p><p>假设我们要要抓取 10000 个节点和 10 亿个路径。并且在每个节点部署相同的的软件。软件可以发现所有的节点。我们必须尽可能减少机器之间的通讯，并确保每个节点负载均衡。你将如何设计这个网页爬虫？<br>如果有一个节点发生故障不工作该怎么办？<br>如何确认爬虫任务已经完成？</p><p>示例 1：</p><pre><code>输入：urls = [  &quot;http://news.yahoo.com&quot;,  &quot;http://news.yahoo.com/news&quot;,  &quot;http://news.yahoo.com/news/topics/&quot;,  &quot;http://news.google.com&quot;,  &quot;http://news.yahoo.com/us&quot;]edges = [[2,0],[2,1],[3,2],[3,1],[0,4]]startUrl = &quot;http://news.yahoo.com/news/topics/&quot;输出：[  &quot;http://news.yahoo.com&quot;,  &quot;http://news.yahoo.com/news&quot;,  &quot;http://news.yahoo.com/news/topics/&quot;,  &quot;http://news.yahoo.com/us&quot;]</code></pre><p>示例 2：</p><pre><code>输入：urls = [  &quot;http://news.yahoo.com&quot;,  &quot;http://news.yahoo.com/news&quot;,  &quot;http://news.yahoo.com/news/topics/&quot;,  &quot;http://news.google.com&quot;]edges = [[0,2],[2,1],[3,2],[3,1],[3,0]]startUrl = &quot;http://news.google.com&quot;输出：[&quot;http://news.google.com&quot;]解释：startUrl 链接与其他页面不共享一个主机名。</code></pre><p>提示：</p><p>1 &lt;= urls.length &lt;= 1000<br>1 &lt;= urls[i].length &lt;= 300</p><p>startUrl 是 urls 中的一个。<br>主机名的长度必须为 1 到 63 个字符（包括点 . 在内），只能包含从 “a” 到 “z” 的 ASCII 字母和 “0” 到 “9” 的数字，以及中划线 “-”。<br>主机名开头和结尾不能是中划线 “-”。</p><p>参考资料：<a href="https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames</a><br>你可以假设路径都是不重复的。</p><details><summary>示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the HtmlParser&apos;s API interface.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * interface HtmlParser &#123;</span><br><span class="line"> *     public List&lt;String&gt; getUrls(String url) &#123;&#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; crawl(String startUrl, HtmlParser htmlParser) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>解法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    private final Set&lt;String&gt; set = Collections.newSetFromMap(new ConcurrentHashMap&lt;String, Boolean&gt;());</span><br><span class="line">    private final List&lt;String&gt; result = Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br><span class="line">    private String HOSTNAME = null;</span><br><span class="line"></span><br><span class="line">    public boolean judgeHostname(String url) &#123;</span><br><span class="line">        int idx = url.indexOf(&apos;/&apos;, 7);</span><br><span class="line">        String hostName = (idx != -1) ? url.substring(0, idx) : url;</span><br><span class="line">        return hostName.equals(HOSTNAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initHostName(String url) &#123;</span><br><span class="line">        int idx = url.indexOf(&apos;/&apos;, 7);</span><br><span class="line">        HOSTNAME = (idx != -1) ? url.substring(0, idx) : url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getUrl(String startUrl, HtmlParser htmlParser) &#123;</span><br><span class="line">        result.add(startUrl);</span><br><span class="line">        List&lt;String&gt; res = htmlParser.getUrls(startUrl);</span><br><span class="line">        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();</span><br><span class="line">        for (String url : res) &#123;</span><br><span class="line">            if (judgeHostname(url) &amp;&amp; !set.contains(url)) &#123;</span><br><span class="line">                set.add(url);</span><br><span class="line">                threads.add(new Thread(() -&gt; &#123;</span><br><span class="line">                    getUrl(url, htmlParser);</span><br><span class="line">                &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Thread thread : threads) &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; crawl(String startUrl, HtmlParser htmlParser) &#123;</span><br><span class="line">        initHostName(startUrl);</span><br><span class="line">        set.add(startUrl);</span><br><span class="line">        getUrl(startUrl, htmlParser);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Thread-join-详解"><a href="#Thread-join-详解" class="headerlink" title="Thread.join()详解"></a>Thread.join()详解</h2><p>上面的代码里用到了join方法，join是Thread类的一个方法，启动线程后直接调用。</p><h3 id="为什么要用join-方法"><a href="#为什么要用join-方法" class="headerlink" title="为什么要用join()方法"></a>为什么要用join()方法</h3><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><h3 id="join方法的作用"><a href="#join方法的作用" class="headerlink" title="join方法的作用"></a>join方法的作用</h3><p>在JDk的API里对于join()方法是：</p><pre><code>joinpublic final void join() throws InterruptedException Waits for this thread to die. Throws: InterruptedException  - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.</code></pre><p>即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p><details>    <summary>join方法示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class BThread extends Thread &#123;</span><br><span class="line">    public BThread() &#123;</span><br><span class="line">        super(&quot;[BThread] Thread&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                System.out.println(threadName + &quot; loop at &quot; + i);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadName + &quot; end.&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from &quot; + threadName + &quot;.run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AThread extends Thread &#123;</span><br><span class="line">    BThread bt;</span><br><span class="line">    public AThread(BThread bt) &#123;</span><br><span class="line">        super(&quot;[AThread] Thread&quot;);</span><br><span class="line">        this.bt = bt;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            bt.join();</span><br><span class="line">            System.out.println(threadName + &quot; end.&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from &quot; + threadName + &quot;.run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        BThread bt = new BThread();</span><br><span class="line">        AThread at = new AThread(bt);</span><br><span class="line">        try &#123;</span><br><span class="line">            bt.start();</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            at.start();</span><br><span class="line">            at.join();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from main&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName + &quot; end!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main start.    //主线程起动，因为调用了at.join()，要等到at结束了，此线程才能向下执行。 </span><br><span class="line">[BThread] Thread start. </span><br><span class="line">[BThread] Thread loop at 0 </span><br><span class="line">[BThread] Thread loop at 1 </span><br><span class="line">[AThread] Thread start.    //线程at启动，因为调用bt.join()，等到bt结束了才向下执行。 </span><br><span class="line">[BThread] Thread loop at 2 </span><br><span class="line">[BThread] Thread loop at 3 </span><br><span class="line">[BThread] Thread loop at 4 </span><br><span class="line">[BThread] Thread end. </span><br><span class="line">[AThread] Thread end.    // 线程AThread在bt.join();阻塞处起动，向下继续执行的结果 </span><br><span class="line">main end!      //线程AThread结束，此线程在at.join();阻塞处起动，向下继续执行的结果。</span><br></pre></td></tr></table></figure><p>修改一下代码:</p><details>    <summary>join方法示例</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(threadName + &quot; start.&quot;);</span><br><span class="line">        BThread bt = new BThread();</span><br><span class="line">        AThread at = new AThread(bt);</span><br><span class="line">        try &#123;</span><br><span class="line">            bt.start();</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            at.start();</span><br><span class="line">            //at.join(); //在此处注释掉对join()的调用</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception from main&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName + &quot; end!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main start.    // 主线程起动，因为Thread.sleep(2000)，主线程没有马上结束;</span><br><span class="line"></span><br><span class="line">[BThread] Thread start.    //线程BThread起动</span><br><span class="line">[BThread] Thread loop at 0</span><br><span class="line">[BThread] Thread loop at 1</span><br><span class="line">main end!   // 在sleep两秒后主线程结束，AThread执行的bt.join();并不会影响到主线程。</span><br><span class="line">[AThread] Thread start.    //线程at起动，因为调用了bt.join()，等到bt结束了，此线程才向下执行。</span><br><span class="line">[BThread] Thread loop at 2</span><br><span class="line">[BThread] Thread loop at 3</span><br><span class="line">[BThread] Thread loop at 4</span><br><span class="line">[BThread] Thread end.    //线程BThread结束了</span><br><span class="line">[AThread] Thread end.    // 线程AThread在bt.join();阻塞处起动，向下继续执行的结果</span><br></pre></td></tr></table></figure><h3 id="从源码看join-方法"><a href="#从源码看join-方法" class="headerlink" title="从源码看join()方法"></a>从源码看join()方法</h3><details>    <summary>从源码看join()方法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Waits at most &#123;@code millis&#125; milliseconds for this thread to</span><br><span class="line">     * die. A timeout of &#123;@code 0&#125; means to wait forever.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; This implementation uses a loop of &#123;@code this.wait&#125; calls</span><br><span class="line">     * conditioned on &#123;@code this.isAlive&#125;. As a thread terminates the</span><br><span class="line">     * &#123;@code this.notifyAll&#125; method is invoked. It is recommended that</span><br><span class="line">     * applications not use &#123;@code wait&#125;, &#123;@code notify&#125;, or</span><br><span class="line">     * &#123;@code notifyAll&#125; on &#123;@code Thread&#125; instances.</span><br><span class="line">     *</span><br><span class="line">     * @param  millis</span><br><span class="line">     *         the time to wait in milliseconds</span><br><span class="line">     *</span><br><span class="line">     * @throws  IllegalArgumentException</span><br><span class="line">     *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line">     *</span><br><span class="line">     * @throws  InterruptedException</span><br><span class="line">     *          if any thread has interrupted the current thread. The</span><br><span class="line">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line">     *          cleared when this exception is thrown.</span><br><span class="line">     */</span><br><span class="line">    public final synchronized void join(long millis)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        long base = System.currentTimeMillis();</span><br><span class="line">        long now = 0;</span><br><span class="line"></span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (millis == 0) &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay = millis - now;</span><br><span class="line">                if (delay &lt;= 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><p>单纯从代码上看： * 如果线程被生成了，但还未被起动，isAlive()将返回false，调用它的join()方法是没有作用的。将直接继续向下执行。 * 在AThread类中的run方法中，bt.join()是判断bt的active状态，如果bt的isActive()方法返回false，在bt.join(),这一点就不用阻塞了，可以继续向下进行了。从源码里看，wait方法中有参数，也就是不用唤醒谁，只是不再执行wait，向下继续执行而已。 * 在join()方法中，对于isAlive()和wait()方法的作用对象是个比较让人困惑的问题：</p><p>isAlive()方法的签名是：public final native boolean isAlive()，也就是说isAlive()是判断当前线程的状态，也就是bt的状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个初始地址 startUrl 和一个 HTML 解析器接口 HtmlParser，请你实现一个 多线程的网页爬虫，用于获取与 startUrl 有 相同主机名 的所有链接。 &lt;/p&gt;
&lt;p&gt;以 任意 顺序返回爬虫获取的路径。&lt;/p&gt;
&lt;p&gt;爬虫应该遵循：&lt;/p&gt;
&lt;p&gt;从 startUrl 开始&lt;br&gt;调用 HtmlParser.getUrls(url) 从指定网页路径获得的所有路径。&lt;br&gt;不要抓取相同的链接两次。&lt;br&gt;仅浏览与 startUrl 相同主机名 的链接。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>1279. 红绿灯路口</title>
    <link href="http://yoursite.com/2021/03/17/1279.%20%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%B7%AF%E5%8F%A3/"/>
    <id>http://yoursite.com/2021/03/17/1279. 红绿灯路口/</id>
    <published>2021-03-17T08:52:12.000Z</published>
    <updated>2021-03-19T01:55:59.435Z</updated>
    
    <content type="html"><![CDATA[<p>给这个路口设计一个没有死锁的红绿灯控制系统。</p><a id="more"></a><p>这是两条路的交叉路口。第一条路是 A 路，车辆可沿 1 号方向由北向南行驶，也可沿 2 号方向由南向北行驶。第二条路是 B 路，车辆可沿 3 号方向由西向东行驶，也可沿 4 号方向由东向西行驶。</p><p>每条路在路口前都有一个红绿灯。红绿灯可以亮起红灯或绿灯。</p><p>绿灯表示两个方向的车辆都可通过路口。<br>红灯表示两个方向的车辆都不可以通过路口，必须等待绿灯亮起。<br>两条路上的红绿灯不可以同时为绿灯。这意味着，当 A 路上的绿灯亮起时，B 路上的红灯会亮起；当 B 路上的绿灯亮起时，A 路上的红灯会亮起.</p><p>开始时，A 路上的绿灯亮起，B 路上的红灯亮起。当一条路上的绿灯亮起时，所有车辆都可以从任意两个方向通过路口，直到另一条路上的绿灯亮起。不同路上的车辆不可以同时通过路口。</p><p>给这个路口设计一个没有死锁的红绿灯控制系统。</p><p>实现函数 void carArrived(carId, roadId, direction, turnGreen, crossCar) :</p><ul><li>carId 为到达车辆的编号。</li><li>roadId 为车辆所在道路的编号。</li><li>direction 为车辆的行进方向。</li><li>turnGreen 是一个函数，调用此函数会使当前道路上的绿灯亮起。</li><li>crossCar 是一个函数，调用此函数会允许车辆通过路口。</li></ul><p>当你的答案避免了车辆在路口出现死锁，此答案会被认定为正确的。当路口已经亮起绿灯时仍打开绿灯，此答案会被认定为错误的。</p><p>示例 1:</p><pre><code>输入: cars = [1,3,5,2,4], directions = [2,1,2,4,3], arrivalTimes = [10,20,30,40,50]输出: [&quot;Car 1 Has Passed Road A In Direction 2&quot;,    // A 路上的红绿灯为绿色，1 号车可通过路口。&quot;Car 3 Has Passed Road A In Direction 1&quot;,    // 红绿灯仍为绿色，3 号车通过路口。&quot;Car 5 Has Passed Road A In Direction 2&quot;,    // 红绿灯仍为绿色，5 号车通过路口。&quot;Traffic Light On Road B Is Green&quot;,          // 2 号车在 B 路请求绿灯。&quot;Car 2 Has Passed Road B In Direction 4&quot;,    // B 路上的绿灯现已亮起，2 号车通过路口。&quot;Car 4 Has Passed Road B In Direction 3&quot;     // 红绿灯仍为绿色，4 号车通过路口。]</code></pre><p>示例 2:</p><pre><code>输入: cars = [1,2,3,4,5], directions = [2,4,3,3,1], arrivalTimes = [10,20,30,40,40]输出: [&quot;Car 1 Has Passed Road A In Direction 2&quot;,    // A 路上的红绿灯为绿色，1 号车可通过路口。&quot;Traffic Light On Road B Is Green&quot;,          // 2 号车在 B 路请求绿灯。&quot;Car 2 Has Passed Road B In Direction 4&quot;,    // B 路上的绿灯现已亮起，2 号车通过路口。&quot;Car 3 Has Passed Road B In Direction 3&quot;,    // B 路上的绿灯现已亮起，3 号车通过路口。&quot;Traffic Light On Road A Is Green&quot;,          // 5 号车在 A 路请求绿灯。&quot;Car 5 Has Passed Road A In Direction 1&quot;,    // A 路上的绿灯现已亮起，5 号车通过路口。&quot;Traffic Light On Road B Is Green&quot;,          // 4 号车在 B 路请求绿灯。4 号车在路口等灯，直到 5 号车通过路口，B 路的绿灯亮起。&quot;Car 4 Has Passed Road B In Direction 3&quot;     // B 路上的绿灯现已亮起，4 号车通过路口。]解释: 这是一个无死锁的方案。注意，在 A 路上的绿灯亮起、5 号车通过前让 4 号车通过，也是一个正确且可被接受的方案。</code></pre><p>提示：</p><pre><code>1 &lt;= cars.length &lt;= 20cars.length = directions.lengthcars.length = arrivalTimes.lengthcars 中的所有值都是唯一的。1 &lt;= directions[i] &lt;= 4arrivalTimes 是非递减的。</code></pre><details><summary>题目要求</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TrafficLight &#123;</span><br><span class="line"></span><br><span class="line">    public TrafficLight() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void carArrived(</span><br><span class="line">        int carId,           // ID of the car</span><br><span class="line">        int roadId,          // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)</span><br><span class="line">        int direction,       // Direction of the car</span><br><span class="line">        Runnable turnGreen,  // Use turnGreen.run() to turn light to green on current road</span><br><span class="line">        Runnable crossCar    // Use crossCar.run() to make car cross the intersection </span><br><span class="line">    ) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题解说实在没太理解，这题又是道收费题目，下面道题解是否能跑通有待验证。</p><details><summary>题解</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class TrafficLight &#123;</span><br><span class="line">    public TrafficLight() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean lightA = true;</span><br><span class="line">    public void carArrived(</span><br><span class="line">        int carId,           // ID of the car</span><br><span class="line">        int roadId,          // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)</span><br><span class="line">        int direction,       // Direction of the car</span><br><span class="line">        Runnable turnGreen,  // Use turnGreen.run() to turn light to green on current road</span><br><span class="line">        Runnable crossCar    // Use crossCar.run() to make car cross the intersection </span><br><span class="line">    ) &#123;</span><br><span class="line">        synchronized (this) </span><br><span class="line">        &#123;</span><br><span class="line">            if( roadId == 1) </span><br><span class="line">            &#123;</span><br><span class="line">                if( !lightA) &#123;</span><br><span class="line">                    turnGreen.run();</span><br><span class="line">                    lightA = true;</span><br><span class="line">                &#125;</span><br><span class="line">                crossCar.run();</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                if( lightA) &#123;</span><br><span class="line">                    turnGreen.run();</span><br><span class="line">                    lightA = false;</span><br><span class="line">                &#125;</span><br><span class="line">                crossCar.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给这个路口设计一个没有死锁的红绿灯控制系统。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Concurrency" scheme="http://yoursite.com/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>953. 验证外星语词典</title>
    <link href="http://yoursite.com/2021/03/04/953.%20%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/"/>
    <id>http://yoursite.com/2021/03/04/953. 验证外星语词典/</id>
    <published>2021-03-04T10:12:12.000Z</published>
    <updated>2021-03-04T10:30:25.352Z</updated>
    
    <content type="html"><![CDATA[<p>某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。</p><p>给定一组用外星语书写的单词words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;输出：true解释：在该语言的字母表中，&apos;h&apos; 位于 &apos;l&apos; 之前，所以单词序列是按字典序排列的。</code></pre><p>示例 2：</p><pre><code>输入：words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;输出：false解释：在该语言的字母表中，&apos;d&apos; 位于 &apos;l&apos; 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</code></pre><p>示例 3：</p><pre><code>输入：words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;输出：false解释：当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 &apos;l&apos; &gt; &apos;∅&apos;，其中 &apos;∅&apos; 是空白字符，定义为比任何其他字符都小（更多信息）。</code></pre><p>提示：</p><pre><code>1 &lt;= words.length &lt;= 1001 &lt;= words[i].length &lt;= 20order.length == 26在 words[i] 和 order 中的所有字符都是英文小写字母。</code></pre><h4 id="方法一：-检查相邻单词"><a href="#方法一：-检查相邻单词" class="headerlink" title="方法一： 检查相邻单词"></a>方法一： 检查相邻单词</h4><p><strong>思路</strong></p><p>只有每对相邻单词都是有序的，那么整个 <code>words</code> 才是有序的。因为有序性是可以传递的，例如，<code>a &lt;= b</code> 和 <code>b &lt;= c</code> 可以推出 <code>a &lt;= c</code>。</p><p><strong>算法</strong></p><p>检查相邻单词 <code>a</code> 和 <code>b</code> 是否满足 <code>a &lt;= b</code>。</p><p>为了检查相邻单词 <code>a</code>，<code>b</code> 是否满足 <code>a &lt;= b</code>，只需要检查它们第一个不同的字母就可以了。例如，对于<code>&quot;applying&quot;</code> 和 <code>&quot;apples&quot;</code>，第一个不同的字母是 <code>y</code> 和 <code>e</code>。之后只需要比较这两个字母在 <code>order</code> 中的下标就可以了。 </p><p>还需要考虑两个单词长度不等的情况。例如，当比较 <code>&quot;app&quot;</code> 和 <code>&quot;apply&quot;</code> 的时候，前三个字母都是相等的，但 <code>&quot;app&quot;</code> 比 <code>&quot;apply&quot;</code> 更短，所以满足 <code>a &lt;= b</code>。</p><details>    <summary>检查相邻单词Java</summary><figure class="highlight java"><figcaption><span>[solution1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); ++i)</span><br><span class="line">            index[order.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line"></span><br><span class="line">        search: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            String word1 = words[i];</span><br><span class="line">            String word2 = words[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the first difference word1[k] != word2[k].</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Math.min(word1.length(), word2.length()); ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(k) != word2.charAt(k)) &#123;</span><br><span class="line">                    <span class="comment">// If they compare badly, it's not sorted.</span></span><br><span class="line">                    <span class="keyword">if</span> (index[word1.charAt(k) - <span class="string">'a'</span>] &gt; index[word2.charAt(k) - <span class="string">'a'</span>])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span> search;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn't find a first difference, the</span></span><br><span class="line">            <span class="comment">// words are like ("app", "apple").</span></span><br><span class="line">            <span class="keyword">if</span> (word1.length() &gt; word2.length())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>检查相邻单词Python</summary><figure class="highlight python"><figcaption><span>[solution1-Python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span><span class="params">(self, words, order)</span>:</span></span><br><span class="line">        order_index = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(order)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(words) - <span class="number">1</span>):</span><br><span class="line">            word1 = words[i]</span><br><span class="line">            word2 = words[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Find the first difference word1[k] != word2[k].</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(min(len(word1), len(word2))):</span><br><span class="line">                <span class="comment"># If they compare badly, it's not sorted.</span></span><br><span class="line">                <span class="keyword">if</span> word1[k] != word2[k]:</span><br><span class="line">                    <span class="keyword">if</span> order_index[word1[k]] &gt; order_index[word2[k]]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># If we didn't find a first difference, the</span></span><br><span class="line">                <span class="comment"># words are like ("app", "apple").</span></span><br><span class="line">                <span class="keyword">if</span> len(word1) &gt; len(word2):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(C)*，其中 *C</em> 是 <code>words</code> 中单词总长度和。</p></li><li><p>空间复杂度： <em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。&lt;/p&gt;
&lt;p&gt;给定一组用外星语书写的单词words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年3月" scheme="http://yoursite.com/categories/2021%E5%B9%B43%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>269.火星词典</title>
    <link href="http://yoursite.com/2021/02/27/269.%E7%81%AB%E6%98%9F%E8%AF%8D%E5%85%B8/"/>
    <id>http://yoursite.com/2021/02/27/269.火星词典/</id>
    <published>2021-02-27T06:12:12.000Z</published>
    <updated>2021-03-04T08:47:03.890Z</updated>
    
    <content type="html"><![CDATA[<p>有一种新的使用拉丁字母的外来语言。但是，你不知道字母之间的顺序。你会从词典中收到一个非空的单词列表，其中的单词在这种新语言的规则下按字典顺序排序。请推导出这种语言的字母顺序</p><a id="more"></a><p>此题也是LintCode上的 892. 外星人字典，可以直接在官网链接<a href="https://www.lintcode.com/problem/alien-dictionary?utm_source=sc-zhihuzl-sy" target="_blank" rel="noopener">^1</a>提交代码测试。也曾经是抖音的一道面试题。</p><ol><li>你可以假设所有的字母都是小写。</li><li>如果a是b的前缀且b出现在a之前，那么这个顺序是无效的。</li><li>如果顺序是无效的，则返回空字符串。</li><li>这里可能有多个有效的字母顺序，返回以正常字典顺序看来最小的。</li></ol><p>样例 1:</p><pre><code>输入：[&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]输出：&quot;wertf&quot;解释：从 &quot;wrt&quot;和&quot;wrf&quot; ,我们可以得到 &apos;t&apos;&lt;&apos;f&apos;从 &quot;wrt&quot;和&quot;er&quot; ,我们可以得到&apos;w&apos;&lt;&apos;e&apos;从 &quot;er&quot;和&quot;ett&quot; ,我们可以得到 get &apos;r&apos;&lt;&apos;t&apos;从 &quot;ett&quot;和&quot;rftt&quot; ,我们可以得到 &apos;e&apos;&lt;&apos;r&apos;所以返回 &quot;wertf&quot;</code></pre><p>样例 2:</p><pre><code>输入：[&quot;z&quot;,&quot;x&quot;]输出：&quot;zx&quot;解释：从 &quot;z&quot; 和 &quot;x&quot;，我们可以得到 &apos;z&apos; &lt; &apos;x&apos;所以返回&quot;zx&quot;</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这是很明显的拓扑排序，可以参考210.课程表II的代码。区别在于那个拓扑排序是对整数而且输入样例是给好的。这道题里要自己整理好要拓扑排序的数据，而且将拓扑排序的代码更改为对字符串排序，在改动的过程中踩了一些坑。</p><p>网上很多博客的代码也踩了这些坑，比如如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[“abc”,”ab”]，所以是没法通过的。</p><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><details>    <summary>宽度优先搜索-拓扑排序</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public static String findOrder(Set&lt;Character&gt; set,Character[][] prerequisites) &#123;</span><br><span class="line">        Map&lt;Character, List&lt;Character&gt;&gt; edges;</span><br><span class="line">        Map&lt;Character,Integer&gt; indeg;</span><br><span class="line">        String res=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        edges=new HashMap&lt;&gt;();</span><br><span class="line">        indeg=new HashMap&lt;&gt;();</span><br><span class="line">        for(Character[] info: prerequisites)&#123;</span><br><span class="line">            List&lt;Character&gt; list = edges.get(info[1]);</span><br><span class="line">            if (Objects.isNull(list)) &#123;</span><br><span class="line">                list = new ArrayList&lt;Character&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(info[0]);</span><br><span class="line">            edges.put(info[1], list);</span><br><span class="line">            indeg.put(info[0], indeg.getOrDefault(info[0],0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里可能有多个有效的字母顺序，返回以正常字典顺序看来最小的，[&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">        //所以使用优先队列</span><br><span class="line">        PriorityQueue&lt;Character&gt; queue=new PriorityQueue&lt;Character&gt;();</span><br><span class="line">        for (Character c: set) &#123;</span><br><span class="line">            if (indeg.getOrDefault(c,0) == 0) &#123;</span><br><span class="line">                queue.offer(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            Character u=queue.poll();</span><br><span class="line">            res+=u;</span><br><span class="line">            if (!Objects.isNull(edges.get(u))) &#123;</span><br><span class="line">                for (Character v : edges.get(u)) &#123;</span><br><span class="line">                    indeg.put(v, indeg.getOrDefault(v, 0) - 1);</span><br><span class="line">                    if (indeg.getOrDefault(v, 0) == 0) &#123;</span><br><span class="line">                        queue.offer(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (set.size() != res.length()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @param words: a list of words</span><br><span class="line">     * @return: a string which is correct order</span><br><span class="line">     */</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        // Write your code here</span><br><span class="line">        Set&lt;Character&gt; set=new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Character[]&gt; lists=new HashSet&lt;&gt;();</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for (String s : words) &#123;</span><br><span class="line">            maxlen = Math.max(s.length(), maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; maxlen; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words.length; j++) &#123;</span><br><span class="line">                Character c;</span><br><span class="line">                if (words[j].length() &gt; i) &#123;</span><br><span class="line">                    c = words[j].charAt(i);</span><br><span class="line">                    set.add(c);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int k = j + 1; k &lt; words.length; k++) &#123;</span><br><span class="line">                    Character d;</span><br><span class="line">                    if (words[k].length() &gt; i) &#123;</span><br><span class="line">                        d = words[k].charAt(i);</span><br><span class="line">                        set.add(d);</span><br><span class="line">                        if (d != c &amp;&amp; words[j].substring(0,i).equals(words[k].substring(0,i))) &#123;</span><br><span class="line">                            lists.add(new Character[]&#123;d,c&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[&quot;abc&quot;,&quot;ab&quot;]</span><br><span class="line">                        if (words[j].startsWith(words[k])) &#123;</span><br><span class="line">                            return &quot;&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Character[][] character = new Character[lists.size()][];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (Character[] c : lists) &#123;</span><br><span class="line">            character[index] = c;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return findOrder(set,character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="解法II"><a href="#解法II" class="headerlink" title="解法II"></a>解法II</h2><details>    <summary>宽度优先搜索-拓扑排序</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String alienOrder(String[] words) &#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = constructGraph(words);</span><br><span class="line">        if (graph == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return topologicalSorting(graph);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    private Map&lt;Character, Set&lt;Character&gt;&gt; constructGraph(String[] words) &#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // create nodes</span><br><span class="line">        for (int i = 0; i &lt; words.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                char c = words[i].charAt(j);</span><br><span class="line">                if (!graph.containsKey(c)) &#123;</span><br><span class="line">                    graph.put(c, new HashSet&lt;Character&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // create edges</span><br><span class="line">        for (int i = 0; i &lt; words.length - 1; i++) &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            while (index &lt; words[i].length() &amp;&amp; index &lt; words[i + 1].length()) &#123;</span><br><span class="line">                if (words[i].charAt(index) != words[i + 1].charAt(index)) &#123;</span><br><span class="line">                    graph.get(words[i].charAt(index)).add(words[i + 1].charAt(index));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[&quot;abc&quot;,&quot;ab&quot;]</span><br><span class="line">            if (index == Math.min(words[i].length(), words[i + 1].length())) &#123;</span><br><span class="line">                if (words[i].length() &gt; words[i + 1].length()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return graph;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Map&lt;Character, Integer&gt; getIndegree(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; indegree = new HashMap&lt;&gt;();</span><br><span class="line">        for (Character u : graph.keySet()) &#123;</span><br><span class="line">            indegree.put(u, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (Character u : graph.keySet()) &#123;</span><br><span class="line">            for (Character v : graph.get(u)) &#123;</span><br><span class="line">                indegree.put(v, indegree.get(v) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">        </span><br><span class="line">        return indegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String topologicalSorting(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123;</span><br><span class="line">        // as we should return the topo order with lexicographical order</span><br><span class="line">        // we should use PriorityQueue instead of a FIFO Queue</span><br><span class="line">        Map&lt;Character, Integer&gt; indegree = getIndegree(graph);</span><br><span class="line">        Queue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for (Character u : indegree.keySet()) &#123;</span><br><span class="line">            if (indegree.get(u) == 0) &#123;</span><br><span class="line">                queue.offer(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Character head = queue.poll();</span><br><span class="line">            sb.append(head);</span><br><span class="line">            for (Character neighbor : graph.get(head)) &#123;</span><br><span class="line">                indegree.put(neighbor, indegree.get(neighbor) - 1);</span><br><span class="line">                if (indegree.get(neighbor) == 0) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sb.length() != indegree.size()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>官网的题解<a href="https://www.jiuzhang.com/solutions/alien-dictionary/" target="_blank" rel="noopener">^2</a>和我自己魔改的版本其实没有太大区别，主要的不同之处在于使用了Map&lt;Character, Set<character>&gt;来存储拓扑图，StringBuilder来保存最终结果，以及判断如果a是b的前缀且b出现在a之前，那么这个顺序是无效的，[“abc”,”ab”]，如果使用Strings自带的startsWith方法效率会比改题解中的利用下标判断低。</character></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一种新的使用拉丁字母的外来语言。但是，你不知道字母之间的顺序。你会从词典中收到一个非空的单词列表，其中的单词在这种新语言的规则下按字典顺序排序。请推导出这种语言的字母顺序&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Topological sort" scheme="http://yoursite.com/tags/Topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识-装箱和拆箱</title>
    <link href="http://yoursite.com/2021/02/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2021/02/22/Java基础知识-装箱和拆箱/</id>
    <published>2021-02-22T03:25:12.000Z</published>
    <updated>2021-02-22T07:24:00.286Z</updated>
    
    <content type="html"><![CDATA[<p>装箱和拆箱</p><a id="more"></a><h1 id="什么是装箱？什么是拆箱？"><a href="#什么是装箱？什么是拆箱？" class="headerlink" title="什么是装箱？什么是拆箱？"></a>什么是装箱？什么是拆箱？</h1><p>在java中有八种基本数据类型对应每种基本类型又有八种包装类型：<a href="https://zhuanlan.zhihu.com/p/78590948" target="_blank" rel="noopener">^1</a></p><p>基本类型：boolean， char， int， byte，short，long， float，double</p><p>包装器类型：Boolean，Character，Integer，Byte，Short，Long，Float，Double</p><p>从上面我们可以看到除了 char和int其它的包装类型名称和对应的基本类型一样只是首字母大写了。</p><p>既然有了基本类型为什么还要有包装类呢？我们在使用的过程中究竟用基本类型还是包装类呢？</p><p>在某些场合不能使用基本类型必须使用包装类，比如集合能接收的类型为Object,基本类型是无法添加进去的，还有范型也必须使用包装类。</p><p>另外假设我们要定义一个变量表示分数 如果用基本类型表示的话：int score;</p><p>默认值为零，如果我想表示分数为空也就是没有参加考试就没法表现了因为值类型是无法赋空值的，如果使用包装类型Integer score,就可以表示这种情况，因为Integer的默认值为空。</p><p>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p><pre><code>Integer i = new Integer(10);</code></pre><p>　　而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p><pre><code>Integer i = 10;</code></pre><p>　　这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。</p><p>　　那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p><pre><code>Integer i = 10;  //装箱int n = i;   //拆箱</code></pre><p>　　<br>　　简单一点说，装箱就是  自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。</p><h1 id="装箱和拆箱是如何实现的"><a href="#装箱和拆箱是如何实现的" class="headerlink" title="装箱和拆箱是如何实现的"></a>装箱和拆箱是如何实现的</h1><p>这部分主要内容来自于<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">^2</a>，作者是Matrix海子，写的很清楚，这里为了阅读方便转载一下，内容如下：</p><details>    <summary>装箱和拆箱是如何实现的</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer i = 10;</span><br><span class="line">        int n = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>先编译<code>javac Main.java</code>，然后反编译class文件 <code>javap -c Main</code>后</p><p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。</p><p>　　其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。</p><p>　　因此可以用一句话总结装箱和拆箱的实现过程：</p><p>　　装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p><h1 id="面试中相关的问题"><a href="#面试中相关的问题" class="headerlink" title="面试中相关的问题"></a>面试中相关的问题</h1><ol><li>代码的输出结果是什么<details> <summary>代码的输出结果是什么</summary></details></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = 100;</span><br><span class="line">        Integer i2 = 100;</span><br><span class="line">        Integer i3 = 200;</span><br><span class="line">        Integer i4 = 200;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟,Integer的valueOf方法的具体实现和IntegerCache类的实现，通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p><p>　　上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p><ol start="2"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Double i1 = 100.0;</span><br><span class="line">        Double i2 = 100.0;</span><br><span class="line">        Double i3 = 200.0;</span><br><span class="line">        Double i4 = 200.0;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>具体为什么，可以去看Double类的valueOf的实现。</p><p>　　在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><p>　　注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</p><p>　　　　　Double、Float的valueOf方法的实现是类似的。　</p><ol start="3"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean i1 = false;</span><br><span class="line">        Boolean i2 = false;</span><br><span class="line">        Boolean i3 = true;</span><br><span class="line">        Boolean i4 = true;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>输出结果都是true,至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然</p><ol start="4"><li>谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。</li></ol><p>　　当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</p><p>　　1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；</p><p>　　2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</p><ol start="5"><li>代码的输出结果是什么</li></ol><details>    <summary>代码的输出结果是什么</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = 1;</span><br><span class="line">        Integer b = 2;</span><br><span class="line">        Integer c = 3;</span><br><span class="line">        Integer d = 3;</span><br><span class="line">        Integer e = 321;</span><br><span class="line">        Integer f = 321;</span><br><span class="line">        Long g = 3L;</span><br><span class="line">        Long h = 2L;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);</span><br><span class="line">        System.out.println(e==f);</span><br><span class="line">        System.out.println(c==(a+b));</span><br><span class="line">        System.out.println(c.equals(a+b));</span><br><span class="line">        System.out.println(g==(a+b));</span><br><span class="line">        System.out.println(g.equals(a+b));</span><br><span class="line">        System.out.println(g.equals(a+h));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>当 “==”运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然：</p><pre><code>truefalsetruetruetruefalsetrue</code></pre><p>第一个和第二个输出结果没有什么疑问。第三句由于  a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p><p>如果对上面的具体执行过程有疑问，可以尝试获取反编译的字节码内容进行查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装箱和拆箱&lt;/p&gt;
    
    </summary>
    
      <category term="2021年2月" scheme="http://yoursite.com/categories/2021%E5%B9%B42%E6%9C%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
