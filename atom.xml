<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-13T06:33:46.311Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>50. Pow(x, n)快速幂算法</title>
    <link href="http://yoursite.com/2021/12/13/50.%20Pow(x,%20n)%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/12/13/50. Pow(x, n)快速幂算法/</id>
    <published>2021-12-13T03:12:12.000Z</published>
    <updated>2021-12-13T06:33:46.311Z</updated>
    
    <content type="html"><![CDATA[<p>在计算斐波那契数时遇到要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，需要用到快速幂算法。</p><p>实现 pow(x, n) ，即计算x的n次幂函数（即x^n）。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：x = 2.00000, n = 10输出：1024.00000</code></pre><p>示例 2：</p><pre><code>输入：x = 2.10000, n = 3输出：9.26100</code></pre><p>示例 3：</p><pre><code>输入：x = 2.00000, n = -2输出：0.25000解释：2^-2 = 1/2^2 = 1/4 = 0.25</code></pre><p>提示：</p><pre><code>-100.0 &lt; x &lt; 100.0-2^31 &lt;= n &lt;= 2^31-1-10^4 &lt;= x^n &lt;= 10^4</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题的方法被称为「快速幂算法」，有递归和迭代两个版本。这篇题解会从递归版本的开始讲起，再逐步引出迭代的版本。</p><p>当指数 <em>n</em> 为负数时，我们可以计算 <em>x^{-n}</em> 再取倒数得到结果，因此我们只需要考虑 <em>n</em> 为自然数的情况。</p><h1 id="方法一：快速幂-递归-1"><a href="#方法一：快速幂-递归-1" class="headerlink" title="方法一：快速幂 + 递归^1"></a>方法一：快速幂 + 递归<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></h1><p>「快速幂算法」的本质是分治算法。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">            y = quickMul(N // <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> y * y <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> y * y * x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickMul(x, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / quickMul(x, -n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickMul</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := quickMul(x, n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y * y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y * y * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：快速幂-迭代"><a href="#方法二：快速幂-迭代" class="headerlink" title="方法二：快速幂 + 迭代"></a>方法二：快速幂 + 迭代</h1><p>由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 <em>x</em>。但我们不妨找一找规律，看看哪些地方额外乘了 <em>x</em>，并且它们对答案产生了什么影响。</p><p>下面的代码给出了详细的注释。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(N)</span>:</span></span><br><span class="line">            ans = <span class="number">1.0</span></span><br><span class="line">            <span class="comment"># 贡献的初始值为 x</span></span><br><span class="line">            x_contribute = x</span><br><span class="line">            <span class="comment"># 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">            <span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                    ans *= x_contribute</span><br><span class="line">                <span class="comment"># 将贡献不断地平方</span></span><br><span class="line">                x_contribute *= x_contribute</span><br><span class="line">                <span class="comment"># 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">                N //= <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickMul(x, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / quickMul(x, -n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickMul</span><span class="params">(x <span class="keyword">float64</span>, N <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ans := <span class="number">1.0</span></span><br><span class="line">    <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">    x_contribute := x</span><br><span class="line">    <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">    <span class="keyword">for</span> N &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">            ans *= x_contribute</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">        x_contribute *= x_contribute</span><br><span class="line">        <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">        N /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算斐波那契数时遇到要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，需要用到快速幂算法。&lt;/p&gt;
&lt;p&gt;实现 pow(x, n) ，即计算x的n次幂函数（即x^n）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>509. 斐波那契数</title>
    <link href="http://yoursite.com/2021/12/13/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/13/509. 斐波那契数/</id>
    <published>2021-12-13T02:12:12.000Z</published>
    <updated>2021-12-13T03:16:50.108Z</updated>
    
    <content type="html"><![CDATA[<p> 计算斐波那契数，虽然此题看起来简单，但面试中常要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，难度属实不低。</p><a id="more"></a><p>[TOC]</p><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p>示例 1：</p><pre><code>输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1</code></pre><p>示例 2：</p><pre><code>输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2</code></pre><p>示例 3：</p><pre><code>输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3</code></pre><p>提示：</p><pre><code>0 &lt;= n &lt;= 30</code></pre><p>与<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a>相同</p><p>参见<a href="https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/" target="_blank" rel="noopener">^1</a></p><h1 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h1><p>斐波那契数的边界条件是 <em>F(0)=0</em> 和 <em>F(1)=1*。当 *n&gt;1</em> 时，每一项的和都等于前两项的和，因此有如下递推关系：</p><p><em>F(n)=F(n-1)+F(n-2)</em></p><p>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 <em>F(0)</em> 和 <em>F(1)</em>。</p><p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 <em>O(n)</em> 的实现。由于 <em>F(n)</em> 只和 <em>F(n-1)</em> 与 <em>F(n-2)</em> 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 <em>O(1)</em>。<strong>如下的代码中给出的就是这种实现。</strong></p><p> <a href="https://assets.leetcode-cn.com/solution-static/509/509_fig1.gif" target="_blank" rel="noopener">fig1</a></p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    p, q, r := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        p = q</span><br><span class="line">        q = r</span><br><span class="line">        r = p + q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        p, q, r = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            p, q = q, r</span><br><span class="line">            r = p + q</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法二：矩阵快速幂"><a href="#方法二：矩阵快速幂" class="headerlink" title="方法二：矩阵快速幂"></a>方法二：矩阵快速幂</h1><p>方法一的时间复杂度是 <em>O(n)</em>。使用矩阵快速幂的方法可以降低时间复杂度。</p><p>首先我们可以构建一个递推关系：</p><p>因此只要我们能快速计算矩阵 <em>M</em> 的 <em>n</em> 次幂，就可以得到 <em>F(n)</em> 的值。如果直接求取 <em>M^n<em>，时间复杂度是 *O(n)</em>，可以定义矩阵乘法，然后用快速幂算法来加速这里 *M^n</em> 的求取。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = matrix_pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix_pow(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret = matrix_multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = matrix_multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix_multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">const</span> res = pow(q, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pow = <span class="function">(<span class="params">a, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">            ret = multiply(ret, a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = multiply(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> matrix [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(a, b matrix)</span> <span class="params">(c matrix)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>]*b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>]*b[<span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a matrix, n <span class="keyword">int</span>)</span> <span class="title">matrix</span></span> &#123;</span><br><span class="line">    ret := matrix&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ret = multiply(ret, a)</span><br><span class="line">        &#125;</span><br><span class="line">        a = multiply(a, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    res := pow(matrix&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Matrix <span class="title">matrixMultiply</span><span class="params">(struct Matrix* a, struct Matrix* b)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c.mat[i][j] = (*a).mat[i][<span class="number">0</span>] * (*b).mat[<span class="number">0</span>][j] + (*a).mat[i][<span class="number">1</span>] * (*b).mat[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Matrix <span class="title">matrixPow</span><span class="params">(struct Matrix a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">ret</span>;</span></span><br><span class="line">    ret.mat[<span class="number">0</span>][<span class="number">0</span>] = ret.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ret.mat[<span class="number">0</span>][<span class="number">1</span>] = ret.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = matrixMultiply(&amp;ret, &amp;a);</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = matrixMultiply(&amp;a, &amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">q</span>;</span></span><br><span class="line">    q.mat[<span class="number">0</span>][<span class="number">0</span>] = q.mat[<span class="number">0</span>][<span class="number">1</span>] = q.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> <span class="title">res</span> = <span class="title">matrixPow</span>(<span class="title">q</span>, <span class="title">n</span> - 1);</span></span><br><span class="line">    <span class="keyword">return</span> res.mat[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        q = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        res = self.matrix_pow(q, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrix_pow</span><span class="params">(self, a: List[List[int]], n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ret = self.matrix_multiply(ret, a)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            a = self.matrix_multiply(a, a)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrix_multiply</span><span class="params">(self, a: List[List[int]], b: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        c = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logn)  。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：通项公式"><a href="#方法三：通项公式" class="headerlink" title="方法三：通项公式"></a>方法三：通项公式</h1><p>斐波那契数 <em>F(n)</em> 是齐次线性递推，根据递推方程 <em>F(n)=F(n-1)+F(n-2)</em>，可以写出这样的特征方程：</p><p><em>x^2=x+1</em></p><p>得到通项公式之后，就可以通过公式直接求解第 <em>n</em> 项。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol3-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sqrt5 = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> fibN = <span class="built_in">Math</span>.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(fibN / sqrt5);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sqrt5 := math.Sqrt(<span class="number">5</span>)</span><br><span class="line">    p1 := math.Pow((<span class="number">1</span>+sqrt5)/<span class="number">2</span>, <span class="keyword">float64</span>(n))</span><br><span class="line">    p2 := math.Pow((<span class="number">1</span>-sqrt5)/<span class="number">2</span>, <span class="keyword">float64</span>(n))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(math.Round((p1 - p2) / sqrt5))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        sqrt5 = <span class="number">5</span>**<span class="number">0.5</span></span><br><span class="line">        fibN = ((<span class="number">1</span> + sqrt5) / <span class="number">2</span>) ** n - ((<span class="number">1</span> - sqrt5) / <span class="number">2</span>) ** n</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>代码中使用的 pow 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 计算斐波那契数，虽然此题看起来简单，但面试中常要求的时间复杂度为O(logn),这样常用的递归和动态规划都不满足要求了，难度属实不低。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Memoization" scheme="http://yoursite.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>面试题 08.06. 汉诺塔问题</title>
    <link href="http://yoursite.com/2021/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.06.%20%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/12/13/面试题 08.06. 汉诺塔问题/</id>
    <published>2021-12-13T02:12:12.000Z</published>
    <updated>2021-12-13T02:23:43.428Z</updated>
    
    <content type="html"><![CDATA[<p> 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><a id="more"></a><p>[TOC]</p><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p>示例1:</p><pre><code>输入：A = [2, 1, 0], B = [], C = []输出：C = [2, 1, 0]</code></pre><p>示例2:</p><pre><code>输入：A = [1, 0], B = [], C = []输出：C = [1, 0]</code></pre><p>提示:</p><pre><code>A中盘子的数目不大于14个。</code></pre><h2 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h2><blockquote><p>相传在很久以前，有个寺庙里的几个和尚整天不停地移动着 64 个盘子，日复一日，年复一年。据说，当 64 个盘子全部移完的那一天就是世界末日…</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有 A,B,C 三根柱子，A 上面有 n 个盘子，我们想把 A 上面的盘子移动到 C 上，但是要满足以下三个条件：</p><ol><li>每次只能移动一个盘子;</li><li>盘子只能从柱子顶端滑出移到下一根柱子;</li><li>盘子只能叠在比它大的盘子上。</li></ol><p><a href="https://pic.leetcode-cn.com/7043dec266338d396d186805072660d5f9517e2c1008af80d461b553c5b32470-p1.png" target="_blank" rel="noopener">p1.png</a></p><h3 id="解题思路：递归与分治"><a href="#解题思路：递归与分治" class="headerlink" title="解题思路：递归与分治"></a>解题思路：递归与分治</h3><p>这是一道递归方法的经典题目，乍一想还挺难理清头绪的，我们不妨先从简单的入手。</p><p>假设 <code>n = 1</code>,只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；</p><p>如果 <code>n = 2</code> 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 4 步。</p><p> <a href="https://pic.leetcode-cn.com/f6f3b97651247c9ff846f115e1866ab364b1c0e265fd51689ddd6a8ca1758482-0806.gif" target="_blank" rel="noopener">0806.gif</a></p><p>如果  <code>n &gt; 2</code> 呢？思路和上面是一样的，我们把 n 个盘子也看成两个部分，一部分有 1 个盘子，另一部分有 n - 1 个盘子。</p><p> <a href="https://pic.leetcode-cn.com/3bffd1a1faf4323a92b659e37d7e2cd6c79fe074602b2977f4a7931fe82bbb13-08061.gif" target="_blank" rel="noopener">08061.gif</a></p><p>观察上图，你可能会问：“那 n - 1 个盘子是怎么从 A 移到 C 的呢？”</p><p>注意，<strong>当你在思考这个问题的时候，就将最初的 n 个盘子从 A 移到 C 的问题，转化成了将 n - 1 个盘子从 A 移到 C 的问题，</strong> 依次类推，直至转化成 1 个盘子的问题时，问题也就解决了。这就是分治的思想。 </p><p>而实现分治思想的常用方法就是递归。不难发现，如果原问题可以分解成若干个与原问题结构相同但规模较小的子问题时，往往可以用递归的方法解决。具体解决办法如下：</p><ul><li><code>n = 1</code> 时，直接把盘子从 A 移到 C；</li><li><code>n &gt; 1</code> 时，<ul><li>先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；</li><li>再将最大的盘子从 A 移到 C；</li><li>再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hanota</span><span class="params">(self, A: List[int], B: List[int], C: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        self.move(n, A, B, C)</span><br><span class="line">    <span class="comment"># 定义move 函数移动汉诺塔</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,n, A, B, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            C.append(A[<span class="number">-1</span>])</span><br><span class="line">            A.pop()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.move(n<span class="number">-1</span>, A, C, B)  <span class="comment"># 将A上面n-1个通过C移到B</span></span><br><span class="line">            C.append(A[<span class="number">-1</span>])          <span class="comment"># 将A最后一个移到C</span></span><br><span class="line">            A.pop()                  <span class="comment"># 这时，A空了</span></span><br><span class="line">            self.move(n<span class="number">-1</span>,B, A, C)   <span class="comment"># 将B上面n-1个通过空的A移到C</span></span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        move(n, A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.push_back(A.back());</span><br><span class="line">            A.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        move(n<span class="number">-1</span>, A, C, B);    <span class="comment">// 将A上面n-1个通过C移到B</span></span><br><span class="line">        C.push_back(A.back());  <span class="comment">// 将A最后一个移到C</span></span><br><span class="line">        A.pop_back();          <span class="comment">// 这时，A空了</span></span><br><span class="line">        move(n<span class="number">-1</span>, B, A, C);     <span class="comment">// 将B上面n-1个通过空的A移到C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            C.add(A.get(A.size() - <span class="number">1</span>));</span><br><span class="line">            A.remove(A.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move(n - <span class="number">1</span>, A, C, B);</span><br><span class="line">        C.add(A.get(A.size() - <span class="number">1</span>));</span><br><span class="line">        A.remove(A.size() - <span class="number">1</span>);</span><br><span class="line">        move(n - <span class="number">1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="复杂度分析：世界会毁灭吗"><a href="#复杂度分析：世界会毁灭吗" class="headerlink" title="复杂度分析：世界会毁灭吗"></a>复杂度分析：世界会毁灭吗</h2><ul><li>时间复杂度：<em>O(2^n-1)</em>。一共需要移动的次数。</li><li>空间复杂度：<em>O(1)</em>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ学习笔记（概念，架构和消息交换机类型）</title>
    <link href="http://yoursite.com/2021/12/12/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B6%88%E6%81%AF%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/12/RabbitMQ学习笔记（概念，架构和消息交换机类型）/</id>
    <published>2021-12-12T12:12:12.000Z</published>
    <updated>2021-12-13T01:56:48.612Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ是AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的技术实现，也是高性能消息服务组件的代表之作。由于其隶属于Pivotal公司，所以与Spring的整合效果是最完善的。在SpringCloud开发技术中大量使用了RabbitMQ消息组件。</p><a id="more"></a><p>[TOC]</p><h1 id="概念-1"><a href="#概念-1" class="headerlink" title="概念^1"></a>概念<a href="[名师讲坛：Java微服务架构实战（SpringBoot+SpringCloud+Docker+RabbitMQ](https://weread.qq.com/web/reader/0e03209071c96a420e02710ka0a32dd027aa0a080f42962)">^1</a></h1><p>RabbitMQ是一种消息队列服务，同样也是在进行系统整合时的一种通信手段，其运行模式遵循“生产者—消费者”模型，即会存在若干个消息生产者以及若干个消息消费者。与JavaEE提出的JMS标准不同之处在于：RabbitMQ是由ERLang开发的基于AMQP应用层协议标准的一种消息组件，所以其处理性能要比JMS组件更高。RabbitMQ官方网站的网址为<a href="http://www.rabbitmq.com" target="_blank" rel="noopener">http://www.rabbitmq.com</a></p><p>深入了解还可以参见<a href="[深入RabbitMQ](https://weread.qq.com/web/reader/80c32e0071dbdd9580c74f2k8f132430178f14e45fce0f7)">^2</a></p><h3 id="提示：常见消息组件。"><a href="#提示：常见消息组件。" class="headerlink" title="提示：常见消息组件。"></a>提示：常见消息组件。</h3><p>消息组件主要划分为JMS组件和AMQP组件两类。[插图] JMS（Java Message Service）组件：ActiveMQ性能较差。[插图] AMQP组件（协议）：性能是最高的，而AMQP有两个主要的开源。|- RabbitMQ：使用最为广泛，响应速度快。|- Kafka：是大数据时代作为数据采集的重要组件，处理速度更高。RabbitMQ是由RabbitMQ Technologies Ltd开发并且提供商业支持的。该公司在2010年4月被SpringSource（VMWare的一个部门）收购，在2013年5月被并入Pivotal。</p><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p>AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放标准，为<br>面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言<br>等条件的限制。</p><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可<br>用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布<br>确认。</li><li>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对<br>于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路<br>由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节<br>点出问题的情况下队列仍然可用。</li><li>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT<br>等等。</li><li>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、<br>Ruby 等等。</li><li>管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控<br>和管理消息 Broker 的许多方面。</li><li>跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生<br>了什么。</li><li>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编<br>写自己的插件。</li></ol><h1 id="RabbitMQ-架构"><a href="#RabbitMQ-架构" class="headerlink" title="RabbitMQ 架构"></a>RabbitMQ 架构</h1><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h2 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h2><ol><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li></ol><h2 id="Exchange-消息交换机（将消息路由给队列-）"><a href="#Exchange-消息交换机（将消息路由给队列-）" class="headerlink" title="Exchange 消息交换机（将消息路由给队列 ）"></a>Exchange 消息交换机（将消息路由给队列 ）</h2><ol start="2"><li>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li></ol><h2 id="Binding（消息队列和交换器之间的关联）"><a href="#Binding（消息队列和交换器之间的关联）" class="headerlink" title="Binding（消息队列和交换器之间的关联）"></a>Binding（消息队列和交换器之间的关联）</h2><ol start="3"><li>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连<br>接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ol start="4"><li>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息<br>可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li></ol><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ol start="5"><li>网络连接，比如一个 TCP 连接。</li></ol><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ol start="6"><li>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li></ol><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><ol start="7"><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li></ol><h2 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h2><ol start="8"><li>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</li></ol><h2 id="Broker-消息队列服务主机"><a href="#Broker-消息队列服务主机" class="headerlink" title="Broker 消息队列服务主机"></a>Broker 消息队列服务主机</h2><ol start="9"><li>表示消息队列服务器实体。</li></ol><h1 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h1><p>Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外headers交换器和direct交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：topic（主题订阅）、direct（直连）、fanout（广播）</p><h2 id="Direct-键（routing-key）分布："><a href="#Direct-键（routing-key）分布：" class="headerlink" title="Direct 键（routing key）分布："></a>Direct 键（routing key）分布：</h2><ol><li>Direct：消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。</li></ol><h2 id="Fanout（广播分发）"><a href="#Fanout（广播分发）" class="headerlink" title="Fanout（广播分发）"></a>Fanout（广播分发）</h2><ol start="2"><li>Fanout：每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout类型转发消息是最快的。</li></ol><h2 id="topic-交换器（模式匹配）"><a href="#topic-交换器（模式匹配）" class="headerlink" title="topic 交换器（模式匹配）"></a>topic 交换器（模式匹配）</h2><ol start="3"><li>topic 交换器：topic交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配 0 个或多个单词，匹配不多不少一个单词。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RabbitMQ是AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的技术实现，也是高性能消息服务组件的代表之作。由于其隶属于Pivotal公司，所以与Spring的整合效果是最完善的。在SpringCloud开发技术中大量使用了RabbitMQ消息组件。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>面试题 16.07. 最大数值</title>
    <link href="http://yoursite.com/2021/12/12/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.07.%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/"/>
    <id>http://yoursite.com/2021/12/12/面试题 16.07. 最大数值/</id>
    <published>2021-12-12T04:12:12.000Z</published>
    <updated>2021-12-12T04:20:48.078Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。</p><a id="more"></a><p>[TOC]</p><p>示例：</p><pre><code>输入： a = 1, b = 2输出： 2</code></pre><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><ol><li><p>首先 a - b 得到差值x</p></li><li><p>由于是long型，右移63位得到符号位，注意负号不变，那么正数右移63位就是0，负数右移63位就是-1</p></li><li><p>那么得出我们的计算公式  (1 + k) * a - b * k</p><p> 当 x &gt;= 0 的时候，k = 0, 即 a &gt; b<br> 那么我们的计算公式为  1 * a - b * 0 = a</p><p> 当 x &lt; 0的时候，k = -1, 即 b &gt; a<br> 那么我们的计算公式为  0 * a - b * ( -1 ) = b</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximum(int a, int b) &#123;</span><br><span class="line">        long x = (long) a - (long) b;</span><br><span class="line">        int k = (int) (x &gt;&gt; 63);</span><br><span class="line"></span><br><span class="line">        return (1 + k) * a - b * k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>关于这道题已有很多解法，大概有以下几种：</p><ol><li>使用 <code>max</code>，<code>abs</code> 之类的库函数。这种真的不要骗自己，就是作弊方法；</li><li>使用位运算，但申请了更大的类型避免溢出。这种没有作弊，但是我觉得还可以改进，因为如果入参就已经是系统支持的最大类型，那么这类解法就无效了；</li><li>使用位运算，同时没有申请更大的类型。这种已经很完美了，但是我没有看到 C/C++ 的 Solution，可能 C/C++ 面对溢出问题会报错（Java 不会），处理起来更困难一些。</li></ol><p>回到问题中，我们现在来一步一步思考。首先，如果没有限制条件，那么非常简单：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者使用三目运算符</span></span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>但是，我们不能使用 if-else 或者比较运算符，所以我们需要构思如何去返回结果，这里不妨构造一个计算公式：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>这里 k 的值应该为 1 或 0，且我们应使其：</p><ul><li>当 a &lt; b 时，k = 0，则 k ^ 1 = 1。此时计算结果等于 b；</li><li>当 a &gt; b 是，k = 1，则 k ^ 1 = 0。此时计算结果等于 a。</li></ul><p>那么如何让 k 满足我们的要求的呢？这里可以用算术运算+位运算操作：判断 a - b 的最高位（符号位），即：</p><ul><li>当 a - b &lt; 0 时，a - b 的最高位为 1，此时，k 应该为 0；</li><li>当 a - b &gt; 0 时，a - b 的最高位为 0，此时，k 应该为 1；</li></ul><p>发现了吗？k 的值和 a - b 的最高位恰好相反，这里很自然的再引入异或运算，可以得到代码：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// C/C++ 中负数右移最高位会补 1，因此需要转成无符号类型后再右移</span></span><br><span class="line">        <span class="comment">// 将 a-b 的符号位移动到最左边，再与 1 异或取反，得到 k 的值</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a - b) &gt;&gt; (bitlen - <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>这样我们就返回了正确结果。但是需要注意 a - b 可能会导致溢出问题，一种简单的解决方式是用更大的类型（例如 long long）保存中间结果，但如果入参已经是系统支持的最大类型，那这种解法就失效了，所以并不完美。因此，我们来思考一下如何在给定的类型范围内解决这个问题。这里，我们需要分情况考虑：</p><ul><li>当 a 和 b 同号时，a - b 不会溢出，使用上面的代码即可；</li><li>当 a 和 b 异号时，a - b 可能溢出，需要额外处理；</li></ul><p>第一种情况我们已经解决了，现在来考虑第二种情况。我们可以使用 a 的符号位异或 b 的符号位，当结果为 1 时，说明异号；结果为 0 时，说明同号。当异号时，我们应该直接返回正数，避免 a - b 的运算。那么当两数异号时，我们如何确定 k 的值呢？当 a 为负数时，a 的符号位为 1，此时 k 应该为 0；当 a 为正数时，a 的符号位为 0，k 应该为 1。总结规律可以发现，k 的值应该等于 a 的符号位异或 1。现在来实现第二种情况的代码：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> asign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> k = asign ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>现在我们已经实现了两种不同情况下的代码，针对两数同号或异号的场景分别处理，以避免溢出问题，最后我们只需要将其组合起来。由于不能使用 if-else 语句，需要我们用一点 trick，见下：</p><details>    <summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算 int 类型的位数，避免不同系统下长度不同</span></span><br><span class="line">        <span class="keyword">int</span> bitlen = <span class="keyword">sizeof</span>(a) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 a 的符号位，b 的符号位</span></span><br><span class="line">        <span class="comment">// C/C++ 中负数右移最高位会补 1，因此需要转成无符号类型后再右移</span></span><br><span class="line">        <span class="keyword">int</span> asign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> bsign = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(b) &gt;&gt; (bitlen - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 假设 a 与 b 异号，计算 k 的值</span></span><br><span class="line">        <span class="keyword">int</span> k = asign ^ <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 a 和 b 异号时，asign ^ bsign ^ 1 为 0，由于 逻辑与运算 的短路性，将不再计算后半行代码，避免溢出</span></span><br><span class="line">        <span class="comment">// 当 a 和 b 同号时，asign ^ bsign ^ 1 为 1，此时会执行后半行代码，重新对 k 赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp_cond = (asign ^ bsign ^ <span class="number">1</span>) &amp;&amp; (k = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(a - b) &gt;&gt; (bitlen - <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>至此，我们就完成了这道题。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Brainteaser" scheme="http://yoursite.com/tags/Brainteaser/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 079. 所有子集</title>
    <link href="http://yoursite.com/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20079.%20%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2021/12/12/剑指 Offer II 079. 所有子集/</id>
    <published>2021-12-12T03:36:12.000Z</published>
    <updated>2021-12-12T03:45:52.725Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 10-10 &lt;= nums[i] &lt;= 10nums 中的所有元素 互不相同</code></pre><p>注意：本题与主站 <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78.子集</a>题相同。</p><h1 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int state = 0; state &lt; (1 &lt;&lt; n); state ++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (((state &gt;&gt; i) &amp; 1) == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur.add(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int state = 0; state &lt; (1 &lt;&lt; n); state ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; cur;</span><br><span class="line">            for (int i = 0; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                if ((state &gt;&gt; i) &amp; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur.push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        for state in range(0, 1 &lt;&lt; n):</span><br><span class="line">            cur = []</span><br><span class="line">            for i in range(n):</span><br><span class="line">                if (state &gt;&gt; i) &amp; 1:</span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">            res.append(cur)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details><h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">    int [] nums;</span><br><span class="line">    int n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, tmp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int idx, List&lt;Integer&gt; path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path1 = new ArrayList&lt;&gt;();     path1.addAll(path);</span><br><span class="line">        dfs(idx + 1, path1);</span><br><span class="line">        path.add(nums[idx]);</span><br><span class="line">        List&lt;Integer&gt; path2 = new ArrayList&lt;&gt;();     path2.addAll(path);</span><br><span class="line">        dfs(idx + 1, path2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        dfs(0, vector&lt;int&gt;&#123;&#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int idx, vector&lt;int&gt; path)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(idx + 1, path);</span><br><span class="line">        path.push_back(nums[idx]);</span><br><span class="line">        dfs(idx + 1, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        def dfs(idx: int, path: List[int]) -&gt; None:</span><br><span class="line">            nonlocal res</span><br><span class="line">            if idx == n:</span><br><span class="line">                res.append(path)</span><br><span class="line">                return </span><br><span class="line">            dfs(idx + 1, path + [nums[idx]])</span><br><span class="line">            dfs(idx + 1, path)</span><br><span class="line"></span><br><span class="line">        dfs(0, [])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">    int [] nums;</span><br><span class="line">    int n;</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        this.n = nums.length;</span><br><span class="line">        backtrace(0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtrace(int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line"></span><br><span class="line">        path.add(nums[idx]);</span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line">        path.remove(path.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        this-&gt;n = nums.size();</span><br><span class="line">        backtrace(0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backtrace(int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        if (idx == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line"></span><br><span class="line">        path.push_back(nums[idx]);</span><br><span class="line">        backtrace(idx + 1);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        path = []</span><br><span class="line">        def backtrace(idx: int) -&gt; None:</span><br><span class="line">            nonlocal res</span><br><span class="line">            nonlocal path</span><br><span class="line">            if idx == n:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                return </span><br><span class="line">                </span><br><span class="line">            backtrace(idx + 1)</span><br><span class="line"></span><br><span class="line">            path.append(nums[idx])</span><br><span class="line">            backtrace(idx + 1)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        backtrace(0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 067. 最大的异或</title>
    <link href="http://yoursite.com/2021/12/12/%E5%89%91%E6%8C%87%20Offer%20II%20067.%20%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96/"/>
    <id>http://yoursite.com/2021/12/12/剑指 Offer II 067. 最大的异或/</id>
    <published>2021-12-12T02:12:12.000Z</published>
    <updated>2021-12-12T01:53:16.297Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p><p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p><p>注意：本题与主站 <a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. 数组中两个数的最大异或值</a>相同</p><p>示例 1：</p><pre><code>输入：nums = [3,10,5,25,2,8]输出：28解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [2,4]输出：6</code></pre><p>示例 4：</p><pre><code>输入：nums = [8,10,2]输出：10</code></pre><p>示例 5：</p><pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]输出：127</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2 * 1040 &lt;= nums[i] &lt;= 231 - 1</code></pre><h1 id="方法一：哈希表-1"><a href="#方法一：哈希表-1" class="headerlink" title="方法一：哈希表^1"></a>方法一：哈希表<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>假设我们已经确定了 <em>x</em> 最高的若干个二进制位，当前正在确定第 <em>k</em> 个二进制位。根据「前言」部分的分析，我们希望第 <em>k</em> 个二进制位能够取到 <em>1</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.insert(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.count(x_next ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = x_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = xNext - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            ISet&lt;int&gt; seen = new HashSet&lt;int&gt;();</span><br><span class="line">            // 将所有的 pre^k(a_j) 放入哈希表中</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                // 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br><span class="line">                // 只需将其右移 k 位</span><br><span class="line">                seen.Add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br><span class="line">            // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br><span class="line">            int xNext = x * 2 + 1;</span><br><span class="line">            bool found = false;</span><br><span class="line">            </span><br><span class="line">            // 枚举 i</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                if (seen.Contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br><span class="line">                // 即为 x = x*2</span><br><span class="line">                x = xNext - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            seen = set()</span><br><span class="line">            <span class="comment"># 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment"># 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment"># 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            x_next = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x_next ^ (num &gt;&gt; k) <span class="keyword">in</span> seen:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                x = x_next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment"># 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaximumXOR = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen.add(num &gt;&gt; k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">const</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.has(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = xNext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> highBit = <span class="number">30</span> <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">for</span> k := highBit; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        seen := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen[num&gt;&gt;k] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        xNext := x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found &#123;</span><br><span class="line">            x = xNext</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">hashTable</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            <span class="keyword">int</span> x = nums[i] &gt;&gt; k;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">                tmp-&gt;key = x;</span><br><span class="line">                HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x_next ^ (nums[i] &gt;&gt; k);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = x_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = x_next - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h1><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie* left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            Add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = Math.Max(x, Check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Add(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (cur.left == null) &#123;</span><br><span class="line">                    cur.left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (cur.right == null) &#123;</span><br><span class="line">                    cur.right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Check(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur.right != null) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur.left != null) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    public Trie left = null;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    public Trie right = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 左子树指向表示 0 的子节点</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 右子树指向表示 1 的子节点</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 字典树的根节点</span></span><br><span class="line">        root = Trie()</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num: int)</span>:</span></span><br><span class="line">            cur = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                        cur.left = Trie()</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                        cur.right = Trie()</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(num: int)</span> -&gt; int:</span></span><br><span class="line">            cur = root</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highBit = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.left == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.left = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.right == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.right = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">check</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    root := &amp;trie&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        root.add(nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = max(x, root.check(nums[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Trie* <span class="title">createTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">ret</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trie</span>));</span></span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                cur-&gt;left = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                cur-&gt;right = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">root</span> = <span class="title">createTrie</span>();</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        add(root, nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = fmax(x, check(root, nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>421. 数组中两个数的最大异或值</title>
    <link href="http://yoursite.com/2021/12/10/421.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/"/>
    <id>http://yoursite.com/2021/12/10/421. 数组中两个数的最大异或值/</id>
    <published>2021-12-10T10:12:12.000Z</published>
    <updated>2021-12-12T01:53:09.707Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p><p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p><p>示例 1：</p><pre><code>输入：nums = [3,10,5,25,2,8]输出：28解释：最大运算结果是 5 XOR 25 = 28.</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：0</code></pre><p>示例 3：</p><pre><code>输入：nums = [2,4]输出：6</code></pre><p>示例 4：</p><pre><code>输入：nums = [8,10,2]输出：10</code></pre><p>示例 5：</p><pre><code>输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]输出：127</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2 * 1040 &lt;= nums[i] &lt;= 231 - 1</code></pre><h1 id="方法一：哈希表-1"><a href="#方法一：哈希表-1" class="headerlink" title="方法一：哈希表^1"></a>方法一：哈希表<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p>假设我们已经确定了 <em>x</em> 最高的若干个二进制位，当前正在确定第 <em>k</em> 个二进制位。根据「前言」部分的分析，我们希望第 <em>k</em> 个二进制位能够取到 <em>1</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.insert(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.count(x_next ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = x_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            <span class="keyword">int</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seen.contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment">// 即为 x = x*2</span></span><br><span class="line">                x = xNext - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            ISet&lt;int&gt; seen = new HashSet&lt;int&gt;();</span><br><span class="line">            // 将所有的 pre^k(a_j) 放入哈希表中</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                // 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br><span class="line">                // 只需将其右移 k 位</span><br><span class="line">                seen.Add(num &gt;&gt; k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br><span class="line">            // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br><span class="line">            int xNext = x * 2 + 1;</span><br><span class="line">            bool found = false;</span><br><span class="line">            </span><br><span class="line">            // 枚举 i</span><br><span class="line">            foreach (int num in nums) &#123;</span><br><span class="line">                if (seen.Contains(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                    found = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (found) &#123;</span><br><span class="line">                x = xNext;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br><span class="line">                // 即为 x = x*2</span><br><span class="line">                x = xNext - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            seen = set()</span><br><span class="line">            <span class="comment"># 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">                <span class="comment"># 只需将其右移 k 位</span></span><br><span class="line">                seen.add(num &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment"># 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">            x_next = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 枚举 i</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x_next ^ (num &gt;&gt; k) <span class="keyword">in</span> seen:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                x = x_next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">                <span class="comment"># 即为 x = x*2</span></span><br><span class="line">                x = x_next - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaximumXOR = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen.add(num &gt;&gt; k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">const</span> xNext = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.has(xNext ^ (num &gt;&gt; k))) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = xNext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> highBit = <span class="number">30</span> <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">for</span> k := highBit; k &gt;= <span class="number">0</span>; k-- &#123;</span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        seen := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            seen[num&gt;&gt;k] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        xNext := x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        found := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;</span><br><span class="line">                found = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> found &#123;</span><br><span class="line">            x = xNext</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = xNext - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">hashTable</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">// 将所有的 pre^k(a_j) 放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span></span><br><span class="line">            <span class="comment">// 只需将其右移 k 位</span></span><br><span class="line">            <span class="keyword">int</span> x = nums[i] &gt;&gt; k;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTable));</span><br><span class="line">                tmp-&gt;key = x;</span><br><span class="line">                HASH_ADD_INT(hashTable, key, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span></span><br><span class="line">        <span class="comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span></span><br><span class="line">        <span class="keyword">int</span> x_next = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x_next ^ (nums[i] &gt;&gt; k);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashTable, &amp;x, tmp);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            x = x_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span></span><br><span class="line">            <span class="comment">// 即为 x = x*2</span></span><br><span class="line">            x = x_next - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：字典树"><a href="#方法二：字典树" class="headerlink" title="方法二：字典树"></a>方法二：字典树</h1><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie* left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    const int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">    public int FindMaximumXOR(int[] nums) &#123;</span><br><span class="line">        int n = nums.Length;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            Add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = Math.Max(x, Check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Add(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (cur.left == null) &#123;</span><br><span class="line">                    cur.left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (cur.right == null) &#123;</span><br><span class="line">                    cur.right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int Check(int num) &#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur.right != null) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur.left != null) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    public Trie left = null;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    public Trie right = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 左子树指向表示 0 的子节点</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 右子树指向表示 1 的子节点</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 字典树的根节点</span></span><br><span class="line">        root = Trie()</span><br><span class="line">        <span class="comment"># 最高位的二进制位编号为 30</span></span><br><span class="line">        HIGH_BIT = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num: int)</span>:</span></span><br><span class="line">            cur = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                        cur.left = Trie()</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                        cur.right = Trie()</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(num: int)</span> -&gt; int:</span></span><br><span class="line">            cur = root</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(HIGH_BIT, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        cur = cur.left</span><br><span class="line">                        x = x * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur = cur.right</span><br><span class="line">                        x = x * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = max(x, check(nums[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highBit = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">add</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.left == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.left = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.right == <span class="literal">nil</span> &#123;</span><br><span class="line">                cur.right = &amp;trie&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *trie)</span> <span class="title">check</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    cur := t</span><br><span class="line">    <span class="keyword">for</span> i := highBit; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        bit := num &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.right != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> cur.left != <span class="literal">nil</span> &#123;</span><br><span class="line">                cur = cur.left</span><br><span class="line">                x = x*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right</span><br><span class="line">                x = x * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaximumXOR</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    root := &amp;trie&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        root.add(nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = max(x, root.check(nums[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Trie* <span class="title">createTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">ret</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Trie</span>));</span></span><br><span class="line">    ret-&gt;left = ret-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">                cur-&gt;left = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">                cur-&gt;right = createTrie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(struct Trie* root, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">cur</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                x = x * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">root</span> = <span class="title">createTrie</span>();</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">        add(root, nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">        x = fmax(x, check(root, nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>面试题 05.03. 翻转数位</title>
    <link href="http://yoursite.com/2021/12/10/%E9%9D%A2%E8%AF%95%E9%A2%98%2005.03.%20%E7%BF%BB%E8%BD%AC%E6%95%B0%E4%BD%8D/"/>
    <id>http://yoursite.com/2021/12/10/面试题 05.03. 翻转数位/</id>
    <published>2021-12-10T07:12:12.000Z</published>
    <updated>2021-12-10T09:50:02.413Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入: num = 1775(110111011112)输出: 8</code></pre><p>示例 2：</p><pre><code>输入: num = 7(01112)输出: 4</code></pre><h1 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h1><p>每次维护三个变量<br>cur：当前位置为止连续1的个数，遇到0归零，遇到1加1<br>insert：在当前位置变成1，往前数连续1的最大个数，遇到0变为cur+1，遇到1加1<br>res:保存insert的最大值即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>    <summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        insert = <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> num &amp; (<span class="number">1</span>&lt;&lt;i):</span><br><span class="line">               cur += <span class="number">1</span></span><br><span class="line">               insert +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                insert = cur + <span class="number">1</span></span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            res = max(res,insert)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insert = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                cur += <span class="number">1</span>;</span><br><span class="line">                insert += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                insert = cur + <span class="number">1</span>;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, insert);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="模拟法解题思路"><a href="#模拟法解题思路" class="headerlink" title="模拟法解题思路"></a>模拟法解题思路</h1><p>这是一道模拟题。</p><p><strong>关键点</strong></p><ol><li>用 bitset&lt;32&gt; 记录好num的32位二进制01串。</li><li>遍历 bitset&lt;32&gt; , 找相邻的连续0串 和 连续1串。</li><li>记录好前后被0串分隔的1串的长度，通过中间的0串的长度是否为1 判断两个1串是否可以连接</li><li>不要忽略特殊情况，当32位全为1时,例如-1，不需要变位就已经达到最长的1串长度，为32</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><details>    <summary>cpp</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;32&gt; bits(num);<span class="comment">//记录 num 的二进制 01 串</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span> , zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= <span class="number">32</span>)&#123;</span><br><span class="line">            n1 = n2 ,n2 = <span class="number">0</span>, zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=<span class="number">32</span> &amp;&amp; bits[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                ++zero;<span class="comment">//统计连续的 0 的个数</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=<span class="number">32</span> &amp;&amp; bits[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                ++n2;<span class="comment">//统计连续的 1 的个数</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,n2+<span class="number">1</span>);           </span><br><span class="line">            <span class="keyword">if</span>(zero==<span class="number">1</span>)&#123; <span class="comment">//如果前后的连续为 1 的串中间之隔了一个0</span></span><br><span class="line">                ans = max(ans,n1+n2+<span class="number">1</span>); <span class="comment">//看连接之后是否达到最长</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(<span class="number">32</span>,ans); <span class="comment">//有可能全为 1 ，此时不用变位已达到最长</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet(<span class="number">32</span>);<span class="comment">//记录 num 的二进制 01 串</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                bitSet.set(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = <span class="number">0</span>;</span><br><span class="line">            zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">32</span> &amp;&amp; !bitSet.get(i)) &#123;</span><br><span class="line">                zero++; <span class="comment">//统计连续的 0 的个数</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">32</span> &amp;&amp; bitSet.get(i)) &#123;</span><br><span class="line">                n2++;<span class="comment">//统计连续的 1 的个数</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, n2 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (zero == <span class="number">1</span>) &#123;<span class="comment">//如果前后的连续为 1 的串中间之隔了一个0</span></span><br><span class="line">                ans = Math.max(ans, n1 + n2 + <span class="number">1</span>);<span class="comment">//看连接之后是否达到最长</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(<span class="number">32</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个32位整数num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 65. 不用加减乘除做加法</title>
    <link href="http://yoursite.com/2021/12/10/%E5%89%91%E6%8C%87%20Offer%2065.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <id>http://yoursite.com/2021/12/10/剑指 Offer 65. 不用加减乘除做加法/</id>
    <published>2021-12-10T04:12:12.000Z</published>
    <updated>2021-12-10T03:52:57.268Z</updated>
    
    <content type="html"><![CDATA[<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><a id="more"></a><p>[TOC]</p><p>示例:</p><pre><code>输入: a = 1, b = 1输出: 2</code></pre><p>提示：</p><pre><code>a, b 均可能是负数或 0结果不会溢出 32 位整数</code></pre><h1 id="解题思路-1："><a href="#解题思路-1：" class="headerlink" title="解题思路^1："></a>解题思路<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/" target="_blank" rel="noopener">^1</a>：</h1><p>本题考察对位运算的灵活使用，即使用位运算实现加法。<br>设两数字的二进制形式 <em>a, b</em> ，其求和 <em>s = a + b</em> ，<em>a(i)</em> 代表 <em>a</em> 的二进制第 <em>i</em> 位，则分为以下四种情况：</p><table><thead><tr><th align="center"><em>a(i)</em></th><th align="center"><em>b(i)</em></th><th align="center">无进位和 <em>n(i)</em></th><th align="center">进位 <em>c(i+1)</em></th></tr></thead><tbody><tr><td align="center"><em>0</em></td><td align="center"><em>0</em></td><td align="center"><em>0</em></td><td align="center"><em>0</em></td></tr><tr><td align="center"><em>0</em></td><td align="center"><em>1</em></td><td align="center"><em>1</em></td><td align="center"><em>0</em></td></tr><tr><td align="center"><em>1</em></td><td align="center"><em>0</em></td><td align="center"><em>1</em></td><td align="center"><em>0</em></td></tr><tr><td align="center"><em>1</em></td><td align="center"><em>1</em></td><td align="center"><em>0</em></td><td align="center"><em>1</em></td></tr></tbody></table><p>观察发现，<strong>无进位和</strong> 与 <strong>异或运算</strong> 规律相同，<strong>进位</strong> 和 <strong>与运算</strong> 规律相同（并需左移一位）。因此，无进位和 <em>n</em> 与进位 <em>c</em> 的计算公式如下；</p><p>（和 <em>s</em> ）<em>=</em>（非进位和 <em>n</em> ）<em>+</em>（进位 <em>c</em> ）。即可将 <em>s = a + b</em> 转化为：</p><p>循环求 <em>n</em> 和 <em>c</em> ，直至进位 <em>c = 0</em> ；此时 <em>s = n</em> ，返回 <em>n</em> 即可。</p><blockquote><p><strong>Q ：</strong> 若数字 <em>a</em> 和 <em>b</em> 中有负数，则变成了减法，如何处理？<br><strong>A ：</strong> 在计算机系统中，数值一律用 <strong>补码</strong> 来表示和存储。<strong>补码的优势：</strong> 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 <strong>同时适用于正数和负数的加法</strong> 。</p></blockquote><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><ul><li><strong>时间复杂度 <em>O(1)</em> ：</strong> 最差情况下（例如 <em>a =</em> 0x7fffffff , <em>b = 1</em> 时），需循环 32 次，使用 <em>O(1)</em> 时间；每轮中的常数次位操作使用 <em>O(1)</em> 时间。</li><li><strong>空间复杂度 <em>O(1)</em> ：</strong> 使用常数大小的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><details>    <summary>java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和</span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a, b = a &amp; x, b &amp; x</span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            a, b = (a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span> &amp; x</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x)</span><br></pre></td></tr></table></figure></details><h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h2><details>    <summary>递归写法java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和</span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><blockquote><p>由于 Python 的数字存储特点，需要做特殊考虑，以下详细介绍。</p></blockquote><h2 id="Python-负数的存储："><a href="#Python-负数的存储：" class="headerlink" title="Python 负数的存储："></a>Python 负数的存储：</h2><p>Python，Java 等语言中的数字都是以 <strong>补码</strong> 形式存储的。但 Python 没有 <code>int</code> , <code>long</code> 等不同长度变量，即在编程时无变量位数的概念。<br><strong>获取负数的补码：</strong> 需要将数字与十六进制数 <code>0xffffffff</code> 相与。可理解为舍去此数字 32 位以上的数字（将 32 位以上都变为 <em>0</em> ），从无限长度变为一个 32 位整数。<br><strong>返回前数字还原：</strong> 若补码 <em>a</em> 为负数（ <code>0x7fffffff</code> 是最大的正数的补码 ），需执行 <code>~(a ^ x)</code> 操作，将补码还原至 Python 的存储格式。 <code>a ^ x</code> 运算将 1 至 32 位按位取反； <code>~</code> 运算是将整个数字取反；因此， <code>~(a ^ x)</code> 是将 32 位以上的位取反，1 至 32 位不变。</p><details>    <summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(hex(<span class="number">1</span>)) <span class="comment"># = 0x1 补码</span></span><br><span class="line">print(hex(<span class="number">-1</span>)) <span class="comment"># = -0x1 负号 + 原码 （ Python 特色，Java 会直接输出补码）</span></span><br><span class="line"></span><br><span class="line">print(hex(<span class="number">1</span> &amp; <span class="number">0xffffffff</span>)) <span class="comment"># = 0x1 正数补码</span></span><br><span class="line">print(hex(<span class="number">-1</span> &amp; <span class="number">0xffffffff</span>)) <span class="comment"># = 0xffffffff 负数补码</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">-1</span> &amp; <span class="number">0xffffffff</span>) <span class="comment"># = 4294967295 （ Python 将其认为正数）</span></span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 64. 求1+2+…+n</title>
    <link href="http://yoursite.com/2021/12/09/%E5%89%91%E6%8C%87%20Offer%2064.%20%E6%B1%821+2+%E2%80%A6+n/"/>
    <id>http://yoursite.com/2021/12/09/剑指 Offer 64. 求1+2+…+n/</id>
    <published>2021-12-09T02:12:12.000Z</published>
    <updated>2021-12-09T07:22:10.018Z</updated>
    
    <content type="html"><![CDATA[<p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入: n = 3输出: 6</code></pre><p>示例 2：</p><pre><code>输入: n = 9输出: 45</code></pre><p>限制：</p><pre><code>1 &lt;= n &lt;= 10000</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先我们梳理题目要求。题目要求我们不能使用乘除法、<code>for</code>、<code>while</code>、<code>if</code>、<code>else</code>、<code>switch</code>、<code>case</code> 等关键字及条件判断语句，因此我们手里能用的工具很少，列举出来发现只有加减法、赋值、位运算符以及逻辑运算符。</p><h1 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h1><p><strong>思路和算法</strong></p><p>试想一下如果不加限制地使用递归的方法来实现这道题，相信大家都能很容易地给出下面的实现（以 C++ 为例）：</p><figure class="highlight c++"><figcaption><span>[sol0-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。</p><p>以逻辑运算符 <code>&amp;&amp;</code> 为例，对于 <code>A &amp;&amp; B</code> 这个表达式，如果 <code>A</code> 表达式返回False  ，那么 <code>A &amp;&amp; B</code> 已经确定为 False ，此时不会去执行表达式 <code>B</code>。同理，对于逻辑运算符 <code>||</code>， 对于 <code>A || B</code> 这个表达式，如果 <code>A</code> 表达式返回 True ，那么 <code>A || B</code> 已经确定为 True ，此时不会去执行表达式 <code>B</code>。</p><p>利用这一特性，我们可以将判断是否为递归的出口看作 <code>A &amp;&amp; B</code> 表达式中的 <code>A</code> 部分，递归的主体函数看作 <code>B</code> 部分。如果不是递归出口，则返回 True，并继续执行表达式 <code>B</code> 的部分，否则递归结束。当然，你也可以用逻辑运算符 <code>||</code> 给出类似的实现，这里我们只提供结合逻辑运算符 <code>&amp;&amp;</code> 的递归实现。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += sumNums(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>TypeScript</summary><figure class="highlight typescript"><figcaption><span>[sol1-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumNums = <span class="function"><span class="keyword">function</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    n &amp;&amp; (n += sumNums(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNums</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">sum</span> = <span class="title">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        ans += n</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; sum(n<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sum(n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(n)*。递归函数递归 *n</em> 次，每次递归中计算时间复杂度为 <em>O(1)</em>，因此总时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：<em>O(n)</em>。递归函数的空间复杂度取决于递归调用栈的深度，这里递归函数调用栈深度为 <em>O(n)</em>，因此空间复杂度为 <em>O(n)</em>。</li></ul><h1 id="方法二：快速乘"><a href="#方法二：快速乘" class="headerlink" title="方法二：快速乘"></a>方法二：快速乘</h1><p><strong>思路和算法</strong></p><p>考虑 <code>A</code> 和 <code>B</code> 两数相乘的时候我们如何利用加法和位运算来模拟，其实就是将 <code>B</code> 二进制展开，如果 <code>B</code> 的二进制表示下第 <em>i</em> 位为 1，那么这一位对最后结果的贡献就是 <em>A</em>(1&lt;&lt;i)* ，即 <em>A&lt;&lt;i</em>。我们遍历 <code>B</code> 二进制展开下的每一位，将所有贡献累加起来就是最后的答案，这个方法也被称作「俄罗斯农民乘法」，感兴趣的读者可以自行网上搜索相关资料。这个方法经常被用于两数相乘取模的场景，如果两数相乘已经超过数据范围，但取模后不会超过，我们就可以利用这个方法来拆位取模计算贡献，保证每次运算都在数据范围内。</p><p>下面给出这个算法的 C++ 实现：</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol20-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickMulti</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; B; B &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans += A;</span><br><span class="line">        &#125;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>回到本题，由等差数列求和公式我们可以知道 1+2+…+n 等价于 n(n+1)/2 ，对于除以 <em>2</em> 我们可以用右移操作符来模拟，那么等式变成了 <em>n(n+1)&gt;&gt;1<em>，剩下不符合题目要求的部分即为 *n(n+1)</em>，根据上文提及的快速乘，我们可以将两个数相乘用加法和位运算来模拟，但是可以看到上面的 C++ 实现里我们还是需要循环语句，有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 *n</em> 为 <em>[1,10000]*，所以 *n</em> 二进制展开最多不会超过 <em>14</em> 位，我们手动展开 <em>14</em> 层代替循环即可，至此满足了题目的要求，具体实现可以参考下面给出的代码。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>TypeScript</summary><figure class="highlight typescript"><figcaption><span>[sol2-TypeScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumNums = <span class="function"><span class="keyword">function</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans: <span class="built_in">number</span> = <span class="number">0</span>, A: <span class="built_in">number</span> = n, B: <span class="built_in">number</span> = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    (B &amp; <span class="number">1</span>) &amp;&amp; (ans += A);</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNums</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans, A, B := <span class="number">0</span>, n, n + <span class="number">1</span></span><br><span class="line">    addGreatZero := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        ans += A</span><br><span class="line">        <span class="keyword">return</span> ans &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    _ = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; addGreatZero()</span><br><span class="line">    A &lt;&lt;= <span class="number">1</span></span><br><span class="line">    B &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Brainteaser" scheme="http://yoursite.com/tags/Brainteaser/"/>
    
  </entry>
  
  <entry>
    <title>1863. 找出所有子集的异或总和再求和</title>
    <link href="http://yoursite.com/2021/12/08/1863.%20%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2021/12/08/1863. 找出所有子集的异或总和再求和/</id>
    <published>2021-12-08T14:12:12.000Z</published>
    <updated>2021-12-09T06:35:01.980Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><a id="more"></a><p>[TOC]</p><p>一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。</p><p>例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。<br>给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p><p>数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。</p><p>示例 1：</p><pre><code>输入：nums = [1,3]输出：6解释：[1,3] 共有 4 个子集：- 空子集的异或总和是 0 。- [1] 的异或总和为 1 。- [3] 的异或总和为 3 。- [1,3] 的异或总和为 1 XOR 3 = 2 。0 + 1 + 3 + 2 = 6</code></pre><p>示例 2：</p><pre><code>输入：nums = [5,1,6]输出：28解释：[5,1,6] 共有 8 个子集：- 空子集的异或总和是 0 。- [5] 的异或总和为 5 。- [1] 的异或总和为 1 。- [6] 的异或总和为 6 。- [5,1] 的异或总和为 5 XOR 1 = 4 。- [5,6] 的异或总和为 5 XOR 6 = 3 。- [1,6] 的异或总和为 1 XOR 6 = 7 。- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28</code></pre><p>示例 3：</p><pre><code>输入：nums = [3,4,5,6,7,8]输出：480解释：每个子集的全部异或总和值之和为 480 。</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 121 &lt;= nums[i] &lt;= 20</code></pre><h1 id="方法一：递归法枚举子集-1"><a href="#方法一：递归法枚举子集-1" class="headerlink" title="方法一：递归法枚举子集^1"></a>方法一：递归法枚举子集<a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/solution/sum-of-all-subset-xor-totals-by-leetcode-o5aa/" target="_blank" rel="noopener">^1</a></h1><p><strong>思路与算法</strong></p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == n)&#123;</span><br><span class="line">            <span class="comment">// 终止递归</span></span><br><span class="line">            res += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前数字</span></span><br><span class="line">        dfs(val ^ nums[idx], idx + <span class="number">1</span>, nums);</span><br><span class="line">        <span class="comment">// 考虑不选择当前数字</span></span><br><span class="line">        dfs(val, idx + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(val, idx)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> idx == n:</span><br><span class="line">                <span class="comment"># 终止递归</span></span><br><span class="line">                res += val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 考虑选择当前数字</span></span><br><span class="line">            dfs(val ^ nums[idx], idx + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 考虑不选择当前数字</span></span><br><span class="line">            dfs(val, idx + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> idx, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">            res += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(val ^ nums[idx], idx + <span class="number">1</span>, nums);</span><br><span class="line">        dfs(val, idx + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：迭代法枚举子集"><a href="#方法二：迭代法枚举子集" class="headerlink" title="方法二：迭代法枚举子集"></a>方法二：迭代法枚举子集</h1><p><strong>提示 <em>1</em></strong></p><p>一个长度为 <em>n</em> 的数组 nums  有 <em>2^n</em> 个子集（包括空集与自身）。我们可以将这些子集一一映射到 <em>[0, 2^n-1]</em> 中的整数。</p><p><strong>提示 <em>2</em></strong></p><p>数组中的每个元素都有「选取」与「未选取」两个状态，可以对应一个二进制位的 <em>1</em> 与 <em>0</em>。那么对于一个长度为 <em>n</em> 的数组nums ，我们也可以用 <em>n</em> 个二进制位的整数来唯一表示每个元素的选取情况。此时该整数第 <em>j</em> 位的取值表示数组第 <em>j</em> 个元素是否包含在对应的子集中。</p><p><strong>思路与算法</strong></p><p>我们也可以用迭代来实现子集枚举。</p><p>根据 <strong>提示 <em>1</em></strong> 与 <strong>提示 <em>2</em></strong>，我们枚举 <em>[0, 2^n-1]</em> 中的整数 <em>i</em>，其第 <em>j</em> 位的取值表示nums 的第 <em>j</em> 个元素是否包含在对应的子集中。</p><p>对于每个整数 <em>i</em>，我们遍历它的每一位计算对应子集的异或总和，并维护这些值之和。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)&#123;   <span class="comment">// 遍历所有子集</span></span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;   <span class="comment">// 遍历每个元素</span></span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j))&#123;</span><br><span class="line">                    tmp ^= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; n):   <span class="comment"># 遍历所有子集</span></span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):   <span class="comment"># 遍历每个元素</span></span><br><span class="line">                <span class="keyword">if</span> i &amp; (<span class="number">1</span> &lt;&lt; j):</span><br><span class="line">                    tmp ^= nums[j]</span><br><span class="line">            res += tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; nums.length); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span> )!= <span class="number">0</span>) &#123;</span><br><span class="line">                    val ^= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n2^n)*，其中 *n</em> 为nums 的长度。我们遍历了 nums 的 <em>2^n</em> 个子集，每个子集需要 <em>O(n)</em> 的时间计算异或总和。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h1 id="方法三：按位考虑-二项式展开-1"><a href="#方法三：按位考虑-二项式展开-1" class="headerlink" title="方法三：按位考虑 + 二项式展开^1"></a>方法三：按位考虑 + 二项式展开<a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/solution/sum-of-all-subset-xor-totals-by-leetcode-o5aa/" target="_blank" rel="noopener">^1</a></h1><p><strong>提示 <em>1</em></strong></p><p>由于异或运算本质上是按位操作，因此我们可以按位考虑取值情况。</p><p><strong>提示 <em>2</em></strong></p><p>对于数组中所有元素的某一位，存在两种可能：</p><ul><li><p>第一种，所有元素该位都为 <em>0</em>；</p></li><li><p>第二种，至少有一个元素该位为 <em>1</em>。</p></li></ul><p>假设数组元素个数为 <em>n</em>，那么第一种情况下，所有子集异或总和中该位均为 <em>0</em>；第二种情况下，所有子集异或总和中该位为 <em>0</em> 的个数与为 <em>1</em> 的个数相等，均为 <em>2^{n-1}</em>。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res |= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res |= num</span><br><span class="line">        <span class="keyword">return</span> res &lt;&lt; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为 nums 的长度，即为一遍遍历数组的时间复杂度。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Combinatorics" scheme="http://yoursite.com/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
    <link href="http://yoursite.com/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2053%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2021/12/08/剑指 Offer 53 - II. 0～n-1中缺失的数字/</id>
    <published>2021-12-08T07:12:12.000Z</published>
    <updated>2021-12-08T07:34:12.449Z</updated>
    
    <content type="html"><![CDATA[<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: [0,1,3]输出: 2</code></pre><p>示例 2:</p><pre><code>输入: [0,1,2,3,4,5,6,7,9]输出: 8</code></pre><p>限制：</p><pre><code>1 &lt;= 数组长度 &lt;= 10000</code></pre><p>此题由<a href="https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/" target="_blank" rel="noopener">268. 丢失的数字</a>改编而来，但题干部分描述的不太清楚，多出来的数字应该是n</p><p>解法可参见<a href="https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/" target="_blank" rel="noopener">268. 丢失的数字</a></p><p>由于该题不同之处在于是有序的，所以还可以使用二分法</p><h1 id="二分法解题思路-1："><a href="#二分法解题思路-1：" class="headerlink" title="二分法解题思路^1："></a>二分法解题思路<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/" target="_blank" rel="noopener">^1</a>：</h1><ul><li>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</li><li>根据题意，数组可以按照以下规则划分为两部分。<ul><li><strong>左子数组：</strong> <em>nums[i] = i</em> ；</li><li><strong>右子数组：</strong> <em>nums[i] != i</em>  ；</li></ul></li><li>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</li></ul><h1 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h1><ul><li><strong>时间复杂度 <em>O(log N)</em>：</strong> 二分法为对数级别复杂度。</li><li><strong>空间复杂度 <em>O(1)</em>：</strong> 几个变量使用常数大小的额外空间。</li></ul><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == m: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == m) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 56 - II. 数组中数字出现的次数 II</title>
    <link href="http://yoursite.com/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2056%20-%20II.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%20II/"/>
    <id>http://yoursite.com/2021/12/08/剑指 Offer 56 - II. 数组中数字出现的次数 II/</id>
    <published>2021-12-08T07:12:12.000Z</published>
    <updated>2021-12-08T07:05:05.128Z</updated>
    
    <content type="html"><![CDATA[<p>在一个数组 nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [3,4,3,3]输出：4</code></pre><p>示例 2：</p><pre><code>输入：nums = [9,1,7,9,7,9,7]输出：1</code></pre><p>限制：</p><pre><code>1 &lt;= nums.length &lt;= 100001 &lt;= nums[i] &lt; 2^31</code></pre><p>参见137. 只出现一次的数字II<a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个数组 nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
    <link href="http://yoursite.com/2021/12/08/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2021/12/08/剑指 Offer 56 - I. 数组中数字出现的次数/</id>
    <published>2021-12-08T06:12:12.000Z</published>
    <updated>2021-12-08T06:40:04.185Z</updated>
    
    <content type="html"><![CDATA[<p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]</code></pre><p>限制：</p><pre><code>2 &lt;= nums.length &lt;= 10000</code></pre><h1 id="📖文字题解"><a href="#📖文字题解" class="headerlink" title="📖文字题解"></a>📖文字题解</h1><h2 id="方法一：分组异或"><a href="#方法一：分组异或" class="headerlink" title="方法一：分组异或"></a>方法一：分组异或</h2><p><strong>思路</strong></p><p>让我们先来考虑一个比较简单的问题：</p><blockquote><p>如果除了<strong>一个</strong>数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p></blockquote><p>答案很简单：全员进行异或操作即可。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 <em>0</em>，不同结果为 <em>1</em>。那么在计算过程中，成对出现的数字的所有位会两两抵消为 <em>0</em>，最终得到的结果就是那个出现了一次的数字。</p><p>那么这一方法如何扩展到找出<strong>两个</strong>出现一次的数字呢？</p><p>如果我们可以把所有数字分成两组，使得：</p><ol><li><p>两个只出现一次的数字在不同的组中；</p></li><li><p>相同的数字会被分到相同的组中。</p></li></ol><p>那么对两个组分别进行异或操作，即可得到答案的两个数字。<strong>这是解决这个问题的关键。</strong></p><p>那么如何实现这样的分组呢？</p><p>记这两个只出现了一次的数字为 <em>a</em> 和 <em>b</em>，那么所有数字异或的结果就等于 <em>a</em> 和 <em>b</em> 异或的结果，我们记为 <em>x</em>。如果我们把 <em>x</em> 写成二进制的形式 X_kX_k-1…X0 ，其中x_i in {0,1} ，我们考虑一下 <em>x_i = 0</em> 和 <em>x_i = 1</em> 的含义是什么？它意味着如果我们把 <em>a</em> 和 <em>b</em> 写成二进制的形式，<em>a_i</em> 和 <em>b_i</em> 的关系——<em>x_i = 1</em> 表示 <em>a_i</em> 和 <em>b_i</em> 不等，<em>x_i = 0</em> 表示 <em>a_i</em> 和 <em>b_i</em> 相等。假如我们任选一个不为 <em>0</em> 的 <em>x_i*，按照第 *i</em> 位给原来的序列分组，如果该位为 <em>0</em> 就分到第一组，否则就分到第二组，这样就能满足以上两个条件，为什么呢？ </p><ul><li><p>首先，两个相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2。</p></li><li><p>这个方法在 <em>x_i = 1</em> 的时候 <em>a</em> 和 <em>b</em> 不被分在同一组，因为 <em>x_i = 1</em> 表示 <em>a_i</em> 和 <em>b_i</em> 不等，根据这个方法的定义「如果该位为 <em>0</em> 就分到第一组，否则就分到第二组」可以知道它们被分进了两组，所以满足了条件 1。</p></li></ul><p>在实际操作的过程中，我们拿到序列的异或和 <em>x</em> 之后，对于这个「位」是可以任取的，只要它满足 <em>x_i = 1*。但是为了方便，这里的代码选取的是「不为 *0</em> 的最低位」，当然你也可以选择其他不为 <em>0</em> 的位置。</p><p>至此，答案已经呼之欲出了。</p><p><strong>算法</strong></p><p>先对所有数字进行一次异或，得到两个出现一次的数字的异或值。</p><p>在异或结果中找到任意为 <em>1</em> 的位。</p><p>根据这一位对所有的数字进行分组。</p><p>在每个组内进行异或操作，得到两个数字。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            ret ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; ret) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ret = functools.reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br><span class="line">        div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> div &amp; ret == <span class="number">0</span>:</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &amp; div:</span><br><span class="line">                a ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= n</span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">SingleNumbers</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xorSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> x <span class="keyword">in</span> nums) xorSum ^= x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lowbit = xorSum &amp; (-xorSum);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> x <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            ret[(x &amp; lowbit) &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>] ^= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)</em>，我们只需要遍历数组两次。</p></li><li><p>空间复杂度：<em>O(1)</em>，只需要常数的空间存放若干变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>477. 汉明距离总和</title>
    <link href="http://yoursite.com/2021/12/07/477.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/"/>
    <id>http://yoursite.com/2021/12/07/477. 汉明距离总和/</id>
    <published>2021-12-07T14:12:12.000Z</published>
    <updated>2021-12-07T14:34:08.966Z</updated>
    
    <content type="html"><![CDATA[<p>两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。</p><p>给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 。</p><a id="more"></a><p>[TOC]</p><p>示例 1：</p><pre><code>输入：nums = [4,14,2]输出：6解释：在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系）所以答案为：HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6</code></pre><p>示例 2：</p><pre><code>输入：nums = [4,14,4]输出：4</code></pre><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 1040 &lt;= nums[i] &lt;= 109给定输入的对应答案符合 32-bit 整数范围</code></pre><h1 id="方法一：逐位统计-1"><a href="#方法一：逐位统计-1" class="headerlink" title="方法一：逐位统计^1"></a>方法一：逐位统计<a href="https://leetcode-cn.com/problems/total-hamming-distance/solution/yi-ming-ju-chi-zong-he-by-leetcode-solut-t0ev/" target="_blank" rel="noopener">^1</a></h1><p>在计算汉明距离时，我们考虑的是同一比特位上的值是否不同，而不同比特位之间是互不影响的。</p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">                c += (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += c * (n - c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">                c += (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += c * (n - c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C#</summary><figure class="highlight plain"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int TotalHammingDistance(int[] nums) &#123;</span><br><span class="line">        int ans = 0, n = nums.Length;</span><br><span class="line">        for (int i = 0; i &lt; 30; ++i) &#123;</span><br><span class="line">            int c = 0;</span><br><span class="line">            foreach (int val in nums) &#123;</span><br><span class="line">                c += (val &gt;&gt; i) &amp; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += c * (n - c);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalHammingDistance</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">30</span>; i++ &#123;</span><br><span class="line">        c := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, val := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            c += val &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans += c * (n - c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalHammingDistance</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">            c = sum(((val &gt;&gt; i) &amp; <span class="number">1</span>) <span class="keyword">for</span> val <span class="keyword">in</span> nums)</span><br><span class="line">            ans += c * (n - c)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            c += (nums[j] &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += c * (numsSize - c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> totalHammingDistance = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>, n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            c += (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += c * (n - c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper学习笔记（概念，协议，投票机制）</title>
    <link href="http://yoursite.com/2021/12/05/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <id>http://yoursite.com/2021/12/05/Zookeeper学习笔记（概念，协议，投票机制）/</id>
    <published>2021-12-05T08:12:12.000Z</published>
    <updated>2021-12-05T08:42:35.117Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper （动物园管理员）是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。</p><a id="more"></a><p>[TOC]</p><p>摘自《Java高并发核心编程卷1：NIO、Netty、Redis、ZooKeeper》1.3　分布式利器ZooKeeper <a href="https://weread.qq.com/web/reader/e6d323b0723b6029e6d1c55kd3d322001ad3d9446802347" target="_blank" rel="noopener">^1</a></p><h1 id="什么是ZooKeeper"><a href="#什么是ZooKeeper" class="headerlink" title="什么是ZooKeeper"></a>什么是ZooKeeper</h1><p>最早起源于雅虎公司研究院的一个研究小组。当时，研究人员发现，在雅虎内部很多大型的系统需要依赖一个类似的系统进行分布式协调，但是这些系统往往存在分布式单点问题，所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架。</p><p>此框架的命名过程也是非常有趣的。在项目初期给这个项目命名时，准备和很多项目一样，按照雅虎公司的惯例使用动物的名字来命名（例如著名的Pig项目）。在探讨取什么名字的时候，研究院的首席科学家Raghu Ramakrishnan开玩笑说：“再这样下去，我们这儿就变成动物园了。”此话一出，大家纷纷表示新框架就叫动物园管理员吧，于是ZooKeeper（动物园管理员）诞生了。而ZooKeeper正好是用来协调分布式环境的不同节点的，形象地说，可以理解为协调各个以动物命名的分布式组件，所以ZooKeeper也就“名副其实”了。</p><h1 id="ZooKeeper的优势"><a href="#ZooKeeper的优势" class="headerlink" title="ZooKeeper的优势"></a>ZooKeeper的优势</h1><p>ZooKeeper的核心优势是实现了分布式环境的数据一致性，简单地说：每时每刻我们访问ZooKeeper的树结构时，不同的节点返回的数据都是一致的。也就是说，对ZooKeeper进行数据访问时，无论是什么时间，都不会引起“脏读”“幻读”“不可重复读”问题。</p><p>“脏读”“幻读”“不可重复读”是数据库事务的概念，当然，ZooKeeper也可以被理解为一种简单的分布式数据库。“脏读”是指一个事务中访问到了另外一个事务未提交的数据。“不可重复读”是指在一个事务内根据同一个条件对数据进行多次查询，但是结果却不一致，原因是其他事务对该数据进行了修改。“幻读”是指当两个完全相同的查询执行时，第二次查询所返回的结果集和第一次查询所返回的结果集不相同，原因也是另外一个事务新增、删除了第一个事务结果集中的数据。</p><h3 id="“不可重复读”和“幻读”的区别"><a href="#“不可重复读”和“幻读”的区别" class="headerlink" title="“不可重复读”和“幻读”的区别"></a>“不可重复读”和“幻读”的区别</h3><p>是：“不可重复读”关注的重点在于记录的更新操作，对同样的记录，再次读取后发现返回的数据值不一样了；“幻读”关注的重点在于记录新增或者删除操作（数据条数发生了变化），同样的条件第一次和第二次查询出来的记录数不一样。</p><p>ZooKeeper对不同系统环境的支持都很好，在绝大多数主流的操作系统上都能够正常运行，如GNU/Linux、Sun Solaris、Win32以及MacOS等。但是，ZooKeeper官方文档中特别强调，由于FreeBSD系统的JVM实现对Java的NIOSelector（选择器）支持得不是很好，因此不建议在FreeBSD系统上部署ZooKeeper生产服务器。可以说，ZooKeeper提供的是分布式系统中非常底层且必不可少的基本功能，如果开发者自己来实现这些功能且达到高吞吐、低延迟，同时还要保持一致性和可用性，实际上是非常困难的。借助ZooKeeper提供的这些功能，开发者就可以轻松地在ZooKeeper之上构建自己的各种分布式系统。</p><h1 id="Zookeeper-概念"><a href="#Zookeeper-概念" class="headerlink" title="Zookeeper 概念"></a>Zookeeper 概念</h1><p>Zookeeper 是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。<br>Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但<br>只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与<br>通知机制。</p><h1 id="Zookeeper-角色"><a href="#Zookeeper-角色" class="headerlink" title="Zookeeper 角色"></a>Zookeeper 角色</h1><p>Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种</p><h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><ol><li>一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader，它会发起并维护与各 Follwer<br>及 Observer 间的心跳。</li><li>所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。只要有超过<br>半数节点（不包括 observeer 节点）写入成功，该写请求就会被提交（类 2PC 协议）。<h2 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h2></li><li>一个 Zookeeper 集群可能同时存在多个 Follower，它会响应 Leader 的心跳，</li><li>Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，</li><li>并且负责在 Leader 处理写请求时对请求进行投票。<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2>角色与 Follower 类似，但是无投票权。Zookeeper 需保证高可用和强一致性，为了支持更多的客<br>户端，需要增加更多 Server；Server 增多，投票阶段延迟增大，影响性能；引入 Observer，<br>Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点； 加入更<br>多 Observer 节点，提高伸缩性，同时不影响吞吐率。</li></ol><h1 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h1><h2 id="事务编号-Zxid（事务请求计数器-epoch）"><a href="#事务编号-Zxid（事务请求计数器-epoch）" class="headerlink" title="事务编号 Zxid（事务请求计数器+ epoch）"></a>事务编号 Zxid（事务请求计数器+ epoch）</h2><p>在 ZAB ( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议） 协议的事务编号 Zxid<br>设计中，Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每<br>一个事务请求，计数器加 1；而高 32 位则代表 Leader 周期 epoch 的编号，每个当选产生一个新<br>的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务的 ZXID，并从中读取<br>epoch 值，然后加 1，以此作为新的 epoch，并将低 32 位从 0 开始计数。<br>Zxid（Transaction id）类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal（提议）<br>ID。为了保证顺序性，该 zkid 必须单调递增。</p><h2 id="epoch"><a href="#epoch" class="headerlink" title="epoch"></a>epoch</h2><p>epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所<br>以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算旧的 leader 崩溃<br>恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。</p><h2 id="Zab-协议有两种模式-恢复模式（选主）、广播模式（同步）"><a href="#Zab-协议有两种模式-恢复模式（选主）、广播模式（同步）" class="headerlink" title="Zab 协议有两种模式-恢复模式（选主）、广播模式（同步）"></a>Zab 协议有两种模式-恢复模式（选主）、广播模式（同步）</h2><p>Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导<br>者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状<br>态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p><h2 id="ZAB-协议-4-阶段"><a href="#ZAB-协议-4-阶段" class="headerlink" title="ZAB 协议 4 阶段"></a>ZAB 协议 4 阶段</h2><h3 id="Leader-election（选举阶段-选出准-Leader）"><a href="#Leader-election（选举阶段-选出准-Leader）" class="headerlink" title="Leader election（选举阶段-选出准 Leader）"></a>Leader election（选举阶段-选出准 Leader）</h3><ol><li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数<br>节点的票数，它就可以当选准 leader。只有到达 广播阶段（broadcast） 准 leader 才会成<br>为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。</li></ol><h3 id="Discovery（发现阶段-接受提议、生成-epoch、接受-epoch）"><a href="#Discovery（发现阶段-接受提议、生成-epoch、接受-epoch）" class="headerlink" title="Discovery（发现阶段-接受提议、生成 epoch、接受 epoch）"></a>Discovery（发现阶段-接受提议、生成 epoch、接受 epoch）</h3><ol start="2"><li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers<br>最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且<br>准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch<br>一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f<br>在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段。</li></ol><h3 id="Synchronization（同步阶段-同步-follower-副本）"><a href="#Synchronization（同步阶段-同步-follower-副本）" class="headerlink" title="Synchronization（同步阶段-同步 follower 副本）"></a>Synchronization（同步阶段-同步 follower 副本）</h3><ol start="3"><li>Synchronization（同步阶段）：同步阶段主要是利用 leader 前一阶段获得的最新提议历史，<br>同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader。<br>follower 只会接收 zxid 比自己的 lastZxid 大的提议。</li></ol><h3 id="Broadcast（广播阶段-leader-消息广播）"><a href="#Broadcast（广播阶段-leader-消息广播）" class="headerlink" title="Broadcast（广播阶段-leader 消息广播）"></a>Broadcast（广播阶段-leader 消息广播）</h3><ol start="4"><li>Broadcast（广播阶段）：到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，<br>并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。<br>ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，只需要得到超过半数的节点的 ACK 就<br>可以了。<h3 id="ZAB-协议-JAVA-实现（FLE-发现阶段和同步合并为-Recovery-Phase（恢复阶段））"><a href="#ZAB-协议-JAVA-实现（FLE-发现阶段和同步合并为-Recovery-Phase（恢复阶段））" class="headerlink" title="ZAB 协议 JAVA 实现（FLE-发现阶段和同步合并为 Recovery Phase（恢复阶段））"></a>ZAB 协议 JAVA 实现（FLE-发现阶段和同步合并为 Recovery Phase（恢复阶段））</h3>协议的 Java 版本实现跟上面的定义有些不同，选举阶段使用的是 Fast Leader Election（FLE），<br>它包含了 选举的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader，这样就省去了<br>发现最新提议的步骤。</li></ol><p>实际的实现将 发现阶段 和 同步合并为 Recovery Phase（恢复阶段）。所<br>以，ZAB 的实现只有三个阶段：Fast Leader Election；Recovery Phase；Broadcast Phase。</p><h2 id="投票机制"><a href="#投票机制" class="headerlink" title="投票机制"></a>投票机制</h2><p>每个 sever 首先给自己投票，然后用自己的选票和其他 sever 选票对比，权重大的胜出，使用权<br>重较大的更新自身选票箱。具体选举过程如下：</p><ol><li>每个 Server 启动以后都询问其它的 Server 它要投票给谁。对于其他 server 的询问，<br>server 每次根据自己的状态都回复自己推荐的 leader 的 id 和上一次处理事务的 zxid（系<br>统启动时每个 server 都会推荐自己）</li><li>收到所有 Server 回复以后，就计算出 zxid 最大的哪个 Server，并将这个 Server 相关信<br>息设置成下一次要投票的 Server。</li><li>计算这过程中获得票数最多的的 sever 为获胜者，如果获胜者的票数超过半数，则改<br>server 被选为 leader。否则，继续这个过程，直到 leader 被选举出来</li><li>leader 就会开始等待 server 连接</li><li>Follower 连接 leader，将最大的 zxid 发送给 leader</li><li>Leader 根据 follower 的 zxid 确定同步点，至此选举阶段完成。</li><li>选举阶段完成 Leader 同步后通知 follower 已经成为 uptodate 状态</li><li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了</li></ol><p>目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是 1,2,3,4,5,按编号依次启动，它们<br>的选择举过程如下：</p><ol><li>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反<br>馈信息，服务器 1 的状态一直属于 Looking。</li><li>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号<br>大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是<br>LOOKING。</li><li>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编<br>号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器<br>1,2 成为小弟。</li><li>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的<br>编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。</li><li>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。</li></ol><h1 id="Zookeeper-工作原理（原子广播）"><a href="#Zookeeper-工作原理（原子广播）" class="headerlink" title="Zookeeper 工作原理（原子广播）"></a>Zookeeper 工作原理（原子广播）</h1><ol><li>Zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制<br>的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</li><li>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多<br>数 server 的完成了和 leader 的状态同步以后，恢复模式就结束了。</li><li>状态同步保证了 leader 和 server 具有相同的系统状态</li><li>一旦 leader 已经和多数的 follower 进行了状态同步后，他就可以开始广播消息了，即进<br>入广播状态。这时候当一个 server 加入 zookeeper 服务中，它会在恢复模式下启动，发<br>现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。Zookeeper<br>服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的<br>followers 支持。</li><li>广播模式需要保证 proposal 被按顺序处理，因此 zk 采用了递增的事务 id 号(zxid)来保<br>证。所有的提议(proposal)都在被提出的时候加上了 zxid。</li><li>实现中 zxid 是一个 64 为的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，<br>每次一个 leader 被选出来，它都会有一个新的 epoch。低 32 位是个递增计数。</li><li>当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式<br>需要重新选举出一个新的 leader，让所有的 server 都恢复到一个正确的状态。</li></ol><h1 id="Znode-有四种形式的目录节点"><a href="#Znode-有四种形式的目录节点" class="headerlink" title="Znode 有四种形式的目录节点"></a>Znode 有四种形式的目录节点</h1><ol><li>PERSISTENT：持久的节点。</li><li>EPHEMERAL：暂时的节点。</li><li>PERSISTENT_SEQUENTIAL：持久化顺序编号目录节点。</li><li>EPHEMERAL_SEQUENTIAL：暂时化顺序编号目录节点。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zookeeper （动物园管理员）是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概念I</title>
    <link href="http://yoursite.com/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5I/"/>
    <id>http://yoursite.com/2021/12/01/计算机网络概念I/</id>
    <published>2021-12-01T02:08:12.000Z</published>
    <updated>2021-12-01T07:15:30.331Z</updated>
    
    <content type="html"><![CDATA[<p>总结计算机网络概念</p><a id="more"></a><p>[TOC]</p><h2 id="（一）请简述TCP-UDP的区别"><a href="#（一）请简述TCP-UDP的区别" class="headerlink" title="（一）请简述TCP\UDP的区别"></a>（一）请简述TCP\UDP的区别</h2><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><p>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接<br>TCP提供可靠的服务（数据传输），UDP无法保证<br>TCP面向字节流，UDP面向报文<br>TCP数据传输慢，UDP数据传输快<br>如果还不是太了解这两者的区别，点击阅读：<a href="https://blog.csdn.net/yipiankongbai/article/details/24435977" target="_blank" rel="noopener">TCP与UDP的区别</a></p><h2 id="（二）请简单说一下你了解的端口及对应的服务？"><a href="#（二）请简单说一下你了解的端口及对应的服务？" class="headerlink" title="（二）请简单说一下你了解的端口及对应的服务？"></a>（二）请简单说一下你了解的端口及对应的服务？</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwow0id9j30cb06gq38.jpg" alt="image"></p><p>了解更多的端口，点击阅读：<a href="http://blog.sina.com.cn/s/blog_66ea0e2801011vb3.html" target="_blank" rel="noopener">常用端口号与对应的服务以及端口关闭</a></p><h2 id="（三）说一说TCP的三次握手"><a href="#（三）说一说TCP的三次握手" class="headerlink" title="（三）说一说TCP的三次握手"></a>（三）说一说TCP的三次握手</h2><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p><p>下面详细说一下三次握手（来自简析TCP的三次握手与四次分手）<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwq2b646j30k00mb0u1.jpg" alt="image"></p><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwrg1lunj30gh07b75e.jpg" alt="image"></p><p>更加深入的了解TCP的三次握手与四次分手：<a href="https://www.jellythink.com/archives/705" target="_blank" rel="noopener">简析TCP的三次握手与四次分手</a></p><h2 id="（四）有哪些私有（保留）地址？"><a href="#（四）有哪些私有（保留）地址？" class="headerlink" title="（四）有哪些私有（保留）地址？"></a>（四）有哪些私有（保留）地址？</h2><p>A类：10.0.0.0 - 10.255.255.255<br>B类：172.16.0.0 - 172.31.255.255<br>C类：192.168.0.0 - 192.168.255.255</p><h2 id="（五）IP地址分为哪几类？简单说一下各个分类"><a href="#（五）IP地址分为哪几类？简单说一下各个分类" class="headerlink" title="（五）IP地址分为哪几类？简单说一下各个分类"></a>（五）IP地址分为哪几类？简单说一下各个分类</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwscdo7yj30ix06i0td.jpg" alt="image"><br>IPv6 – 采用128bit，首部固定部分为40字节。</p><h2 id="（六）在浏览器中输入网址之后执行会发生什么？"><a href="#（六）在浏览器中输入网址之后执行会发生什么？" class="headerlink" title="（六）在浏览器中输入网址之后执行会发生什么？"></a>（六）在浏览器中输入网址之后执行会发生什么？</h2><p>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器<br>浏览器向IP对应的web服务器发送一个HTTP请求<br>服务器响应请求，发回网页内容<br>浏览器解析网页内容</p><p>更加详细的一种说法（以百度为例）（来自计算机网络之面试常考 - 牛客网）<br><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwt38bprj30ga0an40f.jpg" alt="image"></p><p>如果你想要更加深入的了解这个过程，点击阅读：<a href>从输入网址到显示网页的全过程分析</a></p><h2 id="（七）简单解释一些ARP协议的工作过程"><a href="#（七）简单解释一些ARP协议的工作过程" class="headerlink" title="（七）简单解释一些ARP协议的工作过程"></a>（七）简单解释一些ARP协议的工作过程</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1fuqwu74fpuj30go0afjt2.jpg" alt="image"></p><p>以上的说明解释来自（思想时光机），如果你想了解：<a href="https://blog.csdn.net/microtong/article/details/3029931" target="_blank" rel="noopener">ARP协议工作原理</a></p><h2 id="（八）说一说OSI七层模型"><a href="#（八）说一说OSI七层模型" class="headerlink" title="（八）说一说OSI七层模型"></a>（八）说一说OSI七层模型</h2><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1furg8ainkrj30k00scad0.jpg" alt="image"></p><p>了解OSI七层模型，请点击阅读：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">OSI七层模型详解 （下面的图片来自啊该网址）</a></p><h2 id="（九）说一说TCP-IP四层模型"><a href="#（九）说一说TCP-IP四层模型" class="headerlink" title="（九）说一说TCP/IP四层模型"></a>（九）说一说TCP/IP四层模型</h2><p>如果你不了解，请直接点击阅读：<a href="http://www.cnblogs.com/BlueTzar/articles/811160.html" target="_blank" rel="noopener">TCP/IP四层模型</a></p><h2 id="（十）HTTP-协议包括哪些请求？"><a href="#（十）HTTP-协议包括哪些请求？" class="headerlink" title="（十）HTTP 协议包括哪些请求？"></a>（十）HTTP 协议包括哪些请求？</h2><p>GET：对服务器资源的简单请求<br>POST：用于发送包含用户提交数据的请求<br>————以及————</p><p>HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头<br>PUT：传说中请求文档的一个版本<br>DELETE：发出一个删除指定文档的请求<br>TRACE：发送一个请求副本，以跟踪其处理进程<br>OPTIONS：返回所有可用的方法，检查服务器支持哪些方法<br>CONNECT：用于ssl隧道的基于代理的请求</p><h2 id="（十一）简述HTTP中GET和POST的区别-1"><a href="#（十一）简述HTTP中GET和POST的区别-1" class="headerlink" title="（十一）简述HTTP中GET和POST的区别^1"></a>（十一）简述HTTP中GET和POST的区别<a href="https://blog.csdn.net/qq_38182125/article/details/89071899" target="_blank" rel="noopener">^1</a></h2><p>从原理性看：</p><p>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的<br>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</p><p>从表面上看：</p><p>GET请求的数据会附在URL后面，POST的数据放在HTTP包体<br>POST安全性比GET安全性高</p><p>首先我们要清楚GET和POST是什么？</p><p>Get和Post是两种Http请求方式：</p><p><strong><em>GET-从指定的资源请求数据</em></strong></p><p><strong><em>POST-向指定的资源提交要被处理的数据</em></strong></p><p>GET 和 POST 其实都是 HTTP 的请求方法。除了这 2 个请求方法之外，HTTP 还有 HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS 这 6 个请求方法。所以HTTP 的请求方法共计有 8 种。这些请求的描述如下所示：</p><p>其它HTTP请求方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>HEAD</td><td>与GET类似，但只获取HTTP报头，返回的响应中没有文档主体</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定资源</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够把请求连接转换到透明的TCP/IP通道的代理服务器</td></tr><tr><td>OPTIONS</td><td>返回服务器支持的HTTP方法</td></tr><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr></tbody></table><h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>查询字符串（名称/值对）是在GET请求的URL中发送的，即请求的数据会附在 URL 之后（放在请求行中），以 ? 分割 URL 和传输数据，多个参数用 &amp; 连接：</p><pre><code>http://localhost:8080/Merchant/SelectByMerchantNo?name1=value1&amp;name2=value2</code></pre><p>GET 请求可被缓存，如果下一次传输的数据相同，那么就会返回缓存中的内容，以求更快地展示数据。</p><p>GET 请求保留在浏览器历史记录中</p><p>GET 请求可被收藏为书签</p><p>GET 请求不应在处理敏感数据时使用</p><p>GET 请求有长度限制，但是需要注意的是 HTTP 协议中并未规定 GET 请求的长度。这个长度限制主要是由浏览器和 Web 服务器所决定的，并且各个浏览器对长度的限制也各不相同。</p><p>GET 请求只应当用于取回数据</p><p>GET 方法只产生一个 TCP 数据包，浏览器会把请求头和请求数据一并发送出去，服务器响应 200 ok(返回数据)</p><p>根据 HTTP 规范，GET 用于信息获取，而且应该是安全和幂等的 。</p><p><strong><em>安全性</em></strong> 指的是非修改信息，即该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用，也就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p><strong><em>幂等性 (Idempotence)</em></strong> 则指的是无论调用这个URL 多少次，都不会有不同的结果的 HTTP 方法。而在实际过程中，这个规定没有那么严格。例如在一个新闻应用中，新闻站点的头版不断更新，虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。</p><h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>POST 请求不会被缓存</p><p>POST 请求不会保留在浏览器历史记录中</p><p>POST 不能被收藏为书签</p><p>根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。例如我们在刷知乎的时候对某篇文章进行点赞，就是提交的 POST 请求，因为它改变了服务器中的数据（该篇文章的点赞数）。</p><p>POST 方法因为有可能修改服务器上的资源，所以它是不符合安全和幂等性的。</p><p>POST 是将请求信息放置在请求数据中的，这也是 POST 和 GET 的一点不那么重要的区别。有一些博客的说法是 GET 请求的请求信息是放置在 URL 的而 POST 是放置在请求数据中的所以 POST 比 GET 更安全。其实这种说法有待商榷，抓下包 POST 中的请求报文就暴露了，所以POST也不算安全？</p><p>因为 POST 方法的请求信息是放置在请求数据中的，所以它的请求信息是没有长度限制的。</p><p>POST 方法会产生两个 TCP 数据包，浏览器会先将请求头发送给服务器，待服务器响应100 continue，浏览器再发送请求数据，服务器响应200 ok(返回数据)。这么看起来 GET 请求的传输会比 POST 快上一些（因为GET 方法只发送一个 TCP 数据包），但是实际上在网络良好的情况下它们的传输速度基本相同。</p><h3 id="GET与POST的异同"><a href="#GET与POST的异同" class="headerlink" title="GET与POST的异同"></a>GET与POST的异同</h3><table><thead><tr><th></th><th>Get</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中</td><td>参数不会保留在浏览器历史中</td></tr><tr><td>对数据长度的限制</td><td>只允许ASCII字符</td><td>没有限制，也允许二进制数据</td></tr><tr><td>安全性</td><td>较差，因为发送的数据是URL的一部分</td><td>POST比GET更安全，因为参数不会被保留在浏览器历史或WEB服务器日志中</td></tr><tr><td>可见性</td><td>数据在URL中对所有人都是可见的</td><td>数据不会显示在URL中</td></tr></tbody></table><p>上面说了那么多 GET 方法和 POST 方法各自的特点，它们在外在的表现上似乎是有着诸多的不同，但是实际上，它们的本质是一样的，并无区别。</p><p>它们都是 HTTP 请求协议的请求方法，而 HTTP 又是基于TCP/IP的关于数据如何在万维网中如何通信的协议，所以 GET/POST 实际上都是 TCP 链接。</p><p>也就是说，GET 和 POST 所做的事其实是一样的，如果你给 GET 加上请求数据，给 POST 加上 URL 参数，这在技术上是完全可行的，事实上确实有一些人为了贪图方便在更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点（但是强烈不建议这样子做！！！）。</p><p>既然 GET 和 POST 的底层都是 TCP，那么为什么 HTTP 还要特别将它们区分出来呢？</p><p>其实可以想象一下，如果我们直接使用 TCP 进行数据的传输，那么无论是单纯获取资源的请求还是修改服务器资源的请求在外观上看起来都是 TCP 链接，这样就非常不利于进行管理。所以在 HTTP 协议中，就会对这些不同的请求设置不同的类别进行管理，例如单纯获取资源的请求就规定为 GET、修改服务器资源的请求就规定为 POST，并且也对它们的请求报文的格式做出了相应的要求（例如请求参数 GET 位于 URL 而 POST 则位于请求数据中）。</p><p>当然，如果我们想将 GET 的请求参数放置在请求数据中或者将 POST 的请求数据放置在 URL 中，这是完全可以的，虽然这样子做并不符合 HTTP 的规范。但是这样子做是否能得到我们期望的响应数据呢？答案是未必，这取决于服务器的行为。</p><p>以 GET 方法在请求数据中放置请求参数为例，有些服务器会将请求数据中的参数读出，在这种情况下我们依然能获得我们期望的响应数据；而有些服务器则会选择直接忽略，这种情况下我们就无法获取期望的响应数据了。</p><p>所以，对于 GET 和 POST 的区别，总结来说就是：它们的本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。</p><h2 id="十二-简述各类HTTP状态码及其含义-2"><a href="#十二-简述各类HTTP状态码及其含义-2" class="headerlink" title="(十二) 简述各类HTTP状态码及其含义^2"></a>(十二) 简述各类HTTP状态码及其含义<a href="https://cloud.tencent.com/developer/article/1688459" target="_blank" rel="noopener">^2</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结计算机网络概念&lt;/p&gt;
    
    </summary>
    
      <category term="2021年12月" scheme="http://yoursite.com/categories/2021%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="Computer Network" scheme="http://yoursite.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本三剑客，awk、grep、sed</title>
    <link href="http://yoursite.com/2021/11/30/Linux%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%8Cawk%E3%80%81grep%E3%80%81sed/"/>
    <id>http://yoursite.com/2021/11/30/Linux文本三剑客，awk、grep、sed/</id>
    <published>2021-11-30T13:12:12.000Z</published>
    <updated>2021-12-05T01:31:19.357Z</updated>
    
    <content type="html"><![CDATA[<p>awk、grep、sed是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。</p><a id="more"></a><p>[TOC]</p><p>三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。[^1]</p><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><h2 id="什么是grep和egrep"><a href="#什么是grep和egrep" class="headerlink" title="什么是grep和egrep"></a>什么是grep和egrep</h2><p>　Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来（匹配到的标红）。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p><p>　　grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>　　grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><p>　　egrep = grep -E：扩展的正则表达式 （除了&lt; , &gt; , \b 使用其他正则都可以去掉\）　　</p><h2 id="使用grep"><a href="#使用grep" class="headerlink" title="使用grep"></a>使用grep</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code>grep [option] pattern file</code></pre><h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p>常用参数已加粗</p><pre><code>-A&lt;显示行数&gt;：除了显示符合范本样式的那一列之外，并显示该行之后的内容。-B&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前的内容。-C&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前后的内容。-c：统计匹配的行数-e ：实现多个选项间的逻辑or 关系-E：扩展的正则表达式-f FILE：从FILE获取PATTERN匹配-F ：相当于fgrep-i --ignore-case #忽略字符大小写的差别。-n：显示匹配的行号-o：仅显示匹配到的字符串-q： 静默模式，不输出任何信息-s：不显示错误信息。-v：显示不被pattern 匹配到的行，相当于[^] 反向匹配-w ：匹配 整个单词</code></pre><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="认识正则"><a href="#认识正则" class="headerlink" title="认识正则"></a>认识正则</h2><p>（1）介绍</p><p>　　正则表达式应用广泛，在绝大多数的编程语言都可以完美应用，在Linux中，也有着极大的用处。</p><p>　　使用正则表达式，可以有效的筛选出需要的文本，然后结合相应的支持的工具或语言，完成任务需求。</p><p>　　在本篇博客中，我们使用grep/egrep来完成对正则表达式的调用</p><p>（2）正则表达式类型</p><p>正则表达式可以使用正则表达式引擎实现，正则表达式引擎是解释正则表达式模式并使用这些模式匹配文本的基础软件。</p><p>在Linux中，常用的正则表达式有：</p><p> POSIX 基本正则表达式（BRE）引擎<br> POSIX 扩展正则表达式（BRE）引擎</p><h2 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h2><h3 id="匹配字符"><a href="#匹配字符" class="headerlink" title="匹配字符"></a>匹配字符</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre><code>. 匹配任意单个字符，不能匹配空行 [] 匹配指定范围内的任意单个字符 [^] 取反 [:alnum:] 或 [0-9a-zA-Z] [:alpha:] 或 [a-zA-Z] [:upper:] 或 [A-Z] [:lower:] 或 [a-z] [:blank:] 空白字符（空格和制表符） [:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广） [:cntrl:] 不可打印的控制字符（退格、删除、警铃...） [:digit:] 十进制数字 或[0-9] [:xdigit:]十六进制数字 [:graph:] 可打印的非空白字符 [:print:] 可打印字符 [:punct:] 标点符号</code></pre><h3 id="配置次数"><a href="#配置次数" class="headerlink" title="配置次数"></a>配置次数</h3><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><pre><code>*  匹配前面的字符任意次，包括0次，贪婪模式：尽可能长的匹配.*  任意长度的任意字符，不包括0次\?  匹配其前面的字符0 或 1次\+  匹配其前面的字符至少1次\{n\}  匹配前面的字符n次\{m,n\}  匹配前面的字符至少m 次，至多n次\{,n\}  匹配前面的字符至多n次\{n,\}  匹配前面的字符至少n次</code></pre><h3 id="位置锚定：定位出现的位置"><a href="#位置锚定：定位出现的位置" class="headerlink" title="位置锚定：定位出现的位置"></a>位置锚定：定位出现的位置</h3><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><pre><code>^  行首锚定，用于模式的最左侧$  行尾锚定，用于模式的最右侧^PATTERN$，用于模式匹配整行^$ 空行^[[:space:]].*$  空白行\&lt; 或 \b  词首锚定，用于单词模式的左侧\&gt; 或 \b  词尾锚定；用于单词模式的右侧\&lt;PATTERN\&gt;</code></pre><h3 id="分组和后向引用"><a href="#分组和后向引用" class="headerlink" title="分组和后向引用"></a>分组和后向引用</h3><h4 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h4><p>① 分组：() 将一个或多个字符捆绑在一起，当作一个整体进行处理</p><pre><code>　　分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, ...</code></pre><p>② 后向引用</p><pre><code>引用前面的分组括号中的模式所匹配字符，而非模式本身\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符\2 表示从左侧起第2个左括号以及与之匹配右括号之间的模式所匹配到的字符，以此类推\&amp; 表示前面的分组中所有字符</code></pre><h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>（1）字符匹配：</p><pre><code>.  任意单个字符[]  指定范围的字符[^] 不在指定范围的字符  次数匹配：* ：匹配前面字符任意次?  : 0 或1次+ ：1 次或多次{m} ：匹配m次 次{m,n} ：至少m ，至多n次</code></pre><p>（2）位置锚定：</p><pre><code>^ : 行首$ : 行尾\&lt;, \b : 语首\&gt;, \b : 语尾  分组：()后向引用：\1, \2, ...</code></pre><p>（3）总结</p><pre><code>　　除了\&lt;,\b:语首、\&gt;,\b:语尾；使用其他正则都可以去掉\；</code></pre><p>　　</p><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="认识sed"><a href="#认识sed" class="headerlink" title="认识sed"></a>认识sed</h2><p>　　sed 是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（patternspace ），接着用sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’ 的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出或-i。</p><p>　　功能：主要用来自动编辑一个或多个文件, 简化对文件的反复操作</p><h2 id="使用sed"><a href="#使用sed" class="headerlink" title="使用sed"></a>使用sed</h2><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code>sed [options] &apos;[地址定界] command&apos; file(s)</code></pre><p>　　</p><h3 id="常用选项options"><a href="#常用选项options" class="headerlink" title="常用选项options"></a>常用选项options</h3><pre><code>-n：不输出模式空间内容到屏幕，即不自动打印，只打印匹配到的行-e：多点编辑，对每行处理时，可以有多个Script-f：把Script写到文件当中，在执行sed时-f 指定文件路径，如果是多个Script，换行写-r：支持扩展的正则表达式-i：直接将处理的结果写入文件-i.bak：在将处理的结果写入文件之前备份一份</code></pre><h3 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h3><pre><code>不给地址：对全文进行处理单地址：#: 指定的行/pattern/：被此处模式所能够匹配到的每一行地址范围：#,##,+#/pat1/,/pat2/#,/pat1/~：步进 sed -n &apos;1~2p&apos;  只打印奇数行 （1~2 从第1行，一次加2行） sed -n &apos;2~2p&apos;  只打印偶数行</code></pre><h3 id="编辑命令command"><a href="#编辑命令command" class="headerlink" title="编辑命令command"></a>编辑命令command</h3><pre><code>d：删除模式空间匹配的行，并立即启用下一轮循环p：打印当前模式空间内容，追加到默认输出之后a：在指定行后面追加文本，支持使用\n实现多行追加i：在行前面插入文本，支持使用\n实现多行追加c：替换行为单行或多行文本，支持使用\n实现多行追加w：保存模式匹配的行至指定文件r：读取指定文件的文本至模式空间中匹配到的行后=：为模式空间中的行打印行号!：模式空间中匹配行取反处理s///：查找替换，支持使用其它分隔符，如：s@@@，s###；加g表示行内全局替换；在替换时，可以加一下命令，实现大小写转换\l：把下个字符转换成小写。\L：把replacement字母转换成小写，直到\U或\E出现。\u：把下个字符转换成大写。\U：把replacement字母转换成大写，直到\L或\E出现。\E：停止以\L或\U开始的大小写转换</code></pre><h2 id="sed高级编辑命令"><a href="#sed高级编辑命令" class="headerlink" title="sed高级编辑命令"></a>sed高级编辑命令</h2><h3 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a>格式</h3><pre><code>h：把模式空间中的内容覆盖至保持空间中H：把模式空间中的内容追加至保持空间中g：从保持空间取出数据覆盖至模式空间G：从保持空间取出内容追加至模式空间x：把模式空间中的内容与保持空间中的内容进行互换n：读取匹配到的行的下一行覆盖 至模式空间N：读取匹配到的行的下一行追加 至模式空间d：删除模式空间中的行D：删除 当前模式空间开端至\n 的内容（不再传 至标准输出），放弃之后的命令，但是对剩余模式空间重新执行sed</code></pre><h3 id="总结模式空间与保持空间关系："><a href="#总结模式空间与保持空间关系：" class="headerlink" title="总结模式空间与保持空间关系："></a>总结模式空间与保持空间关系：</h3><p>保持空间是模式空间一个临时存放数据的缓冲区，协助模式空间进行数据处理</p><h3 id="倒序输出命令的解读"><a href="#倒序输出命令的解读" class="headerlink" title="倒序输出命令的解读"></a>倒序输出命令的解读</h3><pre><code>sed &apos;1!G;h;$!d&apos; num.txt</code></pre><p>解读：</p><pre><code>1!G第1行不 执行“G”命令，从第2行开始执行。$!d，最后一行不删除（保留最后1行）</code></pre><h1 id="awk-2"><a href="#awk-2" class="headerlink" title="awk^2"></a>awk<a href="https://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="noopener">^2</a></h1><h2 id="认识awk"><a href="#认识awk" class="headerlink" title="认识awk"></a>认识awk</h2><p>　　awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p><p>　　awk其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。</p><h2 id="使用awk"><a href="#使用awk" class="headerlink" title="使用awk"></a>使用awk</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>awk [options] &apos;program&apos; var=value file…awk [options] -f programfile var=value file…awk [options] &apos;BEGIN{ action;… } pattern{ action;… } END{ action;… }&apos; file ...</code></pre><h3 id="常用命令选项"><a href="#常用命令选项" class="headerlink" title="常用命令选项"></a>常用命令选项</h3><pre><code>-F fs：fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:-v var=value：赋值一个用户定义变量，将外部变量传递给awk-f scripfile：从脚本文件中读取awk命令</code></pre><h2 id="awk变量"><a href="#awk变量" class="headerlink" title="awk变量"></a>awk变量</h2><p>变量：内置和自定义变量，每个变量前加 -v 命令选项</p><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>（1）格式</p><pre><code>FS ：输入字段分隔符，默认为空白字符OFS ：输出字段分隔符，默认为空白字符RS ：输入记录分隔符，指定输入时的换行符，原换行符仍有效ORS ：输出记录分隔符，输出时用指定符号代替换行符NF ：字段数量，共有多少字段， $NF引用最后一列，$(NF-1)引用倒数第2列NR ：行号，后可跟多个文件，第二个文件行号继续从第一个文件最后行号开始FNR ：各文件分别计数, 行号，后跟一个文件和NR一样，跟多个文件，第二个文件行号从1开始FILENAME ：当前文件名ARGC ：命令行参数的个数ARGV ：数组，保存的是命令行所给定的各参数，查看参数   </code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>自定义变量( 区分字符大小写)</p><p>（1）-v var=value</p><p>（2）在program 中直接定义</p><p>printf命令<br>比print更强大</p><h3 id="格式-5"><a href="#格式-5" class="headerlink" title="格式"></a>格式</h3><p>（1）格式化输出</p><pre><code>printf &quot;FORMAT&quot;, item1,item2, ...</code></pre><p>①  必须指定FORMAT</p><p>②  不会自动换行，需要显式给出换行控制符，\n</p><p>③  FORMAT 中需要分别为后面每个item 指定格式符</p><p>（2）格式符：与item 一一对应</p><pre><code>%c:  显示字符的ASCII码%d, %i:  显示十进制整数%e, %E: 显示科学计数法数值%f ：显示为浮点数，小数   %5.1f，带整数、小数点、整数共5位，小数1位，不够用空格补上%g, %G ：以科学计数法或浮点形式显示数值%s ：显示字符串；例：%5s最少5个字符，不够用空格补上，超过5个还继续显示%u ：无符号整数%%:  显示% 自身</code></pre><p>（3）修饰符：放在%c[/d/e/f…]之间</p><pre><code>#[.#]：第一个数字控制显示的宽度；第二个# 表示小数点后精度，%5.1f-：左对齐（默认右对齐） %-15s+：显示数值的正负符号 %+d</code></pre><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="格式-6"><a href="#格式-6" class="headerlink" title="格式"></a>格式</h3><pre><code>算术操作符：x+y, x-y, x*y, x/y, x^y, x%y-x:  转换为负数+x:  转换为数值字符串操作符：没有符号的操作符，字符串连接赋值操作符：=, +=, -=, *=, /=, %=, ^=++, --比较操作符：==, !=, &gt;, &gt;=, &lt;, &lt;=模式匹配符：~ ：左边是否和右边匹配包含 !~ ：是否不匹配逻辑操作符：与&amp;&amp; ，或|| ，非!函数调用： function_name(argu1, argu2, ...)条件表达式（三目表达式）：selector?if-true-expression:if-false-expression注释：先判断selector，如果符合执行 ? 后的操作；否则执行 : 后的操作</code></pre><h2 id="awk-PATTERN-匹配部分"><a href="#awk-PATTERN-匹配部分" class="headerlink" title="awk PATTERN 匹配部分"></a>awk PATTERN 匹配部分</h2><h3 id="格式-7"><a href="#格式-7" class="headerlink" title="格式"></a>格式</h3><p>PATTERN：根据pattern 条件，过滤匹配的行，再做处理</p><p>（1）如果未指定：空模式，匹配每一行</p><p>（2）/regular expression/ ：仅处理能够模式匹配到的行，正则，需要用/ / 括起来</p><p>（3）relational expression：关系表达式，结果为“真”才会被处理</p><p>真：结果为非0值，非空字符串</p><p>假：结果为空字符串或0值</p><p>（4）line ranges：行范围</p><p>　　startline(起始行),endline(结束行)：/pat1/,/pat2/  不支持直接给出数字，可以有多段，中间可以有间隔</p><p>（5）BEGIN/END 模式</p><p>　　BEGIN{}:  仅在开始处理文件中的文本之前执行一次</p><p>　　END{} ：仅在文本处理完成之后执行</p><h1 id="awk高阶用法"><a href="#awk高阶用法" class="headerlink" title="awk高阶用法"></a>awk高阶用法</h1><h2 id="awk控制语句—if-else判断"><a href="#awk控制语句—if-else判断" class="headerlink" title="awk控制语句—if-else判断"></a>awk控制语句—if-else判断</h2><p>（1）语法</p><pre><code>if(condition){statement;…}[else statement]  双分支if(condition1){statement1}else if(condition2){statement2}else{statement3}  多分支</code></pre><p>（2）使用场景：对awk 取得的整行或某个字段做条件判断</p><h2 id="awk控制语句—while循环"><a href="#awk控制语句—while循环" class="headerlink" title="awk控制语句—while循环"></a>awk控制语句—while循环</h2><p>（1）语法</p><pre><code>while(condition){statement;…}</code></pre><p>注：条件“真”，进入循环；条件“假”， 退出循环</p><p>（2）使用场景</p><p>　　对一行内的多个字段逐一类似处理时使用</p><p>　　对数组中的各元素逐一处理时使用</p><h2 id="awk控制语句—do-while循环"><a href="#awk控制语句—do-while循环" class="headerlink" title="awk控制语句—do-while循环"></a>awk控制语句—do-while循环</h2><p>（1）语法</p><pre><code>do {statement;…}while(condition)</code></pre><p>意义：无论真假，至少执行一次循环体</p><h2 id="awk控制语句—for循环"><a href="#awk控制语句—for循环" class="headerlink" title="awk控制语句—for循环"></a>awk控制语句—for循环</h2><p>（1）语法</p><pre><code>for(expr1;expr2;expr3) {statement;…}</code></pre><p>　　</p><p>（2）特殊用法：遍历数组中的元素</p><pre><code>for(var in array) {for-body}</code></pre><h2 id="和shell脚本中较相似的控制语句"><a href="#和shell脚本中较相似的控制语句" class="headerlink" title="和shell脚本中较相似的控制语句"></a>和shell脚本中较相似的控制语句</h2><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>和shell中的case很像，就不在演示了</p><pre><code>switch(expression) {case VALUE1 or /REGEXP/:statement1; case VALUE2 or /REGEXP2/: statement2;...; default: statementn}</code></pre><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p>next：提前结束对本行处理而直接进入下一行处理（awk 自身循环）</p><h2 id="awk数组"><a href="#awk数组" class="headerlink" title="awk数组"></a>awk数组</h2><h3 id="关联数组：array-index-expression"><a href="#关联数组：array-index-expression" class="headerlink" title="关联数组：array[index-expression]"></a>关联数组：array[index-expression]</h3><p>（1）可使用任意字符串；字符串要使用双引号括起来</p><p>（2）如果某数组元素事先不存在，在引用时，awk 会自动创建此元素，并将其值初始化为“空串”</p><p>（3）若要判断数组中是否存在某元素，要使用“index in array”格式进行遍历</p><p>（4）若要遍历数组中的每个元素，要使用for 循环：for(var in array) {for-body}</p><h3 id="数值-字符串处理"><a href="#数值-字符串处理" class="headerlink" title="数值\字符串处理"></a>数值\字符串处理</h3><p>（1）数值处理</p><pre><code>rand()：返回0和1之间一个随机数，需有个种子 srand()，没有种子，一直输出0.237788</code></pre><p>（2）字符串处理：</p><pre><code>length([s]) ：返回指定字符串的长度sub(r,s,[t]) ：对t 字符串进行搜索r 表示的模式匹配的内容，并将第一个匹配的内容替换为sgsub(r,s,[t]) ：对t 字符串进行搜索r 表示的模式匹配的内容，并全部替换为s 所表示的内容plit(s,array,[r]) ：以r 为分隔符，切割字符串s ，并将切割后的结果保存至array 所表示的数组中，第一个索引值为1, 第二个索引值为2,…</code></pre><h2 id="awk自定义函数"><a href="#awk自定义函数" class="headerlink" title="awk自定义函数"></a>awk自定义函数</h2><p>（1）格式：和bash区别：定义函数（）中需加参数，return返回值不是$?，是相当于echo输出</p><pre><code>function name ( parameter, parameter, ... ) {    statements    return expression}</code></pre><h2 id="awk中调用shell-命令"><a href="#awk中调用shell-命令" class="headerlink" title="awk中调用shell 命令"></a>awk中调用shell 命令</h2><p>（1）system 命令</p><p>　　空格是awk中的字符串连接符，如果system中需要使用awk中的变量可以使用空格分隔，或者说除了awk 的变量外其他一律用”” 引用 起来。</p><p>（2）awk 脚本</p><p>将awk 程序写成脚本，直接调用或执行</p><p>（3）向awk脚本传递参数</p><p>① 格式：</p><pre><code>awkfile var=value var2=value2... Inputfile</code></pre><p>　　注意 ：在BEGIN 过程 中不可用。直到 首行输入完成以后，变量才可用 。可以通过-v  参数，让awk 在执行BEGIN 之前得到变量的值。命令行中每一个指定的变量都需要一个-v　　</p><h1 id="grep-awk-sed对比"><a href="#grep-awk-sed对比" class="headerlink" title="grep awk sed对比"></a>grep awk sed对比</h1><p>grep 主要用于搜索某些字符串；</p><p>sed，awk 用于处理文本 ；</p><p>　　grep基本是以行为单位处理文本的； 而awk可以做更细分的处理，通过指定分隔符将一行（一条记录）划分为多个字段，以字段为单位处理文本。awk中支持C语法，可以有分支条件判断、循环语句等，相当于一个小型编程语言。</p><p>　　awk功能比较多是一个编程语言了。 grep功能简单，就是一个简单的正则表达式的匹配。 awk的功能依赖于grep。</p><p>　　grep可以理解为主要作用是在一个文件中查找过滤需要的内容。awk不是过滤查找，而是文本处理工具，是把一个文件处理成你想要的格式。</p><p>　　AWK的功能是什么？与sed和grep很相似，awk是一种样式扫描与处理工具。但其功能却大大强于sed和grep。awk提供了极其强大的功能：它几乎可以完成grep和sed所能完成的全部工作，同时，它还可以可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。实际上，awk的确拥有自己的语言：awk程序设计语言，awk的三位创建者已将它正式定义为：样式扫描和处理语言。  使用awk的第一个理由是基于文本的样式扫描和处理是我们经常做的工作，awk所做的工作有些象数据库，但与数据库不同的是，它处理的是文本文件，这些文件没有专门的存储格式，普通的人们就能编辑、阅读、理解和处理它们。而数据库文件往往具有特殊的存储格式，这使得它们必须用数据库处理程序来处理它们。既然这种类似于数据库的处理工作我们经常会遇到，我们就应当找到处理它们的简便易行的方法，UNIX有很多这方面的工具，例如sed 、grep、sort以及find等等，awk是其中十分优秀的一种。 </p><p>　　使用awk的第二个理由是awk是一个简单的工具，当然这是相对于其强大的功能来说的。的确，UNIX有许多优秀的工具，例如UNIX天然的开发工具C语言及其延续C++就非常的优秀。但相对于它们来说，awk完成同样的功能要方便和简捷得多。这首先是因为awk提供了适应多种需要的解决方案：从解决简单问题的awk命令行到复杂而精巧的awk程序设计语言，这样做的好处是，你可以不必用复杂的方法去解决本来很简单的问题。例如，你可以用一个命令行解决简单的问题，而C不行，即使一个再简单的程序，C语言也必须经过编写、编译的全过程。其次，awk本身是解释执行的，这就使得awk程序不必经过编译的过程，同时，这也使得它与shell script程序能够很好的契合。最后，awk本身较C语言简单，虽然awk吸收了C语言很多优秀的成分，熟悉C语言会对学习awk有很大的帮助，但awk本身不须要会使用C语言——一种功能强大但需要大量时间学习才能掌握其技巧的开发工具。 </p><p>　　使用awk的第三个理由是awk是一个容易获得的工具。与C和C++语言不同，awk只有一个文件(/bin/awk)，而且几乎每个版本的UNIX都提供各自版本的awk，你完全不必费心去想如何获得awk。但C语言却不是这样，虽然C语言是UNIX天然的开发工具，但这个开发工具却是单独发行的，换言之，你必须为你的UNIX版本的C语言开发工具单独付费（当然使用D版者除外），获得并安装它，然后你才可以使用它。 </p><p>　　基于以上理由，再加上awk强大的功能，我们有理由说，如果你要处理与文本样式扫描相关的工作，awk应该是你的第一选择。在这里有一个可遵循的一般原则：如果你用普通的shell工具或shell script有困难的话，试试awk,如果awk仍不能解决问题，则便用C语言，如果C语言仍然失败，则移至C++。 </p><p>　　sed是一个非交互性文本流编辑器。它编辑文件或标准输入导出的文本拷贝。sed编辑器按照一次处理 一行的方式来处理文件（或者输入）并把输出送到屏幕上。你可以在vi和ex/ed编辑器里识别他的命令。sed把当前正在处理的行保存在一个临时缓存里，这个缓存叫做模式空间。一但sed完成了对模式空间里的行的处理（即对该行执行sed命令），就把模式空间的行送到屏幕上（除非该命令要删除该行活禁止打印）。处理完该行之后，从模式空间里删除它，然后把下一行读入模式空间，进行处理，并显示。当输入文件的最后一行处理完后，sed终止。通过把每一行存在一个临时缓存里并编辑该行，初始文件不会被修改或被破坏。</p><p>　　<br>[^1]:<a href="https://www.cnblogs.com/along21/p/10366886.html" target="_blank" rel="noopener">https://www.cnblogs.com/along21/p/10366886.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk、grep、sed是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>503. 下一个更大元素 II</title>
    <link href="http://yoursite.com/2021/11/29/503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/"/>
    <id>http://yoursite.com/2021/11/29/503. 下一个更大元素 II/</id>
    <published>2021-11-29T13:12:12.000Z</published>
    <updated>2021-11-29T02:58:52.902Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><a id="more"></a><p>[TOC]</p><p>示例 1:</p><pre><code>输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</code></pre><h1 id="方法一：单调栈-循环数组"><a href="#方法一：单调栈-循环数组" class="headerlink" title="方法一：单调栈 + 循环数组"></a>方法一：单调栈 + 循环数组</h1><p><strong>思路及算法</strong></p><p>我们可以使用单调栈解决本题。单调栈中保存的是下标，从栈底到栈顶的下标在数组nums 中对应的值是单调不升的。</p><p>每次我们移动到数组中的一个新的位置 <em>i</em>，我们就将当前单调栈中所有对应值小于nums[i] 的下标弹出单调栈，这些值的下一个更大元素即为 nums[i] （证明很简单：如果有更靠前的更大元素，那么这些位置将被提前弹出栈）。随后我们将位置 <em>i</em> 入栈。</p><p>但是注意到只遍历一次序列是不够的，例如序列 <em>[2,3,1]<em>，最后单调栈中将剩余 *[3,1]</em>，其中元素 *[1]</em> 的下一个更大元素还是不知道的。</p><p>一个朴素的思想是，我们可以把这个循环数组「拉直」，即复制该序列的前 <em>n-1</em> 个元素拼接在原序列的后面。这样我们就可以将这个新序列当作普通序列，用上文的方法来处理。</p><p>而在本题中，我们不需要显性地将该循环数组「拉直」，而只需要在处理时对下标取模即可。</p><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; nums[stk.top()] &lt; nums[i % n]) &#123;</span><br><span class="line">                ret[stk.top()] = nums[i % n];</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(ret, -<span class="number">1</span>);</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i % n]) &#123;</span><br><span class="line">                ret[stack.pop()] = nums[i % n];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextGreaterElements = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">const</span> stk = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stk.length &amp;&amp; nums[stk[stk.length - <span class="number">1</span>]] &lt; nums[i % n]) &#123;</span><br><span class="line">            ret[stk[stk.length - <span class="number">1</span>]] = nums[i % n];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(i % n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        ret = [<span class="number">-1</span>] * n</span><br><span class="line">        stk = list()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n * <span class="number">2</span> - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> nums[stk[<span class="number">-1</span>]] &lt; nums[i % n]:</span><br><span class="line">                ret[stk.pop()] = nums[i % n]</span><br><span class="line">            stk.append(i % n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight go"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElements</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ans &#123;</span><br><span class="line">        ans[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n*<span class="number">2</span><span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; nums[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &lt; nums[i%n] &#123;</span><br><span class="line">            ans[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] = nums[i%n]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i%n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">nextGreaterElements</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stk[numsSize * <span class="number">2</span> - <span class="number">1</span>], top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; nums[stk[top - <span class="number">1</span>]] &lt; nums[i % numsSize]) &#123;</span><br><span class="line">            ret[stk[top - <span class="number">1</span>]] = nums[i % numsSize];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[top++] = i % numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: <em>O(n)*，其中 *n</em> 是序列的长度。我们需要遍历该数组中每个元素最多 <em>2</em> 次，每个元素出栈与入栈的总次数也不超过 <em>4</em> 次。</p></li><li><p>空间复杂度: <em>O(n)*，其中 *n</em> 是序列的长度。空间复杂度主要取决于栈的大小，栈的大小至多为 <em>2n-1</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。&lt;/p&gt;
    
    </summary>
    
      <category term="2021年11月" scheme="http://yoursite.com/categories/2021%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Monotonic Stack" scheme="http://yoursite.com/tags/Monotonic-Stack/"/>
    
  </entry>
  
</feed>
