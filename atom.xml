<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiye Li</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-16T10:11:12.382Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yiye Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>89. 格雷编码</title>
    <link href="http://yoursite.com/2020/12/16/89.%20%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2020/12/16/89. 格雷编码/</id>
    <published>2020-12-16T08:26:12.000Z</published>
    <updated>2020-12-16T10:11:12.382Z</updated>
    
    <content type="html"><![CDATA[<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p><p>格雷编码序列必须以 0 开头。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1</code></pre><p>示例 2:</p><pre><code>输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。     因此，当 n = 0 时，其格雷编码序列为 [0]。</code></pre><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><ul><li>设 <em>n</em> 阶格雷码集合为 <em>G(n)*，则 *G(n+1)</em> 阶格雷码为：<ul><li>给 <em>G(n)</em> 阶格雷码每个元素二进制形式前面添加 <em>0</em>，得到 <em>G’(n)</em>；</li><li>设 <em>G(n)</em> 集合倒序（镜像）为 <em>R(n)*，给 *R(n)</em> 每个元素二进制形式前面添加 <em>1</em>，得到 <em>R’(n)</em>；</li><li><em>G(n+1) = G’(n) ∪ R’(n)</em> 拼接两个集合即可得到下一阶格雷码。</li></ul></li><li>根据以上规律，可从 <em>0</em> 阶格雷码推导致任何阶格雷码。</li><li>代码解析：<ul><li>由于最高位前默认为 <em>0</em>，因此 <em>G’(n) = G(n)*，只需在 <code>res</code>(即 *G(n)</em> )后添加 <em>R’(n)</em> 即可；</li><li>计算 <em>R’(n)*：执行 <code>head = 1 &lt;&lt; i</code> 计算出对应位数，以给 *R(n)</em> 前添加 <em>1</em> 得到对应 <em>R’(n)</em>；</li><li>倒序遍历 <code>res</code>(即 <em>G(n)</em> )：依次求得 <em>R’(n)</em> 各元素添加至 <code>res</code> 尾端，遍历完成后 <code>res</code>(即 <em>G(n+1)</em>)。</li></ul></li></ul><h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><p> <a href="https://pic.leetcode-cn.com/6c8d62ea7150ece8ed135e6d29bc614eb4022d136b08f3640132fb66e40694c4-Picture1.png" target="_blank" rel="noopener">Picture1.png</a> <a href="https://pic.leetcode-cn.com/e3dcfa34510e7625bfa170388389b14e7fc79e21486db077aac41acf044133f8-Picture2.png" target="_blank" rel="noopener">Picture2.png</a> <a href="https://pic.leetcode-cn.com/d0df7e038c396acf7c5283e8080963ecefe2ab37d4b607982eb3e40b1e5ee03b-Picture3.png" target="_blank" rel="noopener">Picture3.png</a> <a href="https://pic.leetcode-cn.com/28acf6d5b1fae0fb2dddbedd7ac92ffeee8902cd28233bdfb08b52af411a9bb2-Picture4.png" target="_blank" rel="noopener">Picture4.png</a> </p><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res, head = [<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(head + res[j])</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() &#123;&#123; add(<span class="number">0</span>); &#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                res.add(head + res.get(j));</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。&lt;/p&gt;
&lt;p&gt;给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。&lt;/p&gt;
&lt;p&gt;格雷编码序列必须以 0 开头。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>61. 旋转链表</title>
    <link href="http://yoursite.com/2020/12/15/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/12/15/61. 旋转链表/</id>
    <published>2020-12-15T09:26:12.000Z</published>
    <updated>2020-12-16T08:01:10.275Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是非负数。</p><a id="more"></a><p>示例1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p>示例2:</p><pre><code>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre><h1 id="方法-1："><a href="#方法-1：" class="headerlink" title="方法 1："></a>方法 1：</h1><p><strong>直觉</strong></p><p>链表中的点已经相连，一次旋转操作意味着：</p><ul><li>先将链表闭合成环</li><li>找到相应的位置断开这个环，确定新的链表头和链表尾</li></ul><p><a href="https://pic.leetcode-cn.com/e3371c6b03e3c8d3758dcf0b35a45d0a6b39c111373cf7b5bde53e14b6271a04-61.png" target="_blank" rel="noopener">61.png</a></p><blockquote><p>新的链表头在哪里？</p></blockquote><p>在位置 <code>n-k</code> 处，其中 <code>n</code> 是链表中点的个数，新的链表尾就在头的前面，位于位置 <code>n-k-1</code>。</p><blockquote><p>我们这里假设 <code>k &lt; n</code></p><p>如果  <code>k &gt;= n</code>  怎么处理？</p></blockquote><p><code>k</code> 可以被写成 <code>k = (k // n) * n + k % n</code> 两者加和的形式，其中前面的部分不影响最终的结果，因此只需要考虑 <code>k%n</code> 的部分，这个值一定比 <code>n</code> 小。</p><p><strong>算法</strong></p><p>算法实现很直接：</p><ul><li>找到旧的尾部并将其与链表头相连 <code>old_tail.next = head</code>，整个链表闭合成环，同时计算出链表的长度 <code>n</code>。</li><li>找到新的尾部，第 <code>(n - k % n - 1)</code> 个节点 ，新的链表头是第 <code>(n - k % n)</code> 个节点。</li><li>断开环 <code>new_tail.next = None</code>，并返回新的链表头 <code>new_head</code>。</li></ul><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close the linked list into the ring</span></span><br><span class="line">    ListNode old_tail = head;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; old_tail.next != <span class="keyword">null</span>; n++)</span><br><span class="line">      old_tail = old_tail.next;</span><br><span class="line">    old_tail.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find new tail : (n - k % n - 1)th node</span></span><br><span class="line">    <span class="comment">// and new head : (n - k % n)th node</span></span><br><span class="line">    ListNode new_tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)</span><br><span class="line">      new_tail = new_tail.next;</span><br><span class="line">    ListNode new_head = new_tail.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// break the ring</span></span><br><span class="line">    new_tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: <span class="string">'ListNode'</span>, k: <span class="string">'int'</span>)</span> -&gt; 'ListNode':</span></span><br><span class="line">        <span class="comment"># base cases</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># close the linked list into the ring</span></span><br><span class="line">        old_tail = head</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> old_tail.next:</span><br><span class="line">            old_tail = old_tail.next</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        old_tail.next = head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find new tail : (n - k % n - 1)th node</span></span><br><span class="line">        <span class="comment"># and new head : (n - k % n)th node</span></span><br><span class="line">        new_tail = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k % n - <span class="number">1</span>):</span><br><span class="line">            new_tail = new_tail.next</span><br><span class="line">        new_head = new_tail.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># break the ring</span></span><br><span class="line">        new_tail.next = <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O(N)*，其中 *N</em> 是链表中的元素个数</li><li>空间复杂度：<em>O(1)</em>，因为只需要常数的空间</li></ul></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动k个位置，其中k是非负数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>8. 字符串转换整数 (atoi)</title>
    <link href="http://yoursite.com/2020/12/09/8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/"/>
    <id>http://yoursite.com/2020/12/09/8. 字符串转换整数 (atoi)/</id>
    <published>2020-12-09T06:26:12.000Z</published>
    <updated>2020-12-15T09:22:19.958Z</updated>
    
    <content type="html"><![CDATA[<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><a id="more"></a><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>提示：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><pre><code>输入: &quot;42&quot;输出: 42</code></pre><p>示例 2:</p><pre><code>输入: &quot;   -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</code></pre><p>示例 3:</p><pre><code>输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</code></pre><p>示例 4:</p><pre><code>输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。     因此无法执行有效的转换。</code></pre><p>示例 5:</p><pre><code>输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。</code></pre><h1 id="视频题解"><a href="#视频题解" class="headerlink" title="视频题解"></a>视频题解</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>根据问题的描述我们来判断并且描述对应的解题方法。对于这道题目，很明显是字符串的转化问题。需要明确转化规则，尽量根据转化规则编写对应的子函数。</p><p>这里我们要进行模式识别，一旦涉及整数的运算，我们需要注意溢出。本题可能产生溢出的步骤在于推入，乘 10 操作和累加操作都可能造成溢出。对于溢出的处理方式通常可以转换为 <code>INT_MAX</code> 的逆操作。比如判断某数乘 10 是否会溢出，那么就把该数和 <code>INT_MAX</code> 除 10 进行比较。</p><p><a href="3c712e6e-fcf7-4953-9401-bd1d5c2b9cb8">字符串转换整数 (atoi).mp4</a></p><h1 id="文字题解"><a href="#文字题解" class="headerlink" title="文字题解"></a>文字题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>这个问题其实没有考察算法的知识，模拟的是日常开发中对于原始数据的处理（例如「参数校验」等场景），如果面试中遇到类似的问题，应先仔细阅读题目文字说明和示例，有疑惑的地方和需要和面试官确认，在编码的时候需要耐心和细心地调试。</p><p>其实很多时候，业务需求就是类似这样的问题，工作中如果遇到：</p><p>1、有现成的工具和类库需尽量使用，因为它们是性能更优，且经过更严格测试，是相对可靠的；<br>2、能抽取成工具类、工具方法的尽量抽取，以突出主干逻辑、方便以后代码复用；<br>3、不得不写得比较繁琐、冗长的时候，需要写清楚注释、体现逻辑层次，以便上线以后排查问题和后续维护。</p><p>在这我罗列几个要点：</p><ul><li>根据示例 1，需要去掉前导空格；</li><li>根据示例 2，需要判断第 1 个字符为 <code>+</code> 和 <code>-</code> 的情况，因此，可以设计一个变量 <code>sign</code>，初始化的时候为 <code>1</code>，如果遇到 <code>-</code> ，将 <code>sign</code> 修正为 <code>-1</code>；</li><li>判断是否是数字，可以使用字符的 ASCII 码数值进行比较，即 <code>0 &lt;= c &lt;= &#39;9&#39;</code>；</li><li>根据示例 3 和示例 4 ，在遇到第 1 个不是数字的字符的情况下，转换停止，退出循环；</li><li>根据示例 5，如果转换以后的数字超过了 <code>int</code> 类型的范围，需要截取。这里不能将结果 <code>res</code> 变量设计为 <code>long</code> 类型，<strong>注意</strong>：由于输入的字符串转换以后也有可能超过 <code>long</code> 类型，因此需要在循环内部就判断是否越界，只要越界就退出循环，这样也可以减少不必要的计算；</li><li>由于涉及下标访问，因此全程需要考虑数组下标是否越界的情况。</li></ul><p><strong>特别注意</strong>：</p><p>1、由于题目中说「环境只能保存 32 位整数」，因此这里在每一轮循环之前先要检查乘以 <em>10</em> 以后是否溢出，具体细节请见编码。</p><p>2、Java 、Python 和 C++ 字符串的设计都是不可变的，即使用 <code>trim()</code> 会产生新的变量，因此我们<strong>尽量不使用库函数，使用一个变量 <code>index</code> 去做遍历，这样遍历完成以后就得到转换以后的数值</strong>。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="comment">// str.charAt(i) 方法回去检查下标的合法性，一般先转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、去除前导空格</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len &amp;&amp; charArray[index] == <span class="string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、如果已经遍历完成（针对极端用例 "      "）</span></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、如果出现符号字符，仅第 1 个有效，并记录正负</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> firstChar = charArray[index];</span><br><span class="line">        <span class="keyword">if</span> (firstChar == <span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、将后续出现的数字字符进行转换</span></span><br><span class="line">        <span class="comment">// 不能使用 long 类型，这是题目说的</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> currChar = charArray[index];</span><br><span class="line">            <span class="comment">// 4.1 先判断不合法的情况</span></span><br><span class="line">            <span class="keyword">if</span> (currChar &gt; <span class="string">'9'</span> || currChar &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 题目中说：环境只能存储 32 位大小的有符号整数，因此，需要提前判：断乘以 10 以后是否越界</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">'0'</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">'0'</span>) &gt; -(Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2 合法的情况下，才考虑转换，每一步都把符号位乘进去</span></span><br><span class="line">            res = res * <span class="number">10</span> + sign * (currChar - <span class="string">'0'</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>C++</summary><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len = str.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除前导空格</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[index] != <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 处理第 1 个非空字符为正负符号，这两个判断需要写在一起</span></span><br><span class="line">        <span class="keyword">if</span> (str[index] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[index] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据题目限制，只能使用 int 类型</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> curChar = str[index];</span><br><span class="line">            <span class="keyword">if</span> (curChar &lt; <span class="string">'0'</span> || curChar &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; (curChar - <span class="string">'0'</span>) &gt; INT_MAX % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; (curChar - <span class="string">'0'</span>) &gt; -(INT_MIN % <span class="number">10</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = res * <span class="number">10</span> + sign * (curChar - <span class="string">'0'</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<em>O(N)*，这里 *N</em> 为字符串的长度；</li><li>空间复杂度：<em>O(1)</em>。</li></ul><h2 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h2><p><strong>思路</strong></p><p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。</p><p>因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p><p>我们的程序在每个时刻有一个状态 <code>s</code>，每次从序列中输入一个字符 <code>c</code>，并根据字符 <code>c</code> 转移到下一个状态 <code>s&#39;</code>。这样，我们只需要建立一个覆盖所有情况的从 <code>s</code> 与 <code>c</code> 映射到 <code>s&#39;</code> 的表格即可解决题目中的问题。</p><p><strong>算法</strong></p><p>本题可以建立如下图所示的自动机：</p><p><a href="https://assets.leetcode-cn.com/solution-static/8_fig1.PNG" target="_blank" rel="noopener">fig1</a></p><p>我们也可以用下面的表格来表示这个自动机：</p><table><thead><tr><th></th><th align="center">‘ ‘</th><th align="center">+/-</th><th align="center">number</th><th align="center">other</th></tr></thead><tbody><tr><td><strong>start</strong></td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td><strong>signed</strong></td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td><strong>in_number</strong></td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td><strong>end</strong></td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可。</p><p>另外自动机也需要记录当前已经输入的数字，只要在 <code>s&#39;</code> 为 <code>in_number</code> 时，更新我们输入的数字，即可最终得到输入的数字。</p><details>    <summary>自动机Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">INT_MIN = <span class="number">-2</span> ** <span class="number">31</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.state = <span class="string">'start'</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">'start'</span>: [<span class="string">'start'</span>, <span class="string">'signed'</span>, <span class="string">'in_number'</span>, <span class="string">'end'</span>],</span><br><span class="line">            <span class="string">'signed'</span>: [<span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'in_number'</span>, <span class="string">'end'</span>],</span><br><span class="line">            <span class="string">'in_number'</span>: [<span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'in_number'</span>, <span class="string">'end'</span>],</span><br><span class="line">            <span class="string">'end'</span>: [<span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'end'</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_col</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c.isspace():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        self.state = self.table[self.state][self.get_col(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">'in_number'</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + int(c)</span><br><span class="line">            self.ans = min(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> min(self.ans, -INT_MIN)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">'signed'</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">'+'</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        automaton = Automaton()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">            automaton.get(c)</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans</span><br></pre></td></tr></table></figure></details><details>    <summary>自动机C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> state = <span class="string">"start"</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">"start"</span>, &#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"signed"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"in_number"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"end"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][get_col(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">"in_number"</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? min(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : min(ans, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">"signed"</span>)</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">            automaton.get(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>自动机Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton = <span class="keyword">new</span> Automaton();</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            automaton.get(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (automaton.sign * automaton.ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">"start"</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String[]&gt; table = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">"start"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"signed"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"in_number"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        put(<span class="string">"end"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table.get(state)[get_col(c)];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"in_number"</span>.equals(state)) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? Math.min(ans, (<span class="keyword">long</span>) Integer.MAX_VALUE) : Math.min(ans, -(<span class="keyword">long</span>) Integer.MIN_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"signed"</span>.equals(state)) &#123;</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>，自动机的状态只需要常数空间存储。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="http://yoursite.com/2020/12/02/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/12/02/1. 两数之和/</id>
    <published>2020-12-02T09:26:12.000Z</published>
    <updated>2020-12-02T10:29:22.179Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><a id="more"></a><p>示例:</p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h2><p><strong>思路及算法</strong></p><p>最容易想到的方法是枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p><p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p><p><strong>代码</strong></p><details>    <summary>暴力枚举Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">                ret[<span class="number">0</span>] = i, ret[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力枚举Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> x+nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N^2)*，其中 *N</em> 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p><strong>思路及算法</strong></p><p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 <em>O(N)</em> 降低到 <em>O(1)</em>。</p><p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><p><strong>代码</strong></p><details>    <summary>哈希表Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">hashtable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hashTable* <span class="title">find</span><span class="params">(<span class="keyword">int</span> ikey)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">    HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> ikey, <span class="keyword">int</span> ival)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> = <span class="title">find</span>(<span class="title">ikey</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">hashTable</span>));</span></span><br><span class="line">        tmp-&gt;key = ikey, tmp-&gt;val = ival;</span><br><span class="line">        HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;val = ival;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    hashtable = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">it</span> = <span class="title">find</span>(<span class="title">target</span> - <span class="title">nums</span>[<span class="title">i</span>]);</span></span><br><span class="line">        <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">            ret[<span class="number">0</span>] = it-&gt;val, ret[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        insert(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashtable = dict()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></details><details>    <summary>哈希表Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    hashTable := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> p, ok := hashTable[target-x]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;p, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(N)*，其中 *N</em> 是数组中的元素数量。对于每一个元素 <code>x</code>，我们可以 <em>O(1)</em> 地寻找 <code>target - x</code>。</p></li><li><p>空间复杂度：<em>O(N)*，其中 *N</em> 是数组中的元素数量。主要为哈希表的开销。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年12月" scheme="http://yoursite.com/categories/2020%E5%B9%B412%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>176. 第二高的薪水</title>
    <link href="http://yoursite.com/2020/11/30/176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/"/>
    <id>http://yoursite.com/2020/11/30/176. 第二高的薪水/</id>
    <published>2020-11-30T09:12:12.000Z</published>
    <updated>2020-11-30T10:10:47.161Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</p><a id="more"></a><p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</p><pre><code>+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+</code></pre><p>例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。</p><pre><code>+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+</code></pre><h1 id="方法一：使用子查询和-LIMIT-子句"><a href="#方法一：使用子查询和-LIMIT-子句" class="headerlink" title="方法一：使用子查询和 LIMIT 子句"></a>方法一：使用子查询和 <code>LIMIT</code> 子句</h1><p><strong>算法</strong></p><p>将不同的薪资按降序排序，然后使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>LIMIT</code></a> 子句获得第二高的薪资。</p><details>    <summary>使用子查询和 `LIMIT` 子句</summary><figure class="highlight plain"><figcaption><span>[7gHRPQAW-MySQL]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">    Salary AS SecondHighestSalary</span><br><span class="line">FROM</span><br><span class="line">    Employee</span><br><span class="line">ORDER BY Salary DESC</span><br><span class="line">LIMIT 1 OFFSET 1</span><br></pre></td></tr></table></figure></details><p>然而，如果没有这样的第二最高工资，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。</p><details>    <summary>使用子查询和 `LIMIT` 子句</summary><figure class="highlight plain"><figcaption><span>[Z4dXjTB5-MySQL]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    (SELECT DISTINCT</span><br><span class="line">            Salary</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1) AS SecondHighestSalary</span><br><span class="line">;</span><br></pre></td></tr></table></figure></details><h1 id="方法二：使用-IFNULL-和-LIMIT-子句"><a href="#方法二：使用-IFNULL-和-LIMIT-子句" class="headerlink" title="方法二：使用 IFNULL 和 LIMIT 子句"></a>方法二：使用 <code>IFNULL</code> 和 <code>LIMIT</code> 子句</h1><p>解决 “NULL” 问题的另一种方法是使用 “IFNULL” 函数，如下所示。</p><details>    <summary>使用 `IFNULL` 和 `LIMIT` 子句</summary><figure class="highlight plain"><figcaption><span>[UF7BUDgS-MySQL]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    IFNULL(</span><br><span class="line">      (SELECT DISTINCT Salary</span><br><span class="line">       FROM Employee</span><br><span class="line">       ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1),</span><br><span class="line">    NULL) AS SecondHighestSalary</span><br></pre></td></tr></table></figure></details><h1 id="limit和offset用法"><a href="#limit和offset用法" class="headerlink" title="limit和offset用法"></a>limit和offset用法</h1><p>mysql里分页一般用limit来实现，</p><pre><code>select* from test LIMIT 3;</code></pre><p>当 limit后面跟一个参数的时候，该参数表示要取的数据的数量。 表示直接取前三条数据，类似sqlserver里的top语法。</p><p>以下的两种方式均表示取2,3,4三条条数据。</p><p>1.select* from test LIMIT 1,3;<br>当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量。</p><p>2.select * from test LIMIT 3 OFFSET 1;</p><p>(在mysql 5以后支持这种写法)<br>当 limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量 。表示跳过1条数据,从第2条数据开始取，取3条数据，也就是取2,3,4三条数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>393. UTF-8 编码验证</title>
    <link href="http://yoursite.com/2020/11/30/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"/>
    <id>http://yoursite.com/2020/11/30/393. UTF-8 编码验证/</id>
    <published>2020-11-30T09:12:12.000Z</published>
    <updated>2020-12-02T07:45:13.225Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p><a id="more"></a><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><p>对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。</p><p>对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p><p>这是 UTF-8 编码的工作方式：</p><pre><code>Char. number range  |        UTF-8 octet sequence   (hexadecimal)    |              (binary)--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></pre><p>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p><p>注意:</p><p>输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><p>示例 1:</p><pre><code>data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。</code></pre><p>示例 2:</p><pre><code>data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.返回 false 。前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。</code></pre><p><strong>思路</strong></p><p>这个问题非常有趣，因为它本身并不是特别难，但是确实是需要花一些功夫去处理一些细节。很多人解这道题的时候都会忽略一些细节，最后总有那么一到两个 Test Case 过不去。</p><p><strong>说明：</strong> 下面的章节会给出三个例子来解释题目，如果你很清楚这道题了，那你可以直接跳过。</p><p>题述中给了两个例子来帮助你理解 UTF-8 字符集的规则。对于很多人来说这两个例子是不够的，所以接下来做的第一件事就是来理解题述中给的规则，同时再来看一个例子来帮助我们更好地理解这道题。那就开始吧。</p><ul><li>一个合法的 UTF-8 字符的长度为 <code>1-4</code> 字节。</li><li>对于 <code>1</code> 字节的字符，字节的第一位设为 <code>0</code>，后面 <code>7</code> 位为这个符号的 unicode 码。</li><li>对于 <code>n</code> 字节的字符 (n &gt; 1)，第一个字节的前 <code>n</code> 位都为 <code>1</code>，第 <code>n+1</code> 位为 <code>0</code>，后面字节的前两位一律都为 <code>10</code>。</li><li>输入是代表字符的整数数组。我们要判断数组中的数能不能表示成数个合法的 UTF-8 字符。在第一个的例子里面可以看到，数组上的可以表示称数个合法的 UTF-8 字符，因此这个数组是合法的。</li><li>有一个点需要注意的是，数组中的整数是有可能大于255的。我们都知道 8 比特能表示的最大整数为255。假如数组中有一个数为 476，那我们该怎么处理呢？ 根据题述例子中的说明，我们只需要考虑每个整数中 <code>最高8位</code> 就可以了。</li></ul><p>现在规则已经搞清楚了，让我们先来看题述中例子，接下里再看一些可能造成困惑的其他例子。</p><p><strong>例一</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = [197, 130, 1]</span><br></pre></td></tr></table></figure><p>首先把这个数组表示成二进制的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11000101 10000010 00000001</span><br></pre></td></tr></table></figure><blockquote><p>记住，对于一个 <code>n</code> 字节长的 UTF-8 字符来说，第一个字节的前 <code>n</code> 位都为 <code>1</code>，第 <code>n+1</code> 位为 <code>0</code>，后面字节的前两位一律都为 <code>10</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 1 0] 0 0 1 0 1</span><br><span class="line"> ↑   ↑</span><br></pre></td></tr></table></figure><p>第一个字节的前两个比特值都是 <code>1</code>，<code>1</code> 后面紧接着一个 <code>0</code>。这是一个合法 UTF-8 字符的开始。同时从中可知这是一个 <code>2</code> 字节长的 UTF-8 字符。这也就意味着序列中接下来的字节一定是 <code>10xxxxxx</code> 这样的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 1 0] 0 0 1 0 1    [1 0] 0 0 0 0 1 0</span><br><span class="line"> ↑   ↑                ↑ ↑</span><br></pre></td></tr></table></figure><p>是的，确实是遵循了规则。因此数组中 <code>197 130</code> 这两个数共同组成了一个合法的 <code>2</code> 字节  UTF-8 字符。既然数组中还有元素，继续以同样的方式检查。接下来的整数是 1，先把它变成二进制表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000001</span><br></pre></td></tr></table></figure><p>在这里最高比特位是 <code>0</code>，那么它只能满足 <code>1</code> 字节 UTF-8 字符的规则了。让我们来回顾一下这个规则：</p><blockquote><p>对于 <code>1</code> 字节的字符，字节的第一位设为 <code>0</code>，后面 <code>7</code> 位为这个符号的 <code>unicode</code>  码。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0] 0 0 0 0 0 0 1</span><br><span class="line"> ↑</span><br></pre></td></tr></table></figure><p>显然，整数 <code>1</code> 本身就是一个合法的 <code>1</code> 字节 UTF-8 字符。这时候数组已经没有剩余数要处理了，从前面的分析可知整个数组表示的是两个合法的 UTF-8 字符，因此需要返回 <code>True</code>。</p><p><strong>例子二</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[235, 140, 4]</span><br></pre></td></tr></table></figure><p>这是题述中的第二个例子。照样先把这个整数数组的转成二进制表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11101011 10001100 00000100</span><br></pre></td></tr></table></figure><p>从数组的第一个整数开始。第一个字节会告诉我们这个 UTF-8 字符的长度，同时会告诉我们接下里该处理多少个字节来完全解析当前的 UTF-8 字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 1 1 0] 1 0 1 1</span><br><span class="line"> ↑     ↑</span><br></pre></td></tr></table></figure><p>可以看到前四个比特为 <code>1110</code>。这意味着这个 UTF-8 字符总共有 <code>3</code> 字节。记住，我们可以从第一个字节中知晓这个潜在 UTF-8 字符的长度。</p><blockquote><p>对于 <code>n</code> 字节的字符 (n &gt; 1)，第一个字节的前 <code>n</code> 位都为 <code>1</code>，第 <code>n+1</code> 位为 <code>0</code>。</p></blockquote><p>根据这个规则我们知道了第一个 UTF-8 字符是长度为 <code>3</code> 字节。第一个字节已经处理过了，还需要处理剩下的两个字节。我们来看一下这个数组中剩下的两个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 0] 0 0 1 1 0 0       0 0 0 0 0 1 0 0</span><br><span class="line"> ↑ ↑                    ↑ (WRONG!)</span><br></pre></td></tr></table></figure><p>第一个字节遵循了 <code>10xxxxxx</code> 规则，但是第二个字节违反了这个规则。根据第一个字节 <code>11101011</code>，这只能是一个 3 字节 UTF-8 字符。但是最后一个字节违反了规则。因此，这是一个非法字节，这也就意味着可以直接返回 <code>False</code>了。</p><p><strong>例三</strong></p><p>在看题解之前我们来看最后一个例子。在讨论区可以看到这个例子对很多人造成了困惑。</p><p>下面就是这个例子了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[250,145,145,145,145]</span><br></pre></td></tr></table></figure><p>照旧把数组中所有的整数转成二进制表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111010 10010001 10010001 10010001 10010001</span><br></pre></td></tr></table></figure><p>和前两个例子一样，首先看第一个字节来获取当前这个 UTF-8 字符的长度。从第一个字节中可以知道这个 UTF-8 字符的长度是 5 字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 1 1 1 1 0] 1 0</span><br><span class="line"> ↑         ↑</span><br></pre></td></tr></table></figure><p>如果这是一个合法的 UTF-8 字符，那么接下来的四个字节必须遵守 <code>10xxxxxx</code> 规则。我们来看一下接下来的四个字节吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. [1 0] 0 1 0 0 0 1</span><br><span class="line">2. [1 0] 0 1 0 0 0 1</span><br><span class="line">3. [1 0] 0 1 0 0 0 1</span><br><span class="line">4. [1 0] 0 1 0 0 0 1</span><br></pre></td></tr></table></figure><p>可以看到，这四个字节都是遵守 <code>10xxxxxx</code> 规则。那为什么这个例子需要返回 <code>False</code> 呢？ 这是因为你忽略了题目给的第一个规则。</p><blockquote><p>题述中的第一个规则，很清楚地说了 “一个合法的 UTF-8 字符的长度为 <code>1-4</code> 字节。”</p></blockquote><p>从第一个字节就知道了这个 UTF-8 字符将包含 <code>5 字节</code> 了，这也就意味着这个字符绝对是非法的。这也就是为什么对于这个例子应该返回 <code>False</code>了。</p><p>但愿上面我们一起看过的三个例子中能解答你心中大部分的疑惑。接下来我们来看题解吧。</p><h1 id="方法一：-字符串操作"><a href="#方法一：-字符串操作" class="headerlink" title="方法一： 字符串操作"></a>方法一： 字符串操作</h1><p>这个问题本身并不复杂。只要我们遵循题述中的规则，就不会做错了。下面将直接给出算法。</p><p><strong>算法</strong></p><ol><li>对数组中每个整数进行处理。</li><li>对于每个整数，获取当前整数 <code>字符串形式</code> 的二进制表示。考虑到整数可能非常大，我们只需要只保留 <code>最右 8 比特</code> 就可以了。完成这个步骤之后，我们会获得一个 8 比特的二进制字符串数组。我们把这个数组叫做 <code>bin_rep</code>。</li><li>在接下来的步骤中有两个情况需要处理。<ol><li>第一个情况是，我们正在处理某个 UTF-8 字符之中。在这个情况下，我们只需要检查前两个比特是不是 <code>10</code> 就可以了。<code>bin_rep[:2] == &quot;10&quot;</code></li><li>第二个情况是刚开始处理一个新的 UTF-8字符。在这个情况下，我们需要查看这个字节的前缀，计算第一个 <code>0</code> 之前 <code>1</code> 的个数。这会告诉我们当前 UTF-8 字符的大小。</li></ol></li><li>对于数组中的每个整数都这样处理，直到数组为空或者发现非法字符。</li></ol><p>下面是算法的具体实现。</p><details>    <summary>字符串操作Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validUtf8</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of bytes in the current UTF-8 character</span></span><br><span class="line">    <span class="keyword">int</span> numberOfBytesToProcess = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each integer in the data array.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the binary representation. We only need the least significant 8 bits</span></span><br><span class="line">      <span class="comment">// for any given number.</span></span><br><span class="line">      String binRep = Integer.toBinaryString(data[i]);</span><br><span class="line">      binRep =</span><br><span class="line">          binRep.length() &gt;= <span class="number">8</span></span><br><span class="line">              ? binRep.substring(binRep.length() - <span class="number">8</span>)</span><br><span class="line">              : <span class="string">"00000000"</span>.substring(binRep.length() % <span class="number">8</span>) + binRep;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this is the case then we are to start processing a new UTF-8 character.</span></span><br><span class="line">      <span class="keyword">if</span> (numberOfBytesToProcess == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the number of 1s in the beginning of the string.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; binRep.length(); j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (binRep.charAt(j) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          numberOfBytesToProcess += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 byte characters</span></span><br><span class="line">        <span class="keyword">if</span> (numberOfBytesToProcess == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalid scenarios according to the rules of the problem.</span></span><br><span class="line">        <span class="keyword">if</span> (numberOfBytesToProcess &gt; <span class="number">4</span> || numberOfBytesToProcess == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Else, we are processing integers which represent bytes which are a part of</span></span><br><span class="line">        <span class="comment">// a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.</span></span><br><span class="line">        <span class="keyword">if</span> (!(binRep.charAt(<span class="number">0</span>) == <span class="string">'1'</span> &amp;&amp; binRep.charAt(<span class="number">1</span>) == <span class="string">'0'</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We reduce the number of bytes to process by 1 after each integer.</span></span><br><span class="line">      numberOfBytesToProcess -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is for the case where we might not have the complete data for</span></span><br><span class="line">    <span class="comment">// a particular UTF-8 character.</span></span><br><span class="line">    <span class="keyword">return</span> numberOfBytesToProcess == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>字符串操作Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validUtf8</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type data: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Number of bytes in the current UTF-8 character</span></span><br><span class="line">        n_bytes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># For each integer in the data array.</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the binary representation. We only need the least significant 8 bits</span></span><br><span class="line">            <span class="comment"># for any given number.</span></span><br><span class="line">            bin_rep = format(num, <span class="string">'#010b'</span>)[<span class="number">-8</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If this is the case then we are to start processing a new UTF-8 character.</span></span><br><span class="line">            <span class="keyword">if</span> n_bytes == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Get the number of 1s in the beginning of the string.</span></span><br><span class="line">                <span class="keyword">for</span> bit <span class="keyword">in</span> bin_rep:</span><br><span class="line">                    <span class="keyword">if</span> bit == <span class="string">'0'</span>: <span class="keyword">break</span></span><br><span class="line">                    n_bytes += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 1 byte characters</span></span><br><span class="line">                <span class="keyword">if</span> n_bytes == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Invalid scenarios according to the rules of the problem.</span></span><br><span class="line">                <span class="keyword">if</span> n_bytes == <span class="number">1</span> <span class="keyword">or</span> n_bytes &gt; <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Else, we are processing integers which represent bytes which are a part of</span></span><br><span class="line">                <span class="comment"># a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (bin_rep[<span class="number">0</span>] == <span class="string">'1'</span> <span class="keyword">and</span> bin_rep[<span class="number">1</span>] == <span class="string">'0'</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># We reduce the number of bytes to process by 1 after each integer.</span></span><br><span class="line">            n_bytes -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># This is for the case where we might not have the complete data for</span></span><br><span class="line">        <span class="comment"># a particular UTF-8 character.</span></span><br><span class="line">        <span class="keyword">return</span> n_bytes == <span class="number">0</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度： <em>O(N)</em><br>我们需要处理数组中的每一个整数，对每个整数提取它的二进制表示字符串。这个过程的复杂度为 <em>O(N)*，其中 *N</em> 是数组大小。</p></li><li><p>空间复杂度： <em>O(N)</em><br>对于每一个整数都需要创建一个二进制表示字符串。</p></li></ul><h1 id="方法二：-位操作"><a href="#方法二：-位操作" class="headerlink" title="方法二： 位操作"></a>方法二： 位操作</h1><p>前一个方法就可以很好的解决问题了，但是字符串转换的一些操作会花很多时间，我们有更优雅的做法，那就是用位操作。</p><p>首先我们看一下一个整数表示的字节中有哪些部分是需要处理的。</p><ol><li>如果在处理一个 UTF-8 字符的开始，我们需要提取一个字节的前 <em>N</em> 比特，其中 <em>N</em> 不会超过 4，之后的比特就不需要处理了。</li><li>如果是在处理一个 UTF-8 字符的过程中，我们只需要检查前两位是不是 <code>10</code> 就可以了。</li></ol><p>我们来看一下怎么用位操作来完成以上两个任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mask = 1 &lt;&lt; 7</span><br><span class="line">while mask &amp; num:</span><br><span class="line">    n_bytes += 1</span><br><span class="line">    mask = mask &gt;&gt; 1</span><br></pre></td></tr></table></figure><p>首先我们创建了一个掩码，其值为 <code>10000000</code>。接下来会用这个掩码和整数做 <code>逻辑与</code> 操作，这样就可以知道有多少个 <code>1</code> 了。（记住，整数可能非常大，但我们只需要处理前 8 比特）</p><p>检查前两个比特是不是 <code>10</code>，我们可以用下面这两个掩码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mask1 = 1 &lt;&lt; 7</span><br><span class="line">mask2 = 1 &lt;&lt; 6</span><br><span class="line"></span><br><span class="line">if not (num &amp; mask1 and not (num &amp; mask2)):</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure><p>上面的代码可以高效地判断前两个比特是不是 <code>10</code>。如果不是，直接返回 <code>False</code>。</p><p>来看一下具体实现吧。</p><details>    <summary>位操作Java</summary><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validUtf8</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Number of bytes in the current UTF-8 character</span></span><br><span class="line">        <span class="keyword">int</span> numberOfBytesToProcess = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Masks to check two most significant bits in a byte.</span></span><br><span class="line">        <span class="keyword">int</span> mask1 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> mask2 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For each integer in the data array.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="comment">// If this is the case then we are to start processing a new UTF-8 character.</span></span><br><span class="line">            <span class="keyword">if</span> (numberOfBytesToProcess == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">                 <span class="keyword">while</span> ((mask &amp; data[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                    numberOfBytesToProcess += <span class="number">1</span>;</span><br><span class="line">                    mask = mask &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 byte characters</span></span><br><span class="line">                <span class="keyword">if</span> (numberOfBytesToProcess == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Invalid scenarios according to the rules of the problem.</span></span><br><span class="line">                <span class="keyword">if</span> (numberOfBytesToProcess &gt; <span class="number">4</span> || numberOfBytesToProcess == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// data[i] should have most significant bit set and</span></span><br><span class="line">                <span class="comment">// second most significant bit unset. So, we use the two masks</span></span><br><span class="line">                <span class="comment">// to make sure this is the case.</span></span><br><span class="line">                <span class="keyword">if</span> (!((data[i] &amp; mask1) != <span class="number">0</span> &amp;&amp; (mask2 &amp; data[i]) == <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We reduce the number of bytes to process by 1 after each integer.</span></span><br><span class="line">            numberOfBytesToProcess -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is for the case where we might not have the complete data for</span></span><br><span class="line">        <span class="comment">// a particular UTF-8 character.</span></span><br><span class="line">        <span class="keyword">return</span> numberOfBytesToProcess == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>位操作Python</summary><figure class="highlight python"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validUtf8</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type data: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Number of bytes in the current UTF-8 character</span></span><br><span class="line">        n_bytes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Mask to check if the most significant bit (8th bit from the left) is set or not</span></span><br><span class="line">        mask1 = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Mask to check if the second most significant bit is set or not</span></span><br><span class="line">        mask2 = <span class="number">1</span> &lt;&lt; <span class="number">6</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the number of set most significant bits in the byte if</span></span><br><span class="line">            <span class="comment"># this is the starting byte of an UTF-8 character.</span></span><br><span class="line">            mask = <span class="number">1</span> &lt;&lt; <span class="number">7</span></span><br><span class="line">            <span class="keyword">if</span> n_bytes == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> mask &amp; num:</span><br><span class="line">                    n_bytes += <span class="number">1</span></span><br><span class="line">                    mask = mask &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 1 byte characters</span></span><br><span class="line">                <span class="keyword">if</span> n_bytes == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Invalid scenarios according to the rules of the problem.</span></span><br><span class="line">                <span class="keyword">if</span> n_bytes == <span class="number">1</span> <span class="keyword">or</span> n_bytes &gt; <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If this byte is a part of an existing UTF-8 character, then we</span></span><br><span class="line">                <span class="comment"># simply have to look at the two most significant bits and we make</span></span><br><span class="line">                <span class="comment"># use of the masks we defined before.</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (num &amp; mask1 <span class="keyword">and</span> <span class="keyword">not</span> (num &amp; mask2)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            n_bytes -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n_bytes == <span class="number">0</span></span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <em>O(N)</em></li><li>空间复杂度： <em>O(1)</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>69. x 的平方根</title>
    <link href="http://yoursite.com/2020/11/26/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>http://yoursite.com/2020/11/26/69. x 的平方根/</id>
    <published>2020-11-26T07:23:12.000Z</published>
    <updated>2020-11-30T09:08:36.416Z</updated>
    
    <content type="html"><![CDATA[<p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: 4输出: 2</code></pre><p>示例 2:</p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="6d3985c2-8ccf-4fc7-8eda-2b58b4d33362">69 x的平方根 仲耀晖.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本题是一道常见的面试题，面试官一般会要求面试者在不使用sqrt 函数的情况下，得到 <em>x</em> 的平方根的整数部分。一般的思路会有以下几种：</p><ul><li><p>通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；</p></li><li><p>通过数学方法得到近似结果，直接作为答案。</p></li></ul><h2 id="方法一：袖珍计算器算法"><a href="#方法一：袖珍计算器算法" class="headerlink" title="方法一：袖珍计算器算法"></a>方法一：袖珍计算器算法</h2><p>「袖珍计算器算法」是一种用指数函数 exp  和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。</p><p>我们将sqrt(x) 写成幂的形式 <em>x^{1/2}*，再使用自然对数 *e</em> 进行换底，即可得到</p><pre><code>sqrt(x)=x^{1/2} = (e^lnx)^{1/2}=e^{lnx/2}</code></pre><p>这样我们就可以得到sqrt(x)的值了。</p><p><strong>注意：</strong> 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 <a href="https://baike.baidu.com/item/IEEE%20754" target="_blank" rel="noopener">IEEE 754</a>，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。例如当 <em>x = 2147395600</em> 时，(e^lnx/2) 的计算结果与正确值 <em>46340</em> 相差 <em>10^{-11}*，这样在对结果取整数部分时，会得到 *46339</em> 这个错误的结果。</p><p>因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1  中哪一个是真正的答案。</p><details>    <summary>袖珍计算器算法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = int(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>袖珍计算器算法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="keyword">int</span>(math.Exp(<span class="number">0.5</span> * math.Log(<span class="keyword">float64</span>(x))))</span><br><span class="line">    <span class="keyword">if</span> (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x &#123;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(1)</em>，由于内置的 <code>exp</code> 函数与 <code>log</code> 函数一般都很快，我们在这里将其复杂度视为 <em>O(1)</em>。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h2 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h2><p>由于 <em>x</em> 平方根的整数部分 ans 是<strong>满足 k^2&lt;=x  的最大 <em>k</em> 值</strong>，因此我们可以对 <em>k</em> 进行二分查找，从而得到答案。</p><p>二分查找的下界为 <em>0</em>，上界可以粗略地设定为 <em>x</em>。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 <em>x</em> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。</p><details>    <summary>二分查找C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>二分查找Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, x</span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        mid := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt;= x &#123;</span><br><span class="line">            ans = mid</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(logx)，即为二分查找需要的次数。</p></li><li><p>空间复杂度：<em>O(1)</em>。</p></li></ul><h2 id="方法三：牛顿迭代"><a href="#方法三：牛顿迭代" class="headerlink" title="方法三：牛顿迭代"></a>方法三：牛顿迭代</h2><p><strong>思路</strong></p><p><a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a>是一种可以用来快速求解函数零点的方法。参见<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/" target="_blank" rel="noopener">^1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>432. 全 O(1) 的数据结构</title>
    <link href="http://yoursite.com/2020/11/25/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/11/25/432. 全 O(1) 的数据结构/</id>
    <published>2020-11-25T03:23:12.000Z</published>
    <updated>2020-11-26T07:17:28.858Z</updated>
    
    <content type="html"><![CDATA[<p>请你实现一个数据结构支持以下操作：</p><p>Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。</p><p>Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否则使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。</p><p>GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串”” 。</p><p>GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串””。</p><a id="more"></a><p>挑战：</p><p>你能够以 O(1) 的时间复杂度实现所有操作吗？</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>整体思路是利用hashmap和同时维护双向链表实现查找和获取最大值、最小值的key。双向链表按照升序存储，在inc和dec函数需要判断key是否存在和key的value是否是1，然后再去做相应的操作，代码会有点多，利用java核心技术卷1（第11版）中9.4.2中介绍的Map接口的merge和compute函数可以使代码更简洁。</p><p><a href="https://pic.leetcode-cn.com/d268d37992a310a03983af952f865d26619901c938e025d70cb8d1cad9405587-image.png" target="_blank" rel="noopener">image.png</a><br><a href="https://pic.leetcode-cn.com/0c08ecfbd6150c36aec64056bc9e5fcee768b0163c4a6a14555c08267f0ae721-image.png" target="_blank" rel="noopener">image.png</a></p><details>    <summary>双向链表+HashMap</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">class AllOne &#123;</span><br><span class="line">    </span><br><span class="line">    private Node head;</span><br><span class="line">    private Node tail;</span><br><span class="line">    private Map&lt;String, Node&gt; map;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public AllOne() &#123;</span><br><span class="line">        head = new Node(&quot;head&quot;, -1);</span><br><span class="line">        tail = new Node(&quot;tail&quot;, -1);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */</span><br><span class="line">    public void inc(String key) &#123;</span><br><span class="line">        // merge函数会判断map中是否存在key，如果不存在就会用merge函数的第二个参数作为key的value存入map</span><br><span class="line">        // 如果key已经存在，就会利用merge函数的第三个参数，这个参数接收一个函数式接口</span><br><span class="line">        // 该函数式接口会对已经存在的key的value和你提供的value进行操作（就是merge函数的第二个参数）</span><br><span class="line">        // 由于本题只需要对已经存在的key的value加一，故不需要操作你提供的value</span><br><span class="line">        // merge函数会将已经存在的key和函数式接口返回的value关联起来</span><br><span class="line">        // 由于本题要求，故在函数式接口中直接返回原来的value即可</span><br><span class="line">        map.merge(key, new Node(key, 1), (node1, node2) -&gt; &#123;</span><br><span class="line">            node1.value++;</span><br><span class="line">            return node1;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.get(key).moveToTail(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Decrements an existing key by 1. If Key&apos;s value is 1, remove it from the data structure. */</span><br><span class="line">    public void dec(String key) &#123;</span><br><span class="line">        Node temp = map.get(key);</span><br><span class="line">        // computeIfPresent函数其实本质上与merge函数基本相同</span><br><span class="line">        // computeIfPresent函数与merge函数的区别在于computeIfPresent函数不会提供默认值</span><br><span class="line">        // 也就意味着如果你提供的key不在map中computeIfPresent函数什么也不做</span><br><span class="line">        // 相反如果key存在就会执行你提供的函数式接口里面的操作（computeIfPresent函数的第二个参数）</span><br><span class="line">        // 如果你在函数式接口里面返回了null，那computeIfPresent函数会将该key删除（当前前提是该key存在）</span><br><span class="line">        map.computeIfPresent(key, (k, node) -&gt; &#123;</span><br><span class="line">            node.value--;</span><br><span class="line">            if (node.value == 0) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (map.containsKey(key)) &#123;</span><br><span class="line">            map.get(key).moveToHead(head);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (temp != null) &#123;</span><br><span class="line">                temp.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns one of the keys with maximal value. */</span><br><span class="line">    public String getMaxKey() &#123;</span><br><span class="line">        if (map.isEmpty()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return tail.prev.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns one of the keys with Minimal value. */</span><br><span class="line">    public String getMinKey() &#123;</span><br><span class="line">        if (map.isEmpty()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return head.next.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">    </span><br><span class="line">    String key;</span><br><span class="line">    int value;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    </span><br><span class="line">    public Node(String key, int value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        prev = null;</span><br><span class="line">        next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void moveToTail(Node head, Node tail) &#123;</span><br><span class="line">        if (prev == next &amp;&amp; prev == null) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            prev = head;</span><br><span class="line">            next.prev = this;</span><br><span class="line">            head.next = this;</span><br><span class="line">        &#125; else if (next != tail) &#123;</span><br><span class="line">            while (value &gt; next.value &amp;&amp; next != tail) &#123;</span><br><span class="line">                prev.next = next;</span><br><span class="line">                next.prev = prev;</span><br><span class="line">                Node temp = next;</span><br><span class="line">                next = temp.next;</span><br><span class="line">                temp.next = this;</span><br><span class="line">                prev = temp;</span><br><span class="line">                next.prev = this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void moveToHead(Node head) &#123;</span><br><span class="line">        if (prev != head) &#123;</span><br><span class="line">            if (value &lt; prev.value) &#123;</span><br><span class="line">                prev.next = next;</span><br><span class="line">                next.prev = prev;</span><br><span class="line">                Node temp = prev;</span><br><span class="line">                next = temp;</span><br><span class="line">                prev = temp.prev;</span><br><span class="line">                prev.next = this;</span><br><span class="line">                temp.prev = this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        prev = null;</span><br><span class="line">        next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你实现一个数据结构支持以下操作：&lt;/p&gt;
&lt;p&gt;Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。&lt;/p&gt;
&lt;p&gt;Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否则使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。&lt;/p&gt;
&lt;p&gt;GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串”” 。&lt;/p&gt;
&lt;p&gt;GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串””。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>354. 俄罗斯套娃</title>
    <link href="http://yoursite.com/2020/11/24/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/"/>
    <id>http://yoursite.com/2020/11/24/354. 俄罗斯套娃/</id>
    <published>2020-11-24T11:58:12.000Z</published>
    <updated>2020-11-25T03:21:30.825Z</updated>
    
    <content type="html"><![CDATA[<p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><a id="more"></a><p>说明:</p><p>不允许旋转信封。</p><p>示例:</p><pre><code>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]输出: 3解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre><h1 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h1><p>这道题给了我们一堆大小不一的信封，让我们像套俄罗斯娃娃那样把这些信封都给套起来，这道题实际上是之前那道Longest Increasing Subsequence的具体应用，而且难度增加了，从一维变成了两维，但是万变不离其宗，解法还是一样的，首先来看DP的解法，这是一种brute force的解法，首先要给所有的信封按从小到大排序，首先根据宽度从小到大排，如果宽度相同，那么高度小的再前面，这是STL里面sort的默认排法，所以我们不用写其他的comparator，直接排就可以了，然后我们开始遍历，对于每一个信封，我们都遍历其前面所有的信封，如果当前信封的长和宽都比前面那个信封的大，那么我们更新dp数组，通过dp[i] = max(dp[i], dp[j] + 1)。然后我们每遍历完一个信封，都更新一下结果res，参见代码如下；</p><details>    <summary>动态规划解法C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123;</span><br><span class="line">        int res=0,n=envelopes.size();</span><br><span class="line">        vector&lt;int&gt; dp(n,1);</span><br><span class="line">        sort(envelopes.begin(),envelopes.end());</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                if(envelopes[i].first&gt;envelopes[j].first &amp;&amp; envelopes[i].second&gt; envelopes[j].second)&#123;</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><p>可以使用二分查找法来优化速度，我们首先要做的还是给信封排序，但是这次排序和上面有些不同，信封的宽度还是从小到大排，但是宽度相等时，我们让高度大的在前面。那么现在问题就简化了成了找高度数字中的LIS，完全就和之前那道Longest Increasing Subsequence一样了，所以我们还是使用之前那题解法来做，参见代码如下：</p><details>    <summary>二分查找法C++</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123;      </span><br><span class="line">        vector&lt;int&gt; dp;</span><br><span class="line">        sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b)&#123;</span><br><span class="line">            if(a.first==b.first) return a.second&gt; b.second;</span><br><span class="line">            return a.first &lt;b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        for(int i=0;i&lt;envelopes.size();i++)&#123;</span><br><span class="line">            int left=0,right=dp.size(),t=envelopes[i].second;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                int mid=left+(right-left)/2;</span><br><span class="line">                if(dp[mid]&lt; t) left=mid+1;</span><br><span class="line">                else right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if(right&gt;=dp.size()) dp.push_back(t);</span><br><span class="line">            else dp[right]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p>我们要找到最长的序列，且满足 <code>seq[i+1]</code> 中的元素大于 <code>seq[i]</code> 中的元素。</p><p>该问题是输入是按任意顺序排列的——我们不能直接套用标准的 LIS 算法，需要先对数据进行排序。我们如何对数据进行排序，以便我们的 LIS 算法总能找到最佳答案？</p><p>我们可以在<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">这里</a>找到最长递增子序列的解决方法。如果您不熟悉该算法，请先理解该算法，因为它是解决此问题的前提条件。</p><p><strong>算法：</strong><br>假设我们知道了信封套娃顺序，那么从里向外的顺序必须是按 <code>w</code> 升序排序的子序列。</p><p>在对信封按 <code>w</code> 进行排序以后，我们可以找到 <code>h</code> 上最长递增子序列的长度。、</p><p>我们考虑输入 <code>[[1，3]，[1，4]，[1，5]，[2，3]]</code>，如果我们直接对 <code>h</code> 进行 LIS 算法，我们将会得到 <code>[3，4，5]</code>，显然这不是我们想要的答案，因为 <code>w</code> 相同的信封是不能够套娃的。</p><p>为了解决这个问题。我们可以按 <code>w</code> 进行升序排序，若 <code>w</code> 相同则按 <code>h</code> 降序排序。则上述输入排序后为 <code>[[1，5]，[1，4]，[1，3]，[2，3]]</code>，再对 <code>h</code> 进行 LIS 算法可以得到 <code>[5]</code>，长度为 1，是正确的答案。这个例子可能不明显。</p><p>我们将输入改为 <code>[[1，5]，[1，4]，[1，2]，[2，3]]</code>。则提取 <code>h</code> 为 <code>[5，4，2，3]</code>。我们对 <code>h</code> 进行 LIS 算法将得到 <code>[2，3]</code>，是正确的答案。</p><details>    <summary>动态规划解法Python</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from bisect import bisect_left</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def maxEnvelopes(self, arr: List[List[int]]) -&gt; int:</span><br><span class="line">        # sort increasing in first dimension and decreasing on second</span><br><span class="line">        arr.sort(key=lambda x: (x[0], -x[1]))</span><br><span class="line"></span><br><span class="line">        def lis(nums):</span><br><span class="line">            dp = []</span><br><span class="line">            for i in range(len(nums)):</span><br><span class="line">                idx = bisect_left(dp, nums[i])</span><br><span class="line">                if idx == len(dp):</span><br><span class="line">                    dp.append(nums[i])</span><br><span class="line">                else:</span><br><span class="line">                    dp[idx] = nums[i]</span><br><span class="line">            return len(dp)</span><br><span class="line">        # extract the second dimension and run the LIS</span><br><span class="line">        return lis([i[1] for i in arr])</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划解法Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        int len = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">        //如果没有找到关键字，返回值为负的插入点值</span><br><span class="line">        //所谓插入点值就是第一个比关键字大的元素在数组中的位置索引，而且这个位置索引从1开始。</span><br><span class="line">            int i = Arrays.binarySearch(dp, 0, len, num);</span><br><span class="line">            if (i &lt; 0) &#123;</span><br><span class="line">                i = -(i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = num;</span><br><span class="line">            if (i == len) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int maxEnvelopes(int[][] envelopes) &#123;</span><br><span class="line">        // sort on increasing in first dimension and decreasing in second</span><br><span class="line">        Arrays.sort(envelopes, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">            public int compare(int[] arr1, int[] arr2) &#123;</span><br><span class="line">                if (arr1[0] == arr2[0]) &#123;</span><br><span class="line">                    return arr2[1] - arr1[1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return arr1[0] - arr2[0];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // extract the second dimension and run LIS</span><br><span class="line">        int[] secondDim = new int[envelopes.length];</span><br><span class="line">        for (int i = 0; i &lt; envelopes.length; ++i) secondDim[i] = envelopes[i][1];</span><br><span class="line">        return lengthOfLIS(secondDim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="使用STL函数lower-bound的二分查找法"><a href="#使用STL函数lower-bound的二分查找法" class="headerlink" title="使用STL函数lower_bound的二分查找法"></a>使用STL函数lower_bound的二分查找法</h1><details>    <summary>二分查找法</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123;</span><br><span class="line">        vector&lt;int&gt; dp;</span><br><span class="line">        sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,cosnt pair&lt;int,int&gt; &amp;b)&#123;</span><br><span class="line">           if(a.first==b.first) return a.second&gt;b.second;</span><br><span class="line">            return a.first&lt;b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        for(int i=0;i&lt;envelopes.size();i++)&#123;</span><br><span class="line">            auto it=lower_bound(dp.begin(),dp.end(),enveloeps[i].second);</span><br><span class="line">            if(it==dp.end()) dp.push_back(envelopes[i].second);</span><br><span class="line">            else *it=envelopes[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。&lt;/p&gt;
&lt;p&gt;请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>120. 三角形最小路径和</title>
    <link href="http://yoursite.com/2020/11/24/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yoursite.com/2020/11/24/120. 三角形最小路径和/</id>
    <published>2020-11-24T08:25:12.000Z</published>
    <updated>2020-11-24T11:38:41.168Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><a id="more"></a><p>例如，给定三角形：</p><pre><code>[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]</code></pre><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>说明：</p><pre><code>如果你可以只使用 O(n) 的额外空间（n为三角形的总行数）来解决这个问题，那么你的算法会很加分。</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本题是一道非常经典且历史悠久的动态规划题，其作为算法题出现，最早可以追溯到 1994 年的 IOI（国际信息学奥林匹克竞赛）的 <a href="https://ioinformatics.org/files/ioi1994problem1.pdf" target="_blank" rel="noopener">The Triangle</a>。时光飞逝，经过 20 多年的沉淀，往日的国际竞赛题如今已经变成了动态规划的入门必做题，不断督促着我们学习和巩固算法。</p><p>在本题中，给定的三角形的行数为 <em>n</em>，并且第 <em>i</em> 行（从 <em>0</em> 开始编号）包含了 <em>i+1</em> 个数。如果将每一行的左端对齐，那么会形成一个等腰直角三角形，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2]</span><br><span class="line">[3,4]</span><br><span class="line">[6,5,7]</span><br><span class="line">[4,1,8,3]</span><br></pre></td></tr></table></figure><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p><strong>思路与算法</strong></p><p>我们用 <em>f[i][j]</em> 表示从三角形顶部走到位置 <em>(i, j)</em> 的最小路径和。这里的位置 <em>(i, j)</em> 指的是三角形中第 <em>i</em> 行第 <em>j</em> 列（均从 <em>0</em> 开始编号）的位置。</p><p>由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 <em>(i, j)*，上一步就只能在位置 *(i - 1, j - 1)</em> 或者位置 <em>(i - 1, j)</em>。我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：</p><pre><code>f[i][j]=min(f[i-1][j-1],f[i-1][j])+c[i][j]</code></pre><p>其中 <em>c[i][j]</em> 表示位置 <em>(i, j)</em> 对应的元素值。</p><p>注意第 <em>i</em> 行有 <em>i+1</em> 个元素，它们对应的 <em>j</em> 的范围为 <em>[0, i]*。当 *j=0</em> 或 <em>j=i</em> 时，上述状态转移方程中有一些项是没有意义的。例如当 <em>j=0</em> 时，<em>f[i-1][j-1]</em> 没有意义，因此状态转移方程为：</p><p><em>f[i][0] = f[i-1][0] + c[i][0]</em></p><p>即当我们在第 <em>i</em> 行的最左侧时，我们只能从第 <em>i-1</em> 行的最左侧移动过来。当 <em>j=i</em> 时，<em>f[i-1][j]</em> 没有意义，因此状态转移方程为：</p><p><em>f[i][i] = f[i-1][i-1] + c[i][i]</em></p><p>即当我们在第 <em>i</em> 行的最右侧时，我们只能从第 <em>i-1</em> 行的最右侧移动过来。</p><p>最终的答案即为 <em>f[n-1][0]</em> 到 <em>f[n-1][n-1]</em> 中的最小值，其中 <em>n</em> 是三角形的行数。</p><p><strong>细节</strong></p><p>状态转移方程的边界条件是什么？由于我们已经去除了所有「没有意义」的状态，因此边界条件可以定为：</p><p><em>f[0][0] = c[0][0]</em></p><p>即在三角形的顶部时，最小路径和就等于对应位置的元素值。这样一来，我们从 <em>1</em> 开始递增地枚举 <em>i</em>，并在 <em>[0, i]</em> 的范围内递增地枚举 <em>j</em>，就可以完成所有状态的计算。</p><details>    <summary>动态规划C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *min_element(f[n - <span class="number">1</span>].begin(), f[n - <span class="number">1</span>].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[i][j] = Math.min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minTotal = f[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minTotal = Math.min(minTotal, f[n - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Python</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        f = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j]</span><br><span class="line">            f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min(f[n - <span class="number">1</span>])</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumTotal</span><span class="params">(triangle [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(triangle)</span><br><span class="line">    f := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        f[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = min(ans, f[n<span class="number">-1</span>][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>** triangle, <span class="keyword">int</span> triangleSize, <span class="keyword">int</span>* triangleColSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[triangleSize][triangleSize];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[i][j] = fmin(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = f[triangleSize - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; i++)</span><br><span class="line">        ret = fmin(ret, f[triangleSize - <span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是三角形的行数。</p></li><li><p>空间复杂度：<em>O(n^2)<em>。我们需要一个 *n</em>n</em> 的二维数组存放所有的状态。</p></li></ul><h2 id="方法二：动态规划-空间优化"><a href="#方法二：动态规划-空间优化" class="headerlink" title="方法二：动态规划 + 空间优化"></a>方法二：动态规划 + 空间优化</h2><p><strong>思路与算法</strong></p><p>在题目描述中的「说明」部分，提到了可以将空间复杂度优化至 <em>O(n)</em>。</p><p>我们回顾方法一中的状态转移方程：</p><pre><code>f[i][j]=f[i-1][0]+c[i][0]   j=0f[i][j]=f[i-1][i-1]+c[i][j]   j=if[i][j]=min(f[i-1][j-1],f[i-1][j])+c[i][j] otherwise</code></pre><p>可以发现，<em>f[i][j]</em> 只与 <em>f[i-1][..]</em> 有关，而与 <em>f[i-2][..]</em> 及之前的状态无关，因此我们不必存储这些无关的状态。具体地，我们使用两个长度为 <em>n</em> 的一维数组进行转移，将 <em>i</em> 根据奇偶性映射到其中一个一维数组，那么 <em>i-1</em> 就映射到了另一个一维数组。这样我们使用这两个一维数组，交替地进行状态转移。</p><details>    <summary>动态规划 + 空间优化C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> prev = <span class="number">1</span> - curr;</span><br><span class="line">            f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[curr][j] = min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *min_element(f[(n - <span class="number">1</span>) % <span class="number">2</span>].begin(), f[(n - <span class="number">1</span>) % <span class="number">2</span>].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> prev = <span class="number">1</span> - curr;</span><br><span class="line">            f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                f[curr][j] = Math.min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minTotal = f[(n - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minTotal = Math.min(minTotal, f[(n - <span class="number">1</span>) % <span class="number">2</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化Python</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        f = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            curr, prev = i % <span class="number">2</span>, <span class="number">1</span> - i % <span class="number">2</span></span><br><span class="line">            f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                f[curr][j] = min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle[i][j]</span><br><span class="line">            f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min(f[(n - <span class="number">1</span>) % <span class="number">2</span>])</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumTotal</span><span class="params">(triangle [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(triangle)</span><br><span class="line">    f := [<span class="number">2</span>][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        f[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        curr := i % <span class="number">2</span></span><br><span class="line">        prev := <span class="number">1</span> - curr</span><br><span class="line">        f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            f[curr][j] = min(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">        f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = min(ans, f[(n<span class="number">-1</span>)%<span class="number">2</span>][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>** triangle, <span class="keyword">int</span> triangleSize, <span class="keyword">int</span>* triangleColSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">2</span>][triangleSize];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> curr = i % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">1</span> - curr;</span><br><span class="line">        f[curr][<span class="number">0</span>] = f[prev][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            f[curr][j] = fmin(f[prev][j - <span class="number">1</span>], f[prev][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[curr][i] = f[prev][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = f[(triangleSize - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; i++)</span><br><span class="line">        ret = fmin(ret, f[(triangleSize - <span class="number">1</span>) % <span class="number">2</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>上述方法的空间复杂度为 <em>O(n)*，使用了 *2n</em> 的空间存储状态。我们还可以继续进行优化吗？</p><p>答案是可以的。我们从 <em>i</em> 到 <em>0</em> 递减地枚举 <em>j</em>，这样我们只需要一个长度为 <em>n</em> 的一维数组 <em>f</em>，就可以完成状态转移。</p><blockquote><p>为什么只有在递减地枚举 <em>j</em> 时，才能省去一个一维数组？当我们在计算位置 <em>(i, j)</em> 时，<em>f[j+1]</em> 到 <em>f[i]</em> 已经是第 <em>i</em> 行的值，而 <em>f[0]</em> 到 <em>f[j]</em> 仍然是第 <em>i-1</em> 行的值。此时我们直接通过</p></blockquote><pre><code>f[j]=min(f[j-1],f[j])+c[i][j]</code></pre><blockquote><p>进行转移，恰好就是在 <em>(i-1, j-1)</em> 和 <em>(i-1, j)</em> 中进行选择。但如果我们递增地枚举 <em>j</em>，那么在计算位置 <em>(i, j)</em> 时，<em>f[0]</em> 到 <em>f[j-1]</em> 已经是第 <em>i</em> 行的值。如果我们仍然使用上述状态转移方程，那么是在 <em>(i, j-1)</em> 和 <em>(i-1, j)</em> 中进行选择，就产生了错误。</p></blockquote><p>这样虽然空间复杂度仍然为 <em>O(n)*，但我们只使用了 *n</em> 的空间存储状态，减少了一半的空间消耗。</p><details>    <summary>动态规划 + 空间优化C++</summary><figure class="highlight c++"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n);</span><br><span class="line">        f[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                f[j] = min(f[j - <span class="number">1</span>], f[j]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[<span class="number">0</span>] += triangle[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *min_element(f.begin(), f.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        f[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                f[j] = Math.min(f[j - <span class="number">1</span>], f[j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            f[<span class="number">0</span>] += triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minTotal = f[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            minTotal = Math.min(minTotal, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化Python</summary><figure class="highlight python"><figcaption><span>[sol3-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        f = [<span class="number">0</span>] * n</span><br><span class="line">        f[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                f[j] = min(f[j - <span class="number">1</span>], f[j]) + triangle[i][j]</span><br><span class="line">            f[<span class="number">0</span>] += triangle[i][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min(f)</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化Golang</summary><figure class="highlight golang"><figcaption><span>[sol3-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumTotal</span><span class="params">(triangle [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(triangle)</span><br><span class="line">    f := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    f[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">        <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line">            f[j] = min(f[j - <span class="number">1</span>], f[j]) + triangle[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>] += triangle[i][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = min(ans, f[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划 + 空间优化C</summary><figure class="highlight c"><figcaption><span>[sol3-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>** triangle, <span class="keyword">int</span> triangleSize, <span class="keyword">int</span>* triangleColSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[triangleSize];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; ++i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            f[j] = fmin(f[j - <span class="number">1</span>], f[j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>] += triangle[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = f[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangleSize; i++) ret = fmin(ret, f[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n^2)*，其中 *n</em> 是三角形的行数。</p></li><li><p>空间复杂度：<em>O(n)</em>。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本题还有一些其它的动态规划方法，例如：</p><ul><li><p>从三角形的底部开始转移，到顶部结束；</p></li><li><p>直接在给定的三角形数组上进行状态转移，不使用额外的空间。</p></li></ul><p>读者可以自行尝试。如果在面试中遇到类似的题目，需要和面试官进行沟通，可以询问「是否有空间复杂度限制」「是否可以修改原数组」等问题，给出符合条件的算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;
&lt;p&gt;相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>1277. 统计全为 1 的正方形子矩阵</title>
    <link href="http://yoursite.com/2020/11/24/1277.%20%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/11/24/1277. 统计全为 1 的正方形子矩阵/</id>
    <published>2020-11-24T06:07:12.000Z</published>
    <updated>2020-11-24T07:13:34.856Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：matrix =[  [0,1,1,1],  [1,1,1,1],  [0,1,1,1]]输出：15解释： 边长为 1 的正方形有 10 个。边长为 2 的正方形有 4 个。边长为 3 的正方形有 1 个。正方形的总数 = 10 + 4 + 1 = 15.</code></pre><p>示例 2：</p><pre><code>输入：matrix = [  [1,0,1],  [1,1,0],  [1,1,0]]输出：7解释：边长为 1 的正方形有 6 个。 边长为 2 的正方形有 1 个。正方形的总数 = 6 + 1 = 7.</code></pre><p>提示：</p><pre><code>1 &lt;= arr.length &lt;= 3001 &lt;= arr[0].length &lt;= 3000 &lt;= arr[i][j] &lt;= 1</code></pre><h1 id="方法一：递推"><a href="#方法一：递推" class="headerlink" title="方法一：递推"></a>方法一：递推</h1><p>本题和 <a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a> 非常类似，使用的方法也几乎相同。</p><p>我们用 <code>f[i][j]</code> 表示以 <code>(i, j)</code> 为右下角的正方形的最大边长，那么除此定义之外，<code>f[i][j] = x</code> 也表示以 <code>(i, j)</code> 为右下角的正方形的数目为 <code>x</code>（即边长为 <code>1, 2, ..., x</code> 的正方形各一个）。在计算出所有的 <code>f[i][j]</code> 后，我们将它们进行累加，就可以得到矩阵中正方形的数目。</p><p>我们尝试挖掘 <code>f[i][j]</code> 与相邻位置的关系来计算出 <code>f[i][j]</code> 的值。</p><p><a href="https://pic.leetcode-cn.com/14aa58be2ea5c9b36a722db76d2e843c4c909e312223a8461a3d2d93bc734b42-1277-1.png" target="_blank" rel="noopener">1277-1.png</a></p><p>如上图所示，若对于位置 <code>(i, j)</code> 有 <code>f[i][j] = 4</code>，我们将以 <code>(i, j)</code> 为右下角、边长为 <code>4</code> 的正方形涂上色，可以发现其左侧位置 <code>(i, j - 1)</code>，上方位置 <code>(i - 1, j)</code> 和左上位置 <code>(i - 1, j - 1)</code> 均可以作为一个边长为 <code>4 - 1 = 3</code> 的正方形的右下角。也就是说，这些位置的的 <code>f</code> 值至少为 <code>3</code>，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i][j - 1] &gt;= f[i][j] - 1</span><br><span class="line">f[i - 1][j] &gt;= f[i][j] - 1</span><br><span class="line">f[i - 1][j - 1] &gt;= f[i][j] - 1</span><br></pre></td></tr></table></figure><p>将这三个不等式联立，可以得到：</p><pre><code>min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1])&gt;=f[i][j] - 1</code></pre><p>这是我们通过固定 <code>f[i][j]</code> 的值，判断其相邻位置与之的关系得到的不等式。同理，我们也可以固定 <code>f[i][j]</code> 相邻位置的值，得到另外的限制条件。</p><p><a href="https://pic.leetcode-cn.com/dfcaa5390732f1b9d1d9c71f696957cbc91904c52e23705a061bae727228126d-1277-2.png" target="_blank" rel="noopener">1277-2.png</a></p><p>如上图所示，假设 <code>f[i][j - 1]</code>，<code>f[i - 1][j]</code> 和 <code>f[i - 1][j - 1]</code> 中的最小值为 <code>3</code>，也就是说，<code>(i, j - 1)</code>，<code>(i - 1, j)</code> 和 <code>(i - 1, j - 1)</code> 均可以作为一个边长为 <code>3</code> 的正方形的右下角。我们将这些边长为 <code>3</code> 的正方形依次涂上色，可以发现，如果位置 <code>(i, j)</code> 的元素为 <code>1</code>，那么它可以作为一个边长为 <code>4</code> 的正方形的右下角，<code>f</code> 值至少为 <code>4</code>，即：</p><pre><code>f[i][j] &gt;=min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1]) + 1</code></pre><p>将其与上一个不等式联立，可以得到：</p><pre><code>f[i][j] &gt;=min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1]) + 1</code></pre><p>这样我们就得到了 <code>f[i][j]</code> 的递推式。此外还要考虑边界（<code>i = 0</code> 或 <code>j = 0</code>）以及位置 <code>(i, j)</code> 的元素为 <code>0</code> 的情况，可以得到如下完整的递推式：<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/" target="_blank" rel="noopener">^1</a></p><p>我们按照行优先的顺序依次计算 <code>f[i][j]</code> 的值，就可以得到最终的答案。</p><details>    <summary>递推C++</summary><figure class="highlight c++"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = min(min(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]), f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>递推Python</summary><figure class="highlight python"><figcaption><span>[sol1]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        f = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    f[i][j] = matrix[i][j]</span><br><span class="line">                <span class="keyword">elif</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    f[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = min(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                ans += f[i][j]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></details><details>    <summary>递推Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSquares(int[][] matrix) &#123;</span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int row = matrix.length;</span><br><span class="line">        int col = matrix[0].length;</span><br><span class="line">        int[][] dp = new int[row][col];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">                if (i == 0 || j == 0) &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j];</span><br><span class="line">                &#125; else if (matrix[i][j] == 0) &#123;</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(MN)</em>。</p></li><li><p>空间复杂度：<em>O(MN)</em>。由于递推式中 <code>f[i][j]</code> 只与本行和上一行的若干个值有关，因此空间复杂度可以优化至 <em>O(N)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>53. 最大子序和</title>
    <link href="http://yoursite.com/2020/11/24/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://yoursite.com/2020/11/24/53. 最大子序和/</id>
    <published>2020-11-24T05:41:12.000Z</published>
    <updated>2020-11-24T08:24:14.942Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><a id="more"></a><p>示例:</p><pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="f9898f56-4701-4510-b8d4-60e24e129a8f">LeetCode 53.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p><strong>思路和算法</strong></p><p>假设 <code>nums</code> 数组的长度是 <em>n</em>，下标从 <em>0</em> 到 <em>n - 1</em>。</p><p>我们用 <em>a_i</em> 代表 <code>nums[i]</code>，用 <em>f(i)</em> 代表以第 <em>i</em> 个数结尾的「连续子数组的最大和」:</p><p>因此我们只需要求出每个位置的 <em>f(i)*，然后返回 <code>f</code> 数组中的最大值即可。那么我们如何求 *f(i)</em> 呢？我们可以考虑 <em>a_i</em> 单独成为一段还是加入 <em>f(i - 1)</em> 对应的那一段，这取决于 <em>a_i</em> 和 <em>f(i - 1) + a_i</em> 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：</p><pre><code>f(i)=max{f(i-1)+ai,ai}</code></pre><p>不难给出一个时间复杂度 <em>O(n)*、空间复杂度 *O(n)</em> 的实现，即用一个 <code>f</code> 数组来保存 <em>f(i)</em> 的值，用一个循环求出所有 <em>f(i)*。考虑到 *f(i)</em> 只和 <em>f(i - 1)</em> 相关，于是我们可以只用一个变量 <code>pre</code> 来维护对于当前 <em>f(i)</em> 的 <em>f(i - 1)</em> 的值是多少，从而让空间复杂度降低到 <em>O(1)</em>，这有点类似「滚动数组」的思想。</p><p><strong>代码</strong></p><details>    <summary>动态规划cpp</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x: nums) &#123;</span><br><span class="line">            pre = max(pre + x, x);</span><br><span class="line">            maxAns = max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C#</summary><figure class="highlight csharp"><figcaption><span>[sol1-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubArray</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> x <span class="keyword">in</span> nums) &#123;</span><br><span class="line">            pre = Math.Max(pre + x, x);</span><br><span class="line">            maxAns = Math.Max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">    nums.forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">        pre = <span class="built_in">Math</span>.max(pre + x, x);</span><br><span class="line">        maxAns = <span class="built_in">Math</span>.max(maxAns, pre);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> maxAns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[i<span class="number">-1</span>] &gt; nums[i] &#123;</span><br><span class="line">            nums[i] += nums[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; max &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度</strong></p><ul><li>时间复杂度：<em>O(n)*，其中 *n</em> 为 <code>nums</code> 数组的长度。我们只需要遍历一遍数组即可求得答案。</li><li>空间复杂度：<em>O(1)</em>。我们只需要常数空间存放若干变量。</li></ul><h2 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h2><p><strong>思路和算法</strong></p><p><strong>这个分治方法类似于「线段树求解 LCIS 问题」的 <code>pushUp</code> 操作。</strong> 也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐看一看线段树区间合并法解决 <strong>多次询问</strong> 的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。</p><p>我们定义一个操作 <code>get(a, l, r)</code> 表示查询 <em>a</em> 序列 <em>[l, r]</em> 区间内的最大子段和，那么最终我们要求的答案就是 <code>get(nums, 0, nums.size() - 1)</code>。如何分治实现这个操作呢？对于一个区间 <em>[l, r]*，我们取 <img src="./p__m_=_lfloor_frac%7Bl_+_r%7D%7B2%7D_rfloor_.png" alt="m=\lfloor\frac{l+r}{2}\rfloor "> ，对区间 *[l, m]</em> 和 <em>[m + 1, r]</em> 分治求解。当递归逐层深入直到区间长度缩小为 <em>1</em> 的时候，递归「开始回升」。这个时候我们考虑如何通过 <em>[l, m]</em> 区间的信息和 <em>[m + 1, r]</em> 区间的信息合并成区间 <em>[l, r]</em> 的信息。最关键的两个问题是：</p><ul><li>我们要维护区间的哪些信息呢？</li><li>我们如何合并这些信息呢？</li></ul><p>对于一个区间 *[l, r]*，我们可以维护四个量：</p><ul><li><code>lSum</code> 表示 <em>[l, r]</em> 内以 <em>l</em> 为左端点的最大子段和</li><li><code>rSum</code> 表示 <em>[l, r]</em> 内以 <em>r</em> 为右端点的最大子段和</li><li><code>mSum</code> 表示 <em>[l, r]</em> 内的最大子段和</li><li><code>iSum</code> 表示 <em>[l, r]</em> 的区间和</li></ul><p>以下简称 <em>[l, m]</em> 为 <em>[l, r]</em> 的「左子区间」，<em>[m + 1, r]</em> 为 <em>[l, r]</em> 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 <em>[l, r]</em> 的信息）？对于长度为 <em>1</em> 的区间 <em>[i, i]*，四个量的值都和 *a_i</em> 相等。对于长度大于 <em>1</em> 的区间：</p><ul><li>首先最好维护的是 <code>iSum</code>，区间 <em>[l, r]</em> 的 <code>iSum</code> 就等于「左子区间」的 <code>iSum</code> 加上「右子区间」的 <code>iSum</code>。</li><li>对于 <em>[l, r]</em> 的 <code>lSum</code>，存在两种可能，它要么等于「左子区间」的 <code>lSum</code>，要么等于「左子区间」的 <code>iSum</code> 加上「右子区间」的 <code>lSum</code>，二者取大。</li><li>对于 <em>[l, r]</em> 的 <code>rSum</code>，同理，它要么等于「右子区间」的 <code>rSum</code>，要么等于「右子区间」的 <code>iSum</code> 加上「左子区间」的 <code>rSum</code>，二者取大。</li><li>当计算好上面的三个量之后，就很好计算 <em>[l, r]</em> 的 <code>mSum</code> 了。我们可以考虑 <em>[l, r]</em> 的 <code>mSum</code> 对应的区间是否跨越 <em>m</em>——它可能不跨越 <em>m</em>，也就是说 <em>[l, r]</em> 的 <code>mSum</code> 可能是「左子区间」的 <code>mSum</code> 和 「右子区间」的 <code>mSum</code> 中的一个；它也可能跨越 <em>m</em>，可能是「左子区间」的 <code>rSum</code> 和 「右子区间」的 <code>lSum</code> 求和。三者取大。</li></ul><p>这样问题就得到了解决。</p><p><strong>代码</strong></p><details>    <summary>分治cpp</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">        <span class="keyword">int</span> lSum = max(l.lSum, l.iSum + r.lSum);</span><br><span class="line">        <span class="keyword">int</span> rSum = max(r.rSum, r.iSum + l.rSum);</span><br><span class="line">        <span class="keyword">int</span> mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">        <span class="keyword">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Status) &#123;a[l], a[l], a[l], a[l]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Status lSub = get(a, l, m);</span><br><span class="line">        Status rSub = get(a, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治C#</summary><figure class="highlight csharp"><figcaption><span>[sol2-C#]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Status</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Status</span>(<span class="params"><span class="keyword">int</span> lSum_, <span class="keyword">int</span> rSum_, <span class="keyword">int</span> mSum_, <span class="keyword">int</span> iSum_</span>) </span>&#123;</span><br><span class="line">            lSum = lSum_; rSum = rSum_; mSum = mSum_; iSum = iSum_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">pushUp</span>(<span class="params">Status l, Status r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">        <span class="keyword">int</span> lSum = Math.Max(l.lSum, l.iSum + r.lSum);</span><br><span class="line">        <span class="keyword">int</span> rSum = Math.Max(r.rSum, r.iSum + l.rSum);</span><br><span class="line">        <span class="keyword">int</span> mSum = Math.Max(Math.Max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Status(lSum, rSum, mSum, iSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">getInfo</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Status(a[l], a[l], a[l], a[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Status lSub = getInfo(a, l, m);</span><br><span class="line">        Status rSub = getInfo(a, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubArray</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInfo(nums, <span class="number">0</span>, nums.Length - <span class="number">1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Status</span><span class="params">(<span class="keyword">int</span> lSum, <span class="keyword">int</span> rSum, <span class="keyword">int</span> mSum, <span class="keyword">int</span> iSum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lSum = lSum;</span><br><span class="line">            <span class="keyword">this</span>.rSum = rSum;</span><br><span class="line">            <span class="keyword">this</span>.mSum = mSum;</span><br><span class="line">            <span class="keyword">this</span>.iSum = iSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInfo(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">getInfo</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Status(a[l], a[l], a[l], a[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Status lSub = getInfo(a, l, m);</span><br><span class="line">        Status rSub = getInfo(a, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">        <span class="keyword">int</span> lSum = Math.max(l.lSum, l.iSum + r.lSum);</span><br><span class="line">        <span class="keyword">int</span> rSum = Math.max(r.rSum, r.iSum + l.rSum);</span><br><span class="line">        <span class="keyword">int</span> mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Status(lSum, rSum, mSum, iSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Status</span>(<span class="params">l, r, m, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lSum = l;</span><br><span class="line">    <span class="keyword">this</span>.rSum = r;</span><br><span class="line">    <span class="keyword">this</span>.mSum = m;</span><br><span class="line">    <span class="keyword">this</span>.iSum = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pushUp = <span class="function">(<span class="params">l, r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iSum = l.iSum + r.iSum;</span><br><span class="line">    <span class="keyword">const</span> lSum = <span class="built_in">Math</span>.max(l.lSum, l.iSum + r.lSum);</span><br><span class="line">    <span class="keyword">const</span> rSum = <span class="built_in">Math</span>.max(r.rSum, r.iSum + l.rSum);</span><br><span class="line">    <span class="keyword">const</span> mSum = <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Status(lSum, rSum, mSum, iSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getInfo = <span class="function">(<span class="params">a, l, r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l === r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Status(a[l], a[l], a[l], a[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> lSub = getInfo(a, l, m);</span><br><span class="line">    <span class="keyword">const</span> rSub = getInfo(a, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getInfo(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>).mSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>).mSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pushUp</span><span class="params">(l, r Status)</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    iSum := l.iSum + r.iSum</span><br><span class="line">    lSum := max(l.lSum, l.iSum + r.lSum)</span><br><span class="line">    rSum := max(r.rSum, r.iSum + l.rSum)</span><br><span class="line">    mSum := max(max(l.mSum, r.mSum), l.rSum + r.lSum)</span><br><span class="line">    <span class="keyword">return</span> Status&#123;lSum, rSum, mSum, iSum&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(nums []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status&#123;nums[l], nums[l], nums[l], nums[l]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m := (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">    lSub := get(nums, l, m)</span><br><span class="line">    rSub := get(nums, m + <span class="number">1</span>, r)</span><br><span class="line">    <span class="keyword">return</span> pushUp(lSub, rSub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">    lSum, rSum, mSum, iSum <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>假设序列 <em>a</em> 的长度为 <em>n</em>。</p><ul><li>时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为  O(logn) ，这里的总时间相当于遍历这颗二叉树的所有节点，故渐进时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：递归会使用 O(logn) 的栈空间，故渐进空间复杂度为  O(logn) 。</li></ul><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p><p>对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间 <em>[0, n - 1]*，还可以用于解决任意的子区间 *[l, r]</em> 的问题。如果我们把 <em>[0, n - 1]</em> 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在  O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>221.最大正方形</title>
    <link href="http://yoursite.com/2020/11/23/221.%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>http://yoursite.com/2020/11/23/221.最大正方形/</id>
    <published>2020-11-23T13:07:12.000Z</published>
    <updated>2020-11-24T07:38:14.408Z</updated>
    
    <content type="html"><![CDATA[<p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><a id="more"></a><p>示例：</p><pre><code>输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],          [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],          [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],          [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="3cb7322a-5285-49a0-b0e6-539a84fa8dd5">221. 最大正方形.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h2><p>由于正方形的面积等于边长的平方，因此要找到最大正方形的面积，首先需要找到最大正方形的边长，然后计算最大边长的平方即可。</p><p>暴力法是最简单直观的做法，具体做法如下：</p><ul><li><p>遍历矩阵中的每个元素，每次遇到 <em>1</em>，则将该元素作为正方形的左上角；</p></li><li><p>确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 <em>1</em> 的最大正方形；</p></li><li><p>每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 <em>1</em>。</p><details>  <summary>暴力法Java</summary></details></li></ul><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = Math.max(maxSide, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = Math.min(rows - i, columns - j);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123;</span><br><span class="line">                        <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">'0'</span> || matrix[i + m][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                            maxSide = Math.max(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details>    <summary>暴力法C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = max(maxSide, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = min(rows - i, columns - j);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123;</span><br><span class="line">                        <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">'0'</span> || matrix[i + m][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                            maxSide = max(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        maxSide = <span class="number">0</span></span><br><span class="line">        rows, columns = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(columns):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    <span class="comment"># 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = max(maxSide, <span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 计算可能的最大正方形边长</span></span><br><span class="line">                    currentMaxSide = min(rows - i, columns - j)</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, currentMaxSide):</span><br><span class="line">                        <span class="comment"># 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        flag = <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">if</span> matrix[i + k][j + k] == <span class="string">'0'</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">for</span> m <span class="keyword">in</span> range(k):</span><br><span class="line">                            <span class="keyword">if</span> matrix[i + k][j + m] == <span class="string">'0'</span> <span class="keyword">or</span> matrix[i + m][j + k] == <span class="string">'0'</span>:</span><br><span class="line">                                flag = <span class="keyword">False</span></span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> flag:</span><br><span class="line">                            maxSide = max(maxSide, k + <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        maxSquare = maxSide * maxSide</span><br><span class="line">        <span class="keyword">return</span> maxSquare</span><br></pre></td></tr></table></figure></details><details>    <summary>暴力法Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare</span><span class="params">(matrix [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxSide := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxSide</span><br><span class="line">    &#125;</span><br><span class="line">    rows, columns := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; columns; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">                maxSide = max(maxSide, <span class="number">1</span>)</span><br><span class="line">                curMaxSide := min(rows - i, columns - j)</span><br><span class="line">                <span class="keyword">for</span> k := <span class="number">1</span>; k &lt; curMaxSide; k++ &#123;</span><br><span class="line">                    flag := <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">if</span> matrix[i+k][j+k] == <span class="string">'0'</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> m := <span class="number">0</span>; m &lt; k; m++ &#123;</span><br><span class="line">                        <span class="keyword">if</span> matrix[i+k][j+m] == <span class="string">'0'</span> || matrix[i+m][j+k] == <span class="string">'0'</span> &#123;</span><br><span class="line">                            flag = <span class="literal">false</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> flag &#123;</span><br><span class="line">                        maxSide = max(maxSide, k + <span class="number">1</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(mnmin(m,n)^2) ，其中 <em>m</em> 和 <em>n</em> 是矩阵的行数和列数。</p><ul><li>需要遍历整个矩阵寻找每个 <em>1</em>，遍历矩阵的时间复杂度是 <em>O(mn)</em>。</li><li>对于每个可能的正方形，其边长不超过 <em>m</em> 和 <em>n</em> 中的最小值，需要遍历该正方形中的每个元素判断是不是只包含 <em>1</em>，遍历正方形时间复杂度是O(mnmin(m,n)^2) 。</li><li>总时间复杂度是O(mnmin(m,n)^2) 。</li></ul></li><li><p>空间复杂度：<em>O(1)</em>。额外使用的空间复杂度为常数。</p></li></ul><h2 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h2><p>方法一虽然直观，但是时间复杂度太高，有没有办法降低时间复杂度呢？</p><p>可以使用动态规划降低时间复杂度。我们用 <em>dp(i, j)</em> 表示以 <em>(i, j)</em> 为右下角，且只包含 <em>1</em> 的正方形的边长最大值。如果我们能计算出所有 <em>dp(i, j)</em> 的值，那么其中的最大值即为矩阵中只包含 <em>1</em> 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>一开始想到的思路是用相同大小的dp矩阵记录以当前坐标为右下角的最大正方形边长</p><p>但遇到了这个测试用例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     [[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;],</span><br><span class="line">      [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],</span><br><span class="line">      [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">      [&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">      [&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]]</span><br><span class="line">      测试结果:4</span><br><span class="line">期望结果:9</span><br></pre></td></tr></table></figure><p>那么如何计算 <em>dp</em> 中的每个元素值呢？对于每个位置 <em>(i, j)</em>，检查在矩阵中该位置的值：</p><ul><li><p>如果该位置的值是 <em>0</em>，则 <em>dp(i, j) = 0*，因为当前位置不可能在由 *1</em> 组成的正方形中；</p></li><li><p>如果该位置的值是 <em>1</em>，则 <em>dp(i, j)</em> 的值由其上方、左方和左上方的三个相邻位置的 <em>dp</em> 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 <em>1</em>，状态转移方程如下：</p><p><em>dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1</em></p><p>如果读者对这个状态转移方程感到不解，可以参考 <a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/" target="_blank" rel="noopener">1277. 统计全为 1 的正方形子矩阵的官方题解</a>，其中给出了详细的证明。</p><p>此外，还需要考虑边界条件。如果 <em>i</em> 和 <em>j</em> 中至少有一个为 <em>0</em>，则以位置 <em>(i, j)</em> 为右下角的最大正方形的边长只能是 <em>1</em>，因此 <em>dp(i, j) = 1</em>。</p></li></ul><p>以下用一个例子具体说明。原始矩阵如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">1 1 1 1 0</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 1 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure><p>对应的 <em>dp</em> 值如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">1 1 2 2 0</span><br><span class="line">0 1 2 3 1</span><br><span class="line">0 1 2 3 2</span><br><span class="line">0 0 1 2 3</span><br></pre></td></tr></table></figure><p>下图也给出了计算 <em>dp</em> 值的过程。</p><p><a href="https://assets.leetcode-cn.com/solution-static/221/221_fig1.png" target="_blank" rel="noopener">fig1</a></p><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxSide;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = min(min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Python3</summary><figure class="highlight python"><figcaption><span>[sol2-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        maxSide = <span class="number">0</span></span><br><span class="line">        rows, columns = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * columns <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(columns):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    maxSide = max(maxSide, dp[i][j])</span><br><span class="line">        </span><br><span class="line">        maxSquare = maxSide * maxSide</span><br><span class="line">        <span class="keyword">return</span> maxSquare</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare</span><span class="params">(matrix [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(matrix))</span><br><span class="line">    maxSide := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(matrix); i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(matrix[i]))</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(matrix[i]); j++ &#123;</span><br><span class="line">            dp[i][j] = <span class="keyword">int</span>(matrix[i][j] - <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                maxSide = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(matrix); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(matrix[i]); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                dp[i][j] = min(min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]), dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] &gt; maxSide &#123;</span><br><span class="line">                    maxSide = dp[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(mn)*，其中 *m</em> 和 <em>n</em> 是矩阵的行数和列数。需要遍历原始矩阵中的每个元素计算 <code>dp</code> 的值。</p></li><li><p>空间复杂度：<em>O(mn)*，其中 *m</em> 和 <em>n</em> 是矩阵的行数和列数。创建了一个和原始矩阵大小相同的矩阵 <code>dp</code>。由于状态转移方程中的 <em>dp(i, j)</em> 由其上方、左方和左上方的三个相邻位置的 <em>dp</em> 值决定，因此可以使用两个一维数组进行状态转移，空间复杂度优化至 <em>O(n)</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>122.买卖股票的最佳时机II</title>
    <link href="http://yoursite.com/2020/11/23/122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>http://yoursite.com/2020/11/23/122.买卖股票的最佳时机II/</id>
    <published>2020-11-23T11:07:12.000Z</published>
    <updated>2020-11-23T13:01:42.421Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</code></pre><p>示例 2:</p><pre><code>输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre><p>示例 3:</p><pre><code>输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p>提示：</p><pre><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 40 &lt;= prices[i] &lt;= 10 ^ 4</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="140e709c-24c5-4837-978f-d827bf56703e">122. 买卖股票的最佳时机II.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p><p>定义状态 dp[i][0] 表示第 <em>i</em> 天交易完后手里没有股票的最大利润，dp[i][1]  表示第 <em>i</em> 天交易完后手里持有一支股票的最大利润（<em>i</em> 从 <em>0</em> 开始）。</p><p>考虑 dp[i][0]  的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i-1][0]  ，或者前一天结束的时候手里持有一支股票，即dp[i-1][1]  ，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：</p><pre><code>dp[i][0] =max{dp[i-1][0],dp[i-1][1]+prices[i]}</code></pre><p>再来考虑dp[i][1] ，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i-1][1] ，或者前一天结束时还没有股票，即 dp[i-1][0] ，这时候我们要将其买入，并减少 prices[i]  的收益。可以列出如下的转移方程：</p><pre><code>dp[i][1] =max{dp[i-1][1],dp[i-1][0]-prices[i]}</code></pre><p>对于初始状态，根据状态定义我们可以知道第 <em>0</em> 天交易结束的时候dp[0][0]=0,dp[0][1]=-prices[0]。</p><p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n-1][0]  的收益必然是大于dp[n-1][1] 的，最后的答案即为dp[n-1][0] 。</p><details>    <summary>动态规划C++</summary><figure class="highlight c++"><figcaption><span>[sol11-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol11-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol11-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = prices.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Golang</summary><figure class="highlight golang"><figcaption><span>[sol11-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    dp := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="keyword">int</span>, n)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C</summary><figure class="highlight c"><figcaption><span>[sol11-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[pricesSize][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = fmax(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = fmax(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[pricesSize - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i-1][0] 和 dp[i-1][1]  存放在两个变量中，通过它们计算出 dp[i][0] 和 dp[i][1]  并存回对应的变量，以便于第 <em>i+1</em> 天的状态转移即可。</p><details>    <summary>动态规划C++</summary><figure class="highlight c++"><figcaption><span>[sol12-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newDp0 = max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newDp1 = max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Java</summary><figure class="highlight java"><figcaption><span>[sol12-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newDp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newDp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol12-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = prices.length;</span><br><span class="line">    <span class="keyword">let</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">let</span> newDp0 = <span class="built_in">Math</span>.max(dp0, dp1 + prices[i]);</span><br><span class="line">        <span class="keyword">let</span> newDp1 = <span class="built_in">Math</span>.max(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = newDp0;</span><br><span class="line">        dp1 = newDp1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划Golang</summary><figure class="highlight golang"><figcaption><span>[sol12-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    dp0, dp1 := <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp0, dp1 = max(dp0, dp1+prices[i]), max(dp1, dp0-prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>动态规划C</summary><figure class="highlight c"><figcaption><span>[sol12-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> newDp0 = fmax(dp0, dp1 + prices[i]);</span><br><span class="line">        <span class="keyword">int</span> newDp1 = fmax(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = newDp0;</span><br><span class="line">        dp1 = newDp1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为数组的长度。一共有 <em>2n</em> 个状态，每次状态转移的时间复杂度为 <em>O(1)</em>，因此时间复杂度为 <em>O(2n)=O(n)</em>。</p></li><li><p>空间复杂度：<em>O(n)*。我们需要开辟 *O(n)</em> 空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 <em>O(1)</em>。</p></li></ul><h2 id="方法二：贪心-1"><a href="#方法二：贪心-1" class="headerlink" title="方法二：贪心^1"></a>方法二：贪心<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/" target="_blank" rel="noopener">^1</a></h2><details>    <summary>贪心C++</summary><figure class="highlight c++"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += Math.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol2-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> n = prices.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += <span class="built_in">Math</span>.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心Golang</summary><figure class="highlight golang"><figcaption><span>[sol2-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        ans += max(<span class="number">0</span>, prices[i]-prices[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>贪心C</summary><figure class="highlight c"><figcaption><span>[sol2-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        ans += fmax(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 为数组的长度。我们只需要遍历一次数组即可。</p></li><li><p>空间复杂度：<em>O(1)</em>。只需要常数空间存放若干变量。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>121.买卖股票的最佳时机</title>
    <link href="http://yoursite.com/2020/11/23/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/11/23/121.买卖股票的最佳时机/</id>
    <published>2020-11-23T09:58:12.000Z</published>
    <updated>2020-11-23T11:31:33.749Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><a id="more"></a><p>示例 1:</p><pre><code>输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><p>示例 2:</p><pre><code>输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>用两个变量记录历史最低价格和当前最大利润，一次遍历后即可得到结果</p><details>    <summary>动态规划</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int min = Integer.MAX_VALUE, maxprofit = 0;</span><br><span class="line">        for (int i : prices) &#123;</span><br><span class="line">            min = Math.min(min, i);</span><br><span class="line">            maxprofit = Math.max(maxprofit, i - min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>发现</p><pre><code>执行耗时:3 ms,击败了31.66% 的Java用户内存消耗:38.5 MB,击败了64.22% 的Java用户</code></pre><p>把调用的Math函数变成三目运算符</p><pre><code>执行耗时:1 ms,击败了98.63% 的Java用户内存消耗:38.4 MB,击败了76.20% 的Java用户</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>102.二叉树的层次遍历</title>
    <link href="http://yoursite.com/2020/11/23/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2020/11/23/102.二叉树的层次遍历/</id>
    <published>2020-11-23T06:55:32.000Z</published>
    <updated>2020-11-23T09:09:55.308Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><a id="more"></a><p>例如:</p><pre><code>给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [9,20],  [15,7]]</code></pre><h1 id="📺-视频题解"><a href="#📺-视频题解" class="headerlink" title="📺 视频题解"></a>📺 视频题解</h1><p><a href="cd73eb42-8095-48a4-a1e2-d900642c6360">102. 二叉树的层次遍历.mp4</a></p><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p><strong>思路和算法</strong></p><p>我们可以用广度优先搜索解决这个问题。</p><p>我们可以想到最朴素的方法是用一个二元组 <code>(node, level)</code> 来表示状态，它表示某个节点和它所在的层数，每个新进队列的节点的 <code>level</code> 值都是父亲节点的 <code>level</code> 值加一。最后根据每个点的 <code>level</code> 对点进行分类，分类的时候我们可以利用哈希表，维护一个以 <code>level</code> 为键，对应节点值组成的数组为值，广度优先搜索结束以后按键 <code>level</code> 从小到大取出所有值，组成答案返回即可。</p><p>考虑如何优化空间开销：如何不用哈希映射，并且只用一个变量 <code>node</code> 表示状态，实现这个功能呢？</p><p>我们可以用一种巧妙的方法修改 BFS：</p><ul><li>首先根元素入队</li><li>当队列不为空的时候<ul><li>求当前队列的长度 <em>s_i</em></li><li>依次从队列中取 <em>s_i</em> 个元素进行拓展，然后进入下一次迭代</li></ul></li></ul><p>它和 BFS 的区别在于 BFS 每次只取一个元素拓展，而这里每次取 <em>s_i</em> 个元素。在上述过程中的第 <em>i</em> 次迭代就得到了二叉树的第 <em>i</em> 层的 <em>s_i</em> 个元素。</p><p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的<a href="https://baike.baidu.com/item/循环不变式" target="_blank" rel="noopener">循环不变式</a>：第 <em>i</em> 次迭代前，队列中的所有元素就是第 <em>i</em> 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p><ul><li><strong>初始化</strong>：<em>i = 1</em> 的时候，队列里面只有 <code>root</code>，是唯一的层数为 <em>1</em> 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；</li><li><strong>保持</strong>：如果 <em>i = k</em> 时性质成立，即第 <em>k</em> 轮中出队 <em>s_k</em> 的元素是第 <em>k</em> 层的所有元素，并且顺序从左到右。因为对树进行 BFS 的时候由低 <em>k</em> 层的点拓展出的点一定也只能是 <em>k + 1</em> 层的点，并且 <em>k + 1</em> 层的点只能由第 <em>k</em> 层的点拓展到，所以由这 <em>s_k</em> 个点能拓展到下一层所有的 <em>s_{k+1}</em> 个点。又因为队列的先进先出（FIFO）特性，既然第 <em>k</em> 层的点的出队顺序是从左向右，那么第 <em>k + 1</em> 层也一定是从左向右。<strong>至此，我们已经可以通过数学归纳法证明循环不变式的正确性。</strong></li><li><strong>终止</strong>：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。<strong>至此，我们证明了算法是正确的。</strong></li></ul><p><strong>代码</strong></p><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.size();</span><br><span class="line">            ret.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>JavaScript</summary><figure class="highlight javascript"><figcaption><span>[sol1-JavaScript]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> q = [];</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (q.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentLevelSize = q.length;</span><br><span class="line">        ret.push([]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = q.shift();</span><br><span class="line">            ret[ret.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left) q.push(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right) q.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">            node := q[j]</span><br><span class="line">            ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><p>记树上所有节点的个数为 <em>n</em>。</p><ul><li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 <em>O(n)</em>。</li><li>空间复杂度：队列中元素的个数不超过 <em>n</em> 个，故渐进空间复杂度为 <em>O(n)</em>。</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><details>    <summary>递归</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        leveltravel(res,0,root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void leveltravel(vector&lt;vector&lt;int&gt;&gt; &amp;res,int depth,TreeNode * root)&#123;</span><br><span class="line">         if(!root) return ;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        if(res.size()==depth) res.push_back(temp);</span><br><span class="line">        res[depth].push_back(root-&gt;val);</span><br><span class="line">        leveltravel(res,depth+1,root-&gt;left);</span><br><span class="line">        leveltravel(res,depth+1,root-&gt;right);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><p>在做的过程中注意队列的大小会随时变化，因此需要将q.size()保存为一个变量</p><details>    <summary>非递归</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(root) &#123;</span><br><span class="line">            q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">         vector&lt;int&gt; temp;  </span><br><span class="line">         int len=q.size();</span><br><span class="line">         for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            TreeNode *cur;</span><br><span class="line">            cur=q.front();</span><br><span class="line">            temp.push_back(cur-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">             //cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;&quot;   cur-&gt;val=&quot;&lt;&lt;cur-&gt;val&lt;&lt;endl;</span><br><span class="line">            if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">            if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            //cout&lt;&lt;&quot;  *********&quot;&lt;&lt;endl;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>103. 二叉树的锯齿形层次遍历</title>
    <link href="http://yoursite.com/2020/11/23/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2020/11/23/103. 二叉树的锯齿形层次遍历/</id>
    <published>2020-11-23T06:50:12.000Z</published>
    <updated>2020-11-23T09:48:13.732Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><a id="more"></a><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7返回锯齿形层次遍历如下：[  [3],  [20,9],  [15,7]]</code></pre><p>此题较为容易，思路和102. 二叉树的层次遍历比较像，只需要加个boolean来判断是从左到右还是从右到左遍历即可。</p><details>    <summary>Java</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; listList = new LinkedList&lt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return listList;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int len = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode treeNode = queue.poll();</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    list.add(treeNode.val);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    list.add(0,treeNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (treeNode.left != null) &#123;</span><br><span class="line">                    queue.add(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (treeNode.right != null) &#123;</span><br><span class="line">                    queue.add(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            listList.add(list);</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return listList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>107. 二叉树的层次遍历 II</title>
    <link href="http://yoursite.com/2020/11/23/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II/"/>
    <id>http://yoursite.com/2020/11/23/107. 二叉树的层次遍历 II/</id>
    <published>2020-11-23T06:50:12.000Z</published>
    <updated>2020-11-23T09:30:17.322Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><a id="more"></a><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7返回其自底向上的层次遍历为：[  [15,7],  [9,20],  [3]]</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这道题和「<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a>」相似，不同之处在于，第 <em>102</em> 题要求从上到下输出每一层的节点值，而这道题要求从下到上输出每一层的节点值。除了输出顺序不同以外，这两道题的思路是相同的，都可以使用广度优先搜索进行层次遍历。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>树的层次遍历可以使用广度优先搜索实现。从根节点开始搜索，每次遍历同一层的全部节点，使用一个列表存储该层的节点值。</p><p>如果要求从上到下输出每一层的节点值，做法是很直观的，在遍历完一层节点之后，将存储该层节点值的列表添加到结果列表的尾部。这道题要求从下到上输出每一层的节点值，只要对上述操作稍作修改即可：在遍历完一层节点之后，将存储该层节点值的列表添加到结果列表的头部。</p><p>为了降低在结果列表的头部添加一层节点值的列表的时间复杂度，结果列表可以使用链表的结构，在链表头部添加一层节点值的列表的时间复杂度是 <em>O(1)</em>。在 Java 中，由于我们需要返回的 <code>List</code> 是一个接口，这里可以使用链表实现；而 C++ 或 Python 中，我们需要返回一个 <code>vector</code> 或 <code>list</code>，它不方便在头部插入元素（会增加时间开销），所以我们可以先用尾部插入的方法得到从上到下的层次遍历列表，然后再进行反转。</p><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levelOrder = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> levelOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                TreeNode left = node.left, right = node.right;</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            levelOrder.add(<span class="number">0</span>, level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> levelOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>cpp</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">auto</span> levelOrder = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> levelOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> level = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                level.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            levelOrder.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(levelOrder.begin(), levelOrder.end());</span><br><span class="line">        <span class="keyword">return</span> levelOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>Python3</summary><figure class="highlight python"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        levelOrder = list()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> levelOrder</span><br><span class="line">        </span><br><span class="line">        q = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            level = list()</span><br><span class="line">            size = len(q)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">            levelOrder.append(level)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> levelOrder[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></details><details>    <summary>C</summary><figure class="highlight c"><figcaption><span>[sol1-C]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">levelOrderBottom</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** levelOrder = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * <span class="number">2001</span>);</span><br><span class="line">    *returnColumnSizes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2001</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> levelOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>** <span class="title">q</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>*) * 2001);</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    q[right++] = root;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = right - left;</span><br><span class="line">        <span class="keyword">int</span>* level = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span> = <span class="title">q</span>[<span class="title">left</span>++];</span></span><br><span class="line">            level[i] = node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        levelOrder[(*returnSize)++] = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">2</span> * i &lt; *returnSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span>* tmp1 = levelOrder[i];</span><br><span class="line">        levelOrder[i] = levelOrder[(*returnSize) - i - <span class="number">1</span>];</span><br><span class="line">        levelOrder[(*returnSize) - i - <span class="number">1</span>] = tmp1;</span><br><span class="line">        <span class="keyword">int</span> tmp2 = (*returnColumnSizes)[i];</span><br><span class="line">        (*returnColumnSizes)[i] = (*returnColumnSizes)[(*returnSize) - i - <span class="number">1</span>];</span><br><span class="line">        (*returnColumnSizes)[(*returnSize) - i - <span class="number">1</span>] = tmp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> levelOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Golang</summary><figure class="highlight golang"><figcaption><span>[sol1-Golang]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    levelOrder := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> levelOrder</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        level := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            level = <span class="built_in">append</span>(level, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        levelOrder = <span class="built_in">append</span>(levelOrder, level)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(levelOrder) / <span class="number">2</span>; i++ &#123;</span><br><span class="line">        levelOrder[i], levelOrder[<span class="built_in">len</span>(levelOrder) - <span class="number">1</span> - i] = levelOrder[<span class="built_in">len</span>(levelOrder) - <span class="number">1</span> - i], levelOrder[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> levelOrder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(n)*，其中 *n</em> 是二叉树中的节点个数。每个节点访问一次，结果列表使用链表的结构时，在结果列表头部添加一层节点值的列表的时间复杂度是 <em>O(1)</em>，因此总时间复杂度是 <em>O(n)</em>。</p></li><li><p>空间复杂度：<em>O(n)*，其中 *n</em> 是二叉树中的节点个数。空间复杂度取决于队列开销，队列中的节点个数不会超过 <em>n</em>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Breadth-first Search" scheme="http://yoursite.com/tags/Breadth-first-Search/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>23. 合并K个升序链表</title>
    <link href="http://yoursite.com/2020/11/20/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/11/20/23. 合并K个升序链表/</id>
    <published>2020-11-20T09:30:12.000Z</published>
    <updated>2020-11-23T06:49:48.861Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><a id="more"></a><p>示例 1：</p><pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p>示例 2：</p><pre><code>输入：lists = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：lists = [[]]输出：[]</code></pre><p>提示：</p><pre><code>k == lists.length0 &lt;= k &lt;= 10^40 &lt;= lists[i].length &lt;= 500-10^4 &lt;= lists[i][j] &lt;= 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4h</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="前置知识：合并两个有序链表"><a href="#前置知识：合并两个有序链表" class="headerlink" title="前置知识：合并两个有序链表"></a>前置知识：合并两个有序链表</h2><p><strong>思路</strong><br>在解决「合并K个排序链表」这个问题之前，我们先来看一个更简单的问题：如何合并两个有序链表？假设链表 <em>a</em> 和 <em>b</em> 的长度都是 <em>n</em>，<strong>如何在 <em>O(n)</em> 的时间代价以及 <em>O(1)</em> 的空间代价完成合并？</strong> 这个问题在面试中常常出现，为了达到空间代价是 <em>O(1)</em>，我们的宗旨是「原地调整链表元素的 <code>next</code> 指针完成合并」。<strong>以下是合并的步骤和注意事项，对这个问题比较熟悉的读者可以跳过这一部分。此部分建议结合代码阅读。</strong></p><ul><li>首先我们需要一个变量 <code>head</code> 来保存合并之后链表的头部，你可以把 <code>head</code> 设置为一个虚拟的头（也就是 <code>head</code> 的 <code>val</code> 属性不保存任何值），这是为了方便代码的书写，在整个链表合并完之后，返回它的下一位置即可。</li><li>我们需要一个指针 <code>tail</code> 来记录下一个插入位置的前一个位置，以及两个指针 <code>aPtr</code> 和 <code>bPtr</code> 来记录 <em>a</em> 和 <em>b</em> 未合并部分的第一位。<strong>注意这里的描述，<code>tail</code> 不是下一个插入的位置，<code>aPtr</code> 和 <code>bPtr</code> 所指向的元素处于「待合并」的状态，也就是说它们还没有合并入最终的链表。</strong> 当然你也可以给他们赋予其他的定义，但是定义不同实现就会不同。</li><li>当 <code>aPtr</code> 和 <code>bPtr</code> 都不为空的时候，取 <code>val</code> 熟悉较小的合并；如果 <code>aPtr</code> 为空，则把整个 <code>bPtr</code> 以及后面的元素全部合并；<code>bPtr</code> 为空时同理。</li><li>在合并的时候，应该先调整 <code>tail</code> 的 <code>next</code> 属性，再后移 <code>tail</code> 和 <code>*Ptr</code>（<code>aPtr</code> 或者 <code>bPtr</code>）。那么这里 <code>tail</code> 和 <code>*Ptr</code> 是否存在先后顺序呢？它们谁先动谁后动都是一样的，不会改变任何元素的 <code>next</code> 指针。</li></ul><p><strong>代码</strong></p><details>    <summary>C++</summary><figure class="highlight cpp"><figcaption><span>[pre-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">    <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">            tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>Java</summary><figure class="highlight java"><figcaption><span>[pre-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a != <span class="keyword">null</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode tail = head, aPtr = a, bPtr = b;</span><br><span class="line">    <span class="keyword">while</span> (aPtr != <span class="keyword">null</span> &amp;&amp; bPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">            tail.next = aPtr;</span><br><span class="line">            aPtr = aPtr.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = bPtr;</span><br><span class="line">            bPtr = bPtr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.next = (aPtr != <span class="keyword">null</span> ? aPtr : bPtr);</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度</strong></p><ul><li>时间复杂度：<em>O(n)</em>。</li><li>空间复杂度：<em>O(1)</em>。</li></ul><h1 id="方法一：顺序合并"><a href="#方法一：顺序合并" class="headerlink" title="方法一：顺序合并"></a>方法一：顺序合并</h1><p><strong>思路</strong></p><p>我们可以想到一种最朴素的方法：用一个变量 <code>ans</code> 来维护以及合并的链表，第 <em>i</em> 次循环把第 <em>i</em> 个链表和 <code>ans</code> 合并，答案保存到 <code>ans</code> 中。</p><p>一开始看到这种解法，有点疑惑是如何保证遍历时候后合并的链表小的元素能插入进去，后来运行一下注意到每次合并时候都是从两个链表的头开始遍历，所以可以保证。</p><p><strong>代码</strong></p><details>    <summary>顺序合并C++</summary><figure class="highlight cpp"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lists.size(); ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>顺序合并Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; ++i) &#123;</span><br><span class="line">            ans = mergeTwoLists(ans, lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="keyword">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="keyword">null</span> &amp;&amp; bPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="keyword">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度</strong><br><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/" target="_blank" rel="noopener">^1</a>: </p><h1 id="方法二：分治合并"><a href="#方法二：分治合并" class="headerlink" title="方法二：分治合并"></a>方法二：分治合并</h1><p><strong>思路</strong></p><p>考虑优化方法一，用分治的方法进行合并。</p><ul><li>将 <em>k</em> 个链表配对并将同一对中的链表合并；</li><li>第一轮合并以后， <em>k</em> 个链表被合并成了k/2 个链表，平均长度为 2n/k ，然后是k/4  个链表， k/8  个链表等等；</li><li>重复这一过程，直到我们得到了最终的有序链表。</li></ul><p><strong>代码</strong></p><details>    <summary>分治合并cpp</summary><figure class="highlight cpp"><figcaption><span>[sol2-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span> &lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>分治合并Java</summary><figure class="highlight java"><figcaption><span>[sol2-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a != <span class="keyword">null</span> ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = head, aPtr = a, bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr != <span class="keyword">null</span> &amp;&amp; bPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">                tail.next = aPtr;</span><br><span class="line">                aPtr = aPtr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = bPtr;</span><br><span class="line">                bPtr = bPtr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = (aPtr != <span class="keyword">null</span> ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度</strong><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/" target="_blank" rel="noopener">^1</a>: </p><h1 id="方法三：使用优先队列合并"><a href="#方法三：使用优先队列合并" class="headerlink" title="方法三：使用优先队列合并"></a>方法三：使用优先队列合并</h1><p><strong>思路</strong></p><p>这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，<em>k</em> 个链表就最多有 <em>k</em> 个满足这样条件的元素，每次在这些元素里面选取 <code>val</code> 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。</p><p><strong>代码</strong></p><details>    <summary>使用优先队列合并C++</summary><figure class="highlight cpp"><figcaption><span>[sol3-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *ptr;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.push(&#123;node-&gt;val, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head, *tail = &amp;head;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.top(); q.pop();</span><br><span class="line">            tail-&gt;next = f.ptr; </span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>使用优先队列合并Java</summary><figure class="highlight java"><figcaption><span>[sol3-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Status</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Status</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode ptr;</span><br><span class="line"></span><br><span class="line">        Status(<span class="keyword">int</span> val, ListNode ptr) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.ptr = ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Status status2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.val - status2.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Status&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Status&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ListNode node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Status(node.val, node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tail = head;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Status f = queue.poll();</span><br><span class="line">            tail.next = f.ptr;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Status(f.ptr.next.val, f.ptr.next));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度</strong><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/" target="_blank" rel="noopener">^1</a>: </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>445. 两数相加II</title>
    <link href="http://yoursite.com/2020/11/20/445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>http://yoursite.com/2020/11/20/445. 两数相加II/</id>
    <published>2020-11-20T07:30:12.000Z</published>
    <updated>2020-11-20T08:44:34.132Z</updated>
    
    <content type="html"><![CDATA[<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><a id="more"></a><p>进阶：</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：</p><pre><code>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre><h1 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 文字题解</h1><h2 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h2><p><strong>思路与算法</strong></p><p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p><p>我一开始也是用栈来保存相加后的结果，然后再组成链表，但是时间效率略低，<br>代码中直接用链表来保存，这个操作是倒着保存，然后把头节点移向上一级，十分精妙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curnode.next = ans;</span><br><span class="line">ans = curnode;</span><br></pre></td></tr></table></figure><details>    <summary>栈Python3</summary><figure class="highlight plain"><figcaption><span>[sol1-Python3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        while l1:</span><br><span class="line">            s1.append(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        while l2:</span><br><span class="line">            s2.append(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        ans = None</span><br><span class="line">        carry = 0</span><br><span class="line">        while s1 or s2 or carry != 0:</span><br><span class="line">            a = 0 if not s1 else s1.pop()</span><br><span class="line">            b = 0 if not s2 else s2.pop()</span><br><span class="line">            cur = a + b + carry</span><br><span class="line">            carry = cur // 10</span><br><span class="line">            cur %= 10</span><br><span class="line">            curnode = ListNode(cur)</span><br><span class="line">            curnode.next = ans</span><br><span class="line">            ans = curnode</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure></details><details>    <summary>栈C++</summary><figure class="highlight c++"><figcaption><span>[sol1-C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            s1.push(l1 -&gt; val);</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            s2.push(l2 -&gt; val);</span><br><span class="line">            l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() <span class="keyword">or</span> !s2.empty() <span class="keyword">or</span> carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = s1.empty() ? <span class="number">0</span> : s1.top();</span><br><span class="line">            <span class="keyword">int</span> b = s2.empty() ? <span class="number">0</span> : s2.top();</span><br><span class="line">            <span class="keyword">if</span> (!s1.empty()) s1.pop();</span><br><span class="line">            <span class="keyword">if</span> (!s2.empty()) s2.pop();</span><br><span class="line">            <span class="keyword">int</span> cur = a + b + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">auto</span> curnode = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">            curnode -&gt; next = ans;</span><br><span class="line">            ans = curnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details>    <summary>栈Java</summary><figure class="highlight java"><figcaption><span>[sol1-Java]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            <span class="keyword">int</span> b = stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            <span class="keyword">int</span> cur = a + b + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            ListNode curnode = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">            curnode.next = ans;</span><br><span class="line">            ans = curnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<em>O(max(m, n))*，其中 *m</em> 与 <em>n</em> 分别为两个链表的长度。我们需要遍历每个链表。</p></li><li><p>空间复杂度：<em>O(m + n)*，其中 *m</em> 与 <em>n</em> 分别为两个链表的长度。这是我们把链表内容放入栈中所用的空间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
    
    </summary>
    
      <category term="2020年11月" scheme="http://yoursite.com/categories/2020%E5%B9%B411%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
</feed>
